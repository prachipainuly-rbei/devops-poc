#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
from cdb.validationkit import run_with_added_roles, operation, given, when, \
    then, log
from cs.tools.batchoperations import BatchOperation, kExecStateNotExecuted
from cs.documents.batchoperations import BatchOperationDocumentAssignment
from common import generateBatchOperationDocumentAssignment, generateDocumentBatchOperation


# CDB roles arent that readable in gherkin context.
# So we use readable names in Gherkin and map them to CDB ones here
roleMap = {
    "writer": "Documentation"
}


def isDocumentAllocatedToBatchOperation(document, batch_op):
    objs = BatchOperationDocumentAssignment.getPendingObjects(batch_op)
    for obj in objs:
        if obj.getObject() == document:
            return True
    return False


# -------------------------------------------------------------
# Scenario Allocate a Document to a Batch Operation
#
# -------------------------------------------------------------
@given("^a batch operation exists$")
@run_with_added_roles(["Documentation"])
def step(context):
    context.batch_op = generateDocumentBatchOperation()
    context.batch_op_len = len(BatchOperation.Query())


@when("^(?P<role>.*?) allocates this document to the batch operation$")
def step(context, role):
    @run_with_added_roles([roleMap[role]])
    def allocate(context):
        try:
            generateBatchOperationDocumentAssignment(context.document,
                                                     context.batch_op)
        except Exception, e:
            log("Error allocating the document to the batch operation, "
                "details: %s" % e)
    return allocate(context)


@then("^the document is allocated to the batch operation$")
def step(context):
    assert isDocumentAllocatedToBatchOperation(context.document,
                                                context.batch_op),\
        "The document has not been allocated to the batch operation"


# -------------------------------------------------------------
# Scenario Delete allocation of Document to a Batch Operation
#
# -------------------------------------------------------------
@given("^the document is allocated to the batch operation$")
@run_with_added_roles(["Documentation"])
def step(context):
    context.batch_op_asgn = generateBatchOperationDocumentAssignment(
        context.document,
        context.batch_op)


@when("^(?P<role>.*?) deletes this document from the batch operation$")
def step(context, role):
    @run_with_added_roles([roleMap[role]])
    def delete(context):
        try:
            operation("CDB_Delete", context.batch_op_asgn)
        except Exception, e:
            log("Error deleting the allocation of the document to "
                "the batch operation, details: %s" % e)
    return delete(context)


@then("the allocation of the document to the batch operation is deleted")
def step(context):
    assert not isDocumentAllocatedToBatchOperation(context.document,
                                                    context.batch_op),\
        "The document has not been deleted from the batch operation"


# -------------------------------------------------------------
# Scenario Execute Batch Operation with Assigned Documents
#
# -------------------------------------------------------------
@when("^(?P<role>.*?) executes this batch operation$")
def step(context, role):
    @run_with_added_roles([roleMap[role]])
    def execute(context):
        try:
            operation("cdbbop_operation_exec", context.batch_op)
        except Exception, e:
            log("Error executing the batch operation, details: %s" % e)
    return execute(context)


@then("^the operation is executed on all allocated documents")
def step(context):
    for asgn in BatchOperationDocumentAssignment.KeywordQuery(id=context.batch_op.id):
        assert asgn.exec_state != kExecStateNotExecuted
