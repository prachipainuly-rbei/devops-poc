#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#


import os
import tempfile
from cdb.validationkit import run_with_added_roles, operation, given, when, then, \
    log, getStateNumber, checkFile
from common import generateDocument, doc_approve_categ, doc_approve_maincateg, getStateName
from cdb.objects.cdb_file import CDB_File
from cs.documents import Document


# CDB roles arent that readable in gherkin context.
# So we use readable names in Gherkin and map them to CDB ones here
roleMap = {
    "writer": "Documentation"
}


# -------------------------------------------------------------
# Scenario Create New Document
#
# -------------------------------------------------------------
@when("^(?P<role>.*?) creates a new document$")
def _step(context, role):
    @run_with_added_roles([roleMap[role]])
    def create(context):
        context.doc_len = len(Document.Query())
        try:
            operation("CDB_Create", Document,
                      user_input={"titel": "Test"},
                      preset={"z_categ1": doc_approve_maincateg,
                              "z_categ2": doc_approve_categ})
        except Exception, e:
            log("Error creating a document, details: %s" % str(e))
    return create(context)


@then("^a new document is (?P<state>(?:not )?generated)$")
def _step(context, state):
    if state == "generated":
        assert len(Document.Query()) - context.doc_len == 1,\
            "No Document created"
    elif state == "not generated":
        assert len(Document.Query()) - context.doc_len == 0,\
            "A Document was created"
    else:
        assert False, "Unknown state"


# -------------------------------------------------------------
# Scenario Create New Document with predefines
#
# -------------------------------------------------------------
@when("^(?P<role>.*?) creates a new document with$")
def _step(context, role):
    @run_with_added_roles([roleMap[role]])
    def create(context):
        context.attrs = dict(context.table[0].items())
        try:
            context.document = operation("CDB_Create", Document,
                                         preset=context.attrs)
        except Exception, e:
            log("Error creating a document, details: %s" % str(e))
    return create(context)


@then(
    "^the predefined attributes are (?P<state>(?:not )?set) on the document$"
)
def _step(context, state):
    if state == "set":
        if hasattr(context, "attrs"):
            assert hasattr(context, "document"), "No document has been created"
            s_attrs = set(context.attrs.items())
            assert s_attrs.issubset(
                set(context.document.items())
            ), "The Attributes differ"
    elif state == "not set":
        assert not hasattr(context, "document"), "There is a document"
    else:
        assert False, "Unknown state"


# -------------------------------------------------------------
# Scenario Change Document
#
# -------------------------------------------------------------
def getDocumentAttributesToChange():
    return {"titel": "title"}


@given("^a document exists$")
@run_with_added_roles(["Documentation"])
def _step(context):
    context.document = generateDocument()
    context.doc_len = len(Document.Query())


@when("^(?P<role>.*?) changes this document$")
def _step(context, role):
    @run_with_added_roles([roleMap[role]])
    def change(context):
        try:
            operation("CDB_Modify",
                      context.document,
                      user_input=getDocumentAttributesToChange())
        except Exception, e:
            log("Error modifying a document, details: %s" % str(e))
    return change(context)


@then("^the changed document is (?P<state>(?:not )?saved)$")
def _step(context, state):
    res = Document.ByKeys(context.document.z_nummer, context.document.z_index)
    s_attrs = set(getDocumentAttributesToChange().items())
    if state == "saved":
        assert s_attrs.issubset(
            set(res.items())
        ), "The attributes differ"
    elif state == "not saved":
        assert not s_attrs.issubset(
            set(res.items())
        ), "The attributes differ"
    else:
        assert False, "Unknown state"


# -------------------------------------------------------------
# Scenario Copy Document
#
# -------------------------------------------------------------
@when("^(?P<role>.*?) copies this document$")
def _step(context, role):
    @run_with_added_roles([roleMap[role]])
    def copy(context):
        context.doc_len = len(Document.Query())
        try:
            operation("CDB_Copy", context.document)
        except Exception, e:
            log("Error copying the document, details: %s" % str(e))
    return copy(context)


@then("^the document is (?P<action>(?:not )?copied|(?:not )?deleted)$")
def _step(context, action):
    res = Document.ByKeys(context.document.z_nummer, context.document.z_index)
    if action == "copied":
        assert len(Document.Query()) - context.doc_len == 1,\
            "Document not copied"
    elif action == "not copied":
        assert len(Document.Query()) - context.doc_len == 0,\
            "Document copied"
    elif action == "deleted":
        assert res is None, "The document isn't deleted"
    elif action == "not deleted":
        assert context.document == res, "The document is deleted"
    else:
        assert False, "Unknown state"


# -------------------------------------------------------------
# Scenario Delete Document
#
# -------------------------------------------------------------
@when("^(?P<role>.*?) deletes this document$")
def _step(context, role):
    @run_with_added_roles([roleMap[role]])
    def delete(context):
        try:
            operation("CDB_Delete", context.document)
        except Exception, e:
            log("Error deleting the document, details: %s" % str(e))
    return delete(context)


# -------------------------------------------------------------
# Scenario Generate An Index Of A Document
#
# -------------------------------------------------------------
@given("^a released document exists$")
@run_with_added_roles(["Documentation", "Engineering"])
def _step(context):
    context.document = generateDocument()
    context.doc_len = len(Document.Query())
    stateName1 = getStateName(context.document.z_art, "Review")
    stateName2 = getStateName(context.document.z_art, "Released")
    operation("CDB_Workflow", context.document,
              user_input={"zielstatus": stateName1})
    operation("CDB_Workflow", context.document,
              user_input={"zielstatus": stateName2})


@when("^(?P<role>.*?) generates an index of this document$")
def _step(context, role):
    @run_with_added_roles([roleMap[role]])
    def index(context):
        try:
            context.newindex = operation("CDB_Index", context.document)
        except Exception, e:
            log("Error versioning the document, details: %s" % str(e))
    return index(context)


@then("^an index of the original document is (?P<action>(?:not )?generated)$")
def _step(context, action):
    if action == "generated":
        assert len(Document.Query()) - context.doc_len == 1,\
            "No document created"
        assert context.document.z_nummer == context.newindex.z_nummer,\
            "The new index has not the same number"
    elif action == "not generated":
        assert len(Document.Query()) - context.doc_len == 0,\
            "A document was created"
    else:
        assert False, "Unknown state"


# -------------------------------------------------------------
# Scenario Change State Of A Document
#
# -------------------------------------------------------------
@when("^(?P<role>.*?) changes the state of this document$")
def _step(context, role):
    @run_with_added_roles([roleMap[role]])
    def change(context):
        context.to = context.table[0]["TO"]
        context.frm = context.table[0]["FROM"]
        try:
            operation("CDB_Workflow", context.document,
                      user_input={"zielstatus":
                                  getStateName(context.document.z_art,
                                               context.to)})
        except Exception, e:
            log("Error changing state the document, details: %s" % str(e))
    return change(context)


@then("^the changed state of the document is (?P<state>(?:not )?saved)$")
def _step(context, state):
    res = Document.ByKeys(context.document.z_nummer, context.document.z_index)
    if state == "saved":
        assert (res.z_status
                ==
                getStateNumber("doc_approve", context.to)
                ), "The state of the document hasn't changed"
    elif state == "not saved":
        if res is not None:
            assert res.z_status == getStateNumber("doc_approve", context.frm),\
                "The state of the document has changed"
        else:
            return True
    else:
        assert False, "Unknown state"


# -------------------------------------------------------------
# Scenario Release an Index
#
# -------------------------------------------------------------
@given("^an index of this document is generated$")
def _step(context):
    context.old_document = context.document

    @run_with_added_roles(["Documentation"])
    def create(context):
        context.index = operation("CDB_Index", context.document)
    return create(context)


@when("^(?P<role>.*?) releases the index of the document$")
def _step(context, role):
    @run_with_added_roles([roleMap[role]])
    def release(context):
        try:
            wfname = context.index.z_art
            operation("CDB_Workflow", context.index,
                      user_input={"zielstatus":
                                  getStateName(wfname, "Review")})
            operation("CDB_Workflow", context.index,
                      user_input={"zielstatus":
                                  getStateName(wfname, "Released")})
        except Exception, e:
            log("Error releasing state the document, details: %s" % str(e))
    return release(context)


@then("^the index of the document is (?P<state>(?:not )?released)$")
def _step(context, state):
    if state == "released":
        assert (context.index.z_status
                ==
                getStateNumber("doc_standard", "Released")
                ), "The document is not released"
    elif state == "not released":
        assert (context.index.z_status
                !=
                getStateNumber("doc_standard", "Released")
                ), "The document is released"
    else:
        assert False, "Unknown state"


@then("^the (?:state of the )?original document is "
      "(?P<state>approved|invalid|in revision)$")
def _step(context, state):
    if state == "in revision":
        statename = "Revision"
    elif state == "invalid":
        statename = "Obsolete"
    elif state == "approved":
        statename = "Released"

    res = Document.ByKeys(context.document.z_nummer, context.document.z_index)
    assert (res.z_status
            ==
            getStateNumber("doc_standard", statename)
            ), "The original document is not %s" % state


# -------------------------------------------------------------
# Scenario Import A File Into A Document
#
# -------------------------------------------------------------
@given("^a file exists$")
def _step(context):
    f = tempfile.NamedTemporaryFile(delete=False)
    f.write(os.urandom(100))
    f.close()
    context.file = f.name


@when("^(?P<role>.*?) imports this file into the document$")
def _step(context, role):
    @run_with_added_roles([roleMap[role]])
    def imp(context):
        context.file_len = len(context.document.Files)
        try:
            CDB_File.NewFromFile(context.document.cdb_object_id,
                                 context.file,
                                 True)
        except Exception, e:
            log("Error importing a file, details: %s" % str(e))
    return imp(context)


@then("^the file is (?P<state>(?:not )?associated) with the document$")
def _step(context, state):
    context.document.Reload()
    try:
        if state == "associated":
            assert len(context.document.Files) - context.file_len >= 0,\
                "No File associated"
            assert checkFile(context.file,
                             context.document.getPrimaryFile()),\
                "The contents of the primary file differ"
        elif state == "not associated":
            assert len(context.document.Files) - context.file_len == 0,\
                "A File is associated"
        else:
            assert False, "Unknown state"
    finally:
        os.remove(context.file)


# -------------------------------------------------------------
# Scenario Override of file deletes secondary formats
#
# -------------------------------------------------------------
@given("^a primary file is linked to it$")
def _step(context):
    context.execute_steps(u"GIVEN a file exists")

    @run_with_added_roles(["Documentation"])
    def imp(context):
        try:
            context.primaryFile = CDB_File.NewFromFile(
                context.document.cdb_object_id,
                context.file,
                True)
        finally:
            os.remove(context.file)
    return imp(context)


@given("^a secondary file derives from the primary file$")
def _step(context):
    context.execute_steps(u"GIVEN a file exists")

    @run_with_added_roles(["Documentation"])
    def imp(context):
        try:
            secondaryFile = CDB_File.NewFromFile(
                context.document.cdb_object_id,
                context.file,
                False)
            context.primaryFile.DerivedFiles.append(secondaryFile)
        finally:
            os.remove(context.file)
    return imp(context)


@when("^(?P<role>.*?) overrides the primary file$")
def _step(context, role):
    context.execute_steps(u"GIVEN a file exists")

    @run_with_added_roles([roleMap[role]])
    def override(context):
        try:
            f = context.document.getPrimaryFile()
            f.checkin_file(context.file)
        except Exception, e:
            log("Error overriding a file, details: %s" % str(e))
        finally:
            os.remove(context.file)
    return override(context)


@then("^all secondary files are (?P<state>(?:not )?deleted)$")
def check_secondary_files(context, state):
    context.document.Reload()
    if state == "deleted":
        assert len(context.document.getPrimaryFile().DerivedFiles) == 0,\
            "There are secondary files"
    elif state == "not deleted":
        assert len(context.document.getPrimaryFile().DerivedFiles) != 0,\
            "There are no secondary files"
    else:
        assert False, "Unknown state %s" % state


@then("^no file history entries exist$")
def check_no_file_histories(context):
    context.document.Reload()
    for f in context.document.Files:
        assert len(f.Versions) == 0, "History for file %s is not empty" % f.cdbf_name
