#!/usr/bin/env powerscript
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

"""
Special REST application for documents. Implements object versioning related
logic.
"""

__revision__ = "$Id: rest_app.py 171604 2018-01-15 11:20:27Z heiko $"

from webob.exc import HTTPBadRequest

from cdb import objects
from cdb.objects import operations
from cdb.constants import kOperationIndex
from cs.platform.web.license import check_license
from cs.platform.web.permissions import CDB_Permission, ReadPermission
from cs.platform.web.rest import CollectionApp
from cs.platform.web.rest.generic.main import App as GenericApp
from cs.platform.web.rest.generic.model import ObjectCollection
from cs.platform.web.rest.support import decode_key_component

from cs.documents import Document


class DocumentApp(GenericApp):
    def __init__(self):
        super(DocumentApp, self).__init__("document")

    def get_object(self, keys):
        key_values = [decode_key_component(k) for k in keys.split('@')]
        try:
            return Document.DocumentFromRestKey(key_values)
        except ValueError:
            raise HTTPBadRequest()


@CollectionApp.mount(app=DocumentApp, path="document")
def _mount_app():
    return DocumentApp()


@GenericApp.defer_links(model=Document)
def _defer_document(app, _doc):
    return app.child(DocumentApp())


class DocumentCollection(ObjectCollection):
    """
    A collection of document objects. This collection provides only a single
    version of each document.
    """

    def __init__(self, extra_parameters, rule, all_versions, withFiles):
        """
        Initialization of a document collection. All parameter except
        `all_versions` are inheritet from
        `cs.platform.web.rest.generic.modelObjectCollection`.
        If `all_versions` is ``True``, then all versions are returned.
        """
        super(DocumentCollection, self).__init__("document", extra_parameters,
                                                 rule, withFiles)
        self.all_versions = all_versions

    def query(self):
        """ A query on a DocumentCollection filters the list of results, so that
            only a single version of each document is returned. The version to
            be returned is selected by calling the GetLatestObjectVersion()
            method.
            If self.all_versions is True, then all versions are returned. The
            caller can specify this by giving the query parameter all_versions.
        """
        query_result = super(DocumentCollection, self).query()
        if self.all_versions:
            return query_result

        # We filter the queried objects, but have to make sure that the kernel's
        # result_complete is kept intact, if it is present. See the ObjectCollection
        # view implementation.
        if isinstance(query_result, objects.ObjectCollection):
            all_docs = query_result
            result_complete = not all_docs.IsRestricted()
        elif isinstance(query_result, tuple):
            all_docs, result_complete = query_result
        else:
            all_docs = query_result
            result_complete = True

        # The all_docs collection contains all possible candidates, already
        # filtered by the search condition and access rights. For each distinct
        # z_nummer in this list, select the single return value, but keep the
        # order from the original list.
        docs_by_znum = {}
        znum_order = []
        for doc_version in all_docs:
            if doc_version.z_nummer in docs_by_znum:
                docs_by_znum[doc_version.z_nummer].append(doc_version)
            else:
                znum_order.append(doc_version.z_nummer)
                docs_by_znum[doc_version.z_nummer] = [doc_version]
        result = []
        for znum in znum_order:
            docs = docs_by_znum[znum]
            # Call GetLatestObjectVersion on a concrete instance, so that
            # subclasses can override the behaviour.
            latest = docs[0].GetLatestObjectVersion(docs)
            if latest is not None:
                result.append(latest)
        return (result, result_complete)

    @classmethod
    def _path_vars(cls, obj):
        result = {'extra_parameters': obj.extra_parameters,
                  'rule': obj.rule_name,
                  'withFiles': obj.withFiles}
        if obj.all_versions:
            result['all_versions'] = 1
        return result


@DocumentApp.path(path='', model=DocumentCollection,
                  variables=DocumentCollection._path_vars)
def _get_document_collection(extra_parameters, rule='', withFiles='complete'):
    # Any value at all for all_versions means True
    all_versions = extra_parameters.pop('all_versions', None)
    return DocumentCollection(extra_parameters, rule,
                              all_versions is not None,
                              withFiles)


@DocumentApp.json(model=Document, permission=ReadPermission, name="extended")
@check_license
def _document_default(doc, request):
    result = request.view(doc, name="base_data")
    result["relship:versions"] = [request.link(version)
                                  for version in doc.Versions]
    result["relship:uifiles"] = [request.view(f, name='file_meta')
                                 for f in doc.WebUIFiles]
    return result


@DocumentApp.json(model=Document, permission=ReadPermission, name='file')
def _object_file_view(model, request):
    """ This is a temporary fix, that returns the class icon if no actual
        thumbnail can  be found. Reason is, that the OLE icons have not yet
        been converted to SVG, and the PNG icons look terrible when scaled up.
    """
    from cs.platform.web.rest.generic.view import _object_file_view
    result = _object_file_view(model, request)
    if result is None and request.params.get("kind") == "thumbnail":
        result = {'url': None,
                  'iconURL': model.GetClassIcon()}
    return result


class DocumentVersions(object):

    def __init__(self, cdb_obj):
        self.cdb_obj = cdb_obj
        self.versions = cdb_obj.Versions

    def versionize(self, json_args):
        operations.operation(kOperationIndex, self.cdb_obj,
                             operations.prefix_args(None, **json_args))


@DocumentApp.permission_rule(model=DocumentVersions,
                             permission=CDB_Permission)
def _check_versions_permission(identity, model, permission):
    # For DocumentVersions models, check declared permissions on the source doc
    return permission.check_permission(identity, model.cdb_obj)


@DocumentApp.path(path='{keys}/versions', model=DocumentVersions)
def _get_versions(keys, app):
    obj = app.get_object(keys)
    if obj is None:
        return None
    return DocumentVersions(obj)


@DocumentApp.json(model=DocumentVersions, permission=ReadPermission)
def _document_versions(model, request):
    result = [request.view(v) for v in model.versions if v.CheckAccess("read")]
    # FIXME: add context
    return result


@DocumentApp.json(model=DocumentVersions, request_method='PUT',
                  permission=ReadPermission)
# Check read permission on the parent doc, the permission to actually index
# the document are checked by the operations
def _document_new_version(obj, request):
    try:
        obj.versionize(request.json)
    except RuntimeError, x:
        raise HTTPBadRequest(detail=unicode(x))
    return request.view(obj)
