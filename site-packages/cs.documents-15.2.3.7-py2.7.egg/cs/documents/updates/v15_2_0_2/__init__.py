# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2015 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Module __init__

This is the documentation for the __init__ module.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: __init__.py 147025 2016-10-04 09:25:57Z gda $"

# Some imports
import re
import cdbwrapc
import urlparse
import urllib

from cdb.comparch import protocol
from cdb import sqlapi
from cdb import util
from cdb import transactions
from cdb.platform import favourite

from cs import documents


class MigrateCategories(object):
    """
    From the version 15.2.0.2 documents categories are referenced by id,
    instead of copied by value.

    This script migrates the existing data.

    The existing documents are checked again the configured categories.
    The value of the attribute z_categ* is checked against the
    german name of the category.

    If a unique category can be determined for a document,
    the value in z_categ* is replaced by the id of the category.
    Otherwise a new category is generated and marked as obsolete.

    In standard there are only two level of categories, however customers
    can introduce more level through customizing.
    This scripts will migrate all the levels. Some assumptions are made:

    - The attributes in the class documents must be named according to the
      schema z_categ<level> (z_categ1, z_categ2, z_categ3, etc.)
    """

    kGeneratedCategoryDesc = "Automatically generated by the update task " \
                             "cs.documents.updates.v15_2_0_2.MigrateCategories"
    kCategoryAttrPrefix = "z_categ"
    kCategoryExp = re.compile("^(?:zeichnung\.)?%s(?P<level>\d+)$" % kCategoryAttrPrefix)

    def find_categories_by_name(self, *names):
        """
        Find out the ids of the categories given in the parameters.
        The parameters should contain the *german* name of the categories,
        in the order in which they appear in the hierarchy.

        For each parent its subcategories must have a unique name. Therefore
        the parameters should identify a category uniquely.

        In case the parameters do not identify a category uniquely (either
        because no categories with the given names exist, or because
        more than one exists) new categories are created. These new categories
        are marked as obsolete.
        """

        def find_category_by_name(name_d, parent_id):
            # first check if name_d is an id (this happens if the data
            # has already been partially migrated)
            cat = documents.DocumentCategory.ByKeys(
                categ_id=name_d,
                parent_id=parent_id)
            if cat:
                return [cat.categ_id]

            # if not, search for name_d
            cats = documents.DocumentCategory.KeywordQuery(name_d=name_d)
            if parent_id:
                cats = cats.KeywordQuery(parent_id=parent_id)
            else:
                cats = cats.Query("parent_id='' OR parent_id IS NULL")
            return cats.categ_id

        result = []
        parent = None
        for name in names:
            cats = find_category_by_name(name, parent)
            if len(cats) >= 1:
                if len(cats) > 1:
                    protocol.logWarning("Found more than one document category for %s. "
                                        "Will take the first one" % "/".join(names[:len(result) + 1]))
                cat = cats[0]
                parent = cat
                result.append(cat)
            else:
                protocol.logWarning("Cannot find a document category for %s. "
                                    "A new one will be created" % "/".join(names[:len(result) + 1]))
                missing_categories = names[len(result):]
                return result + self.create_categories(*missing_categories,
                                                       parent_id=parent)

        return result

    def create_categories(self, *names, **kwargs):
        def create_category(parent_id, name_d):
            args = {
                "categ_id": util.nextval("doc_categ_id"),
                "parent_id": parent_id,
                "name_d": name_d,
                "descr": self.kGeneratedCategoryDesc,
                "item_ref_mandatory": 0,
                "obsolete": 1
            }
            cat = documents.DocumentCategory.Create(**args)
            return cat.categ_id

        parent_id = kwargs.get("parent_id", "")
        result = []
        for name in names:
            cat_id = create_category(parent_id, name)
            result.append(cat_id)
            parent_id = cat_id

        return result

    def migrate_favorite(self, fav):
        # migrate search favorites
        # change search for document.z_categ* in document.category*_name_de
        # and for model.z_categ* in model.category*_name_de
        # also change url build with the old operation 'query'
        if fav and fav.fav_link:
            url = urlparse.urlparse(fav.fav_link)
            exp = (
                "^byname/classname/(?P<classname>document|model)/"
                "(?P<operation>CDB_Search|query)/"
                "(?P<mode>batch|interactive)"
            )
            if re.match(exp, url.path):
                query = dict(urlparse.parse_qsl(url.query))
                for attr, value in query.items():
                    match = self.kCategoryExp.match(attr)
                    if match:
                        level = match.group("level")
                        query[".category%s_name_de" % level] = value
                        del query[attr]
                args = (
                    url.scheme,
                    url.netloc,
                    url.path,
                    url.params,
                    urllib.urlencode(query),
                    url.fragment
                )
                fav.fav_link = urlparse.urlunparse(args)

    def run(self):
        if "cdb_doc_categ" not in util.tables:
            protocol.logWarning(
                "Cannot find database table cdb_doc_categ; "
                "will not migrate document categories."
            )
            return

        with transactions.Transaction():
            cdef = cdbwrapc.CDBClassDef("document")

            # build a list of all z_categ* attributes, sorted by level
            _attrs = []
            for adef in cdef.getAttributeDefs():
                match = self.kCategoryExp.match(adef.getName())
                if match:
                    level = match.group("level")
                    _attrs.append((int(level), adef.getName()))
            attrs = [attr for _, attr in sorted(_attrs, key=lambda x: x[0])]

            if not attrs:
                protocol.logWarning(
                    "Found 0 attributes according to the schema %s<level>; "
                    "cannot migrate document "
                    "categories." % documents.Document.kCategoryAttrPrefix
                )
                return

            # get all categorizations of existing documents:
            # select distinct z_categ1, z_categ2, z_categ3, ... from zeichnung
            columns = ["distinct %s" % attrs[0]] + attrs[1:]
            records_set = sqlapi.RecordSet2("zeichnung", columns=columns)

            # migrate documents
            for record in records_set:
                names = filter(None, [getattr(record, attr) for attr in attrs])
                cats = self.find_categories_by_name(*names)

                if names and cats and names != cats:
                    protocol.logMessage(
                        "Migrating document categories %s to ids %s" %
                        (", ".join(names), ", ".join(cats)))

                    # On some customized system you can have empty categories
                    # for some documents. In this case we want to update
                    # only those records, where the attributes for the
                    # empty categories are really empty
                    if len(names) != len(columns):
                        cond = " AND ".join([
                            "(z_categ{level} IS NULL OR z_categ{level} = '')".format(level=level + 1)
                            for level in range(len(names), len(columns))
                        ])
                        docs = documents.Document\
                            .Query(cond)
                    else:
                        docs = documents.Document.Query()
                    docs = docs.KeywordQuery(**dict(zip(attrs, names)))
                    docs.Update(**dict(zip(attrs, cats)))

            # migrate favorites
            for favorite in favourite.Favourite.Query():
                self.migrate_favorite(favorite)


pre = []
post = [MigrateCategories]


# Guard importing as main module
if __name__ == "__main__":
    MigrateCategories().run()
