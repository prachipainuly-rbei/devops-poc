#!/usr/bin/env powerscript
# -*- mode: python; coding: iso-8859-1 -*-
#
#
# Copyright (C) 1990 - 2015 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

__revision__ = "$Id: __init__.py 184152 2018-09-19 10:41:11Z heiko $"

# pylint: disable-msg=E0102,W0142,W0612,W0201

__all__ = ['Document']

import os
import urllib

from cdb import auth
from cdb import constants
from cdb import util
from cdb import ue
from cdb import sqlapi
from cdb import misc
from cdb import cad
from cdb import kernel
from cdb import decomp
from cdb.classbody import classbody
from cdb import sig
from cdb import CADDOK
from cdb.objects import Object
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import Forward
from cdb.objects import ReferenceMethods_1
from cdb.objects import ReferenceMethods_N
from cdb.objects import NULL

from cdb.objects.org import User
from cdb.objects.cdb_file import CDB_File, FILE_EVENT
from cdb.platform import olc
from cdb.platform.mom import entities
from cdb.platform.mom import relships
from cs.platform.web.rest import support
from cs.workflow import briefcases
from cs.tools.powerreports import WithPowerReports
from cs.tools.batchoperations import WithBatchOperations
from cs.documents.batchoperations import BatchOperationDocumentAssignment
from cs.sharing import Sharing
from cs.sharing.share_objects import WithSharing
from cs.sharing.groups import RecipientCollection

# These functions/classes should be part of the cs.document namespace
from .index import createDocIndex
from .objects import DocumentCategory
from .objects import WorkflowAssignment
from .objects import CADDocumentType_FType
from .objects import DocumentReference
from .objects import SheetReference
from .objects import DocumentECN
from .typeselect import DocumentTypeSelector

# Forward declare some classes
Document = Forward("cs.documents.Document")
fDocumentReference = Forward("cs.documents.DocumentReference")
fSheetReference = Forward("cs.documents.SheetReference")
f_cdb_file_base = Forward("cdb.objects.cdb_file.cdb_file_base")
fDocumentECN = Forward("cs.documents.DocumentECN")


class Document(Object, WithPowerReports, WithBatchOperations, briefcases.BriefcaseContent, WithSharing):
    __maps_to__ = "zeichnung"
    __classname__ = "document"

    DocumentReferences = Reference_N(fDocumentReference,
                                     fDocumentReference.z_nummer == Document.z_nummer,
                                     fDocumentReference.z_index == Document.z_index)

    ReverseReferences = Reference_N(fDocumentReference,
                                    fDocumentReference.z_nummer2 == Document.z_nummer,
                                    fDocumentReference.z_index2 == Document.z_index)

    WorkspaceItems = Reference_N(f_cdb_file_base,
                                 f_cdb_file_base.cdbf_object_id == Document.cdb_object_id)

    Files = Reference_N(CDB_File, CDB_File.cdbf_object_id == Document.cdb_object_id)
    PrimaryFiles = Reference_N(CDB_File,
                               CDB_File.cdbf_object_id == Document.cdb_object_id,
                               CDB_File.cdbf_primary == '1')

    kCategoryAttrPrefix = "z_categ"

    def _PreviousIndex(self):
        ctx = self.GetContext()
        if ctx and ctx.action == "index" and ctx.mode in ['post_mask', 'pre']:
            prev_idx = ctx.cdbtemplate.z_index
        elif ctx and ctx.action == "delete" and ctx.mode in ['post', 'final']:
            # The kernel code does not work if the document has been removed
            # from the database
            sort_attr = util.get_prop(constants.kPropModelSort)
            if not sort_attr:
                sort_atttr = "z_index"

            val = sort_attr.replace("z_index", "'%s'" % (sqlapi.quote(self.z_index)))
            stmt = "z_index, %s FROM zeichnung " % (sort_attr) + \
                   "WHERE z_nummer='%s' " % (sqlapi.quote(self.z_nummer)) + \
                   "AND %s < %s " % (sort_attr, val) + \
                   "ORDER BY 2 DESC, 1 DESC"
            t = sqlapi.SQLselect(stmt)
            if sqlapi.SQLrows(t):
                prev_idx = sqlapi.SQLstring(t, 0, 0)
            else:
                return None
        else:
            prev_idx = kernel.get_prev_index(self.z_nummer, self.z_index, self.GetTableName())
        return Document.ByKeys(self.z_nummer, prev_idx)

    PreviousIndex = ReferenceMethods_1(Document, lambda self: self._PreviousIndex())
    """
    A `cdb.objects.ReferenceMethod_1` that returns the document that represents
    the previous version of `self` usually by selecting all versions and
    sorting them using the configuration of the property ``ixsm`` and
    ``z_index``. This is quite expensive - if you know your indexing schema
    you should use an implementation that do not need DB-Statements.

    Note that this function will not work for a 'delete'-'post' user exit
    if your sorting uses any other attribute from ``zeichnung`` than
    ``z_index`` for sorting.
    """

    def _getReferencedDocuments(self):
        return Document.SQL(("SELECT DISTINCT zeichnung.*"
                             "  FROM zeichnung, cdb_doc_rel"
                             " WHERE zeichnung.z_nummer=cdb_doc_rel.z_nummer2"
                             "   AND zeichnung.z_index=cdb_doc_rel.z_index2"
                             "   AND cdb_doc_rel.z_nummer='%s'"
                             "   AND cdb_doc_rel.z_index='%s'")
                            % (sqlapi.quote(self.z_nummer),
                               sqlapi.quote(self.z_index)))
    ReferencedDocuments = ReferenceMethods_N(Document, _getReferencedDocuments)

    def _getReferencingDocuments(self):
        return Document.SQL(("SELECT DISTINCT zeichnung.*"
                             "  FROM zeichnung, cdb_doc_rel"
                             " WHERE zeichnung.z_nummer=cdb_doc_rel.z_nummer"
                             "   AND zeichnung.z_index=cdb_doc_rel.z_index"
                             "   AND cdb_doc_rel.z_nummer2='%s'"
                             "   AND cdb_doc_rel.z_index2='%s'")
                            % (sqlapi.quote(self.z_nummer),
                               sqlapi.quote(self.z_index)))
    ReferencingDocuments = ReferenceMethods_N(Document, _getReferencingDocuments)

    # handling of drawings with multiple sheets
    SheetsReferences = Reference_N(fSheetReference,
                                   fSheetReference.z_nummer == Document.z_nummer,
                                   fSheetReference.z_index == Document.z_index)

    DrawingOfSheetReferences = Reference_N(fSheetReference,
                                           fSheetReference.z_nummer2 == Document.z_nummer,
                                           fSheetReference.z_index2 == Document.z_index)

    def _getDrawingsSheets(self):
        return Document.SQL(("SELECT DISTINCT zeichnung.*"
                             "  FROM zeichnung, cdb_drawing2sheets"
                             " WHERE zeichnung.z_nummer=cdb_drawing2sheets.z_nummer2"
                             "   AND zeichnung.z_index=cdb_drawing2sheets.z_index2"
                             "   AND cdb_drawing2sheets.z_nummer='%s'"
                             "   AND cdb_drawing2sheets.z_index='%s'")
                            % (sqlapi.quote(self.z_nummer),
                               sqlapi.quote(self.z_index)))
    DrawingSheets = ReferenceMethods_N(Document, _getDrawingsSheets)

    def _getSheetsDrawing(self):
        return Document.SQL(("SELECT DISTINCT zeichnung.*"
                             "  FROM zeichnung, cdb_drawing2sheets"
                             " WHERE zeichnung.z_nummer=cdb_drawing2sheets.z_nummer"
                             "   AND zeichnung.z_index=cdb_drawing2sheets.z_index"
                             "   AND cdb_drawing2sheets.z_nummer2='%s'"
                             "   AND cdb_drawing2sheets.z_index2='%s'")
                            % (sqlapi.quote(self.z_nummer),
                               sqlapi.quote(self.z_index)))
    CorrespondingDrawings = ReferenceMethods_N(Document, _getSheetsDrawing)

    def _getVersions(self):
        # implemented as ReferenceMethods_N, because CADDOK.SQLDBMS_STRLEN must
        # not be evaluated when importing this module!
        idx_len = '%s(z_index)' % CADDOK.SQLDBMS_STRLEN
        return Document.KeywordQuery(order_by=[idx_len, 'z_index'],
                                     z_nummer=self.z_nummer)
    Versions = ReferenceMethods_N(Document, _getVersions)

    ChangeNotice = Reference_1(fDocumentECN, Document.z_nummer, Document.z_index)

    def isModel(self):
        return (self.GetClassname() == 'model' or
                'model' in self.GetClassDef().getBaseClassNames())

    def GetObjectKind(self):
        return self.z_art

    def CreateIndex(self, new_index="", **kwargs):
        """
        Creates and returns a new version of `self`. You can use `new_index`
        to predefine the value of ``z_index``. If `new_index` is emtpy it is
        generated using the index schema of your installation.
        """
        from .index import _createDocIndex
        index_created = _createDocIndex(self.z_nummer, self.z_index, new_index, **kwargs)
        indexed_object = Document.ByKeys(z_nummer=self.z_nummer, z_index=index_created)
        return indexed_object

    @classmethod
    def makeNumber(cls, doc):
        """
        Returns a new document number for the passed document object.
        Document numbers are generated differently depending on whether an Item is assigned or not.
        Documents without assigned Item:
          A six digit number is generated from cdb_counter DOK_NR_SEQ and a leading 'D' is prepended.
          Example: D000001
        Documents with assigned Item:
          Each item number has it's own range of document numbers starting at 1. A document number
          is generated by appending an increasing id from this range of numbers to the item number.
          Examples: teilenummer = 123456
                    z_nummer = 123456-1 (for the first document assigned to item 123456)
                    z_nummer = 123456-2 (for the second document assigned to item 123456)
        The passed document object may also be None. In this case a six digit number
        is generated from cdb_counter DOK_NR_SEQ and a leading 'D' is prepended.
        """
        result = ""
        if not doc or not doc.teilenummer:
            result = "D%06d" % (util.nextval("DOK_NR_SEQ"))
        else:
            doc._check_partno()
            prefSet = sqlapi.RecordSet2("prefixes",
                                        "prefix='%s'" % doc.teilenummer,
                                        updatable=1)
            if not prefSet:
                curSeq = 1
                sqlapi.SQLinsert("into prefixes (prefix,seq) values ('%s',%s)"
                                 % (doc.teilenummer, 2))
            else:
                curSeq = prefSet[0].seq
                prefSet[0].update(seq=(curSeq + 1))
            result = "%s-%d" % (doc.teilenummer, curSeq)
        return result

    def _check_partno(self, ctx=None):
        """ Checks that the part number / index point to a valid part
        """
        if hasattr(self, "Item") and self.teilenummer and not self.Item:
            raise ue.Exception("part_number", self.teilenummer, self.t_index)

    def getFileSuffix(self):
        """ Returns the file suffix for the primary format """
        return cad.getCADConfValue("ZVS Zeichnung Endung", self.erzeug_system)

    def copyDoc(self, **kwargs):
        """
        Returns a copy of self using `makeNumber` to generate a new document
        number. The function uses `cdb.objects.Object.Copy` which means at
        this time that there is no access check and no user exits are called.
        The function also copies the non derived files of the document using
        `cdb.objects.cdb_file.CDB_File.copy_file`. At this time this function
        does not reset the locking information.

        The function might be replaced in future versions - you should use
        `cdb.objects.operations.operation` for the regular behaviour.
        """
        new_znum = self.makeNumber(None)
        new_zidx = kernel.new_index()
        state_txt = ""
        try:
            state_txt = olc.StatusInfo(self.z_art, 0).getStatusTxt()
        except AttributeError:
            # Invalid state or z_art
            pass
        args = {"z_nummer": new_znum,
                "z_index": new_zidx,
                "cdb_object_id": "",
                "z_status": 0,
                "z_status_txt": state_txt,
                "cdb_lock": "",
                "dateiname": ""}
        args.update(Document.MakeChangeControlAttributes())
        args.update(kwargs)
        new_doc = self.Copy(**args)
        # alle nicht abgeleiteten Dateien kopieren
        new_basename = new_znum + "-" + new_zidx
        for f in self.Files:
            if not f.cdbf_derived_from:
                base, ext = os.path.splitext(f.cdbf_name)
                f.copy_file(new_doc, new_basename + ext)
        return new_doc

    def cad_change_gensystem(self, new_system):
        """
        Called by the component ``cad_change_gensystem`` due to an integration
        import with a different ``erzeug_system``.
        You may overwrite this function to implement different behaviour.
        The methods `cad_change_gensystem_change_primary_flag` and
        `cad_change_gensystem_remove_files` might help you to implement.
        If you want to cancel the integration function and show a message
        in the integration use return [1001, "<your text>"],
        for example:
        return [1001, "Changing application isn't supported."]
        """

        misc.cdblogv(misc.kLogMsg, 7, "cad_change_gensystem to %s" % new_system)

        if (self.erzeug_system, new_system) in [("ProE:Part", "ProE:GenPart"), ("ProE:GenPart", "ProE:Part"), ("ProE:Asmbly", "ProE:GenAsmbly"), ("ProE:GenAsmbly", "ProE:Asmbly")]:
            self.Update(erzeug_system=new_system)
            self.cad_change_gensystem_change_primary_flag_if_primaryfile(new_system)

        else:
            self.Update(erzeug_system=new_system, z_format="", z_format_gruppe="")
            self.cad_change_gensystem_change_primary_flag(new_system)

        return [0, ""]

    def cad_change_gensystem_change_primary_flag_if_primaryfile(self, new_system):
        """
        Set primary flag and cdbf_type in files with the new system.
        To use in `cad_change_gensystem`.
        """

        for f in self.Files:
            if (f.cdbf_type, new_system) in [("ProE:Part", "ProE:GenPart"), ("ProE:GenPart", "ProE:Part"), ("ProE:Asmbly", "ProE:GenAsmbly"), ("ProE:GenAsmbly", "ProE:Asmbly")]:
                f.Update(cdbf_type=new_system, cdbf_primary="1")
                misc.cdblogv(misc.kLogMsg, 7, "cdbf_type set to '%s' in file %s" % (new_system, f.cdbf_name))
                misc.cdblogv(misc.kLogMsg, 7, "primary flag set to '1' in file %s" % f.cdbf_name)
            else:
                if f.cdbf_type != new_system and f.cdbf_primary != "0":
                    f.Update(cdbf_primary="0")
                    misc.cdblogv(misc.kLogMsg, 7, "primary flag set to '0' in file %s" % f.cdbf_name)
                if f.cdbf_type == new_system and f.cdbf_primary == "0":
                    f.Update(cdbf_primary="1")
                    misc.cdblogv(misc.kLogMsg, 7, "primary flag set to '1' in file %s" % f.cdbf_name)

    def cad_change_gensystem_change_primary_flag(self, new_system):
        """
        Set primary flag in files with the new system.
        To use in `cad_change_gensystem`.
        """

        for f in self.Files:
            if f.cdbf_type != new_system and f.cdbf_primary != "0":
                f.Update(cdbf_primary="0")
                misc.cdblogv(misc.kLogMsg, 7, "primary flag set to '0' in file %s" % f.cdbf_name)
            if f.cdbf_type == new_system and f.cdbf_primary == "0":
                f.Update(cdbf_primary="1")
                misc.cdblogv(misc.kLogMsg, 7, "primary flag set to '1' in file %s" % f.cdbf_name)

    def cad_change_gensystem_remove_files(self):
        """
        Delete all files.
        To use in `cad_change_gensystem`,
        if you want to delete the old files bevore importing a new file.
        """

        misc.cdblogv(misc.kLogMsg, 7, "cad_change_gensystem_remove_files called")
        for f in self.PrimaryFiles:
            f.delete_file()
        for f in self.Files:
            f.delete_file()

    def isTemplate(self):
        return self.vorlagen_kz

    def _resolveReferencedDocs(self, depth, nodes, links, path):
        # Prevent recursions
        p = list(path)
        if self not in path:
            nodes.append(self)
            links[self] = []
            p.append(self)
        if depth != 0:
            for ref in self.DocumentReferences:
                doc = ref.ReferencedDocument
                if doc:
                    # Recursion check
                    if self in links and doc not in p:
                        links[self].append(doc)
                    if doc not in nodes:
                        doc._resolveReferencedDocs(depth - 1, nodes, links, p)
                else:
                    misc.cdblogv(misc.kLogMsg, 0,
                                 "DocumentReference %s references an unknown document"
                                 % (ref.GetDescription()))

    def resolveReferencedDocuments(self, depth=0):
        """
        Returns a list of all documents that are referenced by `self` by
        navigating `DocumentReferences` until depth is reached or a
        recursion occures. If depth is ``0`` all references will be returned.
        The result does not contain any duplicates and
        will be sorted in a way that if ``D1`` references ``D2`` that
        ``D1`` is located before ``D2`` in the result as long a there are
        no recursions.

        If a document reference points to an invalid document this reference
        will be ignored.
        """
        def toposort2(nodes, graph):
            counts = dict((n, 0) for n in nodes)
            for targets in graph.values():
                for n in targets:
                    counts[n] += 1
            result = []
            independent = set(n for n in nodes if counts[n] == 0)
            while independent:
                n = independent.pop()
                result.append(n)
                for m in graph.pop(n, ()):
                    counts[m] -= 1
                    if counts[m] == 0:
                        independent.add(m)
            if graph:
                # Recursion add the rest.
                for n in graph.keys():
                    result.append(n)
            return result

        nodes = []
        links = {}
        # Keep original semantic
        if depth == 0:
            depth = -1
        self._resolveReferencedDocs(depth, nodes, links, [self])
        return toposort2(nodes, links)

    @classmethod
    def _set_template_catalog_query_args(cls, ctx):
        if ctx.catalog_invoking_op_name == "cdb_create_doc_from_template":
            if not ctx.catalog_requery:
                if "templatecatalogargsset" not in ctx.ue_args.get_attribute_names():
                    ctx.keep("templatecatalogargsset", "1")
                    ctx.set("cdb_obsolete", "0")
                    # We might got some decomposition-attributes by on_cdb_create_doc_from_template_now
                    for attr in ctx.catalog_invoking_dialog.get_attribute_names():
                        if attr[-15:] == "_initalqueryarg":
                            ctx.set(attr[:-15], ctx.catalog_invoking_dialog[attr])

    @classmethod
    def on_cdb_create_doc_from_template_now(cls, ctx):
        """
        Create an document by selecting an template and copy it
        """
        def _uniquote(s):
            if isinstance(s, unicode):
                v = s.encode('utf-8')
            else:
                v = s
            return urllib.quote(v)

        if misc.CDBApplicationInfo().rootIsa(misc.kAppl_HTTPServer):
            url = "/cs-documents/template_creation"
            if ctx.relationship_name:
                # We have to provide information about the relationship and the
                # parent
                rs = relships.Relship.ByKeys(ctx.relationship_name)
                cdef = entities.CDBClassDef(rs.referer)
                o = support._RestKeyObj(cdef, ctx.parent)
                key = support.rest_key(o)
                url += u"?classname=%s&rs_name=%s&keys=%s" % \
                       (_uniquote(rs.referer),
                        _uniquote(rs.rolename),
                        _uniquote(key))

            ctx.url(url)

        # Get the project
        if not ctx.catalog_selection:
            kwargs = {}
            # If we are in a decomposition, evaluate the predefined attributes
            if "decompositionclsid" in ctx.sys_args.get_attribute_names():
                decomposition = ctx.sys_args["decompositionclsid"]
                if decomposition:
                    # get predefined attrs, e.g. from decompositions
                    cdef = entities.CDBClassDef(decomposition)
                    predef_args = cdef.getPredefinedOpArgs("CDB_Search", True)
                    for arg in predef_args:
                        # This one is for the catalog configuration
                        # to behave as if the attributes were in the
                        # dialog
                        kwargs[arg.name] = arg.value
                        # This one is for _set_template_catalog_query_args
                        kwargs[arg.name + "_initalqueryarg"] = arg.value

            ctx.start_selection(catalog_name="cdb_doc_template", **kwargs)
        else:
            znumber = ctx.catalog_selection[0]["z_nummer"]
            zidx = ctx.catalog_selection[0]["z_index"]
            template = Document.ByKeys(znumber, zidx)
            predef = [("erzeug_system", template["erzeug_system"])]
            ueargs = [("runeditaftercreate", "1")]
            # Zerlegungsattribute vorbelegen
            if "decompositionclsid" in ctx.sys_args.get_attribute_names():
                decomposition = ctx.sys_args["decompositionclsid"]
                if decomposition:
                    # get predefined attrs, e.g. from decompositions
                    cdef = entities.CDBClassDef(decomposition)
                    predef_args = cdef.getPredefinedOpArgs("CDB_Create", True)
                    for arg in predef_args:
                        predef.append((arg.name, arg.value))

            ctx.set_followUpOperation(opname="CDB_Create",
                                      keep_rship_context=True,
                                      opargs=ueargs,
                                      predefined=predef,
                                      tmpl_object=template)

    def _handle_template_create_post(self, ctx):
        if "runeditaftercreate" in ctx.ue_args.get_attribute_names():
            import cdb.kernel
            ft = cdb.kernel.CDBFileType(self.erzeug_system)
            if ft.getEditMode() != "None":
                ctx.set_followUpOperation(opname="CDB_Edit",
                                          use_result=True)

    def delete_batch_op_assignments(self, ctx):
        """ Delete any references to batch operations for a deleted document.
        """
        if not ctx.error:
            assgns = BatchOperationDocumentAssignment.KeywordQuery(z_nummer=self.z_nummer,
                                                                   z_index=self.z_index)
            assgns.Delete()
            # Delete associated long text fields
            sqlapi.SQLdelete(("FROM cdbbop_doc_log"
                              " WHERE z_nummer = '%s' AND z_index = '%s'")
                             % (sqlapi.quote(self.z_nummer),
                                sqlapi.quote(self.z_index)))

    def purgeFileHistoriesAfterRelease(self, ctx):
        """ After release of a document, remove old versions of all files
            attached to this document.
        """
        if not ctx.error and self.status == 200:
            for f in self.Files:
                f.purgeFileHistory()

    ################################################################################
    # File related methods

    def getExternalFilename(self, suffix=None):
        """ Returns the filename to use for an attached file with the given
            suffix. If suffix == None, use the name of the primary file if one
            exists.
            If no file with the desired suffix exists, compute the standard
            filename to use and return that.
        """
        if suffix:
            files = self.getFilesBySuffix(suffix)
        else:
            files = self.getPrimaryFiles()
        if len(files) > 0:
            return files[0].cdbf_name
        # no matching file found; see if we have to derive the suffix from our
        # file type
        if suffix:
            return self.ToObjectHandle().getStandardFilenameBySuffix(suffix)
        else:
            return self.ToObjectHandle().getStandardFilenameByFileTypeName(self.erzeug_system)

    def getPrimaryFile(self):
        """ Get the (single) primary file from the document. If there is more
            than one, issue a log message and take the first one found. If no
            primary file is found, raise an Exception.
        """
        primary_files = self.getPrimaryFiles()
        if len(primary_files) == 0:
            raise Exception("No primary file for %s-%s" % (self.z_nummer, self.z_index))
        else:
            if len(primary_files) > 1:
                misc.cdblogv(misc.kLogMsg, 0,
                             "%d primary files for %s-%s"
                             % (len(primary_files), self.z_nummer, self.z_index))
            return primary_files[0]

    def checkoutPrimaryFile(self, dstFPName):
        """ Check out the primary file for this document to the given path.
            Returns the checked out file
        """
        primary_file = self.getPrimaryFile()
        primary_file.checkout_file(dstFPName)
        return primary_file

    def getFilesBySuffix(self, suffix=None):
        """ Return a list of files with the given suffix.
        """
        if not suffix:
            return self.getPrimaryFiles()
        result = []
        for f in self.Files:
            if f.cdbf_name.lower().endswith(suffix.lower()):
                result.append(f)
        return result

    def getFileBySuffix(self, suffix=None):
        """ Return a files with the given suffix, if the Document has one. If
            more than one file with this suffix is found, a randomly choosen
            one is returned. If no file is found, returns None.
        """
        lst = self.getFilesBySuffix(suffix)
        if len(lst) == 0:
            return None
        else:
            return lst[0]

    def checkoutFile(self, dstFPName, suffix=None):
        """ Check out the file with the given suffix to the given path. No
            suffix means to get the primary file. If more than one file with
            the suffix exists, the first one encountered in the list is used.
            If no file is found, the function will raise an Exception.
            Returns the checked out file.
        """
        if not suffix:
            return self.checkoutPrimaryFile(dstFPName)
        else:
            f = self.getFileBySuffix(suffix)
            if f:
                f.checkout_file(dstFPName)
                return f
            raise Exception("No file with suffix '%s' for %s-%s"
                            % (suffix, self.z_nummer, self.z_index))

    def checkinFile(self, srcFPName, primary=False):
        """ Check in a file. Searches for a file with the same file name, and
            overwrites that if found. Otherwise, creates a new file. If a new
            file is created, set the primary flag according to the parameter.
            Returns the checked in file
        """
        fname = os.path.basename(srcFPName)
        the_file = None
        for f in self.Files:
            if f.cdbf_name.lower() == fname.lower():
                the_file = f
                break
        if the_file:
            # we found an existing file, so use that
            the_file.checkin_file(srcFPName)
        else:
            # create a new file
            the_file = CDB_File.NewFromFile(self.cdb_object_id, srcFPName, primary)
        return the_file

    def get_preview_file(self):
        """
        Deprecated function to get a preview file.
        Use `GetPreviewFile` instead.
        """
        import warnings
        warnings.warn("Documents.get_preview_file is deprecated. "
                      "Use GetPreviewFile instead.",
                      DeprecationWarning,
                      stacklevel=2)
        return self.GetPreviewFile()

    ################################################################################
    # CAD specific stuff, handled via strategy object

    def _getCadStrategy(self):
        """ Returns the strategy object to handle calls to this document. If
            necessary, the strategy is created.
        """
        # FIX: Caching temporarily disabled due to E023381
        # cs = getattr(self, '_cad_strategy', None)
        if True:  # cs is None:
            from cs.documents.docref_resolver_registry import Registry
            cs = Registry.getStrategy(self)
            self._cad_strategy = cs
        return cs

    def getProjectValue(self):
        return self._getCadStrategy().getProjectValue()

    def getPrimaryFiles(self):
        """ Returns the primary files for this Document, or in the case of a
            multi sheet drawing, the primary files of the Document representing
            the first sheet.
        """
        the_doc = self._getCadStrategy().getDrawingOfSheet()
        return [f for f in the_doc.Files if f.cdbf_primary == '1']

    def getAllRefDocs(self, include_wsm_refs=False):
        # include_wsm_refs: temporary fix for E023381
        cs = self._getCadStrategy()
        cs._include_wsm_refs = include_wsm_refs
        return cs.getAllRefDocs()

    def getSMLModels(self):
        return self._getCadStrategy().getSMLModels()

    def getChildren(self, include_wsm_refs=False):
        # include_wsm_refs: temporary fix for E023381
        cs = self._getCadStrategy()
        cs._include_wsm_refs = include_wsm_refs
        return cs.getChildren()

    def GetDisplayAttributes(self):
        """This method creates and returns a results dictionary, containing the
        necessary information for the HTML display in the client."""
        results = super(Document, self).GetDisplayAttributes()
        results["viewurl"] = unicode(self.MakeURL("CDB_View"))
        results.update({u"iconPopUp": "Format: %s" % (unicode(self["erzeug_system"])),
                        u"showMore": "1",
                        })
        heading = [self[f]
                   for f in ["category1_name", "category2_name", "category3_name"]
                   if self.HasField(f, addtl_field_type=any) and self[f] not in (NULL, '')]
        results[u"attrs"].update({u"person": unicode(self.zeichner if self.zeichner != NULL else ""),
                                  u"heading": " - ".join(heading)})
        return results

    # file events: these are called from CDB_File event handlers
    def fileCreated(self, the_file, ctx=None):
        """ Called when a new file has been created for this Document """
        pass

    def fileModified(self, the_file, ctx=None):
        """ Called when a file of this Document has been modified """
        pass

    def fileDeleted(self, the_file, ctx=None):
        """ Called when a file has been deleted from this Document """
        pass

    def fileLocked(self, the_file, ctx=None):
        """ Called when a file of this Document has been locked """
        pass

    def fileUnlocked(self, the_file, ctx=None):
        """ Called when a file of this Document has been unlocked """
        pass

    def on_create_pre(self, ctx):
        self.cdb_obsolete = 0

    def GetActivityStreamTopics(self, posting):
        """
        Returns the Activity stream topics where a posting to the
        document should occure. The default implementation assigns
        a posting to the project and the object itself.
        """
        return [self, self.Project] if hasattr(self, "Project") else [self]

    @classmethod
    def GetLatestObjectVersion(cls, docs):
        """ Used by the REST API, this gets a list of document versions, and
            returns the latest released version from this list. If no such
            version exists, try in_revision versions, and as a fallback just
            take the latest versions.
        """
        # First of all, sort by index, so that we can return the highest index
        # if more than one match.
        sorted_docs = sorted(docs, key=lambda d: (len(d.z_index), d.z_index))
        # TODO: define rules for this
        released = [d for d in sorted_docs if d.z_status in (200, 300)]
        if released:
            return released[-1]
        in_revision = [d for d in sorted_docs if d.z_status == 190]
        if in_revision:
            return in_revision[-1]
        # Fallback: just return the highest index
        return sorted_docs[-1] if sorted_docs else None

    @classmethod
    def DocumentFromRestKey(cls, vals):
        # Keys may be:
        #   doc_number
        #   doc_number + doc_index
        #   doc_number + function_name
        if len(vals) == 1:
            docs = cls.KeywordQuery(z_nummer=vals[0]).Execute()
            # If there is more than one document, but no more keys, return the
            # latest version. Call the function with a document instance, so that
            # a customer subclass can override this.
            # Note: assumes that all versions of a document are of the same class!
            return docs[0].GetLatestObjectVersion(docs) if docs else None
        elif len(vals) == 2:
            # is it a document index ...
            doc = cls.ByKeys(*vals)
            if doc is not None:
                # OK, found as index
                return doc
            docs = cls.KeywordQuery(z_nummer=vals[0]).Execute()
            # ... or a function (see comment above)
            if len(docs) == 0:
                return None
            if hasattr(docs[0], vals[1]) and callable(getattr(docs[0], vals[1])):
                return getattr(docs[0], vals[1])(docs)
            # don't know what to do with the key
            return None
        else:
            raise ValueError("DocumentFromRestKey: cannot interpret %s" % vals)

    def GetReferencedDocsWithInvalidState(self, validStateList):
        """
        Returns a list of documents that are referenced by `self` and
        does not have a state listed in `validStateList`.
        """
        state_cond = ",".join([str(state) for state in validStateList])
        # self.DocumentReferences is not used because of performance issues
        t = sqlapi.SQLselect("r.z_nummer2, r.z_index2 FROM "
                             "cdb_doc_rel r, zeichnung z WHERE "
                             "r.z_nummer='%s' AND r.z_index='%s' "
                             "AND r.z_nummer2=z.z_nummer "
                             "AND r.z_index2=z.z_index "
                             "AND z.z_status not in (%s)"
                             % (sqlapi.quote(self.z_nummer),
                                sqlapi.quote(self.z_index),
                                state_cond))
        return [Document.ByKeys(sqlapi.SQLstring(t, 0, i),
                                sqlapi.SQLstring(t, 1, i))
                for i in range(sqlapi.SQLrows(t))]

    @classmethod
    def on_cdbdoc_decomp_now(cls, ctx):
        cls.GenerateDecomposition()

    @classmethod
    def GenerateDecomposition(cls):
        sa = util.PersonalSettings().getValueOrDefaultForUser("decomp_sort_attribute",
                                                              "DOC",
                                                              "caddok",
                                                              "name_d")
        decompsource = decomp.DecompSource(source_id=None,
                                           relation="cdb_doc_categ",
                                           key_attr="categ_id",
                                           parent_key_attr="parent_id",
                                           attribute_mappings={
                                               "z_categ<level>": "categ_id"
                                           },
                                           c_conditions={},
                                           s_conditions={},
                                           label_attribute="name_<language>",
                                           position_attr="",
                                           icon_attr="icon_id",
                                           leaf_attr="leaf",
                                           default_icon="Folder",
                                           leaf_icon="Folder",
                                           root_id="",
                                           order_by=sa,
                                           table_attr="tab_name",
                                           py_generator=__name__ + ".Document.GenerateDecomposition",
                                           obsolete_attr="obsolete")
        # remove decompositions based on the source object
        decompsource.delete_decompositions()
        # create filter object
        myfilter = decomp.DecompSourceFilter("cdb_dcat_decomp", "decomp_name")
        # create decompositions
        decompsource.generate_decompositions("DOC", myfilter)

    def GetExcludedFieldsOnExport(self):
        return ["cdb_lock", "wsp_lock_id", "share_status"]

    def getAuthorSubjects(self, sharingGroup):
        "support for ObjectSharingGroup 'Authors'"
        author_names = self.autoren.split("/")
        authors = []
        if author_names:
            authors = User.KeywordQuery(name=author_names)
        return RecipientCollection(authors).subjects

    def getReleasedBySubjects(self, sharingGroup):
        "support for ObjectSharingGroup 'ReleasedBy'"
        return RecipientCollection(
            User.KeywordQuery(name=self.pruefer)).subjects

    def GetOLCRelevantAttributes(self):
        """
        The function should return a list of attributes that are relevant
        for `CalculateOLC` to determine the object life cycle.
        """
        return []

    def GetReadonlyAttrsIfOLCStarted(self):
        """
        Returns a list of attributes that should be set readonly if
        the document has left the initial state. The default implementation
        calls `GetOLCRelevantAttributes`.
        """
        return self.GetOLCRelevantAttributes()

    def _OLCRelevantAttrsChanged(self, ctx):
        """
        Returns the list of attributes that are relevant for calculating
        the object life cylde where the value of `ctx.dialog.attr` differs
        from `self.attr`.
        """
        result = []
        for attr in self.GetOLCRelevantAttributes():
            if getattr(ctx.dialog, attr, self[attr]) != ctx.object[attr]:
                result.append(attr)
        return result

    def CalculateOLC(self, ctx):
        """
        The function is called to calculate the object life cycle from the
        attributes provided by ctx.dialog or self. You can overwrite this
        function to adapt the system behaviour. If there is no rule, you should
        return ``None``. The function is used to prevent object
        modifications that implies a change of the object life cycle if the
        document state is not ``0``.
        """
        return None

    def _handleOLCRo(self, ctx):
        if self.z_status == 0:
            return
        attrs = self.GetReadonlyAttrsIfOLCStarted()
        result = list(attrs)  # short list for source_attr in attrs
        # Check if there are attributs - especially mapped attributes, that
        # depends on the attributes used for calculation
        for adef in self.GetClassDef().getAttributeDefs():
            source_attrs = adef.getSQLSelectNames()
            for source_attr in source_attrs:
                if source_attr in attrs:
                    result.append(adef.getName())
        ctx.set_fields_readonly(result)

    def _adaptOLC(self, ctx):
        """
        Calls `CalculateOLC` to determine the suitable object life cycle.
        If the life cycle differs from the actual one and the status is
        ``0`` the lifecylce is changed. If the status is not ``0`` the
        modification is refused.
        """
        changed_attrs = self._OLCRelevantAttrsChanged(ctx)
        if changed_attrs:
            new_olc = self.CalculateOLC(ctx)
            if new_olc is not None and new_olc != self.z_art:
                if self.z_status == 0:
                    ctx.set("z_art", new_olc)
                    ctx.set("z_status_txt",
                            olc.StatusInfo(new_olc, 0).getStatusTxt())
                else:
                    cdef = self.GetClassDef()
                    changed_attrs = ", ".join([
                        cdef.getAttributeDefinition(attr).getLabel() for attr in changed_attrs])
                    raise ue.Exception("err_modify_new_olc", changed_attrs)

    def IsValidInteractiveTargetStatus(self, target_status):
        """
        Called by the framework as an additional check if a target status
        should be selectable by an user. If you return ``False`` the standard
        implementation ensures that the status is excluded in the target status
        catalog of the operation ``CDB_Workflow``. Trying to set the status of
        `self` to `target_status` using a batch operation will also fail.
        You can overwrite this function to exclude status from interactive
        use.
        """
        return True

    def _exclude_batchonly_states(self, ctx):
        # Exclude states that cannot be used interactive
        # Using a batch operation is a kind of interaction
        if not ctx.batch:
            for status in ctx.statelist:
                if not self.IsValidInteractiveTargetStatus(status):
                    ctx.excl_state(status)

    @classmethod
    def GetDefaultErzSystem(cls):
        """
        Retrieve the default that has to be used to initialize the
        attribute ``erzeug_system`` from the personal setting
        ``cs.documents.default_cad``.
        """
        try:
            return util.PersonalSettings()["cs.documents.default_cad"]
        except KeyError:
            return "-"

    @classmethod
    def GetInitialCreateValues(cls):
        """
        The function is called for `CDB_Create`
        to retrieve initial values as ``dict``.
        For interactive operations these attributes
        are set during the ``pre_mask`` call. For batch operations the
        attributes are set in ``pre`` if no value is supplied before.
        """
        return {"cdb_obsolete": 0}

    @classmethod
    def GetInitialIndexValues(cls):
        """
        The function is called for `CDB_Index`
        to retrieve values as ``dict`` that should not be
        copied from the previous version.
        For interactive operations these attributes
        are set during the ``pre_mask`` call. For batch operations the
        attributes are set in ``pre``.
        """
        return {"cdb_obsolete": 0}

    @classmethod
    def GetInitialCopyValues(cls):
        """
        The function is called for `CDB_Copy`
        to retrieve values as ``dict`` that should not be
        copied from the previous version.
        For interactive operations these attributes
        are set during the ``pre_mask`` call. For batch operations the
        attributes are set in ``pre``.
        """
        # Copy is the same as creating a new document
        result = cls.GetInitialCreateValues()
        # At least all attributes resetted for a new version has to
        # be resetted too
        result.update(cls.GetInitialIndexValues())
        return result

    @classmethod
    def CalculateSourceOID(cls, ctx):
        """
        Called by the framework to set the ``source_oid`` attribute
        during the creation of a document.
        The default returns the ``cdb_object_id`` of the template if you
        use :guilabel:`Create from template` and the ``cdb_object_id`` of the
        copy source if the ``CDB_Copy`` operation is used.
        """
        if ctx.action == "create" and ctx.cdbtemplate:
            return getattr(ctx.cdbtemplate, "cdb_object_id", None)
        elif ctx.action == "copy":
            return ctx.object.cdb_object_id

    def _handle_initial_values(self, ctx):
        vals = {}
        if ctx.action == "create":
            vals = self.GetInitialCreateValues()
            if "erzeug_system" not in vals and \
               not ctx.cad_system and \
               not getattr(ctx.dialog, "erzeug_system", ""):
                dflt = self.GetDefaultErzSystem()
                if dflt:
                    vals["erzeug_system"] = self.GetDefaultErzSystem()

        elif ctx.action == "copy":
            vals = self.GetInitialCopyValues()
        elif ctx.action == "index":
            vals = self.GetInitialIndexValues()
        source_oid = self.CalculateSourceOID(ctx)
        if source_oid:
            vals["source_oid"] = source_oid
        for attr, value in vals.items():
            # At create set if no different value is supplied, e.g. by the wsm
            # At other times reset the existing one
            if not getattr(ctx.dialog, attr, "") or ctx.action != "create":
                if ctx.mode == "pre_mask" or not ctx.interactive:
                    ctx.set(attr, value)

    @classmethod
    def CategoryAttributeNames(cls):
        def to_int(s):
            if s:
                try:
                    return int(s)
                except ValueError:
                    pass
            return None

        result = []
        ti = util.tables["zeichnung"]
        for i in range(ti.number_columns()):
            colname = ti[i].name()
            if colname.find(cls.kCategoryAttrPrefix) == 0 and to_int(colname[len(cls.kCategoryAttrPrefix):]):
                result.append(colname)
        result.sort()
        return result

    def get_template_preset_attributes(self):
        """
        Return a list of attribute names that are to be copied from the
        template document, when the operation :guilabel:`New from template`
        is called. You may overwrite this method to customize the list of
        attributes.
        """
        return self.CategoryAttributeNames()

    def preset_template_attributes(self, ctx):
        """
        Copy attributes from a template document bevor showing the
        document creation mask. The standard implementation copies
        every attribute returned by `get_template_preset_attributes`
        from the template if no value has been defined before.
        """
        if ctx.action == 'create':
            # Check for action here instead of creating a separate event_map
            # entry so that the call order is kept from the event map.
            tmpl = ctx.cdbtemplate
            if tmpl and int(tmpl.vorlagen_kz):
                for attr in self.get_template_preset_attributes():
                    if attr in tmpl.get_attribute_names() and not self[attr]:
                        self[attr] = tmpl[attr]

    def GetReviewer(self):
        """
        Returns a list of personal numbers of the persons that should
        review or have reviewed the document. This is e.g. used to implement
        the recipient list :guilabel:`Reviewer` of the sharing. The default
        tries to map the value of the attribute ``pruefer`` to the
        personal no.
        """
        return User.KeywordQuery(name=self.pruefer).personalnummer

    def getReviewerSharingRecipients(self, sharing_group):
        """
        Used for the sharing_group ``Reviewer`` to calculate the
        recipients.
        """
        return [(persno, "Person") for persno in self.GetReviewer()]

    def HandleUnlockForeignLock(self, f, previous_locker, ctx):
        """
        The framework calls this function as part of the ``post``
        user exit of the ``CDB_Unlock`` action of the class
        `cdb.objects.Object.cdb_file.CDB_File` if the user has unlocked
        a file locked by the user identified by `previous_locker`.
        The function generates a sharing to send this information to
        the previous locker. You might overwrite the function to adapt
        this behaviour.
        """
        prev_locker = User.ByKeys(previous_locker)
        if prev_locker:
            msg_lang = prev_locker.GetPreferredLanguage()
            msg = util.CDBMsg(util.CDBMsg.kNone,
                              "cs.documents.file_unlocked_sharing_text")
            msg.addReplacement(prev_locker.name)
            msg.addReplacement(f.GetDescription())
            msg.addReplacement(self.GetDescription())
            msg.addReplacement(auth.name)
            text = msg.getText(msg_lang, True)
            Sharing.createFromObjects([self],
                                      subjects=[(previous_locker, "Person")],
                                      text=text)

    event_map = {
        (('create', 'copy', 'index'), ('pre_mask', 'pre')): ('_handle_initial_values'),
        (('copy', 'create'), 'pre_mask'): ("preset_template_attributes"),
        ('create', 'post'): ('_handle_template_create_post'),
        ('query_catalog', ('pre_mask', 'pre')): ('_set_template_catalog_query_args'),
        ('delete', 'post'): ("delete_batch_op_assignments"),
        ('state_change', 'pre_mask'): ("_exclude_batchonly_states"),
        ('state_change', 'post'): ("purgeFileHistoriesAfterRelease"),
        ('modify', 'pre_mask'): ("_handleOLCRo"),
        ('modify', 'pre'): ("_adaptOLC"),
    }


# If a file connected to a Document changes, trigger propagation to the Document
# instance.
@sig.connect(FILE_EVENT, Document.__maps_to__, any)
def _file_event_handler(the_file, doc_obj_hndl, ctx):
    doc = Document.ByKeys(doc_obj_hndl.getValue('z_nummer', False),
                          doc_obj_hndl.getValue('z_index', False))
    if doc is None:
        return
    if ctx.action == 'create':
        doc.fileCreated(the_file, ctx)
    elif ctx.action == 'modify':
        doc.fileModified(the_file, ctx)
    elif ctx.action == 'delete':
        doc.fileDeleted(the_file, ctx)
    elif ctx.action == 'CDB_Lock':
        doc.fileLocked(the_file, ctx)
    elif ctx.action == 'CDB_Unlock':
        doc.fileUnlocked(the_file, ctx)
        previous_locker = getattr(ctx.sys_args,
                                  "previous_locker",
                                  "")
        if previous_locker and previous_locker != auth.persno:
            doc.HandleUnlockForeignLock(the_file, previous_locker, ctx)
