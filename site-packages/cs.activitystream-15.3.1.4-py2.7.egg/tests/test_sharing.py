#!/usr/bin/env powerscript
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

__docformat__ = "restructuredtext en"
__revision__ = "$Id: test_sharing.py 158065 2017-05-04 06:44:49Z jfi $"

import time
import unittest
from cdb import testcase
from cdb import ue
from cdb import sig
from cdb.objects import ByID
from cdb.objects.operations import operation
from cdb.objects.org import CommonRole
from cdb.objects.org import Organization
from cdb.objects.org import User
from cs.sharing import Sharing
from cs.sharing import errors
from cs.sharing import groups
from cs.sharing import SHARING_CREATED

ORG = None
CADDOK = None
ADMIN = None
SUBJECT = None


# bypass caching issues (same objects instantiated multiple times)
def _assertObjectIn(test, obj, collection):
    test.assertIn(dict(obj), [dict(x) for x in collection])


def setUpModule():
    testcase.run_level_setup()
    global ORG
    global CADDOK
    global ADMIN
    global SUBJECT
    ORG = Organization.ByKeys("131")
    CADDOK = User.ByKeys("caddok")
    ADMIN = CommonRole.ByKeys("Administrator")
    assert ORG, "Organization 131 from base data missing"
    assert CADDOK, "User caddok from base data missing"
    assert ADMIN, "Common Role Administrator from base data missing"
    SUBJECT = CADDOK.personalnummer, CADDOK.__subject_type__
    try:
        testcase.require_uberserver()
    except:
        # unittest does not tear down modules whose setup failed - make it
        tearDownModule()
        raise


def tearDownModule():
    testcase.stop_uberserver()


class RestRollbackTestCase(unittest.TestCase):
    """
    Class emulating from cdb.testcase import RollbackTestCase, which cannot be
    used here, since we need backend access to objects we create in tests.
    """
    @classmethod
    def setUpClass(cls):
        cls.ids = []

    @classmethod
    def tearDownClass(cls):
        for id in cls.ids:
            obj = ByID(id)
            if obj:
                operation("CDB_Delete", obj)

    def rememberForRollback(self, obj_id):
        self.ids.append(obj_id)


@sig.connect(SHARING_CREATED)
def _callback_test_emit_called(sharing):
    test_Sharing.created_sharing = sharing


# __init__.py
class test_Sharing(RestRollbackTestCase):
    """
    Tests `cs.sharing.Sharing`.
    """

    created_sharing = None

    def setUp(self):
        test_Sharing.created_sharing = None

    @classmethod
    def setUpClass(cls):
        RestRollbackTestCase.setUpClass()
        cls.text = u"testing 1, 2, 3... can anybody hear me?"

    def _createFromObjects(self):
        result = Sharing.createFromObjects(
            objects=[ORG],
            subjects=[SUBJECT],
            text=self.text)
        self.assertIsNotNone(result, msg="cs.sharing.Sharing.createFromObjects failed")
        self.rememberForRollback(result.cdb_object_id)
        return result

    def test_createFromObjectsEmitCalled(self):
        self._createFromObjects()
        self.assertIsNotNone(test_Sharing.created_sharing)
        self.assertIsNotNone(test_Sharing.created_sharing.Posting)

    def test_createFromObjects(self):
        from cdb import misc
        misc.cdblogv(misc.kLogErr, 0, "### disabled test_createFromObjects - "
                                      "need packages with shareable objects")
        return
        sharing = self._createFromObjects()
        self.assertIsNotNone(sharing.Posting, msg="no Posting created for Sharing")
        self.assertEqual(sharing.Posting.GetText("cdbblog_posting_txt"), self.text)
        self.assertEqual(len(sharing.Attachments), 1)
        self.assertEqual(len(sharing.AttachedObjects), 1)

        start = time.clock()
        # assume queue was empty before running this test
        from cdb import sqlapi
        job = sqlapi.RecordSet2(
            "mq_share_objects_queue",
            "sharing_object_id='%s'" % sharing.cdb_object_id)[0]

        while job and job.cdbmq_state in "WP":
            time.sleep(3)
            if time.clock() - start > 60:
                job.delete()
                assert False, ("timeout waiting for mq_share_objects_queue")
            jobs = sqlapi.RecordSet2("mq_share_objects_queue",
                                     "cdbmq_id='%s'" % job.cdbmq_id)
            job = jobs[0] if len(jobs) else None

        sharing.Reload()
        self.assertEqual(len(sharing.Subscriptions), 1)
        self.assertEqual(
            len(Sharing.getSharingsForAttachmentID(ORG.cdb_object_id)), 1)
        self.assertEqual(len(Sharing.getSharingsByMe(SUBJECT[0])), 1)
        self.assertEqual(
            len(Sharing.getSharingsToMe(persno=CADDOK.personalnummer)), 0)


# errors.py
class test_ServerResult(unittest.TestCase):
    """
    Tests `cs.sharing.errors.ServerResult`.
    """
    @classmethod
    def setUpClass(cls):
        cls.error_cls = errors.CreateSharingFailed
        cls.default = {"answer": 42}

    def test_success(self):
        with errors.ServerResult(error_cls=self.error_cls,
                                 default=self.default) as x:
            x.result["success"] = 1

        self.assertEqual(x.result, {"answer": 42, "success": 1, "error": None})

    def test_catchException(self):
        with testcase.error_logging_disabled():  # suppress confusing exceptions
            with errors.ServerResult(error_cls=self.error_cls,
                                     default=self.default) as x:
                assert False
                x.result["success"] = 1

        self.assertEqual(x.result, {
            "answer": 42,
            "error": dict(self.error_cls(""))
        })


# groups.py
class test_PersonalSharingGroup(testcase.RollbackTestCase):
    """
    Tests `cs.sharing.groups.PersonalSharingGroup`.
    """
    @classmethod
    def setUpClass(cls):
        cls.name = "Personal Group (Test)"

    def _fromSubjectList(self):
        return groups.PersonalSharingGroup.fromSubjectList(self.name, [SUBJECT])

    def test_fromSubjectList(self):
        group = self._fromSubjectList()
        _assertObjectIn(self, CADDOK, group.getPersons())

    def test_uniqueNamesForUser(self):
        group = self._fromSubjectList()
        with self.assertRaises(ue.Exception) as context:
            same_name = self._fromSubjectList()


class test_ObjectSharingGroup(testcase.RollbackTestCase):
    """
    Tests `cs.sharing.groups.ObjectSharingGroup`.
    """
    @classmethod
    def setUpClass(cls):
        cls.rule = 'cs.sharing: Group "Creator"'
        cls.name = "Object Group (Test)"

    def _getOrgGroups(self):
        return groups.ObjectSharingGroup.forObject(ORG)

    def test_forObject(self):
        print("FIXME needs additional package with sharable objects")
        # groups = self._getOrgGroups()
        # self.assertEqual(len(groups), 1)
        # self.assertEqual(groups[0].pyrule, self.rule)

    def test_getPersons(self):
        print("FIXME needs additional package with sharable objects")
        # group = self._getOrgGroups()[0]
        # self.assertEqual(group.getPersons([ORG]), [SUBJECT])


class test_RecipientsBrowser(unittest.TestCase):
    """
    Tests `cs.sharing.groups.RecipientsBrowser`.
    """
    def _distribute(self, recipients, limit, expected):
        result = groups.RecipientsBrowser.distribute(recipients, limit)
        self.assertEqual(expected, result, (
            "expected {}\n"
            "got      {}".format(expected, result)))

    def _recipients(self, users, roles, lists, flat):
        def l(prefix, amount):
            return ["%s%i" % (prefix, i + 1) for i in range(amount)]

        result = {
            "angestellter": l("U", users),
            "cdb_global_role": l("R", roles),
            "cdb_personal_sharing_group": l("L", lists),
        }
        if flat:
            flattened = []
            for clsname in groups.RecipientsBrowser.__ranking__:
                flattened += result[clsname]
            return flattened
        else:
            return result

    def test_getAllPossibleRecipientsNested(self):
        nested = groups.RecipientsBrowser.getAllPossibleRecipients()
        keys = nested.keys()
        _assertObjectIn(self, ADMIN, nested.get("cdb_global_role", []))
        _assertObjectIn(self, CADDOK, nested.get("angestellter", []))

    def test_getAllPossibleRecipientsFlat(self):
        flat = groups.RecipientsBrowser.getAllPossibleRecipients(flat=True)
        _assertObjectIn(self, ADMIN, flat)
        _assertObjectIn(self, CADDOK, flat)

    def test_distributionNoResults(self):
        self._distribute(
            self._recipients(0, 0, 0, False),
            5,
            self._recipients(0, 0, 0, True))

    def test_distributionUnchanged(self):
        self._distribute(
            self._recipients(2, 2, 1, False),
            5,
            self._recipients(2, 2, 1, True))

    def test_distributionLess(self):
        self._distribute(
            self._recipients(1, 2, 1, False),
            5,
            self._recipients(1, 2, 1, True))

    def test_distributionMore(self):
        self._distribute(
            self._recipients(7, 1, 2, False),
            5,
            self._recipients(2, 1, 2, True))

    def test_distributionZero(self):
        self._distribute(
            self._recipients(0, 4, 4, False),
            5,
            self._recipients(0, 3, 2, True))


class test_RecipientCollection(unittest.TestCase):
    """
    Tests `cs.sharing.groups.RecipientCollection`.
    """
    @classmethod
    def setUpClass(cls):
        cls.err_msg = "resolve_subjects({}) is {}, expected {}"
        cls.illegal_id = "Unbekannter Empf√§nger: '"

    def _test_resolve_subject(self, input, expected):
        result = [p.personalnummer for p in groups.RecipientCollection(
            subjects=input).getPersons()]
        self.assertEqual(
            result, expected, self.err_msg.format(input, result, expected))

    def _test_illegal_id(self, input):
        with self.assertRaises(ue.Exception) as context:
            groups.RecipientCollection(subjects=input)

        self.assertTrue(context.exception.errp[0].startswith(self.illegal_id))

    def _test_illegal_type(self, input):
        with self.assertRaises(KeyError) as context:
            groups.RecipientCollection(subjects=input)

    def _test_not_iterable(self, input):
        with self.assertRaises(TypeError) as context:
            groups.RecipientCollection(subjects=input)

    def _test_not_exactly_two_values(self, input):
        with self.assertRaises(ValueError) as context:
            groups.RecipientCollection(subjects=input)

    def test_resolve_subjects(self):
        self._test_resolve_subject("", [])
        self._test_resolve_subject([], [])
        self._test_resolve_subject([("caddok", "Person")], ["caddok"])
        self._test_resolve_subject([("caddok", "Person"), ("caddok", "Person")], ["caddok"])
        self._test_resolve_subject([("caddok", "Person"), ("Administrator", "Common Role")], ["caddok"])
        self._test_resolve_subject([("Administrator", "Common Role")], ["caddok"])

        self._test_illegal_id([(1, "Person")])
        self._test_illegal_id([(None, "Person")])
        self._test_illegal_type([("caddok", 1)])
        self._test_illegal_type([("caddok", None)])
        self._test_not_iterable([1])
        self._test_not_iterable([None])
        self._test_not_exactly_two_values([""])
        self._test_not_exactly_two_values(["Administrator", "Common Role"])
        self._test_not_exactly_two_values([("Administrator", "Common Role", "?")])


# Allow running this testfile directly
if __name__ == "__main__":
    unittest.main()
