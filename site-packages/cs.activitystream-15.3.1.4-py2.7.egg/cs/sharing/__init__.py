#!/usr/bin/env powerscript
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

__docformat__ = "restructuredtext en"
__revision__ = "$Id: __init__.py 158065 2017-05-04 06:44:49Z jfi $"

import os
from cdb import auth
from cdb import CADDOK
from cdb import i18n
from cdb import sqlapi
from cdb import util
from cdb import sig
from cdb.classbody import classbody
from cdb.cmsg import Cdbcmsg
from cdb.objects import ByID
from cdb.objects import Forward
from cdb.objects import Object
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import ReferenceMethods_1
from cdb.objects import ReferenceMethods_N
from cdb.objects.blog import SystemPosting
from cdb.objects.common import WithEmailNotification
from cdb.objects.operations import operation
from cdb.objects.org import User
from cdb.platform.gui import Message
from cs.activitystream import PostingTools
from cs.activitystream import UserPosting
from cs.activitystream.attachment import Attachment
from cs.sharing.groups import isUserVisible
from cs.sharing.groups import RecipientCollection


fSharing = Forward(__name__ + ".Sharing")
fSharingGroup = Forward("cs.sharing.groups.SharingGroup")
fSharingGroupMember = Forward("cs.sharing.groups.SharingGroupMember")
fPosting = Forward("cdb.objects.blog.Posting")
fSubscription = Forward("cdb.objects.blog.Subscription")
fAttachment = Forward("cs.activitystream.attachment.Attachment")
fUser = Forward("cdb.objects.org.User")
fObject = Forward("cdb.objects.Object")


SHARING_CREATED = sig.signal()


@classbody
class User(object):
    def email_with_sharing(self):
        return self.getSettingValue("user.email_with_sharing")


def generate_cdb_sharing_posting_v():
    """
    Joins cdb_object_ids of attachments, postings, and sharings (newest first)
    """
    addtl = ""
    if sqlapi.SQLdbms() == sqlapi.DBMS_MSSQL:
        addtl = "TOP 100 PERCENT"
    return (
        "SELECT %s a.attachment_id, s.cdb_object_id AS sharing_id, "
        "       p.cdb_object_id AS posting_id "
        "FROM cdb_sharing s "
        "   JOIN cdbblog_posting p ON s.cdb_object_id=p.context_object_id "
        "   JOIN cdbblog_attachment a ON p.cdb_object_id=a.posting_id "
        "ORDER BY p.cdb_cdate DESC"
        ) % addtl


class Sharing(Object, WithEmailNotification):
    """
    `Sharing` is the top-level object used for displaying user-shared objects in
    `cs.activitystream`. Users can add subscribers after creating a Sharing, but
    not remove anybody who already subscribed to it.

    There is no legacy UI (e.g. cdbpc.exe) for creating Sharings. Sharings are
    created exclusively using `cs.sharing.web.share_objects`.
    """
    __maps_to__ = "cdb_sharing"
    __classname__ = "cdb_sharing"
    __sys_posting__ = "cdb_sharing_created"

    Creator = Reference_1(fUser, fSharing.cdb_cpersno)
    AllPostings = Reference_N(
        fPosting, fPosting.context_object_id == fSharing.cdb_object_id)
    Subscriptions = Reference_N(
        fSubscription,
        fSubscription.channel_cdb_object_id == fSharing.cdb_object_id)

    def _get_first_posting(self):
        "Gets the first posting, which holds the attachments."
        for p in self.AllPostings:
            return p
    Posting = ReferenceMethods_1(fPosting, _get_first_posting)

    def _get_attachments(self):
        "Gets the first posting's attachments."
        return Attachment.KeywordQuery(posting_id=self.Posting.cdb_object_id)
    Attachments = ReferenceMethods_N(fAttachment, _get_attachments)

    def _get_attachment_objects(self):
        "Gets the first posting's attached objects."
        objects = [ByID(a.attachment_id) for a in self.Attachments]
        return [o for o in objects if o.CheckAccess("read")]
    AttachedObjects = ReferenceMethods_N(fObject, _get_attachment_objects)

    @classmethod
    def getSharingsForAttachmentID(cls, cdb_object_id):
        sharing_ids = [rec.sharing_id for rec in sqlapi.RecordSet2(
            "cdb_sharing_posting_v",
            "attachment_id='%s'" % sqlapi.quote(cdb_object_id))
            ]
        sharings = cls.KeywordQuery(cdb_object_id=sharing_ids)
        sharings = [s for s in sharings if s and s.CheckAccess("read")]
        sharings.sort(key=lambda x: x.cdb_cdate, reverse=True)
        return sharings

    def _get_sys_posting_vals(self, context_object):
        def _adapt_value(attrname, value):
            try:
                value = value[:util.tables["cdbblog_posting"].column(attrname).length()]
            except:
                pass
            return value.replace("\\n", "\n")

        oh = context_object.ToObjectHandle()
        values = {
            "context_object_id": context_object.cdb_object_id,
            "type": "update",
            }

        # Generate a text for all active languages
        for lang in i18n.getActiveGUILanguages():
            msg = util.CDBMsg(util.CDBMsg.kNone, self.__sys_posting__)
            msg.addReplacement(oh.getDesignation("", lang))
            msg.addReplacement(oh.getStateLabel(lang))
            value = msg.getText(lang, True)
            attrname = "title_" + lang
            values[attrname] = _adapt_value(attrname, value)

        if oh.getClassDef().has_workflow():
            values["context_object_status"] = oh.getState()

        return values

    def create_system_posting(self, context_object):
        """
        Synchronously creates a "cdb_sharing_created" system posting for the
        context_object, then adds the Sharing object self as the posting's
        Attachment (not supported by the system posting MQ).
        """
        if not context_object.GetClassDef().isActivityChannel():
            return

        posting = SystemPosting.do_create(
            **self._get_sys_posting_vals(context_object))
        Attachment.addAttachment(posting.cdb_object_id, self.cdb_object_id)

    @classmethod
    def createFromObjects(cls, objects, subjects, text=None):
        """
        Creates and returns a new `Sharing` with attachments `objects`. If
        `subjects` is a valid subject list, add its subjects as subscribers.
        """
        if not text:
            text = u""

        sharing = operation("CDB_Create", cls)
        for obj in objects:
            sharing.create_system_posting(obj)
        sharing.createPosting([o.cdb_object_id for o in objects], text)
        sharing.sendNotificationAsynchronously(subjects)
        sig.emit(SHARING_CREATED)(sharing)
        return sharing

    def addAttachment(self, object_or_object_id):
        Attachment.addAttachment(
            self.Posting.cdb_object_id,
            getattr(object_or_object_id, "cdb_object_id", object_or_object_id))

    def createPosting(self, attachment_ids, text):
        result = PostingTools.create_posting(
            cdb_classname=UserPosting.__classname__,
            text=text,
            topic_id=self.cdb_object_id)

        if result:
            posting = result.get("posting", None)
            if posting:
                for object_id in attachment_ids:
                    self.addAttachment(object_id)

    def addSubscriptions(self, subject_list):
        if self.GetClassDef().isActivityChannel():
            subscribers = RecipientCollection(subjects=subject_list)
            for person in subscribers.iterPersons():
                if isUserVisible(person):
                    fSubscription.subscribeToChannel(
                        self.cdb_object_id, person.personalnummer)

    # Mail Notification
    __notification_template__ = "new_sharing.html"
    __notification_title__ = "cdb_new_sharing_email"
    __mail_relationships__ = {
        # name of Relship*1
        "Project": "cdb_sharing_project_label",
        "Process": "cdb_sharing_workflow_label",
        }

    def getNotificationTitle(self, ctx=None):
        systemName = Message.ByKeys(
            "branding_product_name_acronym")[CADDOK.LANGUAGE]
        attachment_str = ""

        if len(self.AttachedObjects):
            attachment_str = self.AttachedObjects[0].GetDescription()
            if len(self.AttachedObjects) > 1:
                attachment_str += util.get_label("cdb_sharing_more") % (
                    len(self.AttachedObjects) - 1)

        return util.get_label(self.__notification_title__) % (systemName,
                                                              attachment_str)

    def getRelationships(self, obj):
        result = {}
        if obj and isinstance(obj, Object):
            for relname, label in self.__mail_relationships__.items():
                robj = getattr(obj, relname, None)
                if isinstance(robj, Object) and hasattr(robj, "cdb_object_id"):
                    result[robj.cdb_object_id] = {
                        "label": util.get_label(label),
                        "obj": robj,
                        }
        return result.values()

    def setNotificationContext(self, sc, ctx=None):
        sc.self = self

    def getNotificationReceiver(self, ctx=None):
        ids = self.Subscriptions.personalnummer
        # ids.remove(self.cdb_cpersno)
        users = User.KeywordQuery(personalnummer=ids)
        receivers = [
            (p.e_mail, p.name) for p in users if p.email_with_sharing()]
        return [{"to": set(receivers)}]

    def sendNotificationAsynchronously(self, subjects):
        from cs.sharing.share_objects_queue import share_objects_queue
        job = share_objects_queue.new(sharing_object_id=self.cdb_object_id)
        job.setProperties(subjects)
        job.start()

    def sendNotification(self, sharing, ctx=None):
        # overwrite cdb.objects.common.WithEmailNotification.sendNotification
        sendNotificationAsynchronously(self, None)

    def getFormattedMessage(self):
        return self.Posting.GetText('cdbblog_posting_txt')

    def getActivityStreamURL(self):
        return "%s/activitystream/posting/%s" % (CADDOK.WWWSERVICE_URL,
                                                 self.Posting.cdb_object_id)

    def getActivityStreamURLcdbpc(self):
        cmsg = Cdbcmsg(classname="cdb_sharing",
                       aktion="CDB_ShowObject",
                       interactive=True)
        cmsg.add_item(attrib="cdb_object_id",
                      relation=self.__table_name__,
                      value=self.cdb_object_id)
        return cmsg.cdbwin_url()
    # /Mail Notification

    event_map = {
        ("cdb_sharing_add_person", "now"): "add_person",
        }

    def add_person(self, ctx):
        self.addSubscriptions([(ctx.dialog.person_id, User.__subject_type__)])
