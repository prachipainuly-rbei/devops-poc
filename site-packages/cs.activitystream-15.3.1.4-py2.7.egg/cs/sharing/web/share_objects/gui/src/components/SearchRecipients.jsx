/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: SearchRecipients.jsx 174894 2018-03-22 14:27:29Z gwe $"
 */

import Immutable from 'immutable';
import React from 'react';
import {FormControl, getJSON, postJSON, notifyError} from 'cs-web-components-base';
import {ImmutablePropTypes, connect, PropTypes} from 'cs-web-components-externals';
import FloatingLabel from './FloatingLabel';
import RecipientItemRenderer from './renderer/RecipientItemRenderer';
import SelectedRecipient from './SelectedRecipient';
import SaveRecipientsModal from './dialogs/SaveRecipientsModal';
import AddUserModal from './dialogs/AddUserModal';
import {formatStr} from '../i18n';
import * as constants from '../constants';
import {prefixNS} from '../helpers';
import {setSelectedRecipients} from '../actions/sharing-actions';
import {getShowSaveRecipientsModal, getShowAddUserModal,
        getSelectedRecipients} from '../reducers/sharing-store';


class SearchRecipientsComponent extends React.Component {

    constructor(props) {
        super(props);
        this.state = {
            searchTerm: "",
            recipientSuggestions: [],
            hasMore: false
        };

        this.typeAheadRecipients = FormControl.WithTypeAhead(FormControl.TextInput);
        this.recipientSelected = this.recipientSelected.bind(this);
        this.removeRecipient = this.removeRecipient.bind(this);
        this.resolveRecipient = this.resolveRecipient.bind(this);
        this.timeoutID = null;
    }

    componentWillReceiveProps(nextProps) {
        if (this.props.selectedRecipients !== nextProps.selectedRecipients) {
            this.setState({
                searchTerm: "",
                recipientSuggestions: [],
                hasMore: false
            });
        }
    }

    focus(hasFocus) {
        if (hasFocus) {
            document.getElementById("recipients-frame").classList.add("focus");
        } else {
            document.getElementById("recipients-frame").classList.remove("focus");
        }
    }

    updateSearchTerm(e) {
        const term = e.target.value.trimLeft();
        this.setState({searchTerm: term}, () => {
            if (term !== "") {
                this.queryRecipients();
            } else {
                this.setState({
                    recipientSuggestions: [],
                    hasMore: false
                });
            }
        });
    }

    keyDownHandler(e) {
        if (e.key !== "Backspace" || this.state.searchTerm.length !== 0) {
            return;
        }

        const size = this.props.selectedRecipients.size;
        if (size !== 0) {
            this.removeRecipient(size - 1);
        }
    }

    queryRecipients() {
        if (this.timeoutID) {
            clearTimeout(this.timeoutID);
        }

        this.timeoutID = setTimeout(() => {
            getJSON(constants.URL_RECIPIENTS_POOL, {
                query: this.state.searchTerm,
                limit: constants.TYPEAHEAD_LIMIT
            }).then((data) => {
                this.setState({
                    recipientSuggestions: data.recipients,
                    hasMore: data.has_more
                });
            });
        }, constants.SEARCH_DELAY);
    }

    recipientSelected(idx) {
        const newRecipient = this.state.recipientSuggestions[idx];
        const hasRecipient = this.userExists(this.props.selectedRecipients, newRecipient);

        if (!hasRecipient) {
            this.props.setSelectedRecipients(this.props.selectedRecipients.push(newRecipient));
        }

        this.setState({
            searchTerm: "",
            recipientSuggestions: []
        });
    }

    removeRecipient(idx) {
        this.props.setSelectedRecipients(this.props.selectedRecipients.remove(idx));
    }

    userExists(existing, user) {
        return existing.find((val) => {
            if (val.cdb_object_id) {
                return val.cdb_object_id === user.cdb_object_id;
            }
            return val['@id'] === user['@id'];
        });
    }

    resolveRecipient(idx) {
        const data = {
            group: this.props.selectedRecipients.get(idx)
        };

        postJSON(constants.URL_GROUP_SIZE, data).then((data) => {
            if (data.error || data.size === 0) {
                this.props.notifyError(data.error.statusText, "", data.error.message);
                return;
            }

            let recipientsList = this.props.selectedRecipients.remove(idx);

            data.users.forEach((user) => {
                if (!this.userExists(recipientsList, user)) {
                    recipientsList = recipientsList.push(user);
                }
            });

            this.props.setSelectedRecipients(recipientsList);
        });
    }

    getSaveRecipientsModal() {
        if (!this.props.showSaveRecipientsModal) {
            return null;
        }

        return (
            <SaveRecipientsModal {...this.props} />
        );
    }

    getAddUserModal() {
        if (!this.props.showAddUserModal) {
            return null;
        }

        return (
            <AddUserModal {...this.props} searchTerm={this.state.searchTerm} />
        );
    }

    render() {
        const recipientsInputPlaceholder = formatStr(
            constants.RECIPIENTS_PLACEHOLDER
        );

        const TypeAheadRecipients = this.typeAheadRecipients;

        const recipientsFrame = (
            <div id="recipients-frame"
                 className={"form-control " + prefixNS("recipients-frame")}>
                {this.props.selectedRecipients.map((recipient, idx) => (
                    <SelectedRecipient key={"recipients-selected-" + idx}
                                       index={idx}
                                       recipient={recipient}
                                       onRemoveRecipient={this.removeRecipient}
                                       onResolveRecipient={this.resolveRecipient}
                                       {...this.props} />
                ))}
                <TypeAheadRecipients value={this.state.searchTerm}
                                     matched={Immutable.fromJS(this.state.recipientSuggestions)}
                                     hasMoreMatches={this.state.hasMore}
                                     autoSelectFirstMatch={true}
                                     id={"recipients-query"}
                                     name={"recipients-query"}
                                     type="text"
                                     autoComplete="off"
                                     placeholder={recipientsInputPlaceholder}
                                     onFocus={() => {this.focus(true)}}
                                     onBlur={() => {this.focus(false)}}
                                     onChange={(e) => {this.updateSearchTerm(e)}}
                                     onKeyDown={(e) => {this.keyDownHandler(e)}}
                                     TypeAheadItemRenderer={RecipientItemRenderer}
                                     onSelectAt={this.recipientSelected} />
            </div>
        );

        return (
            <div id="recipients-wrapper" className={prefixNS("recipients-wrapper")}>
                <FloatingLabel input={recipientsFrame}
                        id={"recipients-query"}
                        className={"recipients-query"}
                        placeholder={recipientsInputPlaceholder} />
                {this.getSaveRecipientsModal()}
                {this.getAddUserModal()}
            </div>
        );
    }
}

SearchRecipientsComponent.propTypes = {
    notifyError: PropTypes.func,
    setSelectedRecipients: PropTypes.func,
    showSaveRecipientsModal: PropTypes.bool.isRequired,
    showAddUserModal: PropTypes.bool.isRequired,
    selectedRecipients: ImmutablePropTypes.list
};

function mapStateToProps(state) {
    return {
        showSaveRecipientsModal: getShowSaveRecipientsModal(state),
        showAddUserModal: getShowAddUserModal(state),
        selectedRecipients: getSelectedRecipients(state)
    };
}

const actions = {notifyError, setSelectedRecipients};
const SearchRecipients = connect(mapStateToProps, actions)(SearchRecipientsComponent);
export default SearchRecipients;
