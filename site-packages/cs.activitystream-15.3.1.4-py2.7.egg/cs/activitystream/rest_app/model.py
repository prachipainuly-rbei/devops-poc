import isodate
import urllib
import cdbwrapc
from cdb import auth
from cdb import sqlapi
from cdb import util
from cdb.objects import core
from cdb.constants import kOperationNew
from cdb.objects.operations import operation
from cs.activitystream.objects import Posting
from cs.activitystream.objects import UserPosting
from cs.activitystream.objects import SystemPosting
from cs.activitystream.objects import Comment
from cs.activitystream.objects import Topic2Posting
from cs.activitystream.objects import Channel
from cs.activitystream.objects import Subscription
from cs.activitystream.attachment import Attachment
from cs.sharing import Sharing
from cdb.storage.index.queries import ESQueryPage
from .subscription_category_registry import get_registry
from cdb.objects.org import User


def get_referenced_objects(posting_id, tblname, attrname, check_access=True):
    """ Get referenced objects of a posting with less sql statements.
    :param posting_id: object ID of the posting
    :param tblname: name of the table that contains the references
    :param attrname: name of attribute that contains ID of the referenced object
    :param check_access: whether to call `CheckAccess` on the referenced object
    :return: a list of referenced objects by that posting.
    """
    result = []
    cond = "r.posting_id='%s' AND o.id=r.%s" % (sqlapi.quote(posting_id), attrname)
    tbls = "cdb_object o, %s r" % tblname
    relations = sqlapi.RecordSet2(
        sql=("SELECT distinct o.relation "
             "FROM %s "
             "WHERE %s ") % (tbls, cond)
    )

    for rel in relations:
        records = sqlapi.RecordSet2(
            sql=("SELECT t.* "
                 "FROM %s, %s t "
                 "WHERE %s "
                 "AND t.cdb_object_id=o.id") % (
                    tbls, rel.relation, cond)
        )

        # Find the cdb.objects class for this database table
        cr = core.ClassRegistry()
        klass = cr.find(rel.relation)

        # Build cdb.objects objects from the query result
        objs = klass.FromRecords(records)
        if check_access:
            objs = [obj for obj in objs if obj.CheckAccess(check_access)]
        result += objs

    return result


class WithExtraParams(object):
    __default_posting_count__ = 20

    def __init__(self, extra_parameters):
        self.extra_parameters = extra_parameters

    def _filter_system_posting(self):
        no_sp = self.extra_parameters.get("systemposting", "on") == "off"
        if no_sp:
            comment_table = Comment.GetTableName()
            return [u" (not (%s and not exists"
            "(select * from %s where %s.posting_id=%s.cdb_object_id)))" %
            (SystemPosting._MatchExpression(), comment_table, comment_table, Posting.GetTableName())]
        return []

    def _filter_person(self):
        person = self.extra_parameters.get("pn", "")
        if person:
            persno_cond = sqlapi.quote(person)
            comment_table = Comment.GetTableName()
            return [u" (cdb_cpersno = '%(persno)s' or exists"
                    "(select * from %(ct)s where %(ct)s.posting_id=%(pt)s.cdb_object_id"
                    " and %(ct)s.cdb_cpersno = '%(persno)s'))" % {
                        "persno": persno_cond,
                        "ct": comment_table,
                        "pt": Posting.GetTableName()
                    }]
        return []

    def _filter_date(self):
        date = self.extra_parameters.get("date", None)
        if date:
            try:
                posting_table = Posting.GetTableName()
                comment_table = Comment.GetTableName()
                return [u" (%(cdate)s or exists"
                        "(select * from %(ct)s where %(ct)s.posting_id=%(pt)s.cdb_object_id"
                        " and %(ccdate)s))" % {
                            "cdate": cdbwrapc.build_statement(
                                posting_table, "cdb_cdate", date),
                            "ct": comment_table,
                            "pt": posting_table,
                            "ccdate": cdbwrapc.build_statement(
                                comment_table, "cdb_cdate", date)

                        }]
            except Exception:
                pass
        return []

    def _get_posting_count(self):
        s_cnt = self.extra_parameters.get("posting_count", "")
        try:
            cnt = int(s_cnt)
        except ValueError:
            cnt = self.__default_posting_count__
        return cnt

    def _get_last_queried(self):
        last_comment_date = self.extra_parameters.get("last_comment_date", None)
        last_object_id = self.extra_parameters.get("last_object_id", None)
        last_posting = None
        if last_comment_date and last_object_id:
            try:
                last_posting = (isodate.parse_datetime(last_comment_date),
                                sqlapi.quote(last_object_id))
            except Exception:
                pass
        return last_posting

    def _get_since(self):
        since = self.extra_parameters.get("since", None)
        if since:
            try:
                return [u"last_comment_date > %s" %
                    sqlapi.SQLdbms_date(isodate.parse_datetime(since))]
            except Exception:
                pass
        return []

    def query(self):
        cnt = self._get_posting_count()
        last_posting = self._get_last_queried()
        result = Posting.getPostingsByCondition(self._get_query_cond(), cnt, last_posting)
        return (result[0], result[1] <= cnt)

    def add_posting(self, text):
        return operation(kOperationNew, UserPosting,
                         cdbblog_posting_txt=text)


class PostingCollection(WithExtraParams):

    def _get_all_postings_condition(self):
        if not hasattr(self, "__all_postings_condition__"):
            cond = ""
            # Look up threads for current user
            persno_cond = sqlapi.quote(auth.persno)

            # Company wide threads
            # Own discussions
            # - discussions created by current user
            # - system activities from current user and commented by someone
            cond += (
                "SELECT cdb_object_id from cdbblog_posting WHERE "
                "  context_object_id = ''"
                "  OR "
                "  (cdb_cpersno = '%s' AND (%s OR EXISTS ( "
                "    SELECT cdbblog_comment.posting_id FROM cdbblog_comment "
                "    WHERE cdbblog_comment.posting_id = "
                "      cdbblog_posting.cdb_object_id))) " % (
                    persno_cond, UserPosting.__match__))

            # Threads with topics:
            # - topics subscripted
            cond += (
                "UNION SELECT cdbblog_topic2posting.posting_id "
                "  FROM cdbblog_topic2posting, cdbblog_subscription "
                "  WHERE cdbblog_subscription.personalnummer = '%s' AND "
                "    cdbblog_subscription.channel_cdb_object_id = "
                "      cdbblog_topic2posting.topic_id " % persno_cond)

            # Threads that commented by current user
            cond += (
                "UNION SELECT cdbblog_comment.posting_id "
                "  FROM cdbblog_comment "
                "  WHERE cdbblog_comment.cdb_cpersno = '%s' " % persno_cond)

            self.__all_postings_condition__ = "cdb_object_id in ( %s )" % cond
        return self.__all_postings_condition__

    def _get_query_cond(self):
        cond = [self._get_all_postings_condition()]
        cond += self._filter_system_posting()
        cond += self._filter_person()
        cond += self._filter_date()
        cond += self._get_since()
        return u" and ".join(cond)


class ChannelCollection(object):

    def query(self):
        q_str = "cdb_object_id in (select channel_cdb_object_id from %s where personalnummer='%s')" % (
            Subscription.GetTableName(), sqlapi.quote(auth.persno))
        return [ToAllChannel(), SharingChannel()], Channel.Query(q_str)


class PostingComments(object):
    def __init__(self, posting):
        self.posting = posting

    def query(self):
        return self.posting.AllComments

    def add_comment(self, text):
        return operation(kOperationNew, Comment,
                         cdbblog_comment_txt=text,
                         posting_id=self.posting.cdb_object_id)

    def add_reply_to(self, text, reply_to):
        return operation(kOperationNew, Comment,
                         cdbblog_comment_txt=text,
                         posting_id=self.posting.cdb_object_id,
                         in_reply_to=reply_to.cdb_object_id)


class PostingTopics(object):
    def __init__(self, posting):
        self.posting = posting

    def query(self, check_access=None):
        topics = get_referenced_objects(self.posting.cdb_object_id,
                                        Topic2Posting.GetTableName(),
                                        "topic_id",
                                        check_access)

        ctx = self.posting.ContextObject if self.posting.context_object_id else None
        if not ctx:
            ctx = ToAllChannel()
        elif ctx in topics:
            topics.remove(ctx)
        return [ctx] + topics

    def add_topics(self, topic_ids):
        for topic_id in topic_ids:
            Topic2Posting.createMapping(self.posting.cdb_object_id, topic_id)


class Attachments(object):
    def __init__(self, entry):
        self.entry = entry

    def query(self, check_access=None):
        return get_referenced_objects(self.entry.cdb_object_id,
                                      Attachment.GetTableName(),
                                      "attachment_id",
                                      check_access)

    def add_attachments(self, obj_ids):
        result = []
        for obj_id in obj_ids:
            result.append(Attachment.addAttachment(self.entry.cdb_object_id, obj_id))
        return result

    def has_attachments(self):
        return len(Attachment.KeywordQuery(posting_id=self.entry.cdb_object_id)) > 0

    def modifiable(self):
        # Should not modify existing postings. Use comment to add new attachments
        # TODO performance problem? replace with cpersno check
        return not self.has_attachments() and self.entry.CheckAccess('create_attachment')


class PostingAttachments(Attachments):
    pass


class CommentAttachments(Attachments):
    pass


class ObjectPostings(WithExtraParams):

    def __init__(self, context_id, extra_parameters):
        self.context_id = context_id
        super(ObjectPostings, self).__init__(extra_parameters)

    def _get_query_cond(self):
        cond = [Posting.getTopicCondition().format(("'%s'" % sqlapi.quote(self.context_id)))]
        cond += self._filter_system_posting()
        cond += self._filter_person()
        cond += self._filter_date()
        cond += self._get_since()
        return u" and ".join(cond)

    def add_posting(self, text):
        return operation(kOperationNew, UserPosting,
                         cdbblog_posting_txt=text,
                         context_object_id=self.context_id)


class SubscriptionCategoryBase(object):
    order = 0

    def __init__(self, additional_condition):
        self.additional_condition = additional_condition

    @property
    def icon(self):
        return None

    @property
    def title(self):
        return ""

    def get_objects(self):
        return []


class SubscriptionCollection(object):

    def query(self):
        names = dict(sname=Subscription.GetTableName(),
                     cname=Channel.GetTableName(),
                     persno=sqlapi.quote(auth.persno))
        q_str = "cdb_object_id in (select %(sname)s.channel_cdb_object_id from %(sname)s where " \
                "%(sname)s.personalnummer='%(persno)s' and not exists (select 1 from %(cname)s where " \
                "%(sname)s.channel_cdb_object_id = %(cname)s.cdb_object_id))" % names
        return [categ(q_str) for categ in get_registry().get_categories()]


class SharingChannel(object):
    def __init__(self):
        self.cdb_object_id = "sharing"

    def GetDescription(self):
        return util.Labels()["web.share_objects.shared"]

    def GetObjectIcon(self):
        return self.GetClassIcon()

    def GetClassIcon(self):
        return Channel.GetClassIcon()


class SharingCollection(WithExtraParams):
    def _get_sharing_cond(self):
        str = "context_object_id IN (" + \
        "SELECT DISTINCT({0}.cdb_object_id) FROM {0}, {1} WHERE" + \
        " ({1}.channel_cdb_object_id={0}.cdb_object_id " + \
        "AND ({1}.personalnummer='{2}' AND {1}.cdb_cpersno<>'{2}'))" + \
        "OR {0}.cdb_cpersno='{2}')"
        return str.format(
            sqlapi.quote(Sharing.GetTableName()),
            sqlapi.quote(Subscription.GetTableName()),
            sqlapi.quote(auth.persno)
        )

    def _get_query_cond(self):
        cond = [self._get_sharing_cond()]
        cond += self._filter_system_posting()
        cond += self._filter_person()
        cond += self._filter_date()
        cond += self._get_since()
        return u" and ".join(cond)


class ToAllChannel(object):
    def __init__(self):
        self.cdb_object_id = "to_all"

    def GetDescription(self):
        return util.Labels()["web.activitystream.to-all"]

    def GetObjectIcon(self):
        return self.GetClassIcon()

    def GetClassIcon(self):
        return Channel.GetClassIcon()

    def add_posting(self, text):
        return operation(kOperationNew, UserPosting,
                         cdbblog_posting_txt=text)


class ToAllChannelPostings(WithExtraParams):

    def _get_to_all_postings_condition(self):
        return "context_object_id = ''"

    def _get_query_cond(self):
        cond = [self._get_to_all_postings_condition()]
        cond += self._filter_system_posting()
        cond += self._filter_person()
        cond += self._filter_date()
        cond += self._get_since()
        return u" and ".join(cond)


class PersonSearchModel(ESQueryPage):
    def __init__(self, extra_parameters):
        super(PersonSearchModel, self).__init__()
        self.extra_parameters = extra_parameters

    def settings(self):
        return self._base_settings()

    def get_result_for_activitystream(self):
        params = self.extra_parameters
        params["classname"] = User._getClassname()
        return self._prepare_result(self.extra_parameters)
