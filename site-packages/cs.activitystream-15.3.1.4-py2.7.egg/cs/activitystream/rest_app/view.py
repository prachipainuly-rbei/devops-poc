import json
import morepath
from webob.exc import HTTPUnprocessableEntity
from webob.exc import HTTPInternalServerError
from .main import ActivityStreamApp
from .model import PostingCollection
from .model import PostingComments
from .model import PostingTopics
from .model import ChannelCollection
from .model import ObjectPostings
from .model import SubscriptionCollection
from .model import SubscriptionCategoryBase
from .model import Attachments
from .model import PostingAttachments
from .model import CommentAttachments
from .model import ToAllChannel
from .model import ToAllChannelPostings
from .model import PersonSearchModel
from .model import SharingCollection
from .model import SharingChannel
from cdb import misc
from cdb import auth
from cdb.storage.index.errors import ESException
from cs.activitystream.objects import Posting
from cs.activitystream.objects import SystemPosting
from cs.activitystream.objects import Comment
from cs.activitystream.objects import Topic2Posting
from cdb.objects import Object
from cdb.objects import ByID
from cs.platform.web.root import get_root
from cs.platform.web.root import get_v1
from cs.platform.web.rest import support
from cs.platform.web.rest.generic.model import FileCollection
from cs.platform.web.rest.generic.convert import dump_datetime
from cs.platform.web.uisupport import get_ui_link


# cache generated person views and links for current session
# to boost the performance
PERSON_VIEW_CACHE = {}
PERSON_LINK_CACHE = {}


def _get_collection_app(request):
    return get_v1(request).child("collection")


def _get_person_view(request, person):
    if person.personalnummer not in PERSON_VIEW_CACHE:
        PERSON_VIEW_CACHE[person.personalnummer] = request.view(
            person, app=_get_collection_app(request))
    return PERSON_VIEW_CACHE[person.personalnummer]


def _get_person_link(request, person):
    if person.personalnummer not in PERSON_LINK_CACHE:
        PERSON_LINK_CACHE[person.personalnummer] = get_ui_link(request, person)
    return PERSON_LINK_CACHE[person.personalnummer]


@ActivityStreamApp.json(model=PostingCollection)
def postings_get(posting_collection, request):
    queried = posting_collection.query()
    postings = [request.view(obj) for obj in queried[0]]
    return {"@id": request.link(posting_collection),
            "default_topic": ToAllChannel().GetDescription(),
            "postings": postings,
            "result_complete": queried[1]}


@ActivityStreamApp.json(model=PostingCollection, request_method="POST")
def posting_new(self, request):
    if "text" not in request.json.keys() or len(request.json["text"]) < 1:
        raise HTTPUnprocessableEntity()
    posting = self.add_posting(request.json["text"])
    _add_attachments(PostingAttachments(posting), request)
    return request.view(posting)


@ActivityStreamApp.json(model=Posting)
def posting_get(self, request):
    """Get a posting."""
    is_system_posting = isinstance(self, SystemPosting)
    files = None
    upload_url = ""
    if not is_system_posting:
        generic_as = _get_collection_app(request).child(
            "{rest_name}", rest_name="activitystream")
        files = request.view(FileCollection(self), app=generic_as)
        if self.cdb_cpersno == auth.persno:
            upload_url = request.link(self, app=generic_as) + "/files"
    result = {
        "@id": request.link(self),
        "cdb_object_id": self.cdb_object_id,
        "system:navigation_id": support.rest_key(self),
        "text": self.GetText("cdbblog_posting_txt"),
        "icon": self.GetClassIcon(),
        "title": self.GetDescription(),
        "datetime": self.cdb_mdate.isoformat(),
        "last_comment_date": self.last_comment_date.isoformat(),
        "author": _get_person_view(request, self.Author),
        "comments": request.view(PostingComments(self)),
        "topics": request.view(PostingTopics(self)),
        "attachments": request.view(PostingAttachments(self)),
        "is_system_posting": is_system_posting,
        "system:ui_link": request.link(self, app=get_root(request).child("activitystream")),
        "relship:files": files,
        "file_upload_url": upload_url
    }
    return result


@ActivityStreamApp.json(model=PostingComments)
def comments_get(obj_collection, request):
    """Get a listing of comments for a posting."""
    objs = [request.view(obj) for obj in obj_collection.query()]
    return {
        "@id": request.link(obj_collection),
        "comments": objs,
        "result_complete": True
    }


def _add_comment(col, request, reply_to=None):
    if "text" in request.json.keys() and len(request.json["text"]):
        if not reply_to:
            comment = col.add_comment(request.json["text"])
        else:
            comment = col.add_reply_to(request.json["text"], reply_to)
        _add_attachments(CommentAttachments(comment), request)
        # Return newly created entry instead of collection
        return request.view(comment)
    else:
        raise HTTPUnprocessableEntity()


@ActivityStreamApp.json(model=PostingComments, request_method="POST")
def comment_new(self, request):
    return _add_comment(self, request)


@ActivityStreamApp.json(model=Comment)
def comment_get(self, request):
    """Get a comment."""
    reply_to_comment = self.ReplyTo
    if reply_to_comment is not None:
        reply_to_author = _get_person_link(request, reply_to_comment.Author)
    else:
        reply_to_author = None
    generic_as = _get_collection_app(request).child(
        "{rest_name}", rest_name="activitystream_comment")
    files = None
    upload_url = ""
    if generic_as:
        files = request.view(FileCollection(self), app=generic_as)
        if self.cdb_cpersno == auth.persno:
            upload_url = request.link(self, app=generic_as) + "/files"
    return {
        "@id": request.link(self),
        "cdb_object_id": self.cdb_object_id,
        "text": self.GetText("cdbblog_comment_txt"),
        "reply_to": request.link(reply_to_comment),
        "reply_to_author": reply_to_author,
        "posting_id": request.link(self.Posting),
        "datetime": self.cdb_mdate.isoformat(),
        "author": _get_person_view(request, self.Author),
        "attachments": request.view(CommentAttachments(self)),
        "relship:files": files,
        "file_upload_url": upload_url
    }


@ActivityStreamApp.json(model=Comment, request_method="POST")
def reply_new(self, request):
    return _add_comment(PostingComments(self.Posting), request, self)


def _object_view(obj, request):
    """mini object view"""
    return {"@id": request.link(obj),
            "cdb_object_id": obj.cdb_object_id,
            "description": obj.GetDescription(),
            "object_icon": obj.GetObjectIcon(),
            "class_icon": obj.GetClassIcon()}


@ActivityStreamApp.json(model=Object, name="with_ui_links")
def object_view_with_links(obj, request):
    """object view with UI links"""
    _view = _object_view(obj, request)
    obj_link = obj_ui_link = ""
    # UI link to the real business object referenced as topic
    if isinstance(obj, Posting):
        obj_ui_link = request.link(obj, app=get_root(request).child("activitystream"))
    else:
        try:
            obj_link = request.link(obj, app=_get_collection_app(request))
        except morepath.error.LinkError:
            pass
        obj_ui_link = get_ui_link(request, obj) or ""
    _view.update({
        "object_id": obj_link,
        "object_ui_link": obj_ui_link})
    return _view


@ActivityStreamApp.json(model=Object, name="compact")
def object_get_compact(self, request):
    """mini object view"""
    return _object_view(self, request)


@ActivityStreamApp.json(model=Object)
def object_get(self, request):
    """object view with referenced postings"""
    _view = _object_view(self, request)
    queried = ObjectPostings(self.cdb_object_id, request.params.mixed()).query()
    postings = [request.view(obj) for obj in queried[0]]

    _view.update({
        "postings": postings,
        "result_complete": queried[1]
    })
    return _view


@ActivityStreamApp.json(model=Topic2Posting, internal=True)
def topic2posting_get(self, request):
    """Get a topic for a posting."""
    topic = ByID(self.topic_id)
    if not topic.CheckAccess("read"):
        return None
    return request.view(topic, name="with_ui_links")


@ActivityStreamApp.json(model=PostingTopics)
def topics_get(obj_collection, request):
    topics = [request.view(topic, name="with_ui_links")
              for topic in obj_collection.query(check_access="read")]
    return {"topics": topics,
            "@id": request.link(obj_collection),
            "result_complete": True}


@ActivityStreamApp.json(model=PostingTopics, request_method="POST")
def topic_new(self, request):
    if "topic_ids" in request.json.keys() and len(request.json["topic_ids"]):
        self.add_topics(request.json["topic_ids"])
        return request.view(self)
    else:
        raise HTTPUnprocessableEntity()


@ActivityStreamApp.json(model=Object, request_method="POST")
def topic_posting_new(self, request):
    """Add a posting to an object."""
    col = ObjectPostings(self.cdb_object_id, {})
    return posting_new(col, request)


@ActivityStreamApp.json(model=ChannelCollection, request_method="GET")
def channels_get(obj_collection, request):
    predef, normal = obj_collection.query()
    predef_channels = [request.view(obj, name="compact") for obj in predef]
    channels = [request.view(obj, name="compact") for obj in normal]
    return {"@id": request.link(obj_collection),
            "predefined": predef_channels,
            "channels": channels,
            "result_complete": True}


@ActivityStreamApp.json(model=SubscriptionCollection, request_method="GET")
def subscriptions_get(subscr_collection, request):
    groups = subscr_collection.query()
    subscriptions = []
    for grp in groups:
        subscriptions.append(request.view(grp))
    return {"@id": request.link(subscr_collection),
            "subscriptions": subscriptions,
            "result_complete": True}


@ActivityStreamApp.json(model=SharingChannel, name="compact")
def sharing_get_compact(self, request):
    """Get a topic."""
    return _object_view(self, request)


@ActivityStreamApp.json(model=SharingChannel, name="with_ui_links")
def sharing_get_with_links(self, request):
    """Get a topic."""
    _view = _object_view(self, request)
    _view.update({
        "object_id": "",
        "object_ui_link": ""})
    return _view


@ActivityStreamApp.json(model=SharingChannel)
def sharing_get(self, request):
    """Get postings of 'To All' channel."""
    _view = _object_view(self, request)
    queried = SharingCollection(request.params.mixed()).query()
    objs = [request.view(obj) for obj in queried[0]]
    _view.update({
        "postings": objs,
        "result_complete": queried[1]
    })
    return _view


@ActivityStreamApp.json(model=Attachments)
def attachments_get(obj_collection, request):
    views = [request.view(obj, name="with_ui_links") for obj in obj_collection.query()]
    return {"attachments": [aview for aview in views if aview is not None],
            "@id": request.link(obj_collection),
            "addable": obj_collection.modifiable(),
            "result_complete": True}


def _add_attachments(col, request):
    if "attachment_ids" in request.json.keys() and len(request.json["attachment_ids"]):
        col.add_attachments(request.json["attachment_ids"])
        return True
    else:
        return False


@ActivityStreamApp.json(model=Attachments, request_method="POST")
def attachment_new(self, request):
    if _add_attachments(self, request):
        return request.view(self)
    else:
        raise HTTPUnprocessableEntity()


@ActivityStreamApp.json(model=ToAllChannel, name="compact")
def toall_get_compact(self, request):
    """Get a topic."""
    return _object_view(self, request)


@ActivityStreamApp.json(model=ToAllChannel, name="with_ui_links")
def toall_get_with_links(self, request):
    """Get a topic."""
    _view = _object_view(self, request)
    _view.update({
        "object_id": "",
        "object_ui_link": ""})
    return _view


@ActivityStreamApp.json(model=ToAllChannel)
def toall_get(self, request):
    """Get postings of 'To All' channel."""
    _view = _object_view(self, request)
    queried = ToAllChannelPostings(request.params.mixed()).query()
    objs = [request.view(obj) for obj in queried[0]]
    _view.update({
        "postings": objs,
        "result_complete": queried[1]
    })
    return _view


@ActivityStreamApp.json(model=ToAllChannel, request_method="POST")
def toall_post(self, request):
    return posting_new(self, request)


@ActivityStreamApp.json(model=PersonSearchModel)
def search_person_get(self, request):
    """Get search result for topic or attachment object."""
    try:
        search_result = self.get_result_for_activitystream()
        for entry in search_result["result"]:
            obj = entry.get("self", None)
            if obj:
                # not provide object itself, but app specific data
                entry["self"] = None
                entry["cs_activitystream_data"] = _get_person_view(request, obj)
            entry["date"] = dump_datetime(entry["date"])
        return {"result": search_result}
    except ESException, e:
        misc.log_traceback("Enterprise Search: %s" % e)
        res = request.ResponseClass(json.dumps(unicode(e)),
                                    status=HTTPInternalServerError.code,
                                    content_type="application/json")
        return res


# filter categories
@ActivityStreamApp.json(model=SubscriptionCategoryBase)
def subscription_category(self, request):
    return {"description": self.title,
            "icon": self.icon,
            "subscriptions": [request.view(obj, name="compact") for obj in self.get_objects()]}
