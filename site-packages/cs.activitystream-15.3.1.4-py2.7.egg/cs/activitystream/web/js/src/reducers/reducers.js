/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: reducers.js 164019 2017-08-25 15:37:23Z yzh $"
 */

import Immutable from 'immutable';
import {RECEIVED_POSTINGS, POSTING_CREATED, POSTING_REMOVED,
    APPEND_POSTINGS, POSTING_UPDATED, POSTING_UPDATING,
    UPDATE_CONFIRMED, INCOMING_POSTINGS,
    RECEIVED_CHANNELS, RECEIVED_SUBSCRIPTIONS} from '../actions/actions';

const getCollectionInfo = (col) => {
    let result = Immutable.Map({});
    const postings = col.postings;
    const oids = Immutable.OrderedSet(postings.map(o => o['@id']));
    result = result
        .set('postings', oids)
        .set('result_complete', col['result_complete']);
    if (postings.length > 0) {
        const lastOne = postings[postings.length - 1];
        result = result
            .set('lastCommentDate', lastOne['last_comment_date'])
            .set('lastObjectId', lastOne['cdb_object_id']);
    }
    return result;
};

const getCollectionTimestamp = (col) => {
    const postings = col.postings;
    if (postings.length > 0) {
        const firstOne = postings[0];
        return firstOne['last_comment_date'];
    }
    return undefined;
};

const getCollectionUpdateTime = (col) => {
    let result = Immutable.Map({});
    const updatedAt = getCollectionTimestamp(col);
    if (updatedAt) {
        result = result
            .set('updatedAt', updatedAt);
    }
    return result;
};

export function collections(state = Immutable.Map(), action) {
    const instanceName = action.meta && action.meta.instanceName;
    if (action.type === RECEIVED_POSTINGS) {
        return state.set(
                    instanceName,
                    Immutable.Map(action.payload)
                        .merge(getCollectionInfo(action.payload))
                        .merge(getCollectionUpdateTime(action.payload)));
    } else if (instanceName && state.get(instanceName) === undefined) {
        return state;
    }
    switch (action.type) {
        case APPEND_POSTINGS: {
            const prev = state.getIn([instanceName, 'postings']);
            const updated = getCollectionInfo(action.payload)
                .update('postings', (curr) => prev.union(curr));
            return state.mergeIn([instanceName], updated);
        }
        case INCOMING_POSTINGS: {
            const incoming = getCollectionInfo(action.payload);
            return state.update(
                instanceName,
                (prevData) =>
                    prevData.update(
                        'postings',
                        (prevCol) =>
                            incoming.get('postings').union(prevCol)
                    ));
        }
        case POSTING_CREATED: {
            const posting = action.payload;
            return state.update(
                instanceName,
                (prevData) =>
                    prevData.update(
                        'postings',
                        (prevCol) =>
                            Immutable.OrderedSet([posting['@id']]).union(prevCol)
                    ).set('updatingPosting', posting['cdb_object_id'])
            );
        }
        case POSTING_REMOVED: {
            const postingURL = action.payload;
            return state.update(
                instanceName,
                (prevData) =>
                    prevData.update(
                        'postings',
                        (prevCol) => prevCol.delete(postingURL)
                    )
            );
        }
        case POSTING_UPDATING:
            return state.update(
                instanceName,
                (prevData) => prevData.set(
                    'updatingPosting', action.payload)
            );
        case POSTING_UPDATED:
            return state.update(
                instanceName,
                (prevData) => prevData.set(
                    'updatingPosting', undefined)
            );
        case UPDATE_CONFIRMED:
            return state.update(
                instanceName,
                (prevData) =>
                    prevData.set('updatedAt', action.payload)
                        .set('updatingPosting', undefined)
            );
        default:
            return state;
    }
}

export function channels(state = Immutable.Map(), action) {
    switch (action.type) {
        case RECEIVED_CHANNELS:
            return Immutable.fromJS(action.payload);
        default:
            return state;
    }
}

export function subscriptions(state = Immutable.Map(), action) {
    switch (action.type) {
        case RECEIVED_SUBSCRIPTIONS:
            return Immutable.fromJS(action.payload);
        default:
            return state;
    }
}

export function links(state = Immutable.Map(), action) {
    switch (action.type) {
        case RECEIVED_CHANNELS:
            return state.withMutations(prev => {
                if (action.payload.predefined) {
                    action.payload.predefined.forEach((channel) =>
                        prev.set(channel['cdb_object_id'], channel['@id'])
                    );
                }
                if (action.payload.channels) {
                    action.payload.channels.forEach((channel) =>
                        prev.set(channel['cdb_object_id'], channel['@id'])
                    );
                }
            });
        case RECEIVED_SUBSCRIPTIONS:
            return state.withMutations(prev => {
                if (action.payload.subscriptions) {
                    action.payload.subscriptions.forEach((group) => {
                        if (group.subscriptions) {
                            group.subscriptions.forEach((channel) =>
                                prev.set(
                                    channel['cdb_object_id'], channel['@id'])
                            );
                        }
                    });
                }
            });
        default:
            return state;
    }
}
