/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: actions.js 168213 2017-11-10 10:00:44Z yzh $"
 */

import {prefixNS} from '../helpers.js';
import {
    fetchCollection, createObject, fetchObject,
    postJSON, postForm, makeSequence, singleFetch,
    notifyError, NetworkError
} from 'cs-web-components-base';
import {CHANNLE_LINK, SUBSCRIPTION_LINK} from '../constants';
import {formatStr} from '../i18n';

export const RECEIVED_POSTINGS = prefixNS('RECEIVED_POSTINGS');
export const APPEND_POSTINGS = prefixNS('APPEND_POSTINGS');
export const INCOMING_POSTINGS = prefixNS('INCOMING_POSTINGS');
export const POSTING_CREATED = prefixNS('POSTING_CREATED');
export const POSTING_REMOVED = prefixNS('POSTING_REMOVED');
export const POSTING_UPDATING = prefixNS('POSTING_UPDATING');
export const POSTING_UPDATED = prefixNS('POSTING_UPDATED');
export const UPDATE_CONFIRMED = prefixNS('UPDATE_CONFIRMED');
export const RECEIVED_CHANNELS = prefixNS('RECEIVED_CHANNELS');
export const RECEIVED_SUBSCRIPTIONS = prefixNS('RECEIVED_SUBSCRIPTIONS');

function receivedPostings(instanceName, url, filter, coll) {
    return {
        type: RECEIVED_POSTINGS,
        payload: coll,
        meta: {url, filter, instanceName}
    };
}

function appendPostings(instanceName, url, param, coll) {
    return {
        type: APPEND_POSTINGS,
        payload: coll,
        meta: {url, param, instanceName}
    };
}

function incomingPostings(instanceName, url, param, coll) {
    return {
        type: INCOMING_POSTINGS,
        payload: coll,
        meta: {url, param, instanceName}
    };
}

function postingCreated(instanceName, posting) {
    return {
        type: POSTING_CREATED,
        payload: posting,
        meta: {instanceName}
    };
}

function postingRemoved(instanceName, id) {
    return {
        type: POSTING_REMOVED,
        payload: id,
        meta: {instanceName}
    };
}

function postingUpdating(instanceName, oID) {
    return {
        type: POSTING_UPDATING,
        payload: oID,
        meta: {instanceName}
    };
}

function postingUpdated(instanceName) {
    return {
        type: POSTING_UPDATED,
        meta: {instanceName}
    };
}

function updateConfirmed(instanceName, confirmedAt) {
    return {
        type: UPDATE_CONFIRMED,
        payload: confirmedAt,
        meta: {instanceName}
    };
}

function receivedChannels(channels) {
    return {
        type: RECEIVED_CHANNELS,
        payload: channels
    };
}

function receivedSubscriptions(subscriptions) {
    return {
        type: RECEIVED_SUBSCRIPTIONS,
        payload: subscriptions
    };
}

export function fetchPosting(url) {
    return dispatch => dispatch(fetchObject(url));
}

export function fetchPostings(instanceName, url, filter) {
    return (dispatch) => {
        return dispatch(fetchCollection(url, filter.toJS(), (data) => data.postings))
            .then(data => {
                dispatch(receivedPostings(instanceName, url, filter, data));
                return data;
            });
    };
}

export function fetchMorePostings(instanceName, url, filter) {
    return (dispatch, getState) => {
        const prev = getState()[componentNameSpace]
            .collections.get(instanceName);
        const param = Object.assign(filter.toJS(), {
            last_comment_date: prev.get('lastCommentDate'),
            last_object_id: prev.get('lastObjectId')
        });
        dispatch(fetchCollection(url, param, (data) => data.postings))
            .then(data => dispatch(appendPostings(instanceName, url, param, data)));
    };
}

export function uploadFiles(posting, files) {
    return (dispatch) => {
        const uploadURL = posting.file_upload_url;
        if (!uploadURL) {
            return makeSequence([]);
        }
        const callables =
            files.map(file => () => {
                const formData = new FormData();
                formData.append('content', file);
                formData.append('metadata', JSON.stringify({
                    'cdbf_original_name': file.name,
                    'cdbf_name': file.name
                }));
                return postForm(uploadURL, formData);
            });
        return makeSequence(callables).catch(
            error => {
                let detail = error;
                if (error instanceof NetworkError) {
                    detail = new NetworkError(formatStr('upload-aborted'));
                }
                dispatch(notifyError(detail, null, formatStr('activities')));
            }).then(() => posting);
    };
}

export function reloadPosting(instanceName, postingID) {
    return (dispatch) => {
        return dispatch(fetchPosting(postingID))
            .then(() =>
                dispatch(postingUpdated(instanceName)));
    };
}

export function createPosting(instanceName, url, text, attachments, files) {
    return (dispatch) => {
        const data = {text: text};
        if (attachments.count()) {
            data.attachment_ids = attachments.toArray();
        }
        return dispatch(createObject(url, data)).then(
            (posting) => {
                dispatch(postingCreated(instanceName, posting));
                return posting;
            }).catch(error => {
                let detail = error;
                const response = error.response;
                if (response && response.status === 404 && response.url === url) {
                    detail = new Error(formatStr('context-not-found'));
                    detail.response = response;
                }
                else if (error instanceof NetworkError) {
                    detail = new NetworkError(formatStr('network-error'));
                }
                dispatch(notifyError(detail, null, formatStr('activities')));
                throw detail;
            }).then(
                (posting) => dispatch(uploadFiles(posting, files))
            ).then(
                (posting) => dispatch(reloadPosting(instanceName, posting['@id']))
            );
    };
}

export function createComment(instanceName, url, {posting, text, attachments, files}) {
    return (dispatch) => {
        const data = {text: text};
        const postingURL = posting.get('@id');
        if (attachments.count()) {
            data.attachment_ids = attachments.toArray();
        }
        dispatch(postingUpdating(instanceName, posting.get('cdb_object_id')));
        return dispatch(createObject(url, data))
            .catch(error => {
                let detail = error;
                const response = error.response;
                if (response && response.status === 404 && response.url === url) {
                    detail = new Error(formatStr('posting-not-found'));
                    detail.response = response;
                    dispatch(notifyError(detail));
                    dispatch(postingUpdated(instanceName));
                    dispatch(postingRemoved(instanceName, postingURL));
                }
                else if (error instanceof NetworkError) {
                    detail = new NetworkError(formatStr('network-error'));
                }
                dispatch(notifyError(detail, null, formatStr('activities')));
                throw detail;
            }).then(
                (comment) => dispatch(uploadFiles(comment, files))
            ).then(
                // reload posting
                () => dispatch(reloadPosting(instanceName, postingURL))
            );
    };
}

export function assignTopics(instanceName, posting, topics) {
    return (dispatch) => {
        const url = posting.getIn(['topics', '@id']);
        dispatch(postingUpdating(instanceName, posting.get('cdb_object_id')));
        postJSON(url, {topic_ids: topics.toArray()}).then(
            // reload posting
            () => dispatch(reloadPosting(instanceName, posting.get('@id'))));
    };
}

export function confirmUpdate(instanceName, confirmedAt) {
    return (dispatch) =>
        dispatch(updateConfirmed(instanceName, confirmedAt));
}

export function checkNewPostings(instanceName, url, filter) {
    return (dispatch, getState) => {
        const prev = getState()[componentNameSpace]
            .collections.get(instanceName);
        const param = Object.assign(filter.toJS(), {
            since: prev.get('updatedAt'),
            posting_count: 99999
        });
        dispatch(fetchCollection(url, param, (data) => data.postings))
            .then(data => dispatch(incomingPostings(instanceName, url, param, data)))
            .catch(() => {});
    };
}

export function fetchChannels() {
    return dispatch => {
        return dispatch(singleFetch(
            CHANNLE_LINK,
            data => dispatch(receivedChannels(data))
        ));
    };
}

export function fetchSubscriptions() {
    return dispatch => {
        return dispatch(singleFetch(
            SUBSCRIPTION_LINK,
            data => dispatch(receivedSubscriptions(data))
        ));
    };
}
