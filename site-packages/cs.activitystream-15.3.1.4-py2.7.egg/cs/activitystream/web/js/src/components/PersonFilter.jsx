/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: PersonFilter.jsx 174161 2018-03-07 14:27:13Z yzh $"
 */

import React from 'react';
import {FormControl, Tiles, getJSON, getAppSetup, getIcon} from 'cs-web-components-base';
import {ImmutablePropTypes, PropTypes} from 'cs-web-components-externals';
import Immutable from 'immutable';
import {prefixNS} from '../helpers';
import {formatStr} from '../i18n';

const searchURL = getAppSetup().getIn([componentNameSpace, 'personSearchURL']);
const TypeAheadText = FormControl.WithTypeAhead(FormControl.TextInput);
const SEARCH_DELAY = 250;

function PersonRenderer({item}) {
    const contextObject = item.get('cs_activitystream_data');
    const orgname = contextObject.get('orgname');
    return (
        <div className={prefixNS('person-filter-tile')}>
            <Tiles.Tile contextObject={contextObject}
                        fallbackImg={getIcon('csweb_person_fallback')}
                        headerAttr='name'
                        plain
                        thumbnailSize='lg'>
                <div title={orgname}>{orgname}</div>
            </Tiles.Tile>
        </div>
    );
}

PersonRenderer.propTypes = {
    item: ImmutablePropTypes.map
};

function normValue(value) {
    return value === undefined ? '' : value;
}

export default class PersonFilter extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            text: normValue(props.value),
            matches: Immutable.List(),
            hasMore: false
        };
        this._searchRequest = null;
        this.ontextChange = this.ontextChange.bind(this);
        this.onSelectAt = this.onSelectAt.bind(this);
        this.onBlur = this.onBlur.bind(this);
    }

    componentWillUnmount() {
        this.cancelRequest();
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.value !== this.props.value) {
            this.setState({
                text: normValue(nextProps.value)
            });
        }
    }

    cancelRequest() {
        if (this._searchRequest !== null) {
            clearTimeout(this._searchRequest);
        }
    }

    fetchMatches() {
        const value = this.state.text;
        this.cancelRequest();
        if (!value) {
            this.setState({
                matches: Immutable.List(),
                hasMore: false
            });
            return;
        }
        this._searchRequest = setTimeout(
            () => {
                getJSON(searchURL, {fulltextsearch: `${value}*`}).then(data => {
                    this._searchRequest = null;
                    this.setState({
                        matches: Immutable.fromJS(data.result.result),
                        hasMore: data.result.links.length > 0
                    });
                });
            },
            SEARCH_DELAY
        );
    }

    ontextChange(value) {
        this.setState({
            text: value
        }, this.fetchMatches);
        if (!value) {
            this.props.onFilterChange && this.props.onFilterChange({});
        }
    }

    onSelectAt(idx) {
        const hit = this.state.matches.get(idx);
        this.setState({
            text: hit.getIn(['cs_activitystream_data', 'name']),
            matches: this.state.matches.clear().push(hit),
            hasMore: false
        });
        this.props.onFilterChange && this.props.onFilterChange({
            pn: hit.getIn(['cs_activitystream_data', 'personalnummer']),
            author: hit.getIn(['cs_activitystream_data', 'name'])
        });
    }

    onBlur() {
        const value = normValue(this.props.value);
        if (this.state.text !== value) {
            this.setState({text: value});
        }
    }

    render() {
        return (
            <TypeAheadText
                name={prefixNS('person-filter')}
                className={prefixNS('person-filter')}
                TypeAheadItemRenderer={PersonRenderer}
                value={this.state.text}
                matched={this.state.matches}
                onValueChange={this.ontextChange}
                onSelectAt={this.onSelectAt}
                hasMoreMatches={this.state.hasMore}
                placeholder={formatStr('filter_by_person')}
                onBlur={this.onBlur}
                autoSelectFirstMatch={true}/>
        );
    }
}

PersonFilter.propTypes = {
    value: PropTypes.string,
    onFilterChange: PropTypes.func
};
