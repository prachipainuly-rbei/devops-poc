/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: PostingList.jsx 174894 2018-03-22 14:27:29Z gwe $"
 */

import React from 'react';
import Immutable from 'immutable';
import {connect, ImmutablePropTypes, PropTypes, classNames} from 'cs-web-components-externals';
import {Button} from 'cs-web-components-base';
import {fetchPostings, createPosting, fetchMorePostings,
    confirmUpdate, checkNewPostings} from '../actions/actions';
import {getReferencedPostings} from '../helpers';
import Posting from './Posting';
import {prefixNS} from '../helpers';
import CreateForm from './CreateForm';
import {formatStr} from '../i18n';
import {Collapse, Alert} from 'react-bootstrap';

const CHECKINTERVAL = 900000;  // 15 min.

const getID = (entry) => entry.get('cdb_object_id');
const findByID = (coll, oid) => coll.find(entry => getID(entry) === oid);
const getDate = (entry) => entry.get('last_comment_date');

function sortPostings(postings, dateMap = Immutable.Map()) {
    return postings === undefined ? undefined :
        postings.sortBy(
            posting => dateMap.get(
                getID(posting),
                getDate(posting)
            )).reverse();
}

function getOlderPostings(postings, updatedAt) {
    if (postings === undefined) {
        return postings;
    }
    return postings
        .filter(posting => getDate(posting) <= updatedAt);
}

function generateDateMap(postings) {
    if (postings === undefined) {
        return undefined;
    }
    return Immutable.Map(
        postings.map(posting =>
            [getID(posting), getDate(posting)]));
}

class PostingList extends React.Component {
    constructor(props) {
        super(props);
        // dateMap supposed to keep the sequence of postings to avoid
        // flicking due to posting date changes in store
        this.state = {
            dateMap: undefined,
            postings: undefined,
            newest: props.updatedAt,
            incoming: false
        };
        this.createPosting = this.createPosting.bind(this);
        this.loadMorePostings = this.loadMorePostings.bind(this);
        this.confirmUpdate = this.confirmUpdate.bind(this);
        this.checkNewPostings = this.checkNewPostings.bind(this);
        this.stopChecker = this.stopChecker.bind(this);
        this._checker = null;
    }

    componentWillMount() {
        const {fetchPostings, initDataURL, filter} = this.props;
        fetchPostings(initDataURL, filter);
    }

    componentDidMount() {
        this.checkNewPostings();
    }

    componentWillUnmount() {
        this.stopChecker();
    }

    stopChecker() {
        if (this._checker !== null) {
            window.clearTimeout(this._checker);
        }
        this._checker = null;
    }

    checkNewPostings() {
        this.stopChecker();
        this._checker = window.setTimeout(
            () => {
                const {checkNewPostings, initDataURL, filter} = this.props;
                checkNewPostings(initDataURL, filter);
                this.checkNewPostings();
            },
            CHECKINTERVAL);
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.initDataURL !== this.props.initDataURL ||
            nextProps.filter !== this.props.filter) {
            // new fetching required, clean up old stuff
            this.setState({
                dateMap: undefined,
                incoming: false
            });
            this.stopChecker();
            nextProps.fetchPostings(nextProps.initDataURL, nextProps.filter)
                .then(this.checkNewPostings);
        } else if (this.state.dateMap === undefined) {
            // recreate the posting sequences
            const sorted = sortPostings(nextProps.postings);
            this.setState({
                postings: sorted,
                dateMap: generateDateMap(sorted),
                incoming: false
            });
        } else if (nextProps.updatedAt !== this.props.updatedAt) {
            // keep list uptodate
            this.stopChecker();
            const sorted = sortPostings(
                getOlderPostings(nextProps.postings, nextProps.updatedAt));
            this.setState({
                postings: sorted,
                dateMap: generateDateMap(sorted),
                incoming: nextProps.postings.count() !== sorted.count()
            });
            this.checkNewPostings();
        } else {
            const updatingID = nextProps.updatingPosting;
            const updatingPosting = updatingID ?
                findByID(this.state.postings, updatingID) : undefined;
            const updatedPosting = updatingID ?
                findByID(nextProps.postings, updatingID) : undefined;
            const updating = updatingPosting !== updatedPosting;
            if (!nextProps.postings.equals(this.props.postings) || updating) {
                const nextIDs = nextProps.postings.map(getID);
                let showing = this.state.postings;
                // remove obsolete data
                showing = showing.filter(
                    posting => nextIDs.contains(getID(posting)));
                // local changed posting
                // (creating, commenting, assigning topics)
                if (updating) {
                    showing = showing.delete(updatingPosting).add(updatedPosting);
                }
                // unchanged and newly appended postings e.g. via "load more"
                const olderOnes = getOlderPostings(
                    nextProps.postings, nextProps.updatedAt);
                const olderIDs = olderOnes.map(getID);
                // because the props.postings are real time data,
                // use them in conflicts.
                showing = showing
                    .filterNot(posting => olderIDs.contains(getID(posting)))
                    .union(olderOnes);
                // sort list according to cached date to keep sequence
                // unchanged
                showing = sortPostings(showing, this.state.dateMap);
                const newMap = showing.reduce(
                    (dateMap, posting) => {
                        const oid = getID(posting);
                        return dateMap.set(
                            oid,
                            this.state.dateMap.get(oid, getDate(posting)));
                    }, Immutable.Map());
                this.setState({
                    postings: showing,
                    dateMap: newMap,
                    incoming: nextProps.postings.subtract(showing).count() > 0
                });
            }
        }
    }

    createPosting(text, attachments, files) {
        const {createPosting} = this.props;
        return createPosting(text, attachments, files);
    }

    loadMorePostings() {
        const {initDataURL, filter, fetchMorePostings} = this.props;
        fetchMorePostings(initDataURL, filter);
    }

    renderPostings() {
        const {instanceName, updatedAt} = this.props;
        const postings = this.state.postings;
        return (postings === undefined ?
            null :
            postings.map(posting =>
                <Posting
                    key={posting.get('cdb_object_id')}
                    instanceName={instanceName}
                    posting={posting}
                    lastUpdatedAt={updatedAt}/>
            ));
    }

    confirmUpdate() {
        const {confirmUpdate, postings} = this.props;
        if (confirmUpdate && postings) {
            confirmUpdate(getDate(postings.maxBy(getDate)));
        }
    }

    render() {
        const {topicDesc, defaultTopic, resultComplete, className, showForm} = this.props;
        const topic = topicDesc || defaultTopic;
        const label = formatStr('new-posting', {topic});
        const clsname = classNames(className, prefixNS('posting-list'));
        return (
            <div className={clsname}>
                <Collapse in={this.state.incoming}>
                    <Alert bsStyle="info">
                        <Button.TextButton
                            label={formatStr('incoming-postings')}
                            buttonStyle="primary"
                            onClick={this.confirmUpdate} />
                    </Alert>
                </Collapse>
                {showForm ? (
                    <CreateForm
                        label={label}
                        placeholder={label}
                        createEntry={this.createPosting}/>
                ) : null}
                {this.renderPostings()}
                {resultComplete === false ?
                    <Button.TextButton
                        label={formatStr('load-more')}
                        className={prefixNS('load-more')}
                        buttonStyle="primary"
                        onClick={this.loadMorePostings} /> :
                    null
                }
            </div>
        );
    }
}

PostingList.propTypes = {
    instanceName: PropTypes.string.isRequired,
    initDataURL: PropTypes.string.isRequired,
    resultComplete: PropTypes.bool,
    topicDesc: PropTypes.string,
    defaultTopic: PropTypes.string,
    updatedAt: PropTypes.string,
    postings: ImmutablePropTypes.orderedSet,
    filter: ImmutablePropTypes.map,
    updatingPosting: PropTypes.string,
    confirmUpdate: PropTypes.func,
    fetchPostings: PropTypes.func,
    checkNewPostings: PropTypes.func,
    createPosting: PropTypes.func,
    fetchMorePostings: PropTypes.func,
    className: PropTypes.string,
    showForm: PropTypes.bool
};

PostingList.defaultProps = {
    filter: Immutable.Map()
};

function mapStateToProps(state, ownProps) {
    const {instanceName} = ownProps;
    const compState = state[componentNameSpace];
    const postings = compState === undefined ?
        undefined :
        getReferencedPostings(
            state,
            compState.collections.getIn([
                instanceName,
                'postings'
            ]));
    return {
        postings,
        resultComplete: compState.collections.getIn([
            instanceName,
            'result_complete'
        ]),
        topicDesc: compState.collections.getIn([
            instanceName,
            'description'
        ]),
        defaultTopic: compState.collections.getIn([
            instanceName,
            'default_topic'
        ]),
        updatedAt: compState.collections.getIn([
            instanceName,
            'updatedAt'
        ]),
        updatingPosting: compState.collections.getIn([
            instanceName,
            'updatingPosting'
        ]),
        showForm: compState.collections.getIn([
            instanceName,
            'cdb_object_id'
        ]) !== 'sharing'
    };
}

function mapDispatchToProps(dispatch, ownProps) {
    const {instanceName} = ownProps;
    return {
        fetchPostings: (url, filter) =>
            dispatch(fetchPostings(instanceName, url, filter)),
        fetchMorePostings: (url, filter) =>
            dispatch(fetchMorePostings(instanceName, url, filter)),
        checkNewPostings: (url, filter) =>
            dispatch(checkNewPostings(instanceName, url, filter)),
        createPosting: (text, attachments, files) =>
            dispatch(createPosting(
                instanceName, ownProps.initDataURL, text, attachments, files)),
        confirmUpdate: (confirmAt) =>
            dispatch(confirmUpdate(instanceName, confirmAt))
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(PostingList);
