/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: CreateForm.jsx 168213 2017-11-10 10:00:44Z yzh $"
 */

import React from 'react';
import Immutable from 'immutable';
import {FormControl, FileDropzone, Button, ButtonGroup,
    isSupportedImageType, isSupportedVideoType, Throbber} from 'cs-web-components-base';
import {classNames, PropTypes} from 'cs-web-components-externals';
import {prefixNS} from '../helpers';
import {formatStr} from '../i18n';
import {AssignAttachments} from './Actions';
import Attachments from './Attachments';

class Renderer extends React.PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            src: this.getPreview(props),
            isVideo: isSupportedVideoType(props.file.type)
        };
    }

    getPreview(props) {
        return FileDropzone.getPreview(props.file);
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.file !== this.props.file) {
            this.setState({
                src: this.getPreview(nextProps),
                isVideo: isSupportedVideoType(nextProps.file.type)
            });
        }
    }

    componentWillUnmount() {
        FileDropzone.revokePreview(this.state.src);
    }

    render() {
        const {src, isVideo} = this.state;
        if (isVideo) {
            return (
                <video src={src} />
            );
        } else {
            return (
                <img src={src} />
            );
        }
    }
}

Renderer.propTypes = {
    file: PropTypes.any.isRequired
};

const calculatorClassName = prefixNS('form__height-calculator');

export default class CreateForm extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            newEntry: this.makeNewEntry(),
            expanded: false,
            height: null,
            submitting: false
        };
        this.onChange = this.onChange.bind(this);
        this.onSubmit = this.onSubmit.bind(this);
        this.onClose = this.onClose.bind(this);
        this.expandForm = this.expandForm.bind(this);
        this.assignAttachments = this.assignAttachments.bind(this);
        this.onAddFiles = this.onAddFiles.bind(this);
        this.onDeleteFile = this.onDeleteFile.bind(this);
        this.onDeleteAttachment = this.onDeleteAttachment.bind(this);
        this._form = null;
    }

    onChange(event) {
        this.setState({
            newEntry: this.state.newEntry.set('text', event.target.value)
        }, () => {
            if (this._form) {
                const calcEls = this._form
                    .getElementsByClassName(calculatorClassName);
                if (calcEls.length) {
                    const els = calcEls[0].getElementsByTagName('textarea');
                    if (els.length) {
                        // offsetHeight - clientHeight = border size!
                        const newHeight = els[0].scrollHeight + (
                            els[0].offsetHeight - els[0].clientHeight);
                        this.setState({
                            height: newHeight
                        });
                    }
                }
            }
        });
    }

    makeNewEntry() {
        return Immutable.fromJS({
            text: '',
            attachments: {
                addable: true,
                attachments: []
            },
            files: []
        });
    }

    expandForm() {
        this.setState({
            expanded: true
        });
    }

    onAddFiles(items) {
        const prev = this.state.newEntry.get('files');
        const prevNames = prev.map(file => file.name);
        this.setState({
            newEntry: this.state.newEntry.set(
                'files',
                prev.concat(
                    Immutable.List(items).filter(
                        item => !prevNames.contains(item.name) &&
                                (isSupportedImageType(item.type) ||
                                isSupportedVideoType(item.type))
                    )))
        });
    }

    onDeleteFile(file) {
        const prev = this.state.newEntry.get('files');
        const idx = prev.indexOf(file);
        if (idx > -1) {
            this.setState({
                newEntry: this.state.newEntry.set(
                    'files',
                    prev.delete(idx)
                )
            });
        }
    }

    assignAttachments(attachments) {
        this.setState({
            newEntry: this.state.newEntry.setIn(
                ['attachments', 'attachments'], attachments)
        });
    }

    onDeleteAttachment(attachment) {
        const attachments = this.state.newEntry.getIn(
            ['attachments', 'attachments']);
        const idx = attachments.indexOf(attachment);
        if (idx > -1) {
            this.setState({
                newEntry: this.state.newEntry.setIn(
                    ['attachments', 'attachments'], attachments.delete(idx))
            });
        }
    }

    onSubmit() {
        this.setState({submitting: true}, () => {
            const {createEntry} = this.props;
            const {newEntry} = this.state;
            const text = newEntry.get('text', '');
            const attachments = newEntry.getIn(['attachments', 'attachments'])
                .map(obj => obj.get('cdb_object_id'));
            const files = newEntry.get('files');
            createEntry(text, attachments, files)
                .then(this.onClose)
                .catch(() => {
                    this.setState({submitting: false});
                });
        });
    }

    onClose() {
        this.setState({
            expanded: false,
            height: null,
            newEntry: this.makeNewEntry(),
            submitting: false
        });
        const {onClose} = this.props;
        if (onClose) {
            onClose();
        }
    }

    render() {
        const {label, placeholder} = this.props;
        const text = this.state.newEntry.get('text');
        const fileList = this.state.newEntry.get('files');
        const compactCls = classNames(prefixNS('form'), prefixNS('form--compact'));
        const coverCls = classNames(prefixNS('form__cover'), {
            [prefixNS('form__cover--submitting')]: this.state.submitting
        });
        const areaStl = this.state.height ? {height: this.state.height} : undefined;
        return this.state.expanded ? (
            <form className={prefixNS('form')}
                  ref={c => this._form = c}>
                <div className={coverCls}><Throbber /></div>
                <FormControl.TextArea
                    label={label}
                    value={text}
                    onChange={this.onChange}
                    name="newActivity"
                    rows={3}
                    style={areaStl}
                    autoFocus
                />
                <FileDropzone className={prefixNS('form-upload-margin')} onDrop={this.onAddFiles}>
                    <FileDropzone.Preview files={fileList}
                                          onDelete={this.onDeleteFile}
                                          Renderer={Renderer} />
                    <div className={prefixNS('form-upload-placeholder')}>
                        {formatStr('file-drop-text')}
                    </div>
                </FileDropzone>

                <Attachments activityEntry={this.state.newEntry}
                             onDelete={this.onDeleteAttachment}/>
                <ButtonGroup>
                    <Button.TextButton
                        label={formatStr('publish')}
                        onClick={this.onSubmit}
                        buttonStyle="primary"
                        disabled={text === ''} />
                    <Button.TextButton
                        label={formatStr('cancel')}
                        onClick={this.onClose} />
                </ButtonGroup>
                <ButtonGroup>
                    <AssignAttachments
                        activityEntry={this.state.newEntry}
                        assignAttachments={this.assignAttachments}/>
                </ButtonGroup>
                <div className={calculatorClassName} aria-hidden={true}>
                    <FormControl.TextArea
                        value={text}
                        name="heightCalculator"
                        rows={3}
                    />
                </div>
            </form>
        ) : (
            <form className={compactCls}>
                <FormControl.TextInput
                    name="formTrigger"
                    placeholder={placeholder}
                    onFocus={this.expandForm}/>
            </form>
        );
    }
}

CreateForm.propTypes = {
    label: PropTypes.string,
    placeholder: PropTypes.string,
    createEntry: PropTypes.func.isRequired,
    onClose: PropTypes.func
};
