/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: ActivityText.jsx 162376 2017-07-28 13:55:03Z yzh $"
 */

import React from 'react';
import {Navigation, Button} from 'cs-web-components-base';
import Autolinker from 'autolinker';
import trimRight from 'trim-right';
import {formatStr} from '../i18n';
import {ImmutablePropTypes, PropTypes} from 'cs-web-components-externals';

const linker = new Autolinker({
    newWindow: true,
    stripPrefix: false,
    urls: {
        schemeMatches: true,
        wwwMatches: true,
        tldMatches: false
    },
    email: false,
    phone: false,
    twitter: false,
    hashtag: false
});

const rootURL = window.location.protocol + '//' +
    window.location.hostname.toLowerCase() +
    (window.location.port ? ':' + window.location.port.toLowerCase() : '');

function isExternal(url) {
    const lower = url.toLowerCase();
    return lower.indexOf('cdb:') !== 0 &&
        lower.indexOf('cdbcmsg:') !== 0 &&
        lower.indexOf(rootURL) === -1;
}

function ShowMore(props) {
    return (
        <span>
            <span>...</span>
            <Button.TextButton
                buttonStyle="link"
                label={formatStr('more')}
                {...props} />
        </span>
    );
}

function digest(text, offset, length, tolerance) {
    const end = length - offset;
    if (end < 0 || text.length < end) {
        return [text];
    }
    let cutIndex = text.indexOf(' ', end);
    // if no whitespace go maximum tolerance
    // if whitespace exceeds tolerance, go max tolerance
    if (cutIndex === -1 || cutIndex - end > tolerance) {
        cutIndex = end + tolerance;
    }
    const result = [];
    const before = text.slice(0, cutIndex);
    const after = text.slice(cutIndex);
    if (before) {
        result.push(before);
    }
    result.push(ShowMore);
    if (after) {
        result.push(after);
    }
    return result;
}

function lineBreaking(parts) {
    const result = [];
    let keyIdx = 0;
    parts.forEach(part => {
        let splitted;
        if (typeof part !== 'string') {
            splitted = null;
        } else {
            splitted = part.split('\n');
        }
        if (splitted === null || splitted.length === 1) {
            result.push(part);
        } else {
            // insert link breaker between lines
            splitted.forEach((text, idx) => {
                if (text !== '') {
                    result.push(text);
                }
                if (idx < splitted.length - 1) {
                    result.push(<br key={keyIdx}/>);
                    keyIdx++;
                }
            });
        }
    });
    return result;
}

export default class ActivityText extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            'digest': true,
            'parts': this.parseActivityText(props)
        };
        this.showMore = this.showMore.bind(this);
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.activityEntry !== this.props.activityEntry) {
            this.setState({
                'parts': this.parseActivityText(nextProps)
            });
        }
    }

    parseActivityText(props) {
        const {activityEntry, digestLength, digestTolerance} = props;
        const parts = [];
        const activityText = trimRight(activityEntry.get('text'));
        const matches = linker.parse(activityText);
        let lastIdx = 0;
        if (digestLength === lastIdx) {
            parts.push(ShowMore);
        }
        matches.forEach((match, idx) => {
            const offset = match.getOffset();
            const matched = match.getMatchedText();
            const before = activityText.substring(lastIdx, offset);
            if (before !== '') {
                parts.push(...digest(before, lastIdx, digestLength, digestTolerance));
            }
            const link = match.getAnchorHref();
            const target = isExternal(link) ? '_extern' : '_blank';
            parts.push(
                <Navigation.Link
                    key={`link-${idx}`}
                    to={link}
                    title={link}
                    target={target}>
                    {match.getAnchorText()}
                </Navigation.Link>);
            lastIdx = offset + matched.length;
        });
        if (lastIdx < activityText.length) {
            parts.push(
                ...digest(activityText.substring(lastIdx),
                lastIdx, digestLength, digestTolerance));
        }
        return lineBreaking(parts);
    }

    showMore() {
        this.setState({
            digest: false
        });
    }

    render() {
        const {digest, parts} = this.state;
        let showParts;
        if (digest) {
            const idx = parts.indexOf(ShowMore);
            if (idx === -1) {
                showParts = parts;
            } else {
                showParts = parts.slice(0, idx).concat(
                    <ShowMore key='showMore' onClick={this.showMore} />
                );
            }
        } else {
            showParts = parts;//.filter((item) => item !== ShowMore);
        }
        return (
            <div className="cs-activitystream-web-detail-text">
                {showParts.length ? showParts : null}
            </div>);
    }
}

ActivityText.propTypes = {
    activityEntry: ImmutablePropTypes.map.isRequired,
    digestLength: PropTypes.number,
    digestTolerance: PropTypes.number
};

ActivityText.defaultProps = {
    digestLength: 300,
    digestTolerance: 50
};
