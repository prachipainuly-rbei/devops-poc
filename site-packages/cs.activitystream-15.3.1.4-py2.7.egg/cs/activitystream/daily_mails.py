# coding: utf-8
import argparse
import datetime
from cdb import auth
from cdb import CADDOK
from cdb import i18n
from cdb import misc
from cdb import sqlapi
from cdb import ue
from cdb import version
from cdb.objects import ByID
from cdb.objects.blog import Posting
from cdb.objects.blog import Subscription
from cdb.objects.common import WithEmailNotification
from cdb.objects.org import User
from cdb.platform.gui import Label
from cdb.platform.gui import Message
from cs.activitystream.attachment import Attachment
from cs.sharing import Sharing


DAILY_AS_SETTING = "user.email_daily_as"


class DailyMailer(WithEmailNotification):
    __notification_template__ = "activity_digest.html"
    __notification_title__ = "activity_digest"

    def __init__(self, persno=None, days=None, sender=None):
        self.pcclient = version.verstring(0) == "15.0"  # >= 15.1: use cs.web
        self._getPerson(persno)
        self._getDate(days)
        self._getLabels()
        self.cached_postings = None
        self.sender = User.ByKeys(sender if sender else "caddok")
        self.__attachment_cache__ = {}

    def _getPerson(self, persno):
        if persno:
            self.user = User.ByKeys(sqlapi.quote(persno))
        else:
            self.user = User.ByKeys(auth.persno)

        if not self.user:
            raise ue.Exception("just_a_replacement",
                               "user does not exist (%s)" % persno)
        if not self.user.e_mail:
            raise ue.Exception("just_a_replacement",
                               "user has no e-mail address (%s)" % persno)
        if self.user.getSettingValue(DAILY_AS_SETTING) != "1":
            raise ue.Exception("just_a_replacement",
                               "user does not want daily mails (%s)" % persno)

    def _getDate(self, days=None):
        try:
            days = int(days)
        except (ValueError, TypeError):
            days = 1
        newer_than = datetime.datetime.today() - datetime.timedelta(days=days)
        self.newer_than = newer_than

    def _getLabels(self):
        self.isolang = self.user.GetPreferredLanguage()
        self.lang = i18n._to_cdb(self.isolang)
        if not self.lang:
            self.lang = self.isolang

        def get_datetime_format():
            replacements = [
                ("YYYY", "%Y"),
                ("MM", "%m"),
                ("DD", "%d"),
                ("hh", "%H"),
                ("mm", "%M"),
                ("ss", "%S"),
                ]
            result = i18n.get_datetime_format(self.lang)
            for a, b in replacements:
                result = result.replace(a, b)
            return result

        self.datetime_format = "%A, " + get_datetime_format()

        self.product = Message.ByKeys(
            "branding_product_name")[self.lang]
        self.open_activity_stream = Label.ByKeys(
            "cdbblog_activity_stream")[self.lang]
        self.shared = Label.ByKeys("web.share_objects.shared")[self.lang]
        self.all = Label.ByKeys("web.activitystream.to-all")[self.lang]
        self.disclaimer = "\n".join(l[self.lang] for l in Label.Query(
            "ausgabe_label LIKE 'daily_activities_disclaimer%%'",
            addtl="ORDER BY ausgabe_label ASC"))
        self.notification_title = Label.ByKeys(
            self.__notification_title__)[self.lang]

    def _getComments(self, posting):
        return posting.AllComments.Query(
            "cdb_cdate>{}".format(sqlapi.SQLdbms_date(self.newer_than)))

    def _getTopicIDs(self):
        my_subscriptions = ("SELECT channel_cdb_object_id FROM %s "
                            "WHERE personalnummer='%s'" % (
                                Subscription.GetTableName(),
                                self.user.personalnummer))
        my_sharings = "SELECT cdb_object_id FROM %s WHERE cdb_cpersno='%s'" % (
            Sharing.GetTableName(), self.user.personalnummer)
        return "%s UNION %s" % (my_subscriptions, my_sharings)

    def _getTopicCondition(self):
        subscriptions = Posting.getTopicCondition().format(self._getTopicIDs())
        return ("(context_object_id='' "
                "OR (%s))" % subscriptions)

    def _getPostings(self, newer_than):
        """
        emulates cdb.objects.blog.Posting.getPostingsByCondition

        returns all cdb.objects.blog.Posting objects visible to current user
        that are newer than given datetime.datetime newer_than
        """
        last_date = sqlapi.SQLdbms_date(newer_than)
        topics = self._getTopicCondition()
        postings = Posting.Query(
            "last_comment_date>%s AND %s" % (last_date, topics),
            order_by=[-Posting.last_comment_date, Posting.cdb_object_id])
        return Posting._getAccessiblePostings(postings)

    @property
    def postings(self):
        result = []
        postings = self._getPostings(self.newer_than)
        # FIXME: skip new postings/comments by self.user
        # (only include postings by self.user as context
        # if new comments are by someone else)
        for posting in postings:
            result.append(posting)  # FIXME: skip uncommented SystemPostings
            result += self._getComments(posting)
        return result

    def getNotificationTitle(self, ctx=None):
        return self.notification_title

    def setNotificationContext(self, sc, ctx=None):
        sc.self = self

    def getNotificationReceiver(self, ctx=None):
        return [{"to": [(self.user.e_mail, self.user.name)]}]

    def getNotificationSender(self, ctx=None):
        return (self.sender.e_mail, self.sender.name)

    def getTitle(self, posting_or_comment):
        if posting_or_comment.GetClassname() == "cdbblog_system_posting":
            return posting_or_comment.getTitle()
        return posting_or_comment.Author.name

    def getAuthorName(self, posting_or_comment):
        if posting_or_comment.GetClassname() == "cdbblog_system_posting":
            return posting_or_comment.Author.name

    def getChannelName(self, posting_or_comment):
        if posting_or_comment.GetClassname() == "cdbblog_user_posting":
            channel = posting_or_comment.ContextObject
            if not channel:
                return self.all

            if channel.GetClassname() == "cdb_sharing":
                return self.shared

            return channel.GetDescription()

    def getASLink(self, posting_or_comment=None):
        if self.pcclient:
            return "cdb:///byname/opname/CDB_eLink_cdbblog"

        if not posting_or_comment:
            return "%s/activitystream" % CADDOK.WWWSERVICE_URL

        if posting_or_comment.GetClassname() == "cdbblog_comment":
            posting_id = posting_or_comment.posting_id
        else:
            posting_id = posting_or_comment.cdb_object_id

        return "%s/activitystream/posting/%s" % (
            CADDOK.WWWSERVICE_URL, posting_id)

    def getFormattedTime(self, posting_or_comment):
        return posting_or_comment.cdb_cdate.strftime(self.datetime_format)

    def getFormattedMessage(self, posting_or_comment):
        if posting_or_comment.GetClassname() == "cdbblog_comment":
            text = posting_or_comment.GetText("cdbblog_comment_txt")
        else:
            text = posting_or_comment.GetText("cdbblog_posting_txt")

        return unicode(text)

    def getAttachmentLink(self, attachment):
        if self.pcclient:
            plain = 2
        else:
            plain = 0
        return attachment.MakeURL(action="CDB_ShowObject", plain=plain)

    def getAttachments(self, posting_or_comment):
        result = self.__attachment_cache__.get(
            posting_or_comment.cdb_object_id, [])
        if not result:
            for a in Attachment.KeywordQuery(
                    posting_id=posting_or_comment.cdb_object_id):
                attachment = ByID(a.attachment_id)
                if attachment.CheckAccess("read"):
                    result.append(attachment)

            self.__attachment_cache__[
                posting_or_comment.cdb_object_id] = result

        return result

    def _buildHTML(self, ctx):
        """
        for acceptance tests only
        emulates cdb.objects.common.WithEmailNotification.sendNotification
        """
        from cdb import mail
        from cdb import elink
        req = elink.DummyRequest(None)
        templ_file = self._getNotificationTemplateFile(ctx)
        if not templ_file:
            misc.cdblogv(misc.kLogErr, 0, (
                "%s.sendNotification: could not find the template file: %s."
                % (self.__module__, self.getNotificationTemplateName(ctx))
            ))
            return

        from simpletal import simpleTALES, simpleTALUtils
        templ_cache = simpleTALUtils.TemplateCache()
        mail_templ = templ_cache.getTemplate(templ_file, 'utf-8')
        sc = elink.SimpleContext()
        sc.obj = self
        talctx = simpleTALES.Context(allowPythonPath=1)
        talctx.addGlobal("context", sc)
        self.setNotificationContext(sc, ctx)
        mail_templ.expand(talctx, req, outputEncoding="utf-8")
        msg = mail.Message()
        # pylint: disable-msg=E0611
        from email import Header
        msgheader = Header.Header(self.getNotificationTitle(ctx),
                                  'utf8').encode()
        msg.Subject(msgheader)
        msg.body(req.text(), mimetype="text/html")
        return msg._body.text

    def sendNotification(self, ctx=None, test=False):
        if self.postings:
            if test:
                self.html = self._buildHTML(ctx)
            else:
                WithEmailNotification.sendNotification(self, ctx)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-s", "--sender", metavar="USERID", type=str, default="caddok",
        dest="sender", help="user ID of sender")
    args = parser.parse_args()
    DailyMailer(sender=args.sender).sendNotification()
