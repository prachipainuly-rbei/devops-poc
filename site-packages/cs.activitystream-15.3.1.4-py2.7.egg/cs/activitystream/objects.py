#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""
This modul contains Activity Stream classes.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: objects.py 162383 2017-07-28 14:24:28Z yzh $"

from cdb import auth
from cdb import misc
from cdb import sqlapi
from cdb import transaction
from cdb import constants
from cdb.objects import Object
from cdb.objects import paginated
from cdb.objects import ByID
from cdb.objects import ReferenceMethods_1
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import Forward
from cdb.objects import LocalizedField
from cdb.objects.org import User
from cdb.objects.operations import operation

__all__ = ["Posting", "SystemPosting", "UserPosting",
           "Comment", "Topic2Posting", "Subscription"]

fPosting = Forward(__name__ + ".Posting")
fComment = Forward(__name__ + ".Comment")
fTopic2Posting = Forward(__name__ + ".Topic2Posting")


CACHED_STATEMENTS = {}


class Posting(Object):
    """The base posting class.
    """
    __maps_to__ = "cdbblog_posting"
    __classname__ = "cdbblog_posting"

    def getContextObject(self):
        """
        Returns the context object of the posting as a
        `cdb.objects.Object`. The function will return
        ``None`` if there is no context object or if
        there is no `cdb.objects.Class` for the context
        object.
        """
        try:
            return ByID(self.context_object_id)
        except Exception as exc:
            misc.log_error("Failed to retrieve postings context object: %s" %
                           exc)

    ContextObject = ReferenceMethods_1(Object, getContextObject)

    Author = Reference_1(User, fPosting.cdb_cpersno)

    Comments = Reference_N(fComment,
                           fComment.in_reply_to == fPosting.cdb_object_id,
                           order_by=fComment.cdb_mdate)

    AllComments = Reference_N(fComment,
                              fComment.posting_id == fPosting.cdb_object_id,
                              order_by=fComment.cdb_mdate)

    TopicAssignments = Reference_N(
        fTopic2Posting,
        fTopic2Posting.posting_id == fPosting.cdb_object_id)

    def addTopic(self, topic_or_id):
        """Adds topic assignment.
        """
        if not isinstance(topic_or_id, basestring):
            topic_or_id = topic_or_id.GetObjectID()
        Topic2Posting.createMapping(self.GetObjectID(), topic_or_id)

    def commentUpdated(self, comment):
        """It updates information about the last comment."""
        self.last_comment_date = comment.cdb_mdate

    @staticmethod
    def getPostingsByTopic(topic, cnt=0, last_posting=None):
        """Looks up for postings assigned to the given topic.
            @param topic: a topic object or its cdb_object_id.
            @param cnt: how many items should be returned
            @param last_posting: a tuple of (last_comment_date, cdb_object_id)
                                 of the last returned posting. Used to look
                                 up the next postings older then the given one.
        """
        topic_id = topic
        if not isinstance(topic, basestring):
            topic_id = topic.GetObjectID()
        cond = Posting.getTopicCondition().format("'%s'" % sqlapi.quote(topic_id))
        return Posting.getPostingsByCondition(cond, cnt, last_posting)

    @staticmethod
    def _getAccessiblePostings(postings):
        """
        Checks the ``read`` access for the objects referenced by
        `context_object_id`. Returns the reduced list
        """
        from cdb.platform import mom
        from cdb.objects import NULL
        uuid_set = set()
        for posting in postings:
            if posting.context_object_id:
                uuid_set.add(posting.context_object_id)

        uuids = [uuid for uuid in uuid_set]
        valid_uuids = set([NULL, ""])    # No context object ==> accessible
        valid_uuids |= set(mom.getObjectHandlesFromObjectIDs(
                           uuids, False, True).keys())
        return [posting for posting in postings
                if posting.context_object_id in valid_uuids]

    @staticmethod
    def getPostingsByCondition(cond=None, cnt=0, last_posting=None,
                               check_access=True):
        """
        Looks up for postings just according to the specified sql query
        condition. Returns a tupel of a list of `cdb.objects.Object` and the
        number of potentially accessible postings, which can be used to
        determine whether there are more postings or not. If the access check
        is disabled, that number would be the total number of postings.
            @param cond: used as sql 'where' condition to look up postings.
            @param cnt: how many items should be returned
            @param last_posting: a tuple of (last_comment_date, cdb_object_id)
                                 of the last returned posting. Used to look
                                 up the next postings older then the given one.
            @param check_access: If ``True`` the the ``read``-access will be
                                 checked for all postings that contain a
                                 ``context_object_id``.
        """
        if not cond:
            cond = "1=1"
        if last_posting is None:
            # To guard a stable list during paginated checks
            tblname = Posting.GetTableName()
            newest = sqlapi.RecordSet2(
                sql=("select last_comment_date from %s where last_comment_date = "
                     " (select max(last_comment_date) from %s)") % (
                    tblname, tblname))
            if len(newest):
                last_posting = (newest[0].last_comment_date, "")
            else:
                last_posting = (None, None)

        if not last_posting[0]:
            # no posting created/commented => no posting exists
            return ([], 0)

        last_date = sqlapi.SQLdbms_date(last_posting[0])
        cond = ("(%s) and (last_comment_date<%s or "
                "(last_comment_date=%s and cdb_object_id>'%s'))") % (
            cond,
            last_date,
            last_date,
            last_posting[1])
        order_by = [-Posting.last_comment_date, Posting.cdb_object_id]
        postings = Posting.Query(cond, order_by=order_by)
        if check_access:
            if cnt < 0:
                postings = Posting._getAccessiblePostings(postings)
            else:
                # To figure out whether there are more postings, collect
                # just one more piece than expected.
                # Avoid small batchs: minimal size 21
                page_size = max(cnt + 1, 21)
                all_posts = paginated(postings, page_size, order_by=order_by)
                postings = []
                for page in all_posts:
                    postings += Posting._getAccessiblePostings(page)
                    if len(postings) > cnt:
                        # Enough pieces found(one more than required)
                        break
                    page = None

        return ([posting for posting in postings[:cnt]], len(postings))

    @staticmethod
    def getTopicCondition():
        """Generates the sql query condition pattern to look up postings
        assigned to specified topics.
        """
        key = "topic_condition"

        if key not in CACHED_STATEMENTS.keys():
            from cs.activitystream.attachment import Attachment
            from cs.sharing import Sharing
            vals = {
                "user_id": auth.persno,
                "topic2posting": Topic2Posting.GetTableName(),
                "sharing_posting_v": "cdb_sharing_posting_v",
                "attachment": Attachment.GetTableName(),
                "subscription": Subscription.GetTableName(),
                "sharing": Sharing.GetTableName(),
            }

            conditions = [
                # posting is directly assigned to given topic
                """ SELECT t2p.posting_id
                    FROM {topic2posting} t2p
                    WHERE t2p.topic_id IN ({{0}})""".format(**vals),
                # posting is attached to a sharing by the user themselves
                # union
                # posting is attached to a sharing the user is subscribed to
                """ SELECT posting_id
                    FROM {sharing_posting_v} spv
                    WHERE spv.attachment_id IN ({{0}})
                    AND spv.sharing_id IN (
                        SELECT cdb_object_id
                        FROM {sharing} sharing
                        WHERE sharing.cdb_cpersno='{user_id}'
                        UNION
                        SELECT sub.channel_cdb_object_id FROM {subscription} sub
                        WHERE sub.personalnummer='{user_id}'
                    )""".format(**vals),
            ]

            CACHED_STATEMENTS[key] = (
                "cdb_object_id IN ({conditions})".format(
                    conditions=" UNION ".join(conditions)))

        return CACHED_STATEMENTS[key]

    @staticmethod
    def getNewPostingCount(cond=None, last_updated=None):
        """Looks up for new postings since latest update time.
            @param cond: used as sql 'where' condition to look up postings.
            @param last_updated: the date of last check
        """
        if not cond:
            cond = "1=1"
        if last_updated:
            last_date = sqlapi.SQLdbms_date(last_updated)
            cond = ("(%s) and last_comment_date>%s") % (
                cond,
                last_date)
        return len(Posting.Query(cond))

    def updateLastCommentedDate(self, ctx=None):
        """Initiates the last_comment_date field of the posting object for new
        posting object.
        """
        pobj = self.getPersistentObject()
        if pobj:
            pobj.last_comment_date = self.cdb_mdate

    def addTopics(self, ctx=None):
        """
        Calls cdb.objects.Object.get_topics function to retrieve the topics
        for `self.context_object_id`.
        """
        ctxobj = self.ContextObject
        if ctxobj:
            topics = ctxobj.GetActivityStreamTopics(self)
            for topic in topics:
                if topic:
                    self.addTopic(topic)
            if self.type == "insert":
                channel = ctxobj.GetClassDef().getObjectCreatedPostingChannel()
                if channel:
                    # Check whether the channel is already part of the topics
                    add = True
                    for topic in topics:
                        if topic:
                            if isinstance(topic, basestring):
                                if topic == channel:
                                    add = False
                                    break
                            else:
                                if topic.GetObjectID() == channel:
                                    add = False
                                    break
                    if add:
                        self.addTopic(channel)

    def openThreadPage(self, ctx):
        ctx.url("/activitystream/posting/%s" %
                self.cdb_object_id)

    def GetDisplayAttributes(self):
        """This method creates and returns a results dictionary, containing the
        necessary information for the html display in the client."""
        results = super(Posting, self).GetDisplayAttributes()
        results["viewurl"] = self.MakeURL("cdbblog_open_thread")
        results["attrs"].update({"heading": "%s (%i)" % (
            fComment._getClassDef().getTitle(),
            len(self.AllComments))})
        return results

    # TODO: copy Operation should not be allowed!
    event_map = {
        (("create", "copy"), "post"): ("updateLastCommentedDate",
                                       "addTopics"),
        ("cdbblog_open_thread", "now"): "openThreadPage",
    }


class SystemPosting(Posting):
    """The system posting class. A system posting can only be generated by
    the system. It dosen't contain a text field for user inputs, but title
    fields in all the acitve languages.
    """
    __classname__ = "cdbblog_system_posting"
    __match__ = Posting.cdb_classname >= __classname__

    Title = LocalizedField("title")

    def getTitle(self, lang=''):
        """Gets the title text in specified language.
        """
        return self.Title[lang]

    @classmethod
    def do_create(cls, *args, **kwargs):
        """
        Uses the ``CDB_Create`` operation to create a system posting.
        Returns the posting as `cdb.platform.mom.CDBObjectHandle`.
        """
        try:
            return operation(constants.kOperationNew, cls, *args, **kwargs)
        except RuntimeError as exc:
            misc.log_error("Failed to generate system posting: %s" % exc)


class UserPosting(Posting):
    """The user posting class. It contains a long text field for the text input
    by the user.
    """
    __classname__ = "cdbblog_user_posting"
    __match__ = Posting.cdb_classname >= __classname__

    def GetDisplayAttributes(self):
        """This method creates and returns a results dictionary, containing the
        necessary information for the html display in the client."""
        results = super(UserPosting, self).GetDisplayAttributes()
        newattr = {}
        from cdb import util
        if self.ContextObject:
            newattr["title"] = u'%s %s' % (
                util.Labels()["cdbblog_posting_to_topic"],
                self.ContextObject.GetDescription())
        else:
            newattr["title"] = util.Labels()["cdbblog_posting_to_all"]
        results["attrs"].update(newattr)
        return results


class Comment(Object):
    """The comment class. A comment must be a reply to a posting or another
    comment.
    """
    __maps_to__ = "cdbblog_comment"
    __classname__ = "cdbblog_comment"

    Posting = Reference_1(fPosting,
                          fComment.posting_id)

    ReplyTo = Reference_1(fComment,
                          fComment.in_reply_to)

    Author = Reference_1(User, fComment.cdb_cpersno)

    Comments = Reference_N(fComment,
                           fComment.in_reply_to == fComment.cdb_object_id)

    def updatePosting(self, ctx=None):
        """Tells the posting object that this comment is just created.
        """
        if self.Posting:
            self.Posting.commentUpdated(self)

    def _handle_es_update(self, ctx):
        """ The system is about to delete the object.
            Need to create an index job (Enterprise-Search) now,
            because the DBEventListener normally used for this
            is called after the object is deleted in the database.
            This won't work because the index system needs to find
            the owner of a comment object in order to update the index.
        """
        try:
            if self.Posting:
                from cdb.storage.index.tesjobqueue import TESJobQueue
                TESJobQueue.enqueue(self.Posting.cdb_object_id,
                                    self.Posting.GetTableName(),
                                    None,
                                    None)
        except Exception:
            misc.log_traceback("Error creating index job for %s" %
                               self.cdb_object_id)

    event_map = {("create", "post"): "updatePosting",
                 ('delete', 'post'): "_handle_es_update"}


class Topic2Posting(Object):
    """The topic assignment to posting object. The topic object should has
    cdb_object_id field.
    """
    __maps_to__ = "cdbblog_topic2posting"
    __classname__ = "cdbblog_topic2posting"

    @classmethod
    def createMapping(cls, posting_id, topic_id):
        """Helper function to create topic assignment using operation routine
        to ensure calling event handler.
        """
        if posting_id and topic_id:
            operation(constants.kOperationNew, cls,
                      posting_id=posting_id,
                      topic_id=topic_id)

    @classmethod
    def deleteInvalidAssignments(clss):
        """
        Deletes all entries where either the topic
        or the posting does not exist any longer.
        Returns the number of records that have been
        removed.
        """
        posting_cond = "NOT EXISTS (SELECT id FROM cdb_object " \
                       "WHERE id = %s.posting_id)" % clss.__maps_to__
        topic_cond = "NOT EXISTS (SELECT id FROM cdb_object " \
                     "WHERE id = %s.topic_id)" % clss.__maps_to__
        condition = posting_cond + " OR " + topic_cond
        rs = sqlapi.RecordSet2(clss.__maps_to__, condition=condition)
        with transaction.Transaction():
            for r in rs:
                r.delete()
        return len(rs)


class Subscription(Object):
    """
    """
    __maps_to__ = "cdbblog_subscription"
    __classname__ = "cdbblog_subscription"

    @classmethod
    def subscribeToChannel(clss, object_id, persno=""):
        """
        Checks whether there is a subscription entry
        for the user identified by `persno` or the
        active user if `persno` is ``None``.
        If not the entry will be generated.
        """
        if not persno:
            from cdb import auth
            persno = auth.persno

        if not Subscription.ByKeys(object_id, persno):
            fields = clss.MakeChangeControlAttributes()
            fields["channel_cdb_object_id"] = object_id
            fields["personalnummer"] = persno
            Subscription.Create(**fields)

    @classmethod
    def unsubscribeFromChannel(clss, object_id, persno=None):
        """
        Checks whether there is a subscription entry
        for the user identified by `persno` or the active
        user if `persno` is ``None``.
        If there is an entry the entry will be removed.
        """
        if not persno:
            from cdb import auth
            persno = auth.persno

        subscription = Subscription.ByKeys(object_id, persno)
        if subscription:
            subscription.Delete()

    @classmethod
    def deleteInvalidSubscriptions(clss):
        """
        Deletes all subscriptions to channels that are
        no longer available. Returns the number of entries
        that have been removed.
        """
        condition = "NOT EXISTS (SELECT id FROM cdb_object WHERE " \
                    "id = %s.channel_cdb_object_id)" % clss.__maps_to__
        rs = sqlapi.RecordSet2(clss.__maps_to__, condition=condition)
        with transaction.Transaction():
            for r in rs:
                r.delete()
        return len(rs)


class Channel(Object):
    """
    """
    __maps_to__ = "cdbblog_channel"
    __classname__ = "cdbblog_channel"

    Title = LocalizedField('title')


class MQSystemPosting(Object):
    """
    """
    __maps_to__ = "mq_system_posting"
    __classname__ = "mq_system_posting"

    Title = LocalizedField('title')
