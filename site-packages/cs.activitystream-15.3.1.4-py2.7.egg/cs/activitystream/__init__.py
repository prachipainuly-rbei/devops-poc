#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

"""
Module cs.activitystream.__init__
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: __init__.py 161410 2017-07-07 14:31:45Z yzh $"

import time
import re

from xml.sax.saxutils import escape

from datetime import date, datetime, timedelta

from cs.activitystream.activitylistener import ActivityListener
from cdb import elink
from cdb import auth
from cdb import sqlapi
from cdb import cdbtime
from cdb import util
from cdb import sig
from cdb import constants
from cdb import misc
from cdb import typeconversion
from cdb.constants \
    import kOperationShowObject, kOperationNew  # @UnresolvedImport
from cdb.objects import Rule
from cdb.objects import Object
from cdb.classbody import classbody
from cs.activitystream.objects import Posting
from cs.activitystream.objects import UserPosting
from cs.activitystream.objects import SystemPosting
from cs.activitystream.objects import Comment
from cs.activitystream.objects import Topic2Posting
from cs.activitystream.objects import Subscription
from cdb.objects.operations import operation
from cdb.platform.mom.entities import CDBClassDef

# Exported objects
__all__ = ["PostingRuleChecker", "create_system_posting"]

# How many postings can be listed by default
DEFAULT_POSTING_COUNT = 20
DEFAULT_COMMENT_COUNT = 3


@classbody
class Object(object):
    def GetActivityStreamTopics(self, posting):
        """
        If a posting is generated within the activity stream that
        belongs to `self` this method is called to ask for the topics
        the posting should be assigned to. `posting` is the
        `cs.activitystream.Posting` object the topics are assigned to.
        The method returns a list. The elements of the list are
        strings containing an UUID (cdb_object_id) or objects of
        the type `cdb.objects.Object`. Empty strings or ``None``
        elements will be ignored by the caller. All other entries represents
        the topics the posting will be assigned to.
        The default implementation
        returns [self]. You may overwrite the method
        to assign the posting to additional objects, e.g. like this: ::

           def GetActivityStreamTopics(self, posting):
              return [self, self.Project]

        """
        return [self.cdb_object_id]


class PostingTools(object):

    """
    Helper class for postings.
    """

    POSTING_DIGEST_LENGTH = 300
    POSTING_DIGEST_LENGTH_TOLERANCE = 50

    # TODO: A better approach is to have a global setting for things like
    # date and time format and other locale dependent things.
    DATE_FORMAT = "%d.%m.%Y"
    TIME_FORMAT = "%H:%M"

    plugin_css_files = None

    # Defines "target" attribute of <a> tag for hyperlinks
    _hyperlink_target = None

    @staticmethod
    def get_status_text(obj, status):
        if isinstance(obj, basestring):
            from cdb.objects import ByID
            obj = ByID(obj)
        if obj:
            olc = obj.GetObjectKind()
            if olc:
                from cdb.platform.olc import StateDefinition
                st = StateDefinition.ByKeys(status, olc)
                if st:
                    return st.StateText[""]
        return ""

    @staticmethod
    def get_postings_by_condition(cond=None,
                                  cnt=DEFAULT_POSTING_COUNT,
                                  last_comment_date="",
                                  last_object_id=""):
        """
        Gets postings by condition. To require all postings without
        condition is forbidden.
        """
        postings = []
        allcnt = 0
        if cond:
            last_posting = None
            if last_comment_date:
                last_posting = (last_comment_date, last_object_id)
            postings, allcnt = Posting.getPostingsByCondition(
                cond=cond,
                cnt=cnt,
                last_posting=last_posting)
        return {"postings": postings,
                "posting_cnt": cnt,
                "more_postings": allcnt - cnt,
                "postingtools": PostingTools,
                }

    @staticmethod
    def get_postings(topic_id=None,
                     cnt=DEFAULT_POSTING_COUNT,
                     last_comment_date="",
                     last_object_id=""):
        cond = None
        result = {}
        if topic_id:
            cond = PostingTools.generate_topic_condition("'%s'" % topic_id)
            result["topic_id"] = topic_id
        result.update(PostingTools.get_postings_by_condition(
            cond=cond,
            cnt=cnt,
            last_comment_date=last_comment_date,
            last_object_id=last_object_id))
        return result

    @staticmethod
    def generate_topic_condition(cond):
        """Generates the sql query condition pattern to look up postings
        assigned to specified topics.
        """
        return Posting.getTopicCondition().format(cond)

    @staticmethod
    def get_postings_by_topic_condition(topic_cond=None,
                                        cnt=DEFAULT_POSTING_COUNT,
                                        last_comment_date="",
                                        last_object_id=""):
        cond = None
        if topic_cond:
            cond = PostingTools.generate_topic_condition(topic_cond)
        return PostingTools.get_postings_by_condition(
            cond=cond,
            cnt=cnt,
            last_comment_date=last_comment_date,
            last_object_id=last_object_id)

    @staticmethod
    def check_new_postings(cond=None, last_updated=None):
        return Posting.getNewPostingCount(cond, last_updated)

    @staticmethod
    def get_supplementary_topics(posting, excluded_topics=[],
                                 subscribed_only=True):
        from cdb.objects import ByID
        subscriptions = []
        if subscribed_only:
            cond = "personalnummer = '%s' and channel_cdb_object_id in " \
                "(select topic_id from cdbblog_topic2posting where cdbblog_topic2posting.posting_id = '%s')" \
                % (sqlapi.quote(auth.persno),
                   sqlapi.quote(posting.cdb_object_id))
            subscriptions = Subscription.Query(cond).channel_cdb_object_id

        topics = posting.TopicAssignments.topic_id
        result = [t for t in topics if t not in excluded_topics
                  and t != posting.context_object_id
                  and (not subscribed_only or t in subscriptions)]
        topics = [ByID(t) for t in result]
        return [t for t in topics if t]

    @staticmethod
    def format_posting_date(datestr, notime=False):
        try:
            posting_time = cdbtime.Time(datestr).timetuple()
            posting_dmy = time.strftime(PostingTools.DATE_FORMAT, posting_time)
            today_dmy = time.strftime(
                PostingTools.DATE_FORMAT, date.today().timetuple())
            yesterday_dmy = time.strftime(
                PostingTools.DATE_FORMAT,
                (datetime.now() - timedelta(days=1)).timetuple())
            if notime:
                return unicode(posting_dmy)
            else:
                if posting_dmy == today_dmy:
                    posting_dmy = util.Labels()["cdbblog_date_today"]
                elif posting_dmy == yesterday_dmy:
                    posting_dmy = util.Labels()["cdbblog_date_yesterday"]
                return unicode("%s, %s" % (
                    posting_dmy,
                    time.strftime(PostingTools.TIME_FORMAT, posting_time)))
        except:
            # Probably an invalid datestr
            return unicode("")

    @staticmethod
    def format_date(dateObj):
        return typeconversion.to_legacy_date_format(dateObj)

    @staticmethod
    def short_description(desc, max_len=0, min_len=1, qty=1):
        """
        Return a short description no longer than max_len divided by qty.
        If max_len is 0, no shorterning is performed. The description will not
        be shortened to a length less than min_len.
        """
        if max_len == 0:
            return desc
        if min_len < 1:
            min_len = 1
        short_len = max_len / qty
        if short_len < min_len:
            short_len = min_len
        if short_len >= len(desc) - 3:
            return desc
        else:
            return desc[:short_len] + "..."

    @staticmethod
    def format_user_name(posting, full=True):
        # TODO: A better approach is to have a global setting for such things
        user = posting.Author
        name = ""
        if user:
            name = " ".join([_name
                             for _name in [user.firstname, user.lastname]
                             if _name])
        if not name:
            # Use the persnonal number
            name = posting.cdb_cpersno
        return name

    @staticmethod
    def get_user_info(blogitem, withpic=True):
        name = ""
        pic = ""
        url = None
        pers = blogitem.Author
        if pers:
            name = pers.name
            if withpic:
                from cs.shared.elink_plugins.picture_uploader \
                    import PictureUploader
                pic = PictureUploader.get_preview_img(pers)
            url = pers.MakeURL(kOperationShowObject)
        return (name, pic, url)

    @classmethod
    def get_hyperlink_target(cls):
        """Returns where to open the hyperlinks.
        If the current application is cdbpc client, the hyperlinks would be
        opened in external browser except the internal urls.
        """
        if cls._hyperlink_target is None:
            cls._hyperlink_target = "_blank"
            if elink.isCDBPC():
                cls._hyperlink_target = getattr(constants,
                                                "kW3TargetExtern",
                                                cls._hyperlink_target)
        return cls._hyperlink_target

    @staticmethod
    def get_blogitem_text(blogitem, cutoff=True):
        text = ""
        hasmore = False
        if isinstance(blogitem, UserPosting):
            text = blogitem.GetText("cdbblog_posting_txt")
        elif isinstance(blogitem, Comment):
            text = blogitem.GetText("cdbblog_comment_txt")
        if not isinstance(text, unicode):
            text = unicode(text)
        # Check the completeness of hyperlinks?
        check_link = False
        # Cut off text:  the first end of word after POSTING_DIGEST_LENGTH
        if cutoff and len(text) > PostingTools.POSTING_DIGEST_LENGTH:
            tailidx = text.find(" ", PostingTools.POSTING_DIGEST_LENGTH)
            if tailidx > -1 and tailidx < PostingTools.POSTING_DIGEST_LENGTH + \
                    PostingTools.POSTING_DIGEST_LENGTH_TOLERANCE:
                text = text[:tailidx]
            else:
                text = text[:PostingTools.POSTING_DIGEST_LENGTH]
                # The last hyperlink may be broken
                check_link = True
            hasmore = True
        text = PostingFormatter(text, check_link, hasmore).get_formatted_text()
        return (text, hasmore)

    @staticmethod
    def get_all_comments(posting, cnt=DEFAULT_COMMENT_COUNT):
        """Gets all comments of a posting, no matter it is replying to
        the posting directly or another comment.
            @param cnt: the number of comments returned. 0 means no limit.
            @return: a tuple (the list of comments, total number of comments).
        """
        if cnt is None:
            cnt = DEFAULT_COMMENT_COUNT
        comments = posting.AllComments if posting else []
        if cnt:
            return (comments[-cnt:], len(comments))
        return (comments, len(comments))

    @staticmethod
    def get_topic_description(topic_id):
        if topic_id:
            from cdb.objects import ByID
            topicobj = ByID(topic_id)
            if topicobj:
                return topicobj.GetDescription()
        return ""

    @staticmethod
    def create_posting(**varkw):
        cdb_classname = varkw.get("cdb_classname", "")
        cdbclass = CDBClassDef(cdb_classname)
        if not cdbclass:
            cdbclass = UserPosting

        posting = operation(
            kOperationNew,
            cdbclass,
            cdbblog_posting_txt=varkw.get("text", ""),
            context_object_id=varkw.get("topic_id", ""))
        return {"posting": posting,
                "postingtools": PostingTools}

    @staticmethod
    def create_comment(**varkw):
        comment = None
        posting_id = varkw.get("posting_id", "")
        if posting_id:
            in_reply_to = varkw.get("in_reply_to", "")
            text = varkw.get("text", "")
            comment = operation(kOperationNew,
                                Comment,
                                cdbblog_comment_txt=text,
                                posting_id=posting_id,
                                in_reply_to=in_reply_to)
        return {"blogitem": comment,
                "postingtools": PostingTools}

    @staticmethod
    def in_reply_to_comment(blogitem):
        return isinstance(blogitem, Comment) and \
            blogitem.in_reply_to and \
            blogitem.in_reply_to != blogitem.posting_id

    @staticmethod
    def get_reply_to_title_message_by(blogitem):
        name = ""
        reply_to = blogitem.ReplyTo
        if reply_to:
            name = PostingTools.format_user_name(reply_to, full=False)
        msg = util.Labels()["cdbblog_comment_title_message_by"]
        return msg.replace("#NAME#", name)

    @classmethod
    def templates(cls):
        return _getapp().getTemplates()

    @classmethod
    def plugin(cls, context_obj):
        if context_obj:
            plugins = sig.emit(context_obj.__class__,
                               "cs.activitystream.getplugins")()
            if plugins:
                return plugins[0]
        return None

    @classmethod
    def get_plugin_css_files(cls):
        if cls.plugin_css_files is None:
            plugins = sig.emit("cs.activitystream.getcssfiles")()
            cls.plugin_css_files = \
                ["%s%s" % (plg.getURLPaths()["localres"], plg.css_file)
                 for plg in plugins if getattr(plg, "css_file", None)]
        return cls.plugin_css_files

    @staticmethod
    def get_posting_filter_cond(filterdata):
        cond = []
        if filterdata.get("filter_mine", None):
            cond.append("(cdb_cpersno='%s')" % sqlapi.quote(auth.persno))
        typecond = []
        if filterdata.get("filter_userpostings", None):
            typecond.append(unicode(UserPosting._MatchExpression()))
        if filterdata.get("filter_systempostings", None):
            typecond.append(unicode(SystemPosting._MatchExpression()))
        if typecond:
            cond.append(" or ".join(typecond))
        clsfilters = filterdata.get("filter_classes", None)
        if clsfilters:
            from cdb.kernel import getPrimaryTableForClass
            clscond = []
            for clsname in clsfilters.split(" "):
                tblname = getPrimaryTableForClass(clsname)
                clscond.append("(exists (select cdb_object_id from %s where "
                               "%s.cdb_object_id=topic2p.topic_id))" %
                               (tblname, tblname))
            if clscond:
                cond.append("(cdb_object_id in (select topic2p.posting_id "
                            "from %s topic2p where %s))" %
                            (Topic2Posting.GetTableName(),
                             " or ".join(clscond)))
        return " and ".join(cond)


class PostingFormatter(object):

    url_regexp = re.compile(
        r"((?<!\w)(((https?|cdb|ftp)://)|cdbcmsg:)[^\"\'\s]+)", re.IGNORECASE)

    def __init__(self, text, check_link, hasmore):
        self.text = text
        self.check_link = check_link
        self.hasmore = hasmore

    def get_all(self, text, symbol):
        """
        gets a string, searches for all occurences of symbol

        return:
            result with all indizes of the given symbol
        """
        result = []
        ind = 0

        while True:
            ind = text.find(symbol, ind + 1)
            if ind == -1:
                break
            result.append(ind)

        return result

    def _check_brackets(self, link, br_open="(", br_close=")"):
        """
        gets a string fitting to the regex "url_regexp", makes him to a
        html-hyperlink, counts brackets and looks for pairs, cuts before first
        invalid bracket parameters:
            link:   string fits to the regex
        return:
            tuple of (link, linkrest)
        """
        open_brackets = self.get_all(link, br_open)
        close_brackets = self.get_all(link, br_close)
        open_brackets_len = len(open_brackets)
        close_brackets_len = len(close_brackets)
        brackets_diff = open_brackets_len - close_brackets_len

        if (open_brackets_len == 0 and close_brackets_len == 0) or \
                brackets_diff == 0:
            return (link, "")
        if brackets_diff > 0:  # too many open ones
            text_position = open_brackets[-brackets_diff]
        else:  # too many closed ones
            text_position = close_brackets[brackets_diff]
        return link[:text_position], link[text_position:]

    def check_brackets(self, link):
        rounded = self._check_brackets(link)  # ( )
        angular = self._check_brackets(link, "[", "]")  # [ ]

        return rounded if len(rounded[0]) < len(angular[0]) else angular

    def get_formatted_text(self):

        def link_repl(matchobj):
            """
            called for each match, if check_link is true and the post or
            comment ends with the match, the match is returned.
            Else check_link is called with the matching text
            """
            matchtext = matchobj.group(0)

            if self.check_link and self.text.endswith(matchtext):
                return matchtext

            newLink = self.check_brackets(matchtext)

            return u'<a target="%s" href="%s">%s</a>%s' % (
                PostingTools.get_hyperlink_target(),
                newLink[0],
                newLink[0],
                newLink[1]
            )

        text = escape(self.text).rstrip()
        text = PostingFormatter.url_regexp.sub(link_repl, text)
        text = text.replace("\n", "<br />")
        text = text.replace("  ", "&nbsp;&nbsp;")

        if self.hasmore:
            text = text.rstrip() + "..."

        return text


@elink.using_template_engine("chameleon")
class BlogApp(elink.Application):

    """
    Application for CDB Blog.
    """

    def setup(self):
        self.add("start", RedirectPage())
        self.add("deprecated", StartPage())
        self.add("reloadstartpage", ReloadStartPage())
        self.add("activities", ActivityPage())
        self.add("postinglist", PostingListPage())
        self.add("postings", PostingPage())
        self.add("create_posting", CreatePosting())
        self.add("add_comment", CreateComment())
        self.add("load_all_comments", LoadComments())
        self.add("posting", ThreadPage())
        self.addJSON(self.get_more_text)
        self.addJSON(self.check_new_postings)
        self.addJSON(self._check_start_page_new_postings)

    def get_more_text(self, cdb_object_id, cutoff=False):
        from cdb.objects import ByID
        result = {"text": ""}
        blogitem = ByID(cdb_object_id)
        if isinstance(cutoff, basestring):
            cutoff = cutoff not in ('0', 'false')
        result["text"] = PostingTools.get_blogitem_text(blogitem, cutoff)[0]
        return result

    def check_new_postings(self, topic_id, last_updated=None):
        cond = None
        if topic_id:
            cond = PostingTools.generate_topic_condition("'%s'" % topic_id)
        return PostingTools.check_new_postings(cond, last_updated)

    @classmethod
    def on_CDB_eLink_cdbblog_now(cls, ctx):
        return cls.OpenPageURL("/activitystream/")

    def _get_start_page_condition(self):
        if not hasattr(self, "__start_page_condition__"):
            cond = ""
            # Look up threads for current user
            persno_cond = sqlapi.quote(auth.persno)

            # select * from cdbblog_posting where cdb_object_id in
            # (
            #   SELECT cdb_object_id FROM cdbblog_posting WHERE
            #     (context_object_id = '')
            #     OR
            #     (cdb_cpersno = 'caddok' AND
            #      cdb_classname='cdbblog_user_posting')
            #     OR
            #     (cdb_cpersno = 'caddok' AND
            #      cdb_classname='cdbblog_system_posting'
            #       AND EXISTS (SELECT cdbblog_comment.posting_id
            #       FROM cdbblog_comment
            #         WHERE cdbblog_comment.posting_id =
            #               cdbblog_posting.cdb_object_id))
            #   UNION
            #     SELECT cdbblog_topic2posting.posting_id
            #       FROM cdbblog_topic2posting, cdbblog_subscription
            #       WHERE cdbblog_subscription.personalnummer = 'caddok' AND
            #         cdbblog_subscription.channel_cdb_object_id =
            #         cdbblog_topic2posting.topic_id
            #   UNION
            #     SELECT cdbblog_comment.posting_id
            #       FROM cdbblog_comment
            #       WHERE cdbblog_comment.cdb_cpersno = 'caddok'
            # )
            # order by last_comment_date desc,cdb_object_id

            # Company wide threads
            # Own discussions
            # - discussions created by current user
            # - system activities from current user and commented by someone
            cond += (
                "SELECT cdb_object_id from cdbblog_posting WHERE "
                "  context_object_id = '' "
                "  OR "
                "  (cdb_cpersno = '%s' AND (%s OR EXISTS ( "
                "    SELECT cdbblog_comment.posting_id FROM cdbblog_comment "
                "    WHERE cdbblog_comment.posting_id = "
                "      cdbblog_posting.cdb_object_id))) " % (
                    persno_cond, UserPosting.__match__))

            # Threads with topics:
            # - topics subscripted
            cond += (
                "UNION SELECT cdbblog_topic2posting.posting_id "
                "  FROM cdbblog_topic2posting, cdbblog_subscription "
                "  WHERE cdbblog_subscription.personalnummer = '%s' AND "
                "    cdbblog_subscription.channel_cdb_object_id = "
                "      cdbblog_topic2posting.topic_id " % persno_cond)

            # Threads that commented by current user
            cond += (
                "UNION SELECT cdbblog_comment.posting_id "
                "  FROM cdbblog_comment "
                "  WHERE cdbblog_comment.cdb_cpersno = '%s' " % persno_cond)

            self.__start_page_condition__ = "cdb_object_id in ( %s )" % cond
        return self.__start_page_condition__

    def _check_start_page_new_postings(self, last_updated=None):
        return PostingTools.check_new_postings(
            self._get_start_page_condition(), last_updated)


class PostingListPage(elink.Template):

    """
    Gets posting list for given topic.
    """

    __html__ = """
        <metal:postings use-macro=
            "templates['postings.html'].macros.postinglist" />
    """

    def render(self, context, topic_id=None, cnt=DEFAULT_POSTING_COUNT):
        if not isinstance(cnt, int):
            try:
                cnt = int(cnt)
            except Exception:
                cnt = DEFAULT_POSTING_COUNT
        return PostingTools.get_postings(topic_id, cnt)


class PostingPageBase:

    """
    Reloads postings for given topic.
    """

    __html__ = """
        <metal:postingloop use-macro=
          "postingtools.templates()['postings.html'].macros['postingloop']" />
        """

    def render(self,
               context,
               cnt=DEFAULT_POSTING_COUNT,
               **varkw):
        if not isinstance(cnt, int):
            try:
                cnt = int(cnt)
            except Exception:
                cnt = DEFAULT_POSTING_COUNT
        last_comment_date = varkw.get("last_comment_date", "")
        last_object_id = varkw.get("last_object_id", "")
        topic_id = varkw.get("topic_id", None)
        no_channels = varkw.get("no_channels", None)
        cond = self.get_condition(**varkw)
        result = {}
        if cond:
            result = PostingTools.get_postings_by_condition(
                cond,
                cnt,
                last_comment_date,
                last_object_id)
        else:
            result = PostingTools.get_postings(topic_id,
                                               cnt,
                                               last_comment_date,
                                               last_object_id)
        result["no_channels"] = no_channels
        return result

    def get_condition(self, **varkw):
        return PostingTools.get_posting_filter_cond(varkw)


class PostingPage(PostingPageBase, elink.Template):
    pass


class CreatePosting(elink.Template):

    """
    Creates new Posting.
    """

    __template__ = "posting_created.html"

    def render(self, context, **varkw):
        return PostingTools.create_posting(**varkw)


class CreateComment(elink.Template):

    """
    Creates new comment.
    """

    __template__ = "comment_created.html"

    def render(self, context, **varkw):
        return PostingTools.create_comment(**varkw)


class LoadComments(elink.Template):

    """
    Loads all comments of a posting
    """

    __template__ = "all_comments.html"

    def render(self, context, posting_id):
        from cdb.objects import ByID
        posting = ByID(posting_id)
        return {"postingtools": PostingTools,
                "comments": PostingTools.get_all_comments(posting, 0)}


class ActivityPage(elink.Template):

    """
    Gets posting list for given topic. Serves exclusively for eLinkControl
    on masks.
    """

    __template__ = "activities.html"

    def render(self, context, topic_id=None, cnt=DEFAULT_POSTING_COUNT):
        results = {"create_posting": True,
                   "no_channels": True}
        if not isinstance(cnt, int):
            try:
                cnt = int(cnt)
            except Exception:
                cnt = DEFAULT_POSTING_COUNT
        if not topic_id or len(topic_id) < 36:
            results["create_posting"] = False
            results.update(PostingTools.get_postings_by_condition(None, cnt))
        else:
            results.update(PostingTools.get_postings(topic_id, cnt))
        return results


class StartPage(elink.Template):

    """
    Start page of activity stream.
    """

    __template__ = "start.html"

    def page_title(self):
        title = self.application.title
        try:
            title = util.Labels()['cdbblog_elink_page_title']
        except Exception:
            pass
        return title

    def render(self, context,
               cnt=DEFAULT_POSTING_COUNT, **varkw):
        if not isinstance(cnt, int):
            try:
                cnt = int(cnt)
            except Exception:
                cnt = DEFAULT_POSTING_COUNT
        result = PostingTools.get_postings_by_condition(
            self.application._get_start_page_condition(), cnt)
        result.update({"get_cls_designation": self.get_cls_designation})
        return result

    def get_cls_designation(self, clsname):
        # TODO: may be can be added to default values by engine,
        #      as e.g. options.classDesignation
        if clsname:
            from cdb.platform.mom import entities
            cldef = entities.CDBClassDef(clsname)
            return unicode(cldef.getDesignation())
        return ""


class ReloadStartPage(PostingPageBase, elink.Template):

    """
    Reloads more postings for start page.
    """

    def get_condition(self, **varkw):
        cond1 = PostingPageBase.get_condition(self, **varkw)
        cond2 = self.application._get_start_page_condition()
        if cond1:
            cond2 = "(%s) and (%s)" % (cond1, cond2)
        return cond2


class ThreadPage(elink.Template):

    """
    Gets specified posting and its comments.
    """

    __template__ = "thread.html"

    def render(self, context, cdb_object_id=None):
        results = {"create_posting": False}
        cond = None
        if cdb_object_id:
            cond = "cdb_object_id='%s'" % cdb_object_id
        results.update(PostingTools.get_postings_by_condition(cond))
        return results


class RedirectPage(elink.Resource):
    def _render(self, req):
        self.redirect(to_url="/activitystream/")
        self.write("")


class PostingRuleChecker(object):
    __metaclass__ = misc.Singleton

    RULES_CACHE = {}

    def _get_rule(self, pyrule):
        """
        Retrieve the `cdb.objects.Rule` object. To increase the performance
        the rules are cached.
        """
        rule = self.RULES_CACHE.get(pyrule, None)
        if not rule:
            rule = Rule.ByKeys(pyrule)
            if rule:
                self.RULES_CACHE[pyrule] = rule
        return rule

    def _checkRule(self, pyrule, oh):
        """
        Checks whether `oh` matches the rule identified by the rule's name
        given in `pyrule`.
        """
        rule = self._get_rule(pyrule)
        result = True
        if not rule:
            misc.log_error("Invalid rule '%s' when evaluating "
                           "activity stream rules" % pyrule)
            result = False
        else:
            result = rule.match(oh)
        return result

    def checkRules(self, oh):
        """
        Checks whether `oh` matches all rules that are specified for a system
        posting of the objects class within the data dictionary.
        """
        cldef = oh.getClassDef()
        result = True
        for pyrule in cldef.getSysPostingRules():
            if not self._checkRule(pyrule, oh):
                result = False
                break
        return result


def create_system_posting(cdb_object, msg_label, check_rules=True):
    """
    Creates a system posting. `cdb_object` can either be an instance of
    `cdb.objects.Object` or a `cdb.platform.mom.CDBObjectHandle`. `msg_label`
    defines the message label to use. `check_rules` is optional and set to
    ``True`` by default. If it is set to ``True`` all related rules will be
    checked before the posting job is created. Otherwise the job will be
    created directly without further checks.
    """
    handle = None

    try:
        handle = cdb_object.ToObjectHandle()
    except AttributeError:
        handle = cdb_object

    if not check_rules or PostingRuleChecker().checkRules(handle):
        ActivityListener().create_posting_job(None, handle, msg_label)


# lazy instantiation
_APP = None


def _getapp():
    global _APP
    if _APP is None:
        _APP = BlogApp("CDB Blog")
    return _APP


def handle_request(req):
    """Shortcut to the app"""
    return _getapp().handle_request(req)
