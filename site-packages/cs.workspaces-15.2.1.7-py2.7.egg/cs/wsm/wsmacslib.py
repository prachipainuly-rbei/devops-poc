# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2017 CONTACT Software GmbH
# All rights reserved.
# https://www.contact-software.com/

"""
Module checkout_workspace

This is the documentation for the checkout_workspace module.
"""

import collections
import os

from cdb.sig import emit
from cdb import misc
from cdb.objects.pdd.Files import DuplicateFilenameError

from cs.wsm.wsobjectcache import WsObjectCache
from cs.wsm.index_helper import getIndexes
from cs.wsm.virtualworkspace import VirtualWorkspace, FileTypes


__docformat__ = "restructuredtext en"
__revision__ = "$Id: wsmacslib.py 183681 2018-09-11 12:27:49Z jro $"


def _getDrawingOfSheet(sheetDoc):
    """
    :return Document: The Document containing the drawing file for the sheet document
    """
    drawingDoc = sheetDoc
    for sref in sheetDoc.DrawingOfSheetReferences:
        if sref.z_index == sref.z_index_origin:
            drawingDoc = sref.Drawing
    return drawingDoc


def checkout_workspace(sb, mainDoc, ignore_duplicates=False, use_subdir_for_appinfo=False, result=None):
    """
    :param sb: Sandbox or None
    :param mainDoc: Document
    :param ignore_duplicates: Boolean
        ignores files that belongs to different z_nummmer. The used
        documents is random.

    :param use_subdir_for_appinfo: Boolean
        For compatibility reasons. Classic plugins expect .appinfos in workdir,
        Plugins based on JobExecs and cad commands are using subdirs.

    :param result: optional dict to reuse for result. Dict Document to list of filenames

    :returns result dict dict Document to list of filename

    Checkout workspace in "as saved mode" like the WSM.

    If two documents instances are containing the filename
    DuplicateFilenameError will be raised if the documents don't
    have an equal z_nummer. In this case the maximum index of
    all  documents with equal z_nummer and a filename conflict
    will be used.
    The Index of the mainDoc will not be changed by ths function.
    In case of cyclic references with newer index versions the
    index from mainDoc will be used.

    If sb is None: no files will copied to disk. The returned filenames
    are relative in this case. With a given Sandbox the filenames are absolute.

    This method handle sheets document types.
    If more than one drawing references a sheet the default
    implementation will use the origin document.

    It's possible to overwrite the behaviour by connection
    to "getdrawingofsheet" signal. The function must
    accept the sheet Document as a parameter and must
    return the drawing Doc.

    Appinfo files will be written to .wsm/.info directory relative
    to the main file of a file group.

    Missing link documents are ignored by this function.

    Example usage:
    # simple testcall
    from cs.documents import Document
    import shutil
    from cdb.objects.cdb_file import CDB_File
    from cdb.objects.pdd.Files import Sandbox

    r = dict()
    wdir = u"C:\\temp\work\\"
    if os.path.isdir(wdir):
        shutil.rmtree(wdir)
    doc = Document.ByKeys("W000000","")
    sb = Sandbox(wdir)
    print checkout_workspace(sb, doc, True, result=r)
    sb.close()
    """
    # handle the case: mainDoc is a sheet
    if "additional_document_type" in mainDoc.keys():
        # 0 = no multisheet
        # 1 = multisheet master
        # 2 = multisheet sheet
        if mainDoc.additional_document_type == "2":
            drawingDocs = emit("getdrawingofsheet")(mainDoc)
            if drawingDocs:
                mainDoc = drawingDocs[0]
            else:
                drawingDoc = _getDrawingOfSheet(mainDoc)
                if drawingDoc is not None:
                    mainDoc = drawingDoc

    if result is None:
        result = dict()

    # collect all files reachable from mainDoc and remember their doc(s)
    eList = list()
    filenames = collections.defaultdict(list)  # filenames to list of doc.cdb_object_ids
    vw = VirtualWorkspace(mainDoc, followReferences=True, errors=eList)
    vwFiles = vw.getAllFiles([FileTypes.MainFile])
    for vwFile in vwFiles:
        if vwFile.attrs["cdbf_object_id"] != mainDoc.cdb_object_id:
            filenames[vwFile.getRelFilename()].append(vwFile.attrs["cdbf_object_id"])

    # make sure all affected documents are in the cache
    docObjIds = set()
    for objids in filenames.itervalues():
        docObjIds.update(objids)
    wsCache = WsObjectCache(True)
    docObjects = wsCache.getObjectsByID(list(docObjIds), False)

    objsToCheckOut = set()
    mainFilenames = []

    mainPrim = vw.getMainFilesForBo(mainDoc.cdb_object_id)
    for f in mainPrim:
        mainFilenames.append(f.getRelFilename())
    # check for conflicts find max index
    for fname, fobjects in filenames.iteritems():
        if fname in mainFilenames:
            if ignore_duplicates:
                # always prefer files of the mainDoc
                continue
            else:
                z_nummers = [mainDoc.z_nummer] + [wsCache.getCachedObject(fO).z_nummer for fO in fobjects]
                raise DuplicateFilenameError("Duplicate name: %s, numbers: %s" % (fname, ",".join(z_nummers)))

        # more than one document for this file => there is a conflict
        if len(fobjects) > 1:
            fZnumbers = set()
            indexDocs = list()
            for fobjid in fobjects:
                doc = wsCache.getCachedObject(fobjid)
                indexDocs.append(doc)
                fZnumbers.add(doc.z_nummer)
            # more than one z_nummer for this file
            if len(fZnumbers) > 1:
                # if duplicates are allowed, just use the first document
                if ignore_duplicates:
                    objsToCheckOut.add((fname, wsCache.getCachedObject(fobjects[0])))
                else:
                    raise DuplicateFilenameError("Duplicate name: %s, numbers: %s" % (fname, ",".join(list(fZnumbers))))
            else:
                # only one z_nummer: manage index conflicts
                # find the highest index
                maxIndex = -1
                maxDoc = None
                for doc in indexDocs:
                    # simple and hopefully fast enough, otherwise one call and compare the object_ids
                    _, _, myIndex = getIndexes(doc)
                    if myIndex > maxIndex:
                        maxDoc = doc
                        maxIndex = myIndex
                if maxDoc:
                    objsToCheckOut.add((fname, maxDoc))
        else:
            # simple case: no conflict
            objsToCheckOut.add((fname, wsCache.getCachedObject(fobjects[0])))
    # always check out the files of the main doc
    for mainFname in mainFilenames:
        objsToCheckOut.add((mainFname, mainDoc))

    # now collect destination file paths
    # and actually checkout the files if sb is given
    for relfilename, doc in objsToCheckOut:
        misc.cdblogv(misc.kLogMsg, 5, "Handle file :%s" % relfilename)
        fpathlist = result.get(doc, None)
        if fpathlist is None:
            fpathlist = []
            result[doc] = fpathlist
        # main file
        dest_path = os.path.dirname(relfilename)
        fname = os.path.basename(relfilename)
        for f in doc.Files.KeywordQuery(cdbf_name=fname):
            dp = os.path.join(dest_path, f.cdbf_name)
            if sb is not None:
                fpathlist.append(sb.checkout_to_path(f, dp))
            else:
                fpathlist.append(relfilename)
        # appinfo
        appinfoRecord = vw.getAppinfoRecord(relfilename)
        for vwgf in vw.getGroupFiles(relfilename):
            # move appinfo to correct directory
            if vwgf == appinfoRecord and use_subdir_for_appinfo:
                dname = vwgf.getDirectory()
                bname = vwgf.attrs["cdbf_name"]
                dp = os.path.join(dname, ".wsm", ".info", bname)
            else:
                dp = vwgf.getRelFilename()
            if sb is not None:
                fpathlist.append(sb.checkout_to_path(vwgf.getObject(), dp))
            else:
                fpathlist.append(dp)
    return result
