#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
# $Id: srvwsitem.py 94935 2013-02-22 10:23:47Z gwe $
#
# Copyright (C) 1990 - 2008 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
# File:     WsItem.py
# Author:   ws
# Creation: 15.02.08
# Purpose:

"""
Module WsItem
==================

This is the documentation for the WsItem module.
"""

__docformat__ = "restructuredtext en"

import copy
from cdb.misc import cdblogv
from cdb import misc


class logClasses(object):
    kLogErr = misc.kLogErr
    kLogMsg = misc.kLogMsg


class ChildAlreadyExistingError(Exception):
    """
    This exception is thrown when trying to append a child with an identical (name, type).
    """
    pass


class InvalidItemPath(Exception):
    pass


class InvalidItem(Exception):
    pass


class SrvWsItem(object):
    """
    Baseclass for WsItem implementations.

    :ivar _itemName: unicode string
    :ivar _itemType: unicode string
    :ivar _parent: WsItem tree
    :ivar _children: dictionary of child WsItem objects children are accessed using (itemName, itemType) as key
    """

    def __init__(self, itemName, itemType):
        """
        Initialize WsItem.

        :Parameters:
            itemName : string
                name of the object. The pair (type, itemName) is unique for all
                direct children of one WsItem.
            itemType : string
                type of the object. The pair (type, itemName) is unique for all
                direct children of one WsItem.
            mesh : Mesh instance
                the Mesh containing this WsItem
        """
        self._itemName = itemName
        self._itemType = itemType
        self._itemId = None
        self._parent = None
        self._children = {}
        self._attrDict = {}

    def __str__(self):
        """
        Return a printable representation of self for debug purposes.
        """
        retStr = "WsItem instance at %s\n" % hex(id(self)).upper()
        retStr = "%s_itemName:%s\n_itemType:%s" % (retStr, self._itemName, self._itemType)
        return retStr

    def copyItem(self):
        """
        Makes and returns a plain copy of self

        Doesnt copies the item attributes from attributes store.

        :returns: WsItem
        """
        result = copy.copy(self)
        result._parent = None
        result._children = {}  # cut off the subtrees

        result._attrDict = {}
        result._attrDict.update(self._attrDict)
        result._contentHashes = {}
        result._contentHashes.update(self._contentHashes)

        return result

    def copyTree(self, newMesh=None, resetMesh=False):
        """
        makes and returns a deep copy of myself

        Doesnt copy the item attributes from attributes store.
        """
        copied = self.copyItem()
        if resetMesh:
            copied._mesh = None
        else:
            if newMesh:
                # in the case when the original mesh is readonly, the copy has to be relinked to the
                # new mesh to make appendChild (follows..) possible
                copied._mesh = newMesh
        for child in self.getChildren():
            copied.appendChild(child.copyTree(newMesh, resetMesh))
        return copied

    def getParent(self):
        """
        Get the parent item of this item. None if not available

        :returns: WsItem or None
        """
        return self._parent

    def setParent(self, parent):
        """
        Set the parent item of self.
        """
        self._parent = parent

    def getAttributes(self):
        """
        Get all attributes of this item

        :returns: Dict of attributes
        """
        return self._attrDict

    def getChildren(self):
        """
        Get all children of this item

        :returns: List of children
        """
        return self._children.values()

    def _getItemPathList(self):
        if self._parent is not None:
            p = self._parent._getItemPathList()
            p.append(self.getItemId())
        else:
            p = [self.getItemId()]

        return p

    def getItemPath(self):
        """
        Get the full wsitem path of this item up to the root item.

        :returns: the path (from type, itemName) up to the root item (item with no parent)
        """

        return tuple(self._getItemPathList())

    def appendChild(self, child, overwriteExisting=False):
        """
        Append a child to self.

        Appends a child to self. Modifies the _parent and ._mesh attributes in child
        if overwriteExtisting is False and child.getItemID exists in children an
        exception (ChildAlreadyExistingError) will bei thrown.
        :raises: ChildAlreadyExistingError , AccessViolationError
        """

        typeNamePair = (child._itemType, child._itemName)
        if not overwriteExisting:
            if typeNamePair in self._children:
                cdblogv(logClasses.kLogErr, 0,
                        u"Unable to append child instance '%s' to WsItem instance '%s', because a child with identical name and value already exists"
                        % (child.getItemId(), self.getItemId()))
                e = ChildAlreadyExistingError("cannot append child node '%s' to node '%s'" % (unicode(child.getItemId()), unicode(self.getItemId())))
                e.args = (child,)
                raise e

        self._children[typeNamePair] = child
        child._parent = self

    def deleteChild(self, child):
        """
        delete the child from self
        """
        if child:
            self._children.pop(child.getItemId(), None)

    def delete(self):
        """
        remove itself from the tree
        """
        if self._parent:
            self._parent.deleteChild(self)

    def appendChildToList(self, item, subType, overwriteExisting=False):
        """
        Appends passed item to a itemlist with passed subType

        :Parameters:
            subType : String
                Subtype of passed wsitem
            item : WsItem
                the wsitem to add
        """
        listItem = self.findChildByType(subType)
        if not listItem:
            listItem = SrvWsItem(u"list", subType)
            self.appendChild(listItem)

        listItem.appendChild(item, overwriteExisting)

    def deleteChildFromList(self, item, subType):
        """
        Removes passed item from an itemlist of passed subType

        :Parameters:
            subType : String
                Subtype of passed wsitem
            item : WsItem
                the wsitem to remove
        """
        listItem = self.findChildByType(subType)
        if listItem:
            listItem.deleteChild(item)

    def getItemsAsList(self, itemType):
        """
        Returns all children of a WsItem of passed itemType

        :Parameters:
            itemType : String
                Type of a WsItem
        :returns: List of WsItems or empty List
        """
        ret = []
        rel = self.findChildByType(itemType)
        if rel is not None:
            ret = rel.getChildren()
        return ret

    def setAttribute(self, name, value):
        """
        Sets an attribute for self by name and value.

        :Parameters:
            name : String
                The attributes name
            value : object
                The attributes value

        :raises AccessViolationError: if mesh is readonly
        """

        self._attrDict[name] = value

    def getItemType(self):
        """
        Get the item type of self.

        :returns: itemType : string
        """
        return self._itemType

    def getItemName(self):
        """
        Get the item name of self.

        :returns: item name : string
        """
        return self._itemName

    def getItemId(self):
        """
        Get the unique id of self.

        :returns: item id : string
        """
        if self._itemId is None:
            self._itemId = self.getItemType(), unicode(self.getItemName())

        return self._itemId

    def findChildById(self, itemId):
        """
        Find child by id itemId.

        :Parameters:
            itemId : tuple (type,name)
                id identifying a child WsItem instance

        :returns: found WsItem instance or None
        """
        return self._children.get(itemId, None)

    def findChildrenByName(self, itemName):
        """
        Find child by name itemName.

        :Parameters:
            itemName : unicode
                WsItem instance name

        :returns: list of found WsItem instances
        """
        retChildren = []
        for (_, childName), child in self._children.iteritems():
            if itemName == childName:
                retChildren.append(child)
        return retChildren

    def findChildrenByType(self, itemType):
        """
        Find child by type itemType.

        :Parameters:
            itemType : unicode
                WsItem instance type

        :returns: list of found WsItem instances
        """
        retChildren = []
        for (childType, _), child in self._children.iteritems():
            if itemType == childType:
                retChildren.append(child)
        return retChildren

    def findChildByType(self, itemType):
        """
        Find child by type itemType.

        :Parameters:
            itemType : unicode
                WsItem instance type

        :returns: the first found WsItem of the given type
        """
        for (childType, _), child in self._children.iteritems():
            if itemType == childType:
                return child

    def findAttributeByName(self, name):
        """
        Find attribute by its name.

        :Parameters:
            name : string
                the attribute's name

        :returns: object: the found attribute value or None
        """
        return self._attrDict.get(name, None)

    def compareItemTree(self, other, hashType, validTypes=None, wsPath="", otherWsPath=None):
        """
        Compare two WsItem trees by the passed hashtype of the
        single wsitems. Only wsitems with types contained in list validTypes
        are compared. If validTypes is None, all wsitems are compared.
        If parent wsitems are unchanged, the child wsitems are considered
        unchanged, too. Workspace path is needed for content- and blobhash
        calculation.

        :Parameters:
            other : WsItem instance
                another WsItem tree to compare with self
            hashType : HASHTYPES attribute
                the hashtype used for comparing
            validTypes : list of valid wsitem types
                only nodes with a type contained in validTypes are compared
            wsPath : String
                The absolut workspace path
            otherWsPath : String
                The absolut workspace path of the other WsItem


        :return: A 4-tuple of dictionaries. All four dictionaries map a WsItem path to a WsItem instance.

            1. equalItems contains unchanged wsitems in self
            2. changedItems contains changed wsitems in self
            3. onlyInSelf contains wsitems, which do exist only in self
            4. onlyInOther contains wsitems, which do exist only in other
        """

        if otherWsPath is None:
            oPath = wsPath
        else:
            oPath = otherWsPath
        equalItems = {}
        changedItems = {}
        onlyInSelf = {}
        onlyInOther = {}
        if validTypes is None:
            vType = []
        else:
            vType = validTypes
        self._compareItemTree(other, equalItems, changedItems, onlyInSelf, onlyInOther, hashType, vType, wsPath, oPath)

        return (equalItems, changedItems, onlyInSelf, onlyInOther)

    def findUpByType(self, itemType):
        """
        Find WsItem instances matching itemType upwards in the tree hierarhy.

        Search the hierarchy upwardly for the first occurrence of a matching
        WsItem instance.

        :Parameters:
            itemType : string
                a string describing the searched type

        :returns: WsItem. The first matching WsItem instance or None
        """
        retWsItem = None
        if not self._parent is None:
            if self._parent._itemType == itemType:
                retWsItem = self._parent
            else:
                retWsItem = self._parent.findUpByType(itemType)

        return retWsItem

    def findItemByPath(self, itemPath):
        """
        :Parameters:
            itemPath : list of (type, name) pairs
                The path of the item to find

        :returns: WsItem. The item which corresponds to the passed absolute wsitem path or None
        """
        item = None

        if itemPath:
            if len(itemPath) == 1:
                nodeId = itemPath[0]
                if nodeId == self.getItemId():
                    item = self

            elif len(itemPath) > 1:
                currentNode = self
                itemPath = itemPath[1:]
                for node in itemPath:
                    child = currentNode.findChildById(node)
                    if child is None:
                        break
                    else:
                        currentNode = child
                else:
                    item = child

        return item
