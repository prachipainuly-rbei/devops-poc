# File:     test_index_helper.py
# Author:   wme
# Creation: 04.10.2011


"""
Module test_index_helper.py
"""
import unittest

from cdb.objects import Rule, Predicate, Term
from cs.documents import Document
from cdb.testcase import run_level_setup, without_error_logging
from cs.wsm.index_helper import IndexUpdateRule, getIndexes
from cdb.platform.gui import Label
from cdb import sqlapi
from cdb.objects.operations import operation
from cdb.constants import kOperationNew  # @UnresolvedImport


PRF = "CDBWSM_IHTEST"
RULEID = "16397"
DocClass = "cs.documents.Document"


def setUp():
    run_level_setup()


class Test_IndexHelper(unittest.TestCase):

    @without_error_logging
    def setUp(self):
        self.cleanUp()
        # Object rule describing freigegebene Dokumente
        self.orule1 = Rule.Create(name=PRF + "or1", description="description 1")
        self.pred1 = Predicate.Create(name=self.orule1.name, fqpyname=DocClass, predicate_name=PRF + "pr1")
        self.term1 = Term.Create(name=self.orule1.name, fqpyname=DocClass, predicate_name=self.pred1.predicate_name,
                                 attribute="z_status", operator="=", expression="200",
                                 id=RULEID)

        # Object rule matching all documents
        self.orule2 = Rule.Create(name=PRF + "or2", description="description 2")
        self.pred2 = Predicate.Create(name=self.orule2.name, fqpyname=DocClass, predicate_name=PRF + "pr2")

        # labels as names for the rules
        self.label1 = Label.Create(ausgabe_label=PRF + "1", d="Label 1")
        self.label2 = Label.Create(ausgabe_label=PRF + "2", d="Label 2")

        # the actual index rules
        self.highest_index = IndexUpdateRule.Create(name=self.label2.ausgabe_label,
                                                    object_rule=self.orule2.name)
        self.released = IndexUpdateRule.Create(name=self.label1.ausgabe_label,
                                               object_rule=self.orule1.name,
                                              )

        # some documents as input data
        self.doc0 = operation(kOperationNew, Document,
                              z_nummer=PRF + "doc1", z_index="", z_status=200, z_categ1="144", z_categ2="296")
        self.doc1 = self.doc0.CreateIndex()
        self.doc1.z_status = 0
        self.doc0.z_status = 200  # changed by CreateIndex

        self.doc2 = Document.Create(z_nummer=PRF + "doc2", z_index="", z_status=0)

    def tearDown(self):
        self.cleanUp()

    def cleanUp(self):
        sqlapi.SQLdelete("FROM zeichnung WHERE z_nummer LIKE '%s%%'" % PRF)
        sqlapi.SQLdelete("FROM ausgaben WHERE ausgabe_label LIKE '%s%%'" % PRF)
        sqlapi.SQLdelete("FROM index_update_rule WHERE name LIKE '%s%%'" % PRF)
        sqlapi.SQLdelete("FROM cdb_pyrule WHERE name LIKE '%s%%'" % PRF)
        sqlapi.SQLdelete("FROM cdb_pypredicate WHERE name LIKE '%s%%'" % PRF)
        sqlapi.SQLdelete("FROM cdb_pyterm WHERE name LIKE '%s%%'" % PRF)

    def test_withoutRule(self):
        indexes, externalNumber, myIndex = getIndexes(self.doc0)
        assert len(indexes) == 2
        assert not indexes[0].is_default
        assert not indexes[1].is_default
        assert indexes[myIndex].object_id == self.doc0.cdb_object_id

    def test_highest_index(self):
        indexes, externalNumber, myIndex = getIndexes(self.doc0, self.highest_index.cdb_object_id)
        assert len(indexes) == 2
        assert not indexes[0].is_default
        assert indexes[1].is_default

    def test_released(self):
        indexes, externalNumber, myIndex = getIndexes(self.doc0, self.released.cdb_object_id)
        assert len(indexes) == 2
        assert indexes[0].is_default
        assert not indexes[1].is_default

    def test_noMatch(self):
        indexes, externalNumber, myIndex = getIndexes(self.doc2, self.released.cdb_object_id)
        assert len(indexes) == 1
        assert not indexes[0].is_default

    def test_withFallback(self):
        self.released.fallback_rule = self.highest_index.cdb_object_id
        # match without fallback
        indexes, externalNumber, myIndex = getIndexes(self.doc0, self.released.cdb_object_id)
        assert len(indexes) == 2
        assert indexes[0].is_default
        assert not indexes[1].is_default
        # match only by fallback
        self.doc0.z_status = 0
        indexes, externalNumber, myIndex = getIndexes(self.doc0, self.released.cdb_object_id)
        assert len(indexes) == 2
        assert not indexes[0].is_default
        assert indexes[1].is_default

    def test_cyclic_fallback(self):
        self.released.fallback_rule = self.released.cdb_object_id
        indexes, externalNumber, myIndex = getIndexes(self.doc2, self.released.cdb_object_id)
        assert len(indexes) == 1
        assert not indexes[0].is_default

    def test_wrong_fallback(self):
        self.released.fallback_rule = "non-existing rule"
        indexes, externalNumber, myIndex = getIndexes(self.doc2, self.released.cdb_object_id)
        assert len(indexes) == 1
        assert not indexes[0].is_default

    def text_noFiltering(self):
        indexes, _, _ = getIndexes(self.doc0, indexFilterRuleId="")
        assert len(indexes) == 2
        assert not indexes[0].is_default
        assert not indexes[1].is_default

    def text_filteringNonReleased(self):
        indexes, _, _ = getIndexes(self.doc0, indexFilterRuleId=self.released.cdb_object_id)
        assert len(indexes) == 1
        assert not indexes[0].is_default

    def text_filterWithRuleThatAlwaysMatches(self):
        indexes, _, _ = getIndexes(self.doc0, indexUpdateRuleId=self.released.cdb_object_id,
                                   indexFilterRuleId=self.highest_index.cdb_object_id)
        assert len(indexes) == 2
        assert not indexes[0].is_default
        assert indexes[1].is_default

    def test_indexRulesAreCachedWhenAccessedById(self):
        # GIVEN: an index rule that has previously been accessed by id
        rule1 = IndexUpdateRule.getIndexRuleById(self.highest_index.cdb_object_id)
        del rule1  # forget reference

        # AND: a mechanism to observe database access
        recordWasCreated = {}
        record_init = sqlapi.Record.__init__
        try:
            def f(*args, **kwargs):
                recordWasCreated[0] = True
                return record_init(*args, **kwargs)

            sqlapi.Record.__init__ = f

            # WHEN: I access the index rule again by id
            rule2 = IndexUpdateRule.getIndexRuleById(self.highest_index.cdb_object_id)
        finally:
            sqlapi.Record.__init__ = record_init

        # THEN: no database access occurred
        assert not recordWasCreated

    def test_indexRulesAreCachedWhenAccessedByName(self):
        # GIVEN: an index rule that has previously been accessed by name
        rule1 = IndexUpdateRule.getIndexRuleByName(self.highest_index.name)
        del rule1  # forget reference

        # AND: a mechanism to observe database access
        recordWasCreated = {}
        record_init = sqlapi.Record.__init__
        try:
            def f(*args, **kwargs):
                recordWasCreated[0] = True
                return record_init(*args, **kwargs)

            sqlapi.Record.__init__ = f

            # WHEN: I access the index rule again by name
            rule2 = IndexUpdateRule.getIndexRuleByName(self.highest_index.name)
        finally:
            sqlapi.Record.__init__ = record_init

        # THEN: no database access occurred
        assert not recordWasCreated


if "__main__" == __name__:
    suite = unittest.makeSuite(Test_IndexHelper, 'test')
    runner = unittest.TextTestRunner()
    runner.run(suite)
