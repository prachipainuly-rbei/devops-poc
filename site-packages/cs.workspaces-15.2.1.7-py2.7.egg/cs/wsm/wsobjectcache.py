#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

__docformat__ = "restructuredtext en"

from collections import defaultdict

from cdb import sqlapi, misc, util
from cdb import auth, CADDOK
from cdb.objects import ByID
from cdb.objects.cdb_file import cdb_file_base
from cs.documents import Document
from cs.vp.items import Item
from cdb.platform.acs import RelshipAccessProfileMapping
from cdb.platform.olc import StateDefinition
from cdb.platform.mom import getObjectHandlesFromObjectIDs


class WsObjectCache(object):
    """
    A cache for Object Framework objects.
    Only valid during one user exit run.

    The difference to the normal object cache:
      - can retrieve multiple objects at once (given a list of ids)
      - always retrieves all files of retrieved business objects at once
      - optionally retrieves access rights in a more efficient but less general
        way
    """
    def __init__(self,
                 simplifiedRightsCheck,
                 doRightsCheck=True,
                 extendedCaching=False,
                 fileCaching=True,
                 lang=None):
        """
        :param simplifiedRightsCheck: Boolean
          If True, rights are indirectly checked using a RecordSet2. This
           does not support every configuration. Files inherit the rights from
           their document/business object.
          If False, every object (business objects and files) is checked
           in isolation, using Object.CheckAccess.
        :param doRightsCheck: Boolean
          If True rights checks are processed, else no rights checks are processed
        :param extendedCaching: Boolean
          If True, also caches linked documents, items of documents, indexes and
           extended information about files
        :param: fileCaching: Boolean
           caches cdb_files if true
        """
        self._objects = {}  # cdb_object_id -> Object
        self._files = defaultdict(list)  # cdb_object_id -> list(cdb_file_base)
        self._objectRights = {}  # cdb_object_id -> dict(access->Bool)
        self._simplifiedRightsCheck = simplifiedRightsCheck
        self._doRightsCheck = doRightsCheck

        self._extendedCaching = extendedCaching
        self._fileCaching = fileCaching
        self._items = []  # keeps Items to prevent GC
        self._indexes = defaultdict(list)  # z_nummer -> list(Record)
        self._fileAttributes = defaultdict(dict)  # (cdb_object_id, cdb_wspitem_id) -> dict
        self._linkStatus = defaultdict(dict)  # (cdb_object_id, cdb_wspitem_id) -> (linkId -> "0"|"1")

        # maps WSM object right names to CDB object right names
        self._objectRightsMapping = {'save': 'save',
                                     'index': 'index',
                                     'get': 'read',
                                     'delete': 'delete'}
        # "WSM file right names" -> "CDB object right name"
        # only needed for simplified rights checking
        self._fileRightsMapping = self._calculateFileRightMapping()

        self._rightsToRetrieve = set(self._objectRightsMapping.values() +
                                     self._fileRightsMapping.values())
        self._status_name_cache = dict()  # (status, kind) -> string

        self.lang = lang or CADDOK.ISOLANG

    def getObjectsByID(self, ids, alsoFetchLinkedObjects=False):
        """
        @param ids list(cdb_object_id)
        :returns: list of Objects, in no particular order
        """
        result = {}
        missing = []
        for id in ids:
            if id in self._objects:
                result[id] = self._objects[id]
            else:
                missing.append(id)
        if missing:
            result.update(self._fetchObjectsByID(missing, alsoFetchLinkedObjects))

        return result.values()

    def getObjectById(self, objId):
        ret = None
        objs = self.getObjectsByID([objId])
        if len(objs) == 1:
            ret = objs[0]
        return ret

    def prefetchObjects(self, ids, alsoFetchLinkedObjects=True):
        """
        Make sure all objects for the given id are in the cache.
        @param ids list(cdb_object_id)
        @param alsoFetchLinkedObjects whether to cache all linked docs (transitively)
        :returns None
        """
        _ = self.getObjectsByID(ids, alsoFetchLinkedObjects=alsoFetchLinkedObjects)

    def getCachedObject(self, id):
        """
        @param id cdb_object_id
        :returns Object or None
        """
        return self._objects.get(id)

    def workspaceItemsOf(self, id):
        """
        @param id cdb_object_id of a business object
            the business object is expected to be in the cache;
            otherwise a warning is logged and the object is added to the cache
        :returns list(cdb_file_base)
        """
        self._ensureCached(id)
        return self._files[id]

    def rightsOfBusinessObject(self, obj):
        """
        :param obj Document, Frame or similar
        :returns dict(access->Bool)
        """
        wsmRights = {}

        if self._doRightsCheck:
            cdbRights = self._cdbRightsOfBusinessObject(obj)
            wsmRights = self.mapToWsmObjectRights(cdbRights)

        return wsmRights

    def rightsOfFile(self, fileObj):
        """
        :param fileObj: cdb_file_base (or derived)
        :return: dict(access->Bool)
        """
        wsmRights = {}
        if self._doRightsCheck:
            cdbf_object_id = fileObj.cdbf_object_id
            self._ensureCached(cdbf_object_id)

            if self._simplifiedRightsCheck:
                bobj = self._objects[cdbf_object_id]
                cdbRights = self._cdbRightsOfBusinessObject(bobj)
            else:
                cdbRights = self._rightsOfObject(fileObj)

            wsmRights = self.mapToWsmFileRights(cdbRights)

        return wsmRights

    def indexesOfDocument(self, doc):
        """
        :param doc: Document
        :return: list of Records (or None if extended caching disabled)
        """
        if not self._extendedCaching:
            return None

        indexes = []
        self._ensureCached(doc.cdb_object_id)
        all_indexes = self._indexes[doc.z_nummer]
        # return only readable indexes
        for index in all_indexes:
            if index.cdb_object_id in self._objectRights:
                cdbRights = self._objectRights.get(index.cdb_object_id)
                wsmRights = self.mapToWsmObjectRights(cdbRights)
                isReadable = wsmRights.get("get", False)
                if isReadable:
                    indexes.append(index)
            else:
                # without rights check: add all indexes
                indexes.append(index)
        return indexes

    def wsmAttributesOfFile(self, cdbf_object_id, cdb_wspitem_id):
        """
        :return: dict (or None if extended caching disabled)
        """
        if self._extendedCaching:
            self._ensureCached(cdbf_object_id)
            return self._fileAttributes[(cdbf_object_id, cdb_wspitem_id)]
        else:
            return None

    def linkStatusOf(self, cdbf_object_id, cdb_wspitem_id):
        """
        :return: dict(link_id -> "0"|"1") (or None if extended caching disabled)
        """
        if self._extendedCaching:
            self._ensureCached(cdbf_object_id)
            return self._linkStatus[(cdbf_object_id, cdb_wspitem_id)]
        else:
            return None

    def getCdbObjectRightsAndStatusTextByID(self, ids):
        """
        Specialized method for fast server rights requests.

        @param ids list(cdb_object_id)

        :returns: tuple of
                1. nested dict cdb_object_id -> access right -> Bool
                2. dict cdb_object_id -> (attribute name,
                                          attribute value,
                                          second attribute name,
                                          second attribute value)
        """
        rights = {}
        status = {}
        if ids:
            docIds = filterNonDocuments(ids)
            if docIds:
                rights = self._getRightsOfDocuments(docIds, status)

            otherIds = set(ids) - set(docIds)
            for nonDocumentId in otherIds:
                obj = ByID(nonDocumentId)
                if obj:
                    rights[nonDocumentId] = self._rightsOfObject(obj)
                    if status is not None:
                        # the object may or may not have a status text attribute
                        try:
                            status[nonDocumentId] = (
                                "cdb_status_txt",
                                "joined_status_name",
                                self._get_status_name(
                                    obj.z_status, obj.z_art),
                                "status",
                                obj.status)
                        except AttributeError:
                            pass
                else:
                    misc.cdblogv(misc.kLogErr, 0,
                                 "WsObjectCache.getObjectRightsByID: unknown object id '%s'." % nonDocumentId)
        return rights, status

    def getLockInfoOfNonDerivedFiles(self, ids, wspLockId):
        """
        Specialized method for fast server rights requests.
        @param ids list(cdb_object_id of business objects)
        :returns: nested dict (bo cdb_object_id -> file cdb_object_id -> status/locker -> string)
        """
        sql = """
        SELECT cdb_file.cdb_lock,
               cdb_file.cdb_lock_id,
               cdb_file.cdbf_object_id,
               cdb_file.cdb_object_id,
               angestellter.name AS mapped_cdb_lock_name
        FROM
               cdb_file
        LEFT JOIN
               angestellter
        ON
               cdb_file.cdb_lock = angestellter.personalnummer
        WHERE
               cdb_file.cdb_classname = 'cdb_file'
               AND (cdb_file.cdb_belongsto='' OR cdb_file.cdb_belongsto IS NULL)
        """
        records = partionedSqlQuery(sql, "cdb_file.cdbf_object_id", ids)
        res = defaultdict(dict)
        for r in records:
            status = u"not"
            lockerName = u""
            locker = r.cdb_lock
            if locker:
                lockerName = r.mapped_cdb_lock_name
                if lockerName is None:
                    misc.cdblogv(misc.kLogMsg, 0,
                                 "WsObjectCache, warning: file '%s' of document '%s' is locked"
                                 " by unknown user '%s' (no matching name in 'angestellter')"
                                 % (r.cdb_object_id, r.cdbf_object_id, locker))
                    lockerName = u""
                if locker == auth.persno:
                    status = u"self"
                    lockId = r.cdb_lock_id
                    if lockId and wspLockId:
                        if lockId != wspLockId:
                            status = u"other_ws"
                else:
                    status = u"other"
            res[r.cdbf_object_id][r.cdb_object_id] = {'status': status, 'locker': lockerName}
        return res

    def mapToWsmFileRights(self, cdbRights):
        """
        :param cdbRights: dict of CDB object rights -> bool
        :return: dict of WSM file rights -> bool
        """
        wsmRights = {}
        for wsmRightName, cdbRightName in self._fileRightsMapping.iteritems():
            wsmRights[wsmRightName] = cdbRights[cdbRightName]
        return wsmRights

    def mapToWsmObjectRights(self, cdbRights):
        """
        :param cdbRights: dict of CDB object rights -> bool
        :return: dict of WSM object rights -> bool
        """
        wsmRights = {}
        for wsmRightName, cdbRightName in self._objectRightsMapping.iteritems():
            wsmRights[wsmRightName] = cdbRights[cdbRightName]
        return wsmRights

    def _ensureCached(self, id):
        """
        If the object with the given cdb_object_id is not cached, load it
        into cache and log a warning.

        :param id: cdb_object_id
        """
        if id not in self._objects:
            self._fetchObjectsByID([id])
            misc.cdblogv(misc.kLogMsg, 0,
                         "WsObjectCache: object with id '%s' unexpectedly not cached." % id)

    def _fetchObjectsByID(self, ids, alsoFetchLinkedObjects=False):
        if self._extendedCaching and alsoFetchLinkedObjects:
            ids = self._extendWithLinkedDocuments(set(ids))
            ids = list(ids)
        # retrieving documents in one go
        docs = getDocumentsById(ids)
        # refresh all document object handles in the internal cache (CDB)
        # (otherwise we may get outdated values for joined attributes)
        getObjectHandlesFromObjectIDs(ids, True)

        self._objects.update(docs)
        result = docs.copy()
        docIds = docs.keys()
        nonDocIds = set(ids) - set(docIds)
        # retrieve non-documents (frames etc.)
        for id in nonDocIds:
            obj = ByID(id)
            if obj is not None:
                self._objects[obj.cdb_object_id] = obj
                result[obj.cdb_object_id] = obj

        # prefetch cdb_file objects
        if not self._fileCaching:
            # always follow links. even if ignore_links is yes,
            # the wsm needs them, e.g. for checkout
            self._retrieveWorkspaceItemsOf(ids, ('cdb_link_item', ))
        else:
            self._retrieveWorkspaceItemsOf(ids)

        # prefetch rights of documents in one go
        if not self._doRightsCheck:
            pass  # pass the rights checks
        elif self._simplifiedRightsCheck:
            self._retrieveRightsOf(docIds)

        if self._extendedCaching:
            self._retrieveItemsOf(docs.values())
            self._retrieveIndexesOf(docs.values())
        return result

    def _extendWithLinkedDocuments(self, ids, visited=None):
        if visited is None:
            visited = ids
        linkedIds = getLinkedIds(ids)
        newIds = linkedIds - visited
        result = ids | newIds
        if newIds:
            result |= self._extendWithLinkedDocuments(newIds, visited | newIds)
        return result

    def _rightsOfObject(self, obj):
        rs = {}
        for cdbRight in self._rightsToRetrieve:
            val = obj.CheckAccess(cdbRight)
            rs[cdbRight] = val
        return rs

    def _cdbRightsOfBusinessObject(self, obj):
        self._ensureCached(obj.cdb_object_id)
        if obj.cdb_object_id in self._objectRights:
            cdbRights = self._objectRights.get(obj.cdb_object_id)
        else:
            cdbRights = self._rightsOfObject(obj)
        return cdbRights

    def _retrieveWorkspaceItemsOf(self, objIds, classNames=None):
        fileDict = getWorkspaceItems(objIds, classNames)
        self._files.update(fileDict)
        if self._extendedCaching:
            if self._fileCaching:
                self._retrieveFileAttributesOf(objIds)
            self._retrieveLinkStatusOf(objIds)

    def _retrieveItemsOf(self, docs):
        """
        :param docs: list of Document
        """
        self._items.extend(getItems(docs))

    def _retrieveIndexesOf(self, docs):
        z_nummers = [d.z_nummer for d in docs]
        if z_nummers:
            missingObjectCacheIds = []
            indexes = getIndexes(z_nummers)
            for record in indexes:
                # retrieve i18ned status name efficiently
                record.joined_status_name = self._get_status_name(record.z_status, record.z_art)
                self._indexes[record.z_nummer].append(record)

                # check if already added to objects cache
                indexObjectId = record.cdb_object_id
                if indexObjectId not in self._objects:
                    missingObjectCacheIds.append(indexObjectId)

            # add index versions to default objects cache too (objects of type
            # Document) without retrieving indices again (extended caching disabled)
            if missingObjectCacheIds:
                oldValue = self._extendedCaching
                self._extendedCaching = False
                try:
                    self._fetchObjectsByID(missingObjectCacheIds, alsoFetchLinkedObjects=False)
                finally:
                    self._extendedCaching = oldValue

    def _get_status_name(self, status, kind):
        key = (status, kind)
        res = self._status_name_cache.get(key, "")
        if not res:
            sd = StateDefinition.ByKeys(status, kind)
            if sd:
                res = sd.StateText[self.lang]
                self._status_name_cache[key] = res
        return res

    def _retrieveFileAttributesOf(self, objIds):
        records = getRecordsByAttributeIn("cdb_file_wsm", "cdbf_object_id", objIds)
        for r in records:
            key = r.cdbf_object_id, r.file_wspitem_id
            ignoredKeys = ["cdb_object_id", "cdbf_object_id", "file_wspitem_id"]
            attrs = {}
            for attrKey in r.keys():
                if attrKey not in ignoredKeys:
                    attrs[attrKey] = r.get(attrKey)
            self._fileAttributes[key] = attrs

    def _retrieveLinkStatusOf(self, objIds):
        records = getRecordsByAttributeIn("cdb_file_links_status", "cdbf_object_id", objIds)
        for r in records:
            key = r.cdbf_object_id, r.file_wspitem_id
            linkStatusDict = self._linkStatus[key]
            linkStatusDict[r.link_id] = r.relevant

    def _retrieveRightsOf(self, ids):
        """
        Retrieves access rights for the given documents and remembers them in
        self._object_rights.

        :param ids: list of cdb_object_ids of documents
        """
        if ids:
            self._objectRights.update(self._getRightsOfDocuments(ids))

    def _getRightsOfDocuments(self, ids, status=None):
        """
        :param ids: list of cdb_object_ids of documents
        :param status: optional dict that will receive the values of the status
                       text and status attributes for every document
                    (this is part of this method purely for performance reasons,
                     i.e. to limit the number of SQL statements)
        :return nested dict(cdb_object_id -> access right -> bool)
        """
        res = {}
        accessToIds = {}
        for right in self._rightsToRetrieve:
            records = getRecordsByAttributeIn("zeichnung",
                                              "cdb_object_id",
                                              ids,
                                              access=right)
            accessToIds[right] = set(r.cdb_object_id for r in records)
            if status is not None:
                for r in records:
                    status[r.cdb_object_id] = (
                        "joined_status_name",
                        self._get_status_name(r.z_status, r.z_art),
                        "z_status",
                        r.z_status)
        for id in ids:
            rs = {}
            for access in accessToIds:
                val = id in accessToIds[access]
                rs[access] = val
            res[id] = rs
        return res

    def _calculateFileRightMapping(self):
        """
        Find out how to map WSM file rights to CDB object rights, using
        the Beziehungsrechteprofil of document.
        """
        res = {'save': 'save',
               'get': 'read_file',
               'delete': 'delete',
               'index': 'index'}
        if self._doRightsCheck:
            if self._simplifiedRightsCheck:
                profile = "Files"
                rs = sqlapi.RecordSet2("cdb_relships", "reference='cdb_file' AND referer='document'")
                if rs:
                    profile = rs[0].rs_acc_prof
                res['delete'] = 'save'

                # "WSM file right name" -> "CDB file right name"
                wsmFileRightToCdbFileRight = {'save': 'save',
                                              'get': 'read_file',
                                              'delete': 'delete_file'}
                for wsmFileRight in wsmFileRightToCdbFileRight:
                    cdbFileRight = wsmFileRightToCdbFileRight[wsmFileRight]
                    mapping = RelshipAccessProfileMapping.ByKeys(rs_acc_prof=profile,
                                                                 reference_allow=cdbFileRight)
                    if mapping is not None:
                        cdbObjectRight = mapping.referer_allow
                        res[wsmFileRight] = cdbObjectRight
                    else:
                        misc.cdblogv(misc.kLogMsg, 5,
                                     "WsObjectCache: no relationship access mapping found for file right '%s'" % cdbFileRight)
        return res


# maximum number of values to put into a "WHERE X IN" query
MAX_IN_ELEMENTS = 900


def queryByAttributeIn(table, attribute, values, access=None, addtl=""):
    """
    Retrieve a list of records (contained in a list of RecordSet2s) with a

     "WHERE attribute IN (value1, ..., valueN)"

    query. Automatically splits the query if more than MAX_IN_ELEMENTS values
    are given.

    :param table unicode
      name of database table
    :param attribute: unicode
      name of attribute to check for (should probably be indexed in the db!)
    :param values: list(unicode)
      list of values to check for
    :param access: optional access right to limit the result
    :param addtl: forwarded to RecordSet2
    :return: list of RecordsSet2
    """
    if len(values) > MAX_IN_ELEMENTS:
        values1 = values[:MAX_IN_ELEMENTS]
        values2 = values[MAX_IN_ELEMENTS:]
        records1 = queryByAttributeIn(table, attribute, values1, access, addtl)
        records2 = queryByAttributeIn(table, attribute, values2, access, addtl)
        records1.extend(records2)
        return records1

    valueString = u",".join(u"'" + sqlapi.quote(val) + u"'" for val in values)
    condition = u"%s IN (%s)" % (attribute, valueString)
    records = sqlapi.RecordSet2(table, condition,
                                access=access, access_persno=auth.persno,
                                addtl=addtl)
    return [records]


def getRecordsByAttributeIn(table, attribute, values, access=None, addtl=""):
    """
    Like queryByAttributeIn but returns a list of records instead.
    """
    recordSets = queryByAttributeIn(table, attribute, values, access, addtl)
    records = []
    for recordSet in recordSets:
        records.extend(list(recordSet))
    return records


def getObjectsByAttributeIn(table, attribute, values, objectClass, addtl=""):
    """
    Like getRecordsByAttributeIn but returns a Object Framework objects instead of records.
    :param objectClass: a object frameworks class
    :return: list instances of objectClass
    """
    recordSets = queryByAttributeIn(table, attribute, values, addtl=addtl)
    objects = []
    for recordSet in recordSets:
        objects.extend(list(objectClass.FromRecords(recordSet)))
    return objects


def getDocumentsById(ids):
    """
    Retrieves Documents from the database and returns them as a dict
    (cdb_object_id -> Document).

    :param ids: list of cdb_object_id
    :return: dict
    """
    documents = getObjectsByAttributeIn(
        u"zeichnung", u"cdb_object_id", ids, Document)
    docDict = dict((d.cdb_object_id, d) for d in documents)
    return docDict


def filterNonDocuments(ids):
    """
    :param ids: list of cdb_object_id
    :return: list of cdb_object_id that belong to a Document
    """
    res = []
    recordSets = getRecordsByAttributeIn(u"zeichnung", u"cdb_object_id", ids)
    for r in recordSets:
        res.append(r.cdb_object_id)
    return res


def getWorkspaceItems(ids, classNames=None):
    """
    :param ids list of cdb_object_id of business objects
    :param classNames optional sequence of class names; otherwise, all entries are returned
    :return: dict(business object id -> list(cdb_file_base))
    """
    addtl = u""
    if classNames:
        addtl = u" AND cdb_classname IN (%s)"\
                % u",".join(u"'" + sqlapi.quote(className) + u"'"
                            for className in classNames)
    files = getObjectsByAttributeIn(
        u"cdb_file", u"cdbf_object_id", ids, cdb_file_base, addtl)
    fileDict = defaultdict(list)
    for file in files:
        fileDict[file.cdbf_object_id].append(file)
    return fileDict


MAX_PAIRS = 400


def queryByAttributePair(table, attribute1, attribute2, values):
    """
    Retrieve a list of records (contained in a list of RecordSet2s) with a

     "WHERE attribute1 = value1a AND attribute1b = value1b
        OR  attribute1 = value2a AND attribute2b = value1b
        ...

    query. Automatically splits the query if more than MAX_PAIRS values
    are given.

    :param table unicode
      name of database table
    :param attribute1: unicode
    :param attribute2: unicode
    :param values: list((unicode, unicode))
      list of values to check for
    :return: list of RecordsSet2
    """
    if len(values) > MAX_PAIRS:
        values1 = values[:MAX_PAIRS]
        values2 = values[MAX_PAIRS:]
        records1 = queryByAttributePair(table, attribute1, attribute2, values1)
        records2 = queryByAttributePair(table, attribute1, attribute2, values2)
        records1.extend(records2)
        return records1

    condition = u"1=0"
    for val1, val2 in values:
        condition += " OR %s = '%s' AND %s = '%s'" % (attribute1, sqlapi.quote(val1), attribute2, sqlapi.quote(val2))
    records = sqlapi.RecordSet2(table, condition, access_persno=auth.persno)
    return [records]


def getRecordsByAttributePair(table, attribute1, attribute2, values):
    """
    Like queryByAttributePair but returns a list of records instead.
    """
    recordSets = queryByAttributePair(table, attribute1, attribute2, values)
    records = []
    for recordSet in recordSets:
        records.extend(list(recordSet))
    return records


def getObjectsByAttributePair(table, attribute1, attribute2, values, objectClass):
    """
    :param objectClass: a object frameworks class
    :return: list instances of objectClass
    """
    recordSets = queryByAttributePair(table, attribute1, attribute2, values)
    objects = []
    for recordSet in recordSets:
        objects.extend(list(objectClass.FromRecords(recordSet)))
    return objects


def getItems(docs):
    """
    Efficiently retrieves all items of the given documents.

    :param docs: list of Document
    :return: list of Item
    """
    keys = []
    for d in docs:
        if d.teilenummer:
            t_index = d.t_index or ""
            keys.append((d.teilenummer, t_index))
    items = []
    if keys:
        items = getObjectsByAttributePair(u"teile_stamm", u"teilenummer", u"t_index", keys, Item)
    return items


def getIndexes(z_nummers):
    """
    Get all indexes of the given documents.
    Sorted first by document, then by "ixsm" property.

    :param z_nummers: non-empty list of z_nummer strings
    :return: list of Record
    """
    sortCriteria = util.get_prop("ixsm")
    if not sortCriteria:
        sortCriteria = "z_index"
    sortCriteria = "ORDER BY z_nummer, %s" % sortCriteria
    return getRecordsByAttributeIn("zeichnung", "z_nummer", z_nummers, addtl=sortCriteria)


def getLinkedIds(ids):
    """
    :param ids: set of cdb_objects_ids of documents
    :return: set of cdb_objects_ids of documents directly linked
    """
    onlyLinks = " AND cdb_classname = 'cdb_link_item'"
    linkItems = getRecordsByAttributeIn("cdb_file", "cdbf_object_id", list(ids), addtl=onlyLinks)
    linkedIds = {l.cdb_link for l in linkItems if l.cdb_link}
    return linkedIds


def partionedSqlQuery(sql, attribute, values):
    """
    :param sql: a SELECT query that ends with the WHERE clause (that we attach to)
    :param attribute: name of attribute to compare to values
    :param values: list of values
    :return: list of records
    """
    if len(values) > MAX_IN_ELEMENTS:
        values1 = values[:MAX_IN_ELEMENTS]
        values2 = values[MAX_IN_ELEMENTS:]
        records1 = partionedSqlQuery(sql, attribute, values1)
        records2 = partionedSqlQuery(sql, attribute, values2)
        records1.extend(records2)
        return records1

    valueString = u",".join("'" + sqlapi.quote(val) + "'" for val in values)
    condition = u"%s IN (%s)" % (attribute, valueString)
    sql += " AND %s" % condition
    recordSet = sqlapi.RecordSet2(sql=sql)
    records = list(recordSet)
    return records
