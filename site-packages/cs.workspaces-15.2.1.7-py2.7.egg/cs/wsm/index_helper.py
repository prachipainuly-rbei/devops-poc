#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2010 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

"""
Module index_helper

This is the documentation for the index_helper module.


"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: index_helper.py 163399 2017-08-16 13:34:46Z wme $"

from cdb.objects import Object, Rule
from cs.documents import Document
from cs.vp.items import Item
from cdb import sqlapi
from cdb import util
from cdb import misc

from collections import namedtuple


IndexInfo = namedtuple('IndexInfo',
                       ['object_id',
                        'number_key',
                        'sort_value',
                        'index',
                        'is_default',
                        'status',
                        'status_text'])


def _getNumberKey(classId, number):
    return "%s_%s" % (classId, number)


def getIndexes(doc, indexUpdateRuleId="", indexFilterRuleId="", wsObjectCache=None):
    """
    Creates a list of available indexes for the given object.

    Considers the "ixsm"/"ixsp" properties.

    Removes indexes that do not match the optional index filter rule.

    If the optional index update rule is given and an index matches this rule,
    the index is marked as default.

    doc: Document|Item|Frame...

    indexUpdateRuleId: string
        cdb_object_id of the currently selected index_update_rule
        or empty string

    indexFilterRuleId: string
        cdb_object_id of the currently selected filter index rule
        or empty string

    wsObjectCache: WsObjectCache
        optional cache to avoid database access
    """
    relation = None
    bos = None
    if isinstance(doc, Document):
        objectClass = Document
        classId = "Document"
        sortCriteria = util.get_prop("ixsm")
        if not sortCriteria:
            sortCriteria = "z_index"
        relation = "zeichnung"
        numberAttribute = "z_nummer"
        indexAttribute = "z_index"
        statusAttribute = "z_status"
        statusTextAttribute = "z_status_txt"
        number = doc.z_nummer
        externalNumber = _getNumberKey(classId, number)
        if wsObjectCache:
            bos = wsObjectCache.indexesOfDocument(doc)
            # NOTE: "joined_status_name" is added by WsObjectCache
            statusTextAttribute = "joined_status_name"
    elif type(doc) == Item:
        # UNTESTED
        objectClass = Item
        classId = "Item"
        sortCriteria = util.get_prop("ixsp")
        if not sortCriteria:
            sortCriteria = "t_index"
        relation = "teile_stamm"
        numberAttribute = "teilenummer"
        indexAttribute = "t_index"
        statusAttribute = "status"
        statusTextAttribute = "cdb_status_txt"
        number = doc.teilenummer
        externalNumber = _getNumberKey(classId, number)
    else:
        indexInformation = [IndexInfo(doc.cdb_object_id,
                                      doc.cdb_object_id,
                                      0,
                                      "",
                                      False,
                                      "0",
                                      "unknown")]
        myIndex = 0
        externalNumber = doc.cdb_object_id
    if relation is not None:
        if bos is None:
            bos = sqlapi.RecordSet2(relation,
                                    condition="%s='%s'" % (
                                        numberAttribute,
                                        sqlapi.quote(number)
                                    ),
                                    addtl="order by %s" % sortCriteria
                                    )
        bos = filter_indexes(bos, indexFilterRuleId, objectClass, doc)
        default_index = get_default_index(bos, indexUpdateRuleId, objectClass)
        myIndex = 0
        indexInformation = []
        for i in range(len(bos)):
            bo = bos[i]
            if bo.cdb_object_id == doc.cdb_object_id:
                myIndex = i
            numberKey = _getNumberKey(classId, bos[i][numberAttribute])
            isDefault = default_index is not None and i == default_index
            indexInfo = IndexInfo(bo.cdb_object_id, numberKey, i, bo[indexAttribute],
                                  isDefault, bo[statusAttribute], bo[statusTextAttribute])
            indexInformation.append(indexInfo)

    return indexInformation, externalNumber, myIndex


def filter_indexes(records, indexFilterRuleId, objectClass, doc):
    """
    Filter the records using the given IndexUpdateRule.
    (We need to know the OF class in order to use object rules.)

    @param records RecordSet2
    @param indexFilterRuleId string cdb_object_id of a IndexUpdateRule or ""
    @param objectClass a class derived from Object
    @param doc the base object
    @return list of records or RecordSet2
    """
    if not indexFilterRuleId:
        return records

    filterRule = IndexUpdateRule.getIndexRuleByName(indexFilterRuleId)
    if not filterRule:
        filterRule = IndexUpdateRule.getIndexRuleById(indexFilterRuleId)
    if not filterRule:
        misc.cdblogv(misc.kLogErr, 0,
                     "Could not find index filter rule with cdb_object_id '%s'. Indexes are not filtered."
                     % indexFilterRuleId)
        result = records
    else:
        result = []
        for r in records:
            obj = objectClass._FromRecord(r)
            if obj.cdb_object_id == doc.cdb_object_id or filterRule.match(obj):
                result.append(r)
        if misc.cdblog_on(misc.kLogMsg, 8):
            numOriginal = len(records)
            numRemaining = len(result)
            ruleName = filterRule.get_name()
            misc.cdblogv(misc.kLogMsg, 8,
                         "Removed %d of %d indexes, using index filter rule '%s'"
                         % (numOriginal - numRemaining, numOriginal, ruleName))
    return result


def get_default_index(records, indexUpdateRuleId, objectClass):
    """parameters:
        records: RecordSet2, in ascending order

       returns: index of the default index according to the given index update rule or None
    """
    rulesTested = set()
    while indexUpdateRuleId:
        indexUpdateRule = IndexUpdateRule.getIndexRuleByName(indexUpdateRuleId)
        if not indexUpdateRule:
            indexUpdateRule = IndexUpdateRule.getIndexRuleById(indexUpdateRuleId)
        if not indexUpdateRule or indexUpdateRule.name in rulesTested:
            break
        rulesTested.add(indexUpdateRule.name)
        # find the newest index that matches
        for record, index in zip(reversed(records), range(len(records) - 1, -1, -1)):
            obj = objectClass._FromRecord(record)
            if indexUpdateRule.match(obj):
                return index
        # otherwise try fallback rule
        indexUpdateRuleId = indexUpdateRule.fallback_rule

    return None


class IndexUpdateRule(Object):
    """
    Specialized object rules for selecting and filtering indexes.
    They have a user-visible name and may have a fallback rule.
    """
    __maps_to__ = "index_update_rule"
    __classname__ = "index_update_rule"

    _indexRuleByNameCache = {}
    _indexRuleByIdCache = {}

    @staticmethod
    def getIndexRuleByName(indexRuleName):
        """
        Return the index rule associated with indexRuleName, None if not existing.

        :Parameters:
            indexRuleName : string
                name of the index rule
        """
        cached = IndexUpdateRule._indexRuleByNameCache.get(indexRuleName, "CACHEMISS")
        if cached != "CACHEMISS":
            return cached

        rule = None
        rules = IndexUpdateRule.KeywordQuery(name=indexRuleName)
        if len(rules):
            rule = rules[0]
        IndexUpdateRule._indexRuleByNameCache[indexRuleName] = rule
        return rule

    @staticmethod
    def getIndexRuleById(indexRuleId):
        cached = IndexUpdateRule._indexRuleByIdCache.get(indexRuleId, "CACHEMISS")
        if cached != "CACHEMISS":
            return cached

        rule = IndexUpdateRule.ByKeys(indexRuleId)
        IndexUpdateRule._indexRuleByIdCache[indexRuleId] = rule
        return rule

    def get_name(self):
        # self.name is the internal name (ID)
        # self.designation is the user-visible name (multi-language)
        return self.designation

    def match(self, obj):
        # cache the object rule
        if (not hasattr(self, '_object_rule') or
                    self._object_rule is None or
                    self._object_rule.name != self.object_rule):
            self._object_rule = Rule.ByKeys(self.object_rule)
        if self._object_rule is None:
            misc.cdblogv(misc.kLogErr, 0,
                         "Index update rule without object rule: '%s', %s"
                         % (self.name, self.object_rule))
            return False
        return self._object_rule.match(obj)


if "__main__" == __name__:
    import sys
    if "--test" == sys.argv[-1]:
        import doctest
        doctest.testmod()
