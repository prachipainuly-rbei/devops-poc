#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
import os
import tempfile

from lxml import etree as ElementTree

from cdb import CADDOK
from cdb.objects.cdb_file import CDB_File, cdb_link_item
from cdb.validationkit import run_with_added_roles, operation, given, when, then, \
    log, getStateNumber
from cs.documents import Document
from cs.workspaces import Workspace
from cs.vp.items import Item

from common import \
    generateItem, generateCADDocument, \
    generateWorkspace, getStateName, getWorkspaceAttributesToChange


# CDB roles are not that readable in gherkin context.
# Use readable names in Gherkin and map them to CDB ones here
roleMap = {
    "engineer": ["Documentation", "Engineering"]
}


# -------------------------------------------------------------
# Scenario: Create New Workspace
#
# -------------------------------------------------------------
@when(u'^(?P<role>.*?) creates a new workspace$')
def step(context, role):
    @run_with_added_roles(roleMap[role])
    def create(content):
        context.wspLen = len(Workspace.Query())
        try:
            generateWorkspace(context)
        except Exception, e:
            log("Error creating the workspace, details: %s" % str(e))
    return create(context)


@then(u'^a new workspace is created$')
def step(context):
    assert len(Workspace.Query()) - context.wspLen == 1, \
        "No Workspace created"


# -------------------------------------------------------------
# Scenario: Change Workspace
#
# -------------------------------------------------------------
@given(u'^a workspace exists$')
@given(u'^a Draft workspace exists$')
@run_with_added_roles(roleMap['engineer'])
def step(context):
    generateWorkspace(context)


@when(u'^(?P<role>.*?) changes this workspace$')
def step(context, role):
    @run_with_added_roles(roleMap[role])
    def change(context):
        try:
            operation("CDB_Modify", context.workspace,
                      user_input=getWorkspaceAttributesToChange())
        except Exception, e:
            log("Error modifying the workspace, details: %s" % str(e))
    return change(context)


@then(u'^the changed workspace is saved$')
def step(context):
    res = Workspace.ByKeys(context.workspace.z_nummer, context.workspace.z_index)
    s_attrs = set(getWorkspaceAttributesToChange().items())
    assert s_attrs.issubset(set(res.items())), "The attributes were not changed"


# -------------------------------------------------------------
# Scenario: Copy Workspace
#
# -------------------------------------------------------------
@when(u'^(?P<role>.*?) copies this workspace$')
def step(context, role):
    @run_with_added_roles(roleMap[role])
    def copy(context):
        context.wspLen = len(Workspace.Query())
        try:
            context.workspaceCopy = operation("CDB_Copy", context.workspace)
        except Exception, e:
            log("Error copying the workspace, details: %s" % str(e))
    return copy(context)


@then(u'^the workspace is copied$')
def step(context):
    assert len(Workspace.Query()) - context.wspLen == 1, \
        "Workspace not copied"

    # Check the number of links in copied workspace and compare to original workspace
    wsp = Workspace.ByKeys(context.workspace.z_nummer, context.workspace.z_index)
    wspCopy = Workspace.ByKeys(context.workspaceCopy.z_nummer, context.workspaceCopy.z_index)
    assert len(wsp.WorkspaceItems) == len(wspCopy.WorkspaceItems)

    # Check if documents are linked to the copied workspace
    wspLinks = wsp.WorkspaceItems
    wspCopiedLinks = wspCopy.WorkspaceItems
    assert wspLinks[0].LinkedObject.z_nummer == wspCopiedLinks[0].LinkedObject.z_nummer
    assert wspLinks[1].LinkedObject.z_nummer == wspCopiedLinks[1].LinkedObject.z_nummer


# -------------------------------------------------------------
# Scenario: Delete Workspace
#
# -------------------------------------------------------------
@when(u'^(?P<role>.*?) deletes this workspace$')
def step(context, role):
    @run_with_added_roles(roleMap[role])
    def delete(context):
        try:
            operation("CDB_Delete", context.workspace)
        except Exception, e:
            log("Error deleting the workspace, details: %s" % str(e))
    return delete(context)


@then(u'^the workspace is deleted$')
def step(context):
    res = Workspace.ByKeys(context.workspace.z_nummer, context.workspace.z_index)
    assert res is None, "Workspace not deleted"

    # Check if workspace links to documents were deleted
    assert not cdb_link_item.ByKeys(context.doc1Link.link.cdb_object_id), \
        "Link to Doc1 not deleted"
    assert not cdb_link_item.ByKeys(context.doc2Link.link.cdb_object_id), \
        "Link to Doc2 not deleted"

    # Check if documents still exists
    res = Document.ByKeys(context.doc1.z_nummer, context.doc1.z_index)
    assert res is not None
    res = Document.ByKeys(context.doc2.z_nummer, context.doc2.z_index)
    assert res is not None


# -------------------------------------------------------------
# Scenario: Generate An Index Of A Workspace
#
# -------------------------------------------------------------
@then(u'^an index of the original workspace is not created$')
def step(context):
    assert len(Workspace.Query()) - context.wspLen == 0, \
        "An index of this workspace created"


# -------------------------------------------------------------
# Scenario: Generate An Index Of A Released Workspace
#
# -------------------------------------------------------------
@given(u'^a Released workspace exists$')
@run_with_added_roles(roleMap['engineer'])
def step(context):
    context.workspace = generateWorkspace(context)
    stateApproved = getStateName(context.workspace.z_art, "Released")
    operation("CDB_Workflow", context.workspace,
              user_input={"zielstatus": stateApproved})


@given(u'^(?P<role>.*?) generates an index of this workspace$')
@when(u'^(?P<role>.*?) generates an index of this workspace$')
def step(context, role):
    @run_with_added_roles(roleMap[role])
    def index(context):
        context.wspLen = len(Workspace.Query())
        try:
            context.newindex = operation("CDB_Index", context.workspace)
        except Exception, e:
            log("Error versioning the workspace, details: %s" % str(e))
    return index(context)


@then(u'^an index of the original workspace is created$')
def step(context):
    assert len(Workspace.Query()) - context.wspLen == 1, \
        "No index of this workspace created"
    assert context.workspace.z_nummer == context.newindex.z_nummer, \
        "The new index has not the same number"
    assert context.newindex.z_index == "a", \
        "The new index has no index number"

    # Check the number of links of original and indexed workspace
    wsp = Workspace.ByKeys(context.workspace.z_nummer, context.workspace.z_index)
    wspCopy = Workspace.ByKeys(context.newindex.z_nummer, context.newindex.z_index)
    assert len(wsp.WorkspaceItems) == len(wspCopy.WorkspaceItems)


# -------------------------------------------------------------
# Scenario: Generate An Index Of A Disabled Workspace
#
# -------------------------------------------------------------
@given(u'^a Blocked workspace exists$')
@run_with_added_roles(roleMap['engineer'])
def step(context):
    context.workspace = generateWorkspace(context)
    stateApproved = getStateName(context.workspace.z_art, "Released")
    stateDisabled = getStateName(context.workspace.z_art, "Blocked")
    operation("CDB_Workflow", context.workspace,
              user_input={"zielstatus": stateApproved})
    operation("CDB_Workflow", context.workspace,
              user_input={"zielstatus": stateDisabled})


# -------------------------------------------------------------
# Scenario: Generate An Index Of A In Revision Workspace
#
# -------------------------------------------------------------
@given(u'^a Revision workspace exists$')
@run_with_added_roles(roleMap['engineer'])
def step(context):
    context.workspace = generateWorkspace(context)
    stateApproved = getStateName(context.workspace.z_art, "Released")
    stateInRevision = getStateName(context.workspace.z_art, "Revision")
    operation("CDB_Workflow", context.workspace,
              user_input={"zielstatus": stateApproved})
    operation("CDB_Workflow", context.workspace,
              user_input={"zielstatus": stateInRevision})


# -------------------------------------------------------------
# Scenario: Generate An Index Of A Invalid Workspace
#
# -------------------------------------------------------------
@given(u'^a Obsolete workspace exists$')
@run_with_added_roles(roleMap['engineer'])
def step(context):
    context.workspace = generateWorkspace(context)
    stateApproved = getStateName(context.workspace.z_art, "Released")
    stateInRevision = getStateName(context.workspace.z_art, "Revision")
    stateInvalid = getStateName(context.workspace.z_art, "Obsolete")
    operation("CDB_Workflow", context.workspace,
              user_input={"zielstatus": stateApproved})
    operation("CDB_Workflow", context.workspace,
              user_input={"zielstatus": stateInRevision})
    operation("CDB_Workflow", context.workspace,
              user_input={"zielstatus": stateInvalid})


# -------------------------------------------------------------
# Scenario: Change State Of A Workspace (Valid)
#
# -------------------------------------------------------------
@when(u'^(?P<role>.*?) changes the state of this workspace to (?P<state>.*?)$')
def step(context, role, state):
    @run_with_added_roles(roleMap[role])
    def change(context):
        context.to = state
        try:
            operation("CDB_Workflow", context.workspace,
                      user_input={"zielstatus": getStateName(context.workspace.z_art, context.to)})
        except Exception, e:
            log("Error changing the state of the workspace, details %s" % str(e))
    return change(context)


@then(u'^the changed state of the workspace is saved$')
def step(context):
    res = Workspace.ByKeys(context.workspace.z_nummer, context.workspace.z_index)
    assert (res.z_status == getStateNumber("doc_standard", context.to)), \
        "The state of the workspace has not changed"


# -------------------------------------------------------------
# Scenario: Change State Of A Workspace (Invalid)
#
# -------------------------------------------------------------
@then(u'^the changed state of the workspace is not saved$')
def step(context):
    res = Workspace.ByKeys(context.workspace.z_nummer, context.workspace.z_index)
    assert (res.z_status != getStateNumber("doc_standard", context.to)), \
        "The state of the workspace has changed"


# -------------------------------------------------------------
# Scenario: Change A Released Workspace
#
# -------------------------------------------------------------
@then(u'^the changed workspace is not saved$')
def step(context):
    res = Workspace.ByKeys(context.workspace.z_nummer, context.workspace.z_index)
    s_attrs = set(getWorkspaceAttributesToChange().items())
    assert not s_attrs.issubset(set(res.items())), \
        "The attributes were changed"


# -------------------------------------------------------------
# Scenario: Release An Index Of A Workspace
#
# -------------------------------------------------------------
@when(u'^(?P<role>.*?) releases the index of the workspace$')
def step(context, role):
    @run_with_added_roles(roleMap[role])
    def release(context):
        try:
            stateApproved = getStateName(context.newindex.z_art, "Released")
            operation("CDB_Workflow", context.newindex,
                      user_input={"zielstatus": stateApproved})
        except Exception, e:
            log("The index of the workspace was not released, details: %s" % str(e))
    return release(context)


@then(u'^the index of the workspace is released$')
def step(context):
    res = Workspace.ByKeys(context.newindex.z_nummer, context.newindex.z_index)
    assert (res.z_status == getStateNumber("doc_standard", "Released")), \
        "The index of the workspace is not released"


# -------------------------------------------------------------
# Scenario: Lock A Workspace
#
# -------------------------------------------------------------
@when(u'^(?P<role>.*?) locks this workspace$')
def step(context, role):
    @run_with_added_roles(roleMap[role])
    def lock(context):
        try:
            operation("CDB_Lock", context.workspace)
        except:
            log("Error locking workspace, details %s" % str(e))
    return lock(context)


@then(u'^the workspace remains unlocked$')
def step(context):
    assert not context.workspace.cdb_lock


# -------------------------------------------------------------
# Scenario: Open A Workspace
#
# -------------------------------------------------------------
@when(u'^(?P<role>.*?) opens this workspace$')
@run_with_added_roles(roleMap['engineer'])
def step(context, role):
    try:
        context.workspace.open_file()
    except:
        log("Error opening workspace, details %s" % str(e))


@then(u'^the workspace is opened$')
def step(context):
    filename = os.path.join(CADDOK.TMPDIR, "open_ws.cdbwscall")
    xmlFile = None
    try:
        xmlFile = open(filename)
    except Exception, e:
        log("The xml file was not found, details: %s" % str(e))
        assert False
    content = xmlFile.read()
    xmlFile.close()
    try:
        root = ElementTree.fromstring(content)
    except Exception, e:
        log("The xml file is not wellformed, details: %s" % str(e))
        assert False

    # Check the structure of the xml file
    assert root.tag == "cdbwsinfo"
    assert root[0].tag == "command"
    assert root[0].text == "loadworkspacebyid"
    assert root[1].tag == "parameters"
    assert root[1][0].tag == "parameter"
    assert root[1][0].text == context.workspace.cdb_object_id


# -------------------------------------------------------------
# Scenario: Open A CAD Document
#
# -------------------------------------------------------------
@given('^a CAD document exists$')
@run_with_added_roles(roleMap['engineer'])
def step(context):
    context.item = generateItem()
    context.cadDocument = generateCADDocument(context.item)


@given('^the CAD Document has a primary file$')
@run_with_added_roles(roleMap['engineer'])
def step(context):
    # Create temp file in file system
    f = tempfile.NamedTemporaryFile(delete=False)
    f.write(os.urandom(100))
    f.close()
    context.file = f.name

    # Import the file into the CAD document as primary file
    CDB_File.NewFromFile(context.cadDocument.cdb_object_id,
                         context.file,
                         True)


@when(u'^(?P<role>.*?) opens this CAD document$')
def step(context, role):
    try:
        context.cadDocument.open_cad_file()
    except Exception, e:
        log("Error opening the CAD document, details %s" % str(e))


@then(u'^the CAD document is opened$')
def step(context):
    filename = os.path.join(CADDOK.TMPDIR, "command.cdbwscall")
    xmlFile = None
    try:
        xmlFile = open(filename)
    except Exception, e:
        log("The xml file was not found, details: %s" % str(e))
        assert False
    content = xmlFile.read()
    xmlFile.close()
    try:
        root = ElementTree.fromstring(content)
    except Exception, e:
        log("The xml file is not wellformed, details: %s" % str(e))
        assert False

    # Check the structure of the xml file
    assert root.tag == "cdbwsinfo"
    assert root[0].tag == "command"
    assert root[0].text == "loadandopencaddocument"
    assert root[1].tag == "options"
    assert root[1][0].tag == "pdmadapter"
    assert root[1][0].text == "CDB 10.1"
    assert root[1][1].tag == "requiredversion"
    assert root[1][1].text == "3.2.0"
    assert root[2].tag == "parameters"
    assert root[2][0].tag == "parameter"
    assert root[2][0].text == context.cadDocument.cdb_object_id
