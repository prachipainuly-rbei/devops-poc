# -*- mode: python; coding: utf-8 -*-
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# https://www.contact-software.com/
"""
This benchmarks some operations used for the kpi dashboards, raising the measurements
'runtime' and 'number of issues SQL statements'.
"""

import logging
import uuid
import io
import datetime

from pyperf.bench import Bench
from pyperf.timer import Timer
from cdb.testcase import run_level_setup
from cdb.objects.operations import operation
from cdb import transactions, sqlapi
from cs.metrics.qualitycharacteristics import History
from cs.metrics.cockpit.qc_cockpits import gethistorydata


class RollbackContext(object):

    def begin_transaction(self):
        if transactions.Transaction.stack:
            while transactions.Transaction.stack:
                dangling_transaction = transactions.Transaction.stack.pop()
                dangling_transaction._rollback()
            sys.stderr.write(
                "\n*** RollbackContext: dangling transaction contexts "
                "\n*** have been unwound. Probably another RollbackContext "
                "\n*** failed in an unusual way."
                "\n"
            )
        self.transaction = transactions.Transaction()
        self.transaction.__enter__()

    def rollback_transaction(self):
        assert hasattr(self, "transaction"), "begin_transaction was not called"
        self.transaction.__exit__(transactions.Rollback(), None, None)

    def __enter__(self, *_args, **_kwargs):
        self.begin_transaction()

    def __exit__(self, *_args, **_kwargs):
        self.rollback_transaction()


class GetHistoryData(Bench):
    def __init__(self, *args, **kwargs):
        self.kpi = '3c087a4f-8001-11e6-ad2f-082e5f0d0c14'
        self.kpi_type = 'qc_object'
        self.logger = logging.getLogger(__name__ + 'GetHistoryData')
        super(GetHistoryData, self).__init__(*args, **kwargs)

    def setUpClass(self):
        if run_level_setup:
            run_level_setup()
        self.count = self.args.get('count_of_history_points')
        self.generate_history_points()
        self.warmup()

    def generate_history_points(self):
        with transactions.Transaction():
            sqlapi.SQLdelete("FROM cdbqc_history WHERE cdbqc_object_id='%s'" % self.kpi)
            basedate = datetime.datetime(year=1970, month=1, day=1)
            for days in range(0, self.count):
                next_date = basedate + datetime.timedelta(days=days)
                History._Create(
                    cdbqc_object_id=self.kpi,
                    cdb_cdate=next_date,
                    value=days,
                    cdbqc_qgrade_object_id='1283df0f-1469-11e2-8fe5-082e5f0d0c14'
                )

    def warmup(self):
        with RollbackContext():
            try:
                self._doIt()
            except BaseException as e:
                self.logger.error("%s, %s", self.kpi, self.kpi_type)
                self.logger.exception(e)

    def _doIt(self):
        res = gethistorydata(qc_ids=[self.kpi], qc_cockpit_app='qc_object')
        assert self.kpi in res, "no history for requested kpi"
        assert len(res.get(self.kpi).get('gdata')) == self.count, "wrong history count for requested kpi (%d != %d)" % (len(res.get(self.kpi).get('gdata')), self.count)

    def bench_operation(self):
        times = []
        sql_counts = []

        for _ in range(self.args["iterations"]):
            with RollbackContext():
                sql_count_before = sqlapi.SQLget_statistics()['statement_count']
                with Timer() as t:
                    self._doIt()
                sql_count_after = sqlapi.SQLget_statistics()['statement_count']
                times.append(t.elapsed.total_seconds())
                sql_counts.append(sql_count_after - sql_count_before)

        self.storeResult(times, name="bench_runtime", type="time_series")
        self.storeResult(sql_counts, name="bench_sqlstms", type="count", unit="statements")
