#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""
Module common

This is the documentation for the common module.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: common.py 181352 2018-07-31 07:57:24Z khi $"

import logging
import socket
from cdb import constants
from cdb import objects
from cdb.validationkit import operation

from cs.metrics import computationrules
from cs.metrics import qualitycharacteristics
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support import wait
from selenium.webdriver.common.by import By


_uc_dict = None
LOG = logging.getLogger(__name__)


# How long should we wait after an ajax call is finished
# to continue testing. This is currently very high, but
# needed for the buildbot.
AJAX_STABILITY = 120 if 'bbc' in socket.gethostname() else 1

# Maximal timeout of webdriver queries. Very high for buildbot / not so high locally
WEB_DRIVER_TIMEOUT = 120 if 'bbc' in socket.gethostname() else 10


def waitForAjax(driver, stability=AJAX_STABILITY):
    def check_active_ajax(driver):
        res = driver.execute_script("jQuery.active === 0;")
        return res

    if stability == 1:
        wait.WebDriverWait(driver, WEB_DRIVER_TIMEOUT).until(check_active_ajax)
    else:
        waitUntilXTimes(driver, check_active_ajax, stability)


def waitForJSValue(driver, js_command, value, stability=AJAX_STABILITY):
    def check_js_command_result(driver):
        res = driver.execute_script(js_command)
        if res == value:
            LOG.info('"%s"!="%s"', res, value)
            return True
        else:
            LOG.info('"%s"!="%s"', res, value)
            print(res)
            return False

    if stability == 1:
        wait.WebDriverWait(driver, WEB_DRIVER_TIMEOUT).until(check_js_command_result)
    else:
        waitUntilXTimes(driver, check_js_command_result, stability)


def waitForSuccessfulLogin(driver, stability=AJAX_STABILITY):
    def check_successful_login(driver):
        href_last_segment = driver.execute_script("""return window.location.href.split('/').pop()""")
        return href_last_segment != 'login'

    if stability == 1:
        wait.WebDriverWait(driver, WEB_DRIVER_TIMEOUT).until(check_successful_login)
    else:
        waitUntilXTimes(driver, check_successful_login, stability)


def waitForElementVisibility(driver, element):
    wait.WebDriverWait(driver, WEB_DRIVER_TIMEOUT).until(EC.visibility_of(element))


def waitUntilXTimes(driver, method, x=0, fail_message=''):
    import time
    from selenium.common.exceptions import TimeoutException
    assert x >= 0, 'at least one time required'
    end_time = time.time() + WEB_DRIVER_TIMEOUT
    while (True):
        try:
            value = method(driver)
            if value and x == 0:
                return value
            elif value and x > 0:
                x -= 1
        except wait.IGNORED_EXCEPTIONS:
            pass
        time.sleep(wait.POLL_FREQUENCY)
        if (time.time() > end_time):
            break
    raise TimeoutException(fail_message)


def resolve_update_clock(name):
    global _uc_dict
    if _uc_dict is None:
        _uc_dict = dict([(uc.name_de, uc.position)
                         for uc in computationrules.UpdateClock.Query()])

    return _uc_dict.get(name, "")


def getObligatoryForUnitType():
    return {}, {
        "name_de": "QC Test Unit Type",
        "name_en": "QC Test Unit Type",
        "cdb_module_id": "cs.portfolios"
    }


def generateUnitType(preset=None, user_input=None):
    _preset, _user_input = getObligatoryForUnitType()
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     qualitycharacteristics.QCUnitType,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForUnit(unit_type):
    return {
        "cdbqc_utype_object_id": unit_type.cdb_object_id,
    }, {
        "name_de": "QC Test: Unit",
        "name_en": "QC Test: Unit",
        "shortcut_unit": "u",
        "cdb_module_id": "cs.portfolios"
    }


def generateUnit(unit_type, preset=None, user_input=None):
    _preset, _user_input = getObligatoryForUnit(unit_type)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     qualitycharacteristics.QCUnit,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForExpressionComputationRule(expression):
    return {}, {
        "name": "QC Test: computation rule",
        "expression": expression,
    }


def generateExpressionComputationRule(expression, preset=None, user_input=None):
    _preset, _user_input = getObligatoryForExpressionComputationRule(expression)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     computationrules.ExpressionEvaluation,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForCustomComputationRule(fqpyname):
    return {}, {
        "name": "QC Test: computation rule",
        "fqpyname": fqpyname
    }


def generateCustomComputationRule(fqpyname, preset=None, user_input=None):
    _preset, _user_input = getObligatoryForCustomComputationRule(fqpyname)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     computationrules.CustomComputation,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForSQLStatisticsComputationRule(statistics_name, evalued_attribute):
    return {}, {
        "name": "QC Test: computation rule",
        "statistics_name": statistics_name,
        "evalued_attribute": evalued_attribute
    }


def generateSQLStatisticsComputationRule(statistics_name, evalued_attribute,
                                         preset=None, user_input=None):
    _preset, _user_input = getObligatoryForSQLStatisticsComputationRule(statistics_name,
                                                                        evalued_attribute)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     computationrules.SQLStatistics,
                     preset=_preset,
                     user_input=_user_input)


def generateRule(preset=None, user_input=None):
    _user_input = {"name": "QC Test: rule"}
    if user_input:
        _user_input.update(user_input)
    _preset = preset if preset else {}

    return operation(constants.kOperationNew,
                     objects.Rule,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForPredicate(rule, fqpyname):
    return {
        "name": rule.name,
    }, {
        "fqpyname": fqpyname,
        "predicate_name": "QC Test: predicate"
    }


def generatePredicate(rule, fqpyname, preset=None, user_input=None):
    _preset, _user_input = getObligatoryForPredicate(rule, fqpyname)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     objects.Predicate,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForTerm(predicate, attribute, operator, expression):
    return {
        "name": predicate.name,
        "fqpyname": predicate.fqpyname,
        "predicate_name": predicate.predicate_name,
    }, {
        "attribute": attribute,
        "operator": operator,
        "expression": expression
    }


def generateTerm(predicate, attribute, operator, expression,
                 preset=None, user_input=None):
    _preset, _user_input = getObligatoryForTerm(predicate, attribute, operator,
                                                expression)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     objects.Term,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForQCDefinition(unit):
    return {}, {
        "name_de": "QC Test: qc definition",
        "name_en": "QC Test: qc definition",
        "cdb_objektart": "cdbqc_definition",
        "unit_object_id": unit.cdb_object_id,
        "unit_type": unit.cdbqc_utype_object_id,
        "computed": 1,
        "priority": 0,
        "status": 0,
        "asyncron": 0,
        "subject_type": "Common Role",
        "subject_id": "public",
        "cdb_module_id": "cs.portfolios"
    }


def generateObjectQCDefinition(unit, preset=None, user_input=None):
    _preset, _user_input = getObligatoryForQCDefinition(unit)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     qualitycharacteristics.ObjectQCDefinition,
                     preset=_preset,
                     user_input=_user_input)


def generateClassQCDefinition(unit, preset=None, user_input=None):
    _preset, _user_input = getObligatoryForQCDefinition(unit)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     qualitycharacteristics.ClassQCDefinition,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForOKZClassAssociation(qcdefinition, classname):
    return {
        "cdbqc_def_object_id": qcdefinition.cdb_object_id,
    }, {
        "classname": classname,
        "obj_rule_name": "",
    }


def generateOKZClassAssociation(qcdefinition, classname, preset=None, user_input=None):
    _preset, _user_input = getObligatoryForOKZClassAssociation(qcdefinition, classname)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     qualitycharacteristics.OKZClassAssociation,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForKKZClassAssociation(qcdefinition, classname,
                                        computation_rule):
    return {
        "cdbqc_def_object_id": qcdefinition.cdb_object_id,
    }, {
        "classname": classname,
        "obj_rule_name": "",
        "computation_rule_id": computation_rule.cdb_object_id,
        "update_clock": resolve_update_clock(u"täglich"),
    }


def generateKKZClassAssociation(qcdefinition, classname, computation_rule,
                                preset=None, user_input=None):
    _preset, _user_input = getObligatoryForKKZClassAssociation(qcdefinition,
                                                               classname,
                                                               computation_rule)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     qualitycharacteristics.KKZClassAssociation,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForGroupingAttribute(association, attribute):
    return {
        "classname": association.classname,
        "cdbqc_def_object_id": association.cdbqc_def_object_id
    }, {
        "attribute_name": attribute,
        "cdb_module_id": "cs.portfolios"
    }


def generateGroupingAttribute(association, attribute,
                              preset=None, user_input=None):
    _preset, _user_input = getObligatoryForGroupingAttribute(association,
                                                             attribute)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     qualitycharacteristics.GroupingAttribute,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForChildren(association, relationship):
    aggregation_rule = qualitycharacteristics.AggregationRule.ByKeys(name_de="Summe")
    return {
        "classname": association.classname,
        "cdbqc_def_object_id": association.cdbqc_def_object_id
    }, {  # TODO: object rule
        "aggr_rule_id": aggregation_rule.cdb_object_id,
        "relship_name": relationship,
    }


def generateChildrenConfiguration(association, relationship,
                                  preset=None, user_input=None):
    _preset, _user_input = getObligatoryForChildren(association, relationship)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     qualitycharacteristics.ChildConfiguration,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForParent(association, relationship):
    return {
        "classname": association.classname,
        "cdbqc_def_object_id": association.cdbqc_def_object_id
    }, {  # TODO: object rule
        "relship_name": relationship,
    }


def generateParentConfiguration(association, relationship,
                                preset=None, user_input=None):
    _preset, _user_input = getObligatoryForParent(association, relationship)
    if user_input:
        _user_input.update(user_input)
    if preset:
        _preset.update(preset)

    return operation(constants.kOperationNew,
                     qualitycharacteristics.ParentConfiguration,
                     preset=_preset,
                     user_input=_user_input)


def getObligatoryForPortfolio():
    return {
        "name_de": "QC Test: portfolio",
        "name_en": "QC Test: portfolio",
        "status": 0,
        "cdb_objektart": "cdb_portfolio"
    }


def getObligatoryForPortfolioCategory(portfolio, level):
    return {
        "portfolio_object_id": portfolio.cdb_object_id,
        "name_de": "QC Test: category",
        "ebene": level
    }


def getObligatoryForPortfolioFolder(portfolio, category, parent=None):
    result = {
        "portfolio_object_id": portfolio.cdb_object_id,
        "category_object_id": category.cdb_object_id,
        "name_de": "QC Test: folder",
        "name_en": "QC Test: folder",
        "status": 0,
        "cdb_objektart": "cdb_pf_folder",
        "position": 0,
    }

    if parent:
        result["parent_object_id"] = parent.cdb_object_id

    return result


def generatePortfolioStructure():
    from cs import portfolios

    portfolio = portfolios.Portfolio.Create(**getObligatoryForPortfolio())
    category1 = portfolios.PortfolioCategory\
        .Create(**getObligatoryForPortfolioCategory(portfolio, 1))
    category2 = portfolios.PortfolioCategory\
        .Create(**getObligatoryForPortfolioCategory(portfolio, 2))

    folder1 = portfolios.PortfolioFolder\
        .Create(**getObligatoryForPortfolioFolder(portfolio, category1))
    folder2 = portfolios.PortfolioFolder\
        .Create(**getObligatoryForPortfolioFolder(portfolio, category2, folder1))

    return portfolio

# def create_object_rule():
#     """Create object rule to select only the test project"""
#     # Create rule
#     operation(constants.kOperationNew,  # @UndefinedVariable
#               objects.Rule,
#               preset={"name": "QC Test"})
#
#     # Create predicate for Projects
#     preset = {"name": "QC Test",
#               "fqpyname": "cs.pcs.projects.Project",
#               "predicate_name": "QC Test"}
#     operation(constants.kOperationNew,  # @UndefinedVariable
#               objects.Predicate,
#               preset=preset)
#
#     # Create term for Projects
#     preset = {"name": "QC Test",
#               "fqpyname": "cs.pcs.projects.Project",
#               "predicate_name": "QC Test",
#               "attribute": "cdb_project_id",
#               "operator": "LIKE",
#               "expression": "QC00000%"}
#     operation(constants.kOperationNew,  # @UndefinedVariable
#               objects.Term,
#               preset=preset)
#
#     # Create predicate for Tasks
#     preset = {"name": "QC Test",
#               "fqpyname": "cs.pcs.projects.tasks.Task",
#               "predicate_name": "QC Test"}
#     operation(constants.kOperationNew,  # @UndefinedVariable
#               objects.Predicate,
#               preset=preset)
#
#     # Create term for Tasks
#     preset = {"name": "QC Test",
#               "fqpyname": "cs.pcs.projects.tasks.Task",
#               "predicate_name": "QC Test",
#               "attribute": "cdb_project_id",
#               "operator": "LIKE",
#               "expression": "QC00000%"}
#     operation(constants.kOperationNew,  # @UndefinedVariable
#               objects.Term,
#               preset=preset)
