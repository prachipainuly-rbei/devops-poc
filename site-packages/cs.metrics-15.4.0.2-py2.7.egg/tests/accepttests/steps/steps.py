#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""
Module steps

This is the documentation for the steps module.
"""

from cdb import constants
from cdb.objects import ByID
from cdb.objects.core import ClassRegistry
from cdb.validationkit import given
from cdb.validationkit import operation
from cdb.validationkit import run_with_roles
from cdb.validationkit import then
from cdb.validationkit import when

import common
from cs.metrics import qualitycharacteristics
from cs.metrics.cockpit import QCObjectCockpit
from cs.metrics.qualitycharacteristics import QCGrade


__docformat__ = "restructuredtext en"
__revision__ = "$Id: steps.py 181352 2018-07-31 07:57:24Z khi $"

# Some imports


def _get_qcs_for_obj(obj):
    def _ObjectQualityCharacteristics(obj):
        return qualitycharacteristics.ObjectQualityCharacteristic.KeywordQuery(cdbf_object_id=obj.cdb_object_id)

    def _ClassQualityCharacteristics(obj):
        bases = list(obj.GetClassDef().getBaseClassNames())
        bases.append(obj.GetClassname())

        condition = qualitycharacteristics.ClassQualityCharacteristic.classname.one_of(*bases)
        cqcs = qualitycharacteristics.ClassQualityCharacteristic.Query(condition)
        try:
            result = [cqc for cqc in cqcs if
                      all([gr.attribute_value == getattr(obj, gr.attribute_name) for gr in cqc.Groupings])]
        except KeyError:
            # read access to virtual attributes leads to KeyError, but they can be accessed on persistent objects
            pobj = obj.getPersistentObject()
            result = [cqc for cqc in cqcs if
                      all([gr.attribute_value == getattr(pobj, gr.attribute_name) for gr in cqc.Groupings])]
        return result
    return _ObjectQualityCharacteristics(obj) + _ClassQualityCharacteristics(obj)


@given("^a (?P<qctype>class|object|computed object) "
       "quality characteristics definition exists$")
@run_with_roles(["public"])
def a_qc_definition_exists(context, qctype):
    unit_type = common.generateUnitType()
    unit = common.generateUnit(unit_type)

    if qctype == "class":
        context.qcdefinition = common.generateClassQCDefinition(unit)
    elif qctype == "object" or qctype == "computed object":
        user_input = {
            "computed": 1 if qctype == "computed object" else 0
        }
        context.qcdefinition = common.generateObjectQCDefinition(unit,
                                                                 user_input=user_input)


@given("^a class association "
       "(?:with a (?P<rule>sql statistics|custom|expression) computation rule )?"
       "(?P<description>with grouping|with object rule)?"
       "(?P<take_aggr>which takes the aggregate value as actual value)?"
       "(?: )?exists$")
@run_with_roles(["public"])
def a_class_association_exists(context, rule=None, description=None,
                               take_aggr=None):
    from cs.portfolios import PortfolioFolder

    user_input = {}
    orule = None
    if description == "with object rule":
        orule = common.generateRule()
        common.generateTerm(
            common.generatePredicate(orule, "cs.portfolios.PortfolioFolder"),
            "name_de", "LIKE", "QC Test%")
        user_input["obj_rule_name"] = orule.name

    if isinstance(context.qcdefinition,
                  qualitycharacteristics.ClassQCDefinition):
        if rule == "sql statistics":
            crule = common.generateSQLStatisticsComputationRule("COUNT", "*")

            def _ev(qc):
                if qc.Groupings:
                    attrs = {grouping.attribute_name: grouping.attribute_value
                             for grouping in qc.Groupings}
                    c = PortfolioFolder.KeywordQuery(**attrs)
                else:
                    c = PortfolioFolder.Query()

                if orule:
                    c = filter(orule.match, c)
                return len(c)
            context.expected_value = _ev
        else:
            fqpyname = "cs.metrics.qcclasses.test_computation_rule"
            crule = common.generateCustomComputationRule(fqpyname)

            context.expected_value = lambda x: 42

        ca = common.generateKKZClassAssociation(context.qcdefinition,
                                                "cdb_portfolio_folder",
                                                crule)

        if description == "with grouping":
            common.generateGroupingAttribute(ca, "category_object_id")
    elif isinstance(context.qcdefinition,
                    qualitycharacteristics.ObjectQCDefinition):
        if rule == "expression":
            crule = common.generateExpressionComputationRule("position - status")

            def _ev(qc):
                obj = ByID(qc.cdbf_object_id)
                if obj:
                    return obj.position - obj.status
            context.expected_value = _ev

            user_input["computation_rule_id"] = crule.cdb_object_id
            user_input["update_clock"] = common.resolve_update_clock(u"täglich")
        elif rule == "custom":
            fqpyname = "cs.metrics.qcclasses.test_computation_rule"
            crule = common.generateCustomComputationRule(fqpyname)
            context.expected_value = lambda x: 42

            user_input["computation_rule_id"] = crule.cdb_object_id
            user_input["update_clock"] = common.resolve_update_clock(u"täglich")

        if take_aggr is not None:
            user_input["take_aggr_val"] = 1

        ca = common.generateOKZClassAssociation(context.qcdefinition,
                                                "cdb_portfolio_folder",
                                                user_input=user_input)
    context.portfolio = common.generatePortfolioStructure()
    context.class_association = ca


@when("^the status of the quality characteristics definition is changed to valid$")
@given("^the status of the quality characteristics definition is changed to valid$")
@run_with_roles(["public"])
def status_qc_definition_changed_to_valid(context):
    status = qualitycharacteristics.QCDefinition.VALID.status
    context.qcdefinition.ChangeState(status)


@then("^the quality characteristics objects are created$")
def the_qc_objects_are_created(context):
    context.qcdefinition.Reload()
    if isinstance(context.qcdefinition,
                  qualitycharacteristics.ClassQCDefinition):
        assert len(context.qcdefinition.QualityCharacteristics) >= 1,\
            "The quality characteristics objects have not been created"
    elif isinstance(context.qcdefinition,
                    qualitycharacteristics.ObjectQCDefinition):
        qcdef_id = context.qcdefinition.cdb_object_id

        from cs import portfolios
        folders = portfolios.PortfolioFolder\
            .KeywordQuery(portfolio_object_id=context.portfolio.cdb_object_id)

        assert all((folder.ObjectQualityCharacteristics
                        .KeywordQuery(cdbqc_def_object_id=qcdef_id)
                        for folder in folders)),\
            "Some quality characteristics objects have not been created"


@when("^the quality characteristics are computed$")
@run_with_roles(["public"])
def the_quality_characteristics_are_computed(context):
    for qc in context.qcdefinition.QualityCharacteristics:
        operation("cdbqc_compute", qc)


@then("^the quality characteristics are computed correctly$")
def the_quality_characteristics_are_computed_correctly(context):
    for qc in context.qcdefinition.QualityCharacteristics:
        assert qc.act_value == context.expected_value(qc), \
            "Some quality characteristics have not been computed correctly"


@given("^the class association has aggregation$")
@run_with_roles(["public"])
def the_class_association_has_aggregation(context):
    common.generateChildrenConfiguration(context.class_association,
                                         "cdb_portfolio_folder2childern")
    common.generateParentConfiguration(context.class_association,
                                       "cdb_portfolio_folder2parent")


@when("^the value of the quality characteristics of a children is changed$")
@run_with_roles(["public"])
def the_value_of_the_qc_of_a_children_is_changed(context):
    category = context.portfolio.Categories.KeywordQuery(ebene=2)[0]
    folder = category.Folders[0]

    qcdef_id = context.qcdefinition.cdb_object_id
    qc = qualitycharacteristics\
        .ObjectQualityCharacteristic.ByKeys(cdbqc_def_object_id=qcdef_id,
                                            cdbf_object_id=folder.cdb_object_id)
    operation(constants.kOperationModify,
              qc,
              user_input={"act_value": 10})


@then("^the (?P<what>aggregate|actual) value of the quality characteristics of the parent "
      "is changed$")
@run_with_roles(["public"])
def the_value_is_changed(context, what):
    category = context.portfolio.Categories.KeywordQuery(ebene=1)[0]
    folder = category.Folders[0]

    qcdef_id = context.qcdefinition.cdb_object_id
    qc = qualitycharacteristics\
        .ObjectQualityCharacteristic.ByKeys(cdbqc_def_object_id=qcdef_id,
                                            cdbf_object_id=folder.cdb_object_id)

    if what == "aggregate":
        value = qc.aggr_value
    elif what == "actual":
        value = qc.act_value

    assert value == 10, "The %s value is not changed" % what


@given(u'^the (?P<clazz>\w*) object with (?P<identifier_key>\w*)=(?P<identifier_val>\w*) exists$')
def step_impl(context, clazz, identifier_key, identifier_val):
    cls = ClassRegistry().find(clazz)
    context.qc_context_obj = cls.ByKeys(**{identifier_key: identifier_val})
    assert context.qc_context_obj, '{clazz} obj with identifier {identifier_key}={identifier_val} does not exists'.format(clazz=clazz,
                                                                                                                          identifier_key=identifier_key,
                                                                                                                          identifier_val=identifier_val)


@given(u'^it has a quality characteristic for (?P<code>\w*)$')
def step_impl(context, code):  # @DuplicatedSignature
    for qc in _get_qcs_for_obj(context.qc_context_obj):
        qcd = qc.Definition
        if qcd.identifier.strip() == code.strip():
            context.qc_definition = qcd
            context.qc = qc
            return  # success
    assert False, 'it does not have a quality characteristic for code {code}'.format(code=code)


@given(u'^the quality characteristic (?P<code>\w*) is not computed$')
def step_impl(context, code):  # @DuplicatedSignature
    assert not context.qc_definition.computed, "the quality characteristic with code {code} is computed but shouldn't".format(code=code)


@given(u'^no history values exists for the quality characteristic (?P<code>\w*)$')
def step_impl(context, code):  # @DuplicatedSignature
    for h in context.qc.Historie:
        h.Delete()
    context.qc.Reload()
    assert len(context.qc.Historie) == 0, "has history values but shouldn't"


@given(u'^the quality characteristic definition has a class association for (?P<classname>\w*)$')
def step_impl(context, classname):  # @DuplicatedSignature
    for asso in context.qc_definition.Associations:
        if asso.classname == classname.strip():
            context.qc_definition_selected_association = asso
            return  # success
    assert False, 'it does not have class association for classname "{classname}"'.format(classname=classname.strip())


@given(u'^the class association for (?P<classname>\w*) has the object rule (?P<object_rule_name>\w*)$')
def step_impl(context, classname, object_rule_name):  # @DuplicatedSignature
    for asso in context.qc_definition.Associations:
        if asso.classname == classname.strip():
            context.qc_definition_selected_association = asso
            assert asso.ORule, 'missing object rule on class association for %s' % classname
            context.qc_definition_selected_association_object_rule = asso.ORule
            assert asso.ORule.name == object_rule_name, 'invalid object rule assigned - expected %s, found %s' % (object_rule_name, asso.ORule.name)
            return  # success
    assert False, 'missing class association for classname "{classname}"'.format(classname=classname.strip())


@given(u'^the class association for (?P<classname>\w*) has the computation rule (?P<computation_rule_name>\w*)$')
def step_impl(context, classname, computation_rule_name):  # @DuplicatedSignature
    for asso in context.qc_definition.Associations:
        if asso.classname == classname.strip():
            context.qc_definition_selected_association = asso
            assert context.qc_definition_selected_association.ComputationRule.name == computation_rule_name.strip(), "the class association has not the computation_rule"
            return  # success
    assert False, 'missing class association for classname "{classname}"'.format(classname=classname.strip())


@when(u'^the user computes the quality characteristic (?P<code>\w*) for it$')
def step_impl(context, code):  # @DuplicatedSignature
    qcs = _get_qcs_for_obj(context.qc_context_obj)
    for qc in qcs:
        if qc.Definition.identifier.strip() == code.strip():
            qc.compute()
            return  # success
    assert False, 'it does not have a quality characteristic for code {code}'.format(code=code)


@when(u'^the user opens the object kpi cockpit on that object$')
def step_impl(context):  # @DuplicatedSignature
    url = context.server_url
    url += QCObjectCockpit.getModuleURL("obj_cockpit")
    url += "?cdb_object_id=%s" % context.qc_context_obj.cdb_object_id
    context.webdriver.get(url)


@when(u'^the user enters a value and submits it changes$')
def step_impl(context):  # @DuplicatedSignature
    driver = context.webdriver
    css_td_val_selector = "tr[data-elink-cdb_object_id=\"{qc_id}\"] td.qceditable.val".format(qc_id=context.qc.cdb_object_id)
    td_val = driver.find_element_by_css_selector(css_td_val_selector)
    td_val.click()
    td_val_input = driver.find_element_by_css_selector(css_td_val_selector + ' input')
    context.qc_changed_value = 42.0
    td_val_input.clear()
    td_val_input.send_keys(("%.2f" % context.qc_changed_value).replace('.', ','))
    td_val_input.send_keys("\n")
    common.waitForJSValue(driver, "return $('.val.qceditable').first().text();", "42,000")


@then(u'^the computed result is equal to the number of elements found by the object rule$')
def step_impl(context):
    assert context.qc.act_value == len(context.qc_definition_selected_association_object_rule.getObjects())


@then(u'^the changed value is saved$')
def step_impl(context):  # @DuplicatedSignature
    context.qc.Reload()
    assert context.qc.act_value == context.qc_changed_value, 'value is different to the entered one %s!=%s' % (context.qc.act_value,
                                                                                                               context.qc_changed_value)


@then(u'^a new history entry with the value and quality grade manual has been created$')
def step_impl(context):  # @DuplicatedSignature
    assert len(context.qc.Historie) == 1, 'no new history entry was created'
    assert context.qc.Historie[0].value == context.qc_changed_value, 'wrong history value'
    assert context.qc.Historie[0].cdbqc_qgrade_object_id == '7a245670-fa59-11e0-9756-001d60a6c82c', 'wrong quality grade'  # manual q grade cdb_object_id
