.. -*- rst -*- 

Customization of BOM algorithms
===============================

Implementing a new BOM reader
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The cs.vp.bomcreator module offers a general mechanism to automatically derive
a BOM (bill of materials) from CAD documents (and other business objects) with appropriate information.
Examples for concrete implementations of this mechanism are contained in the
|cs.workspaces| package. These implementations work on CAD documents that were
imported with the Workspace Manager.

In this section, you will learn how to extend this functionality with your own
algorithms. This gives you the flexibility to use arbitrary files, file
structures or system objects as the source for your automatically generated
bills of materials, if you are willing to invest in the implementation effort.

To read about this functionality from a user perspective, see section
"Stuecklisten-Ausleitung aus CAD-Systemen" in chapter "Stuecklisten und
Produktstrukturen" of the |cs.vp| user manual. To learn about
the configuration options, read chapter "Stuecklistenverwaltung", section
"Stuecklistenausleitung aus CAD-Systemen" in the |cs.vp| administration manual.


Example: Extracting a BOM from a CSV file
"""""""""""""""""""""""""""""""""""""""""
BOM readers are implemented as classes that directly or indirectly are
derived from the abstract base class :class:`cs.vp.bomcreator.bomreader.BOMReader`.
This class defines a very flexible interface. Most custom
implementation don't need this flexibility and should derive from
:class:`cs.vp.bomcreator.bomreader.SimpleBOMReader` instead.

As a simple example, the following listing shows the implementation of a BOM reader
that reads its information from a file with lines of comma-separated values. The implementation
assumes that it is invoked on a document with a text file as the first primary file. ::

    from cdb.objects import ByID
    from cs.vp.bomcreator.bomreader import SimpleBOMReader
    import csv


    class CSVBOMReader(SimpleBOMReader):
        """
        A BOM-Reader that interprets a CSV-file as a bill of materials.
        """

        def fill_BOM(self, bom_context):
            """
            :Parameters:
             - bom_context: bomreader.BOMContext
            """
            doc = ByID(bom_context.object_id)
            if doc.PrimaryFiles:
                anchor_file = doc.PrimaryFiles[0]
                content = anchor_file.get_content()    # String
                lines = content.splitlines()           # list of Strings
        
                # now parse the lines and create a BOM item for each
                # assumption: every line has the format "part number,part index"
                for part_no, part_index in csv.reader(lines):
                    self.add_position(teilenummer=part_no,
                                      t_index=part_index)


As you see, this class only has one method: :meth:`fill_BOM`. It takes a
:class:`cs.vp.bomcreator.bomreader.BOMContext` as its sole argument. From this
`bom_context` object the method navigates to the first primary file of the
document and extracts its contents. The contents string is split into lines which
are parsed as pairs of part numbers and part indices. Using this part information,
the method fills the internal BOM object by repeated calls to :meth:`add_position`.

Before it can be used, the class has to be made available to the system. See section
"`Integrating a new BOM reader`_".

This implementation has some weaknesses which will be discussed in
"`Improvements to the example`_". But first we describe the features that even this simple
implementation gets for free.


Advantages of using a :class:`SimpleBOMReader`
""""""""""""""""""""""""""""""""""""""""""""""
BOMs generated by custom BOM readers

* will automatically be merged with existing BOMs in the database,
* are displayed in the interactive preview, and
* will be stored in the database after user confirmation.

When creating a BOM with a class derived from :class:`SimpleBOMReader`, it will
also automatically take into account any configuration settings:

* BOM items will be merged using the correct key attributes.
* Positions will be displayed according to the configured display columns.
* When storing positions in the database, only the configured attributes
  will be updated.
* New BOM items without a value for the `position` attribute will
  be assigned a position value according to the configured step width.


Improvements to the example
"""""""""""""""""""""""""""
The implementation of the `CSVBOMReader` in the example above has some problems.
This section shows how to avoid them.

* Reading the complete file contents with the :meth:`get_contents` method can
  be problematic with large files. You should check the `cdbf_size` attribute before,
  or use a sandbox instead.
* The implementation does not handle the case where a line does not match the expected
  format.

  But more importantly, it also does not check whether the item that a position
  references, actually exists. BOM reader implementations should always verify
  the existence of items. Otherwise the whole BOM import will fail and the user
  will see an error message only after they tried to save the BOM.
  
  Both problems can be fixed by rewriting the `for`-loop like this: ::

        for line_tuple in csv.reader(lines):
            if len(line_tuple) != 2:
                self.add_error("Unexpected line: '%s'" % str(line_tuple))
            else:
                (part_no, part_index) = line_tuple
                item = Item.ByKeys(part_no, part_index)
                if item is None:
                    self.add_error("Item does not exist: '%s-%s'"
                                   % (part_no, part_index))
                else:
                    self.add_position(teilenummer=part_no,
                                      t_index=part_index)

  This implementation needs an additional import: ::

      from cs.vp.items import Item

  The messages passed to :meth:`add_error` will be shown to the user, who can
  then decide whether they want to save the BOM nevertheless.
* The implementation does not respect object rules which may be configured to
  filter some BOM items. This can be fixed by using the method
  :meth:`ignore_component_item` and change the last statement to: ::

                    if not self.ignore_component_item(item):
                        self.add_position(teilenummer=part_no,
                                          t_index=part_index)



Merging attribute values of merged positions
""""""""""""""""""""""""""""""""""""""""""""
When multiple positions are merged on the basis of their key attributes,
the `menge` attribute is automatically aggregated. Other attributes
are not merged, however. In this case, the value of the position that was
added first is always used.

If you need to change this behaviour, you can check the return value of
the :meth:`add_position` method. Whenever the call to :meth:`add_position`
results in a merge with an existing position, the existing position is returned
as an instance of :class:`cs.vp.bomcreator.bom.BOMEntry`. Otherwise `None`
is returned. The `attrs` field
of :class:`cs.vp.bomcreator.bom.BOMEntry` is a dictionary and can be
manipulated in custom code. In this example, we manipulate the `auswahlmenge`
attribute (which is NOT identical to `menge`): ::

        existingEntry = self.add_position(teilenummer=part_no, auswahlmenge=2.0)
        if existingEntry is not None:
            # update auswahlmenge manually
            existingEntry.attrs['auswahlmenge'] += 2.0


Alternatives to :class:`SimpleBOMReader`
""""""""""""""""""""""""""""""""""""""""
Customizations that need to create and display more than one BOM in one step,
have to derive from the more general interface
:class:`cs.vp.bomcreator.bomreader.BOMReader` instead.

It is an an important design decision whether to use the methods of the
:class:`cs.vp.bomcreator.factory.Factory` class to create BOMs and
BOM items or whether to create these objects manually. If you use the
factory methods, the resulting BOMs will automatically respect the current
configuration settings. If you want to work independently from these settings,
you should avoid the factory methods.

The following example illustrates a BOM reader that creates two BOMs using the
`Factory` class. It assumes that there are two pre-existing items `self.part`
and `self.assembly2`::


        class MultipleBOMReader(BOMReader):
        """
        An example of a BOMReader that create more than one BOM.
        """
            def __init__(self, bom_context, factory, custom_state):
                # MISSING: prepare test data self.part and self.assembly2

                # create the main bom for the main assembly (taken from the CAD document)
                self._bom = factory.create_BOM()
                # ... and add a position
                self._bom.create_and_add_entry(teilenummer=self.part.teilenummer, t_index=self.part.t_index, menge=1.0)

                # create another BOM for our test assembly, also containing a position
                bom2 = factory.create_BOM_for_assembly(self.assembly2)
                bom2.create_and_add_entry(teilenummer=self.part.teilenummer, t_index=self.part.t_index, menge=1.0)

                # return both BOMs as a list
                self.boms = [self._bom, bom2]


Customizing an existing BOM reader
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Often it is not necessary to implement a new BOM method from scratch when
handling customization requests. If the requirements cannot be met with
configuration changes and object rules alone, it may suffice to extend an
existing class by overriding a specific method.

All existing implementations support an explicit customization point:
the method :meth:`adjust_and_filter`. We will show how to use it in the next
section.


Example: Converting attributes from Workspace Manager file information
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
For this example, we assume that we are importing the BOM from a CAD system,
using the Workspace Manager. We also assume that the package |cs.workspaces|
is installed.

The problem that is example tries to solve is: the `menge` attribute does not
have the required format. It uses the comma as the decimal separator instead of
following the English convention. To convert the value, we can use a
customization that like this: ::

    from cs.vp.bomcreator.cadbominforeader import CADBomInfoReader

    class CustomCADBomInfoReader(CADBomInfoReader):
        def adjust_and_filter(self, attributes):
            menge = attributes.get('menge')
            try:
                if isinstance(menge, basestring):
                    menge2 = string.replace(menge, ',', '.')
                    attributes['menge'] = float(menge2)
                return True
            except ValueError:
                self.add_error("Could not convert 'menge' value: '%s'" % str(menge))
                return False 

:meth:`adjust_and_filter` is a method that is supported by all BOM reader
implementations. It works on the level of single BOM items and allows to
change the value of attributes, to add new attribute values, and to discard a
position completely.

As its input, the method takes a dictionary of attribute values.
This dictionary may contain a value for any of the attributes of the system's
`bom_item` class. However, if the data comes from an external source, you
cannot make any assumptions about which attributes are present or about the
format of their values.

The above example checks whether there is a `menge` attribute and whether it is
a string. If this is the case, it replaces all commas with periods, tries to
convert the resulting string to a float and stores the float in the dictionary.
If no error occurs, the method returns `True` which indicates that the BOM
position should not be discarded. If an exception occurs because the `menge`
string still cannot be converted to float, the method returns `False` and the
BOM item will be filtered out.

   .. note::
       This specific implementation can be problematic if input data contains
       commas as thousands separators. In this case you need a more
       sophisticated algorithm.


Integrating a new BOM reader
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
A new class like `CSVBomReader` should be part of a new or existing
CONTACT Elements package. In this way, custom BOM implementations can easily be
distributed and updated.

The fully qualified Python class name must be configured as described in section
"Konfiguration einer eigenen Methode zur Stuecklistenausleitung" in the
|cs.vp| administration manual.


Using callbacks
^^^^^^^^^^^^^^^
Sometimes it is necessary to maintain additional database relations whenever
BOM items are written or deleted. The easiest way to do this is to
override one or more of these methods in your `BOMReader` implementation:

* :meth:`post_write_component`
* :meth:`post_write_bom`
* :meth:`post_write_boms`


However, you should be aware that this only works with BOMs which were
created with one of the methods in the :class:`cs.vp.bomcreator.factory.Factory`
class. For details, see the documentation of
:class:`cs.vp.bomcreator.bomreader.BOMReader`.

.. warning::
   You cannot use instance variables in these methods.
   If you need persistent values, use :meth:`set_user_attribute` of class
   :class:`cs.vp.bomcreator.bom.GeneratedBOM` instead.

Shared position numbers
^^^^^^^^^^^^^^^^^^^^^^^
Position numbers are typically automatically created for every new BOM entry,
using the configured step width. If your goal is to have multiple BOM entries
which receive the same generated position number, you can use the class
:class:`cs.vp.bomcreator.bom.SharedPosition`. For example: ::

        shared_pos = SharedPosition()
        bom.create_and_add_entry(teilenummer=part_nr_1, position=shared_pos)
        bom.create_and_add_entry(teilenummer=part_nr_2, position=shared_pos)


The two entries will receive their common position number when the BOM is
synchronized with the database.

The class `SharedPosition` can also be used with the method meth:`add_position`
of BOM readers.


Customizing the order of entries for generating position numbers in CADBomInfoReader
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
When position numbers are automatically assigned to new BOM entries, the order of entries
as added to the BOM is taken into account, e.g. earlier entries get a lower position number.

But sometimes the required behavior is different. Implementations derived from the class
`CADBomInfoReader` can override the method :meth:`sort_key` to influence the order. For example,
to sort by the attribute "netto_breite" before assigning position numbers, add this implementation
to your BOM reader: ::

            def sort_key(self, entry):
                return entry.attrs['netto_breite']

By default, `CADBomInfoReader` uses the order of the XML elements in the appinfo
file.


Configuring an operation for other classes than CAD documents
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
This package comes with a predefined interactive operation for creating BOMs from CAD documents.
This operation is called `cdbwsm_createbom` and belongs to the data dictionary class `model`.
The operation opens a preview of the BOM and allows the user to save it to the database.

It is possible to define such an operation for other data dictionary classes. Classes must fulfill these requirements:

* They *must* have an attribute `cdb_object_id` with the usual semantics.
* They *must* have a 1:1 PowerScript relation named `Item` which returns the associated item. This item will receive the
  BOM when it is saved by the user.
* They *may* have an attribute `erzeug_system` which describes the associated application. The application determines
  the applied BOM configuration and the value of the `cadsource` attribute of the generated components.

The operation must be defined as a `SingleObject` operation of type `PowerScript`. To implement the operation,
connect to it and start the preview application like this: ::

    from cdb import sig

    @sig.connect(OwnClass, "operation_name", "now")
    def create_bom_from_own_class(self, ctx):
        ctx.url("powerscript/"
                "cs.vp.bomcreator.app/"
                "bomcreator_confirm?cdb_object_id=%s" % self.cdb_object_id)


Or, if your class does *not* have an attribute `erzeug_system`: ::

    from cdb import sig

    @sig.connect(OwnClass, "operation_name", "now")
    def create_bom_from_own_class(self, ctx):

        cadsource = "ProE"  # replace with your own application!

        ctx.url("powerscript/"
                "cs.vp.bomcreator.app/"
                "bomcreator_confirm?cdb_object_id=%s&cadsource=%s" %
                (self.cdb_object_id, cadsource))


The built-in `BOMReader` implementations all only work on CAD documents. So you also need to implement your own `BOMReader`
if your new operation should do something useful. The `cdb_object_id` of the business object will be available as part of the
:class:`cs.vp.bomcreator.bomreader.BOMContext` that is passed to your `BOMReader`.


Reference
^^^^^^^^^


.. toctree::

   cdb_bom_bomreader
   cdb_bom_factory
   cdb_bom_bom
