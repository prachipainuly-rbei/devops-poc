/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: webpack.config.common.js 182554 2018-08-20 14:06:43Z cla $"
 */

/* eslint-env node */

// const componentNameSpace = "cs-web-components-xx";
const path = require('path');
const webpack = require('webpack');
const OnlyIfChangedPlugin = require("only-if-changed-webpack-plugin");
const fs = require('fs');

const opts = {
    rootDir: process.cwd(),
    devBuild: process.env.NODE_ENV !== 'production'
};

function getComponentNameSpace() {
    return JSON.parse(fs.readFileSync(path.join(opts.rootDir, 'namespace.json')));
}

function TrackRunPlugin(componentNameSpace) {
    return function() {
        this.plugin('watch-run', function(watching, callback) {
            console.log(
                'Build started [' +
                componentNameSpace +
                ']: ' +
                new Date().toLocaleTimeString()
            );
            callback();
        });
        this.plugin("done", function() {
            console.log(
                "Build done [" +
                componentNameSpace +
                "]: " +
                new Date().toLocaleTimeString()
            );
        });
        this.plugin("failed", function() {
            console.log(
                "Build failed [" +
                componentNameSpace +
                "]: " +
                new Date().toLocaleTimeString()
            );
        });
    }
}

function makeConfig() {
    const componentNameSpace = getComponentNameSpace();
    const buildPath = path.join(process.cwd(), 'build');

    const entries = {
        [componentNameSpace]: './src/index'
    };
    if (fs.existsSync(path.resolve('./src/stories/index.js'))) {
        entries[`${componentNameSpace}-stories`] = './src/stories/index';
    }
    return {
        entry: entries,
        output: {
            path: buildPath,
            filename: "[name].[chunkhash].js",
            libraryTarget: 'umd',
            library: "[name]",
            devtoolModuleFilenameTemplate: function(info) {
                if (info.resourcePath.startsWith('./')) {
                    return 'webpack:///webpack/' +
                        componentNameSpace + info.resourcePath.slice(1);
                }
                return 'webpack:///' + info.resourcePath;
            }
        },
        devtool: 'source-map',
        module: {
            rules: [
                {
                    test: /\.jsx?$/,
                    exclude: /(node_modules|bower_components)/,
                    loader: 'eslint-loader',
                    enforce: "pre",
                    options: {
                        failOnWarning: false,
                        failOnError: false,
                        configFile: path.join(__dirname, '.eslintrc.json')
                    }
                },
                {
                    test: /\.jsx?$/, exclude: /(node_modules|bower_components)/,
                    loader: 'babel-loader',
                    options: {
                        extends: path.join(__dirname, '.babelrc')
                    }
                },
                {
                    test: /\.css$/,
                    use: [
                        {loader: "style-loader"},
                        {loader: "css-loader"}
                    ]
                },
                {
                    test: /\.png(\?v=\d+\.\d+\.\d+)?$/,
                    loader: "url-loader",
                    options: {
                        limit: 100000
                    }
                },
                {
                    test: /\.gif(\?v=\d+\.\d+\.\d+)?$/,
                    loader: "url-loader",
                    options: {
                        limit: 100000
                    }
                },
                {
                    test: /\.svg(\?v=\d+\.\d+\.\d+)?$/,
                    loader: "url-loader",
                    options: {
                        limit: 100000,
                        mimetype: "image/svg+xml"
                    }
                },
                {
                    test: /\.(woff|woff2|eot|ttf)$/,
                    loader: 'url-loader',
                    options: {
                        limit: 100000
                    }
                }
            ]
        },
        externals: {
            "jquery": "jQuery",
            "react": "React",
            "react-dom": "ReactDOM",
            "react-bootstrap": "ReactBootstrap",
            "immutable": "Immutable",
            "underscore": "_",
            "d3": "d3",
            "moment": "moment",
            "cs-web-components-externals": "cs-web-components-externals",
            "cs-web-components-base": "cs-web-components-base",
            "cs-web-components-storybook": "cs-web-components-storybook"
        },
        resolve: {
            extensions: ['.js', '.jsx'],
            modules: ["node_modules", path.join(process.env.CADDOK_BASE, "node_modules")]
        },
        resolveLoader: {
            modules: ["node_modules", path.join(process.env.CADDOK_BASE, "node_modules")]
        },
        plugins: [
            new webpack.DefinePlugin({'componentNameSpace': JSON.stringify(componentNameSpace)}),
            TrackRunPlugin(componentNameSpace),
            function() {
                const cacheDir = path.join(opts.rootDir, '.cache');
                if (!fs.existsSync(cacheDir)) {
                    fs.mkdirSync(cacheDir);
                }
            },
            new OnlyIfChangedPlugin({
                cacheDirectory: path.join(opts.rootDir, '.cache'),
                cacheIdentifier: opts
            }),
            /************************************************************
             *
             * IMPORTANT!
             *
             * This custom plugin generates a stats.json file everytime
             * a new bundle is emitted. It contains mapping information
             * used by the cs.platform.web.static.Registry() code of the
             * platform. Without this information the backend code is unable
             * to locate and deploy the correct files to the client.
             *
             ************************************************************/
            function() {
                let _stats_db = {};

                function syncStatsDBWithFSContent() {
                    Object.entries(_stats_db)
                        .filter((entry) => {
                            return !fs.existsSync(path.join(buildPath, entry[1]));
                        })
                        .map(entry => entry[0])
                        .forEach((k) => {
                            delete _stats_db[k];
                        });
                }

                function loadStatsDBFromFS() {
                    statsFile = path.join(buildPath, 'stats.json');

                    if (fs.existsSync(statsFile)) {
                        _stats_db = JSON.parse(fs.readFileSync(statsFile, 'utf8'));
                        syncStatsDBWithFSContent();
                    }
                }

                function buildTargetName(chunkFileName, chunk) {
                    const target_filename = chunkFileName;
                    const hashed_fn_extension = target_filename.substr(chunk.length + 1);
                    const source_filename = [chunk].concat(hashed_fn_extension.split('.').slice(1)).join('.');

                    // If a previous js bundle exists, we are
                    // going to remove the outdated version!
                    if  (_stats_db[source_filename] && _stats_db[source_filename] !== target_filename) {
                        const old_target_name = path.join(buildPath, _stats_db[source_filename]);
                        if (fs.existsSync(old_target_name)) {
                            fs.unlinkSync(old_target_name);
                        }
                    }

                    _stats_db[source_filename] = target_filename;
                }

                this.plugin("run", function(_, runDone) {
                    loadStatsDBFromFS();
                    runDone();
                });

                this.plugin("watch-run", function(_, runDone) {
                    loadStatsDBFromFS();
                    runDone();
                });

                this.plugin("done", function(stats) {
                    const _stats = stats.toJson();

                    for(const chunk in _stats.assetsByChunkName) {
                        if (Array.isArray(_stats.assetsByChunkName[chunk])) {
                            for (const file in _stats.assetsByChunkName[chunk]) {
                                buildTargetName(_stats.assetsByChunkName[chunk][file], chunk);
                            }
                        } else {
                            buildTargetName(_stats.assetsByChunkName[chunk], chunk);
                        }
                    }

                    fs.writeFileSync(
                        path.join(buildPath, "stats.json"),
                        JSON.stringify(_stats_db),
                        'utf8'
                    );
                });
            }
        ]
    };
}

module.exports = {
    getComponentNameSpace: getComponentNameSpace,
    makeConfig: makeConfig
};
