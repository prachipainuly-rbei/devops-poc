
.. _`operations_dialog_hooks`:

Dialog Hooks
************

If you use the forms defined as masks in |elements| you can adapt the
form behaviour by adding own code that is called whenever the user changes
a specific value of the form. There are two kinds of dialog hooks - hooks
that are executed in the backend and hooks that are executed in the frontend.


Configuration
=============
.. _`HELPID_csweb_dialog_hook_function`:
.. _`dialog_hook_function`:

Dialog Hook Function
--------------------
A dialog hook function object defines which piece of code has to be
executed and defines if this code is part of the frontend or the backend.

The dialog has these members:

* :guilabel:`Label`: The name of the hook. The name is used to reference the
  function.
* :guilabel:`Function`: The name of the function that implements the hook.
  This is the full qualified python name if the hook is implemented in the
  backend or the name of a JavaScript function for frontend hooks.
* :guilabel:`Backend`: The checkbox has to be set if the hook is implemented
  in the backend.
* :guilabel:`Description`: A text that describes the function of the hook.
* :guilabel:`Module`: The software module this configuration belongs to.

Predefined hook function
^^^^^^^^^^^^^^^^^^^^^^^^

- ``EmulateLegacyDialogItemChange``: This backend hook function emulates the
  behaviour of the |win.client|. An operation is constructed and usually
  an user exit of kind ``dialogitem_change`` is called. The action is
  quite expensive - usually you should prefer to migrate the code.

- ``EmulateLegacyDialogButton``: This backend hook function emulates the
  behaviour of the |win.client|. An operation is constructed and usually
  an user exit of kind ``button_pressed`` is called. The action is
  quite expensive - usually you should prefer to migrate the code.


.. _`HELPID_csweb_dialog_hook`:
.. _`dialog_hook`:

Dialog Hook
-----------
If you want a dialog hook to be executed you have to connect a dialog hook
function with a dialog configuration. You will usually add a hook using
the register :guilabel:`Dialog Hooks` of the mask configuration. The
configuration contains this fields:

* :guilabel:`Mask Name`: The name of the dialog that is adapted by the hook.
* :guilabel:`Attribute`: The attribute that triggers the hook. If the value
  of the given attribute changes the hook is called. There are some special
  values that can be used as attribute names:

  - ``*``: This value activates a hook for all changes of the dialog.
    This is ok for frontend hooks but might lead to performance problems
    if you implement the hook in the backend.

  - ``::PRE_SUBMIT::``: This value can be used if you want to check the
    dialog values before the dialog is closed as the result of clicking
    on a submit button.

  - ``::PRE_DISPLAY::``: This value can be used to configure backend hooks
    that calculates additional values before the dialog ist shown. The hook
    parameter of the callback function is derived from
    `cs.web.components.ui_support.dialog_hooks.DialogHookPreDisplay`. At this
    time frontend hooks are not called for ``::PRE_DISPLAY::``.

* :guilabel:`Label`: The name of the :ref:`hook function <dialog_hook_function>`
  to be called.
* :guilabel:`Function`, `Backend`: Some information retrieved from the
  :ref:`hook function <dialog_hook_function>`.
* :guilabel:`Position`: If there are several hooks defined for an attribute
  the position defines the calling order. Hooks with a low position are called
  first. Note that frontend hooks are always called before backend hooks.
* :guilabel:`Active`: The checkbox has to be set if the hook should be executed.
* :guilabel:`Module`: The software module this configuration belongs to.


Implementation
==============

In general you should prefer to write frontend hooks because they do not need
a roundtrip to the server.

Frontend Hooks
--------------

If you implement a frontend hook you have to ensure that the library that
contains the JavaScript function is part of the page where the mask is shown.
The call of frontend hooks is synchron.

Backend Hooks
-------------

To implement a backend hook you have to implement a python function with
one parameter. This parameter can be used to retrieve information about
the actual mask and to manipulate the form. It is of type
`cs.web.components.ui_support.dialog_hooks.DialogHook`. An implementation
might look as follows:

.. code-block:: python

    def handle_categ_change(hook):
        """
        (De)-activates the dialog field for the subcategory depending
        on the actual category
        """
        categ = hook.get_new_values["categ"]
        if has_subcategs(categ):
            hook.set_writeable("categ2")
        else:
            hook.set_readonly("categ2")
            hook.set("categ2", "")

At this time backend dialog hooks are called asynchron which means that
the user might continue his work before the hook result is applied to the
form.

cs.web.components.ui_support.dialog_hooks
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.. automodule:: cs.web.components.ui_support.dialog_hooks

.. autoclass:: cs.web.components.ui_support.dialog_hooks.DialogHook
   :members:
   :member-order: bysource

.. autoclass:: cs.web.components.ui_support.dialog_hooks.DialogHookPreDisplay
   :members:
   :member-order: bysource


Examples
========

The following code-snippet gives an example how a backend-based dialog hook may display
a simple choice to the user:

.. code-block:: python

   def example_hook(hook):
       from cs.web.components.ui_support.frontend_dialog import FrontendDialog
       fe = FrontendDialog('This is a FrontendDialog',
                           'Please select a choice to continue')
       fe.add_button('Call Server', 0, FrontendDialog.ActionCallServer, is_default=True)
       fe.add_button('To Dialog', 0, FrontendDialog.ActionBackToDialog, is_cancel=True)
       hook.set_dialog(fe)
