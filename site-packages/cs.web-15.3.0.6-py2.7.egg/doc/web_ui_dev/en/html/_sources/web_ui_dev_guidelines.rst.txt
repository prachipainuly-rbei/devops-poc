.. _`web_ui_dev_guidelines`:

Guidelines for developing Web UI applications and components
############################################################

Babel Presets
*************

* We use all plugins from `Env preset <http://babeljs.io/docs/plugins/preset-env//>`_
  and `React preset <http://babeljs.io/docs/plugins/preset-react/>`_ to compile
  our javascript files.

* We also use the `transform-object-rest-spread <http://babeljs.io/docs/plugins/transform-object-rest-spread/>`_
  plugin to allow rest properties for object destructing or to spread properties
  for object literals. This proposal is currently in stage 4 of the standardization
  prozess, and will be contained in one of the next standard versions.
  Example usage:

  .. code-block:: javascript

     const { settings, label, ...others } = this.props;
     ...
     // settings should be excluded from props
     <SomeComponent label={label} ...others />


JavaScript style guide
**********************

The build process of the libraries delivered by |contact| includes a call to the
`ESLint <https://eslint.org/>`_ style checker. The concrete styling rules are
contained in the :file:`.eslintrc.json` file in the package ``cs.web`` package.

React style guide
*****************

* We use `ES2015 classes <http://facebook.github.io/react/docs/reusable-components.html#es6-classes>`_
  to implement React components, not the :samp:`React.createClass` variant.

* If possible, we use plain JavaScript functions, see
  `Stateless Functions <http://facebook.github.io/react/docs/reusable-components.html#stateless-functions>`_

* Every React component has a :samp:`propTypes` definition. This serves as
  documentation to the user, and enables runtime checks by the React library.

.. _`web_ui_dev_naming`:

Naming rules
************

Naming rules have two main purposes: avoid name clashes without the need for
coordination, and making the source of some programming artifact obvious. The
component architecture already provide a namespace system, in the form of module
names. As all relevant programming artifacts are located in those modules, we
use the module names as basis for our naming rules (see :ref:`web_ui_glossary`
for definitions of the following terms).

Libraries
=========

Library names are used in the backend, to specify the libraries that are needed
by an application. In addition, the library name becomes part of the URL of its
contained resources. A library has the same name as a Python module that is
located in the same directory, but with dashes (``-``) instead of dots. Most
open source JavaScript libraries use dashes (e.g. ``react-bootstrap``), and we
adhere to this convention.

Example: :samp:`cs-web-components-base-ui-lib`

Resources
=========

Resource URLs are already unique, because they contain the library name. However,
the JavaScript debuggers in web browsers often list only the last components of
the URL. Therefore, for JavaScript resources, we include the library name in the
file name.

CSS classes
===========

For CSS class names, the main consideration is that unrelated parts of an
application don't influence each other. This can happen if two components
define the same CSS class, but with different semantics.

* CSS classes that are defined by a component always include the component name.
  Only if a CSS class is shared by several components, the library name can be
  used instead.

  .. code-block:: scss

     // componentNameSpace == 'cs-web-components-base'
     .#{$componentNameSpace}-ui-lib-frame { ... }

* We follow the `Block Element Modifier methodology <http://getbem.com/>`_ to
  define CSS class names for elements contained in components, and for flag
  classes that denote a different appearance / behaviour of components.

* Redefinition of global styles is forbidden. If a global style can't be used as
  is, the redefinition must be restricted to descendants of a component specific
  class.

  .. code-block:: scss

     // componentNameSpace == 'cs-web-components-base'
     .#{$componentNameSpace}-ui-lib-frame {
           .textfield { ... }
     }

* The same rule holds, if styles of a component must be changed in some
  context.

  .. code-block:: scss

     // componentNameSpace == 'cs-documents'
     .#{$componentNameSpace}-ui-app {
         .cs-web-components-base-ui-lib-frame { ... }
     }

* Each component must have at least one CSS class set on the root element, in
  order to allow customization.

.. attention::

   Due to the way Internet Explorer interprets flex-base it is sometimes necessary
   to specify a flex value such as 0px to avoid components taking their maximum
   possible size inside a flex layout.

   Since, in production mode, the SCSS compiler optimizes sizes with value 0 by
   removing the unit, this may lead to problems in IE. This can be avoided by
   instead specifying a flex-base value of 1px.

Redux reducers
==============

The names of the reducer functions are used as keys into the global Redux
store (the application state). Reducer names start with the name of the library
they are a part of, with an additional describing suffix; the separator character
is a ``-``.

For reducers provided by the Web UI, a simple name (without dashes) can be used.
Because every other reducer name must have at least one ``-``, there is no
danger of collision. On the other hand, it is expected that these "standard"
reducers are used by most applications, and shorter names are more convenient.

Redux actions
=============

The Redux action objects that are used to send data to the store, are modeled
after the `Flux Standard Actions <https://github.com/acdlite/flux-standard-action>`_
conventions.

The ``type`` members of the action objects must be unique over the actions
from all libraries that make up an application. Therefore, they also start with
the library name.

Promise
*******

The fetch APIs and the async action creators(thunks) return javascript promise
objects. The caller should take care of error handling. Recommended is to add
a catch() call at the end of chaining, even with an empty function if the error
can be ignored.

Error Boundaries
****************

React 16 introduced `Error Boundaries <https://reactjs.org/docs/error-boundaries.html>`_,
that can be used to contain errors in the render phase, so that exceptions don't
leave the whole page corrupted.

These Error Boundaries should be placed around uses of external code, where the
author of a component has no control over the inner workings of child components.
