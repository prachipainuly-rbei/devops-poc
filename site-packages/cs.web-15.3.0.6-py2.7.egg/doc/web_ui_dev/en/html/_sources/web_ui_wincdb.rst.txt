.. _`wincdb_webui`:

Embedded Web Applications
#########################

Web applications may be used in the context of the desktop
client. This section describes, how the interaction between the
desktop client and embedded web applications works out of the box, and
how it can be improved by application developers.

Handling Modifications in Embedded Web Applications
===================================================

Embedding web applications as ELinkControls in dialogs allows the user
to modify data. If, however, the dialog is closed or reloaded, all
changes that are not persisted get lost.

The behaviour of the desktop client is to notify the user of such
ongoing changes, and prompting if the dialog should really be
closed. For operations run in the web application this behaviour
usually works out of the box. If, on the other hand, the web
application employs custom components or low-level REST calls to
modify data, the custom code needs to signal ongoing modifications.

This is achieved by dispatching into the Redux store
``modifications``.  Let's look at a simple example of a component that
changes its modification state:

.. code-block:: none

  import React from 'react';
  import {Checkbox} from 'react-bootstrap';

  const ModificationDemo = props => (
     <Checkbox onChange={event => props.setComponentModified(
                                     this, event.target.checked)}
               value={props.modifications.get(this)}>
        Modified
     </Checkbox>
  );

  ModificationDemo.propTypes = {
    setComponentModified: React.PropTypes.func,
    modifications: React.PropTypes.bool
  };

  function mapStateToProps(state) {
    return {
        modifications: state.modifications
    };
 }

 export default connect(
   mapStateToProps, {setComponentModified}
 )(ModificationDemo);

The component ``ModificationDemo`` provides a simple checkbox which
updates its modification state by dispatching setComponentModified
(Line 5). In the store, modifications are stored per component, so the
component passes itself as a key, as well as its modification state as
a boolean value. Components may also read their modification state by
connecting to the store.

Note that a component must actively reset its modification state if
changes are discarded or persisted.
