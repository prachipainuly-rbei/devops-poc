/* global env */
exports.publish = publish;

// Configure path shortening
var path_type = 'short';
var path_file_limit = 40;

var logger = require('jsdoc/util/logger');
var helper = require('jsdoc/util/templateHelper');
var path = require('canonical-path');
var _ = require('lodash');
var deasync = require('deasync');
var fs = require('fs');
var mkdirp = require('mkdirp');
var util = require('./util');
var async = require('async');
var path = require('path');

var context;

/**
 * @param {TAFFY} taffyData See <http://taffydb.com/>.
 * @param {object} options JSDoc passed options
 * @param {Tutorial} tutorials List of tutorial
 * @return {undefined}
 */
function publish(taffyData, options, tutorials) {
  logger.debug('Tutorials', tutorials);
  logger.debug('Options', options);

  if (!(options.package || options._.length == 1)) {
    logger.error('jsdoc-sphinx-contact requires either a package.json or a single source root.')
    return;
  }

  const baseDir = options.package ? 
                  path.join(path.dirname(options.package), 'src') : 
                  options._[0];
  
  if (!options.package && baseDir) {
    const namespace_path = path.join(baseDir, '../namespace')
    options.package = {
      name: require(path.isAbsolute(namespace_path) ? 
                    namespace_path :
                    path.join(process.cwd(), namespace_path)),
      description: ''
    }
  }

  // Use .rst as default extension
  helper.fileExtension = '.rst';

  // README.rst must be kept as it is.
  // TODO If env.opts._ is exactly one entry that is a directory we are in recurse mode...
  //      So look for README.rst in directory
  var readme = _.find(env.opts._, /README.rst/);
  if (readme && !fs.lstatSync(readme).isDirectory()) {
    logger.debug('Load README.rst file:', readme);
    options.readme = fs.readFileSync(readme);
  }

  // Prune, include filename, and sort
  taffyData = helper.prune(taffyData);
  taffyData().update(function() {
    this.rstLinkName = this.name;

    if (this.longname.match(/^package:[^~]*$/)) {
        this.rstPath = '__package__.rst';
    } else if (this.meta && this.meta.filename) {
        const prunedFilename = this.meta.filename.replace(/\.[^/.]+$/, "")
        // Mangle metadata
        if (this.kind === 'file') {
            this.rstPath = prunedFilename + '.rst';
        }

        else {
            const relativePath = (this.meta && this.meta.path && baseDir) ?
                path.relative(baseDir, this.meta.path) : "";
            const issueWarning = function () {
                if (util.mainDocletKinds.indexOf(this.kind) === -1) {
                    console.log(
                      'WARNING:', 
                      (relativePath + path.sep + this.meta.filename + ':' + this.longname),
                      'is no main doclet and is not contained in an @module definition'
                    );
                }
            }.bind(this);

            // if this is an index.js and its a submodule the entity's name is the last 
            // part of the path, e.g.: 
            // - src/foo/bah/index.js    -> foo.bah.__module__
            // - src/foo/bah/MyModule.js -> foo.bah.MyModule.__module__
            const pathComponents = relativePath.split(path.sep);
            // TODO test: should support manually setting name with @module [name]
            // use prunedFilename to determine if this.name was manually set (we want to pop) 
            // last path component if name is index.js 
            const moduleConfig = { // !!! Relies on evaluation order !!!
                name: (prunedFilename === 'index' && pathComponents.length > 0) ?
                            (this.name.endsWith('index') ? // Was module name manually set
                             pathComponents.pop() : 
                             (pathComponents.pop(), this.name)) :
                            prunedFilename,
                path: pathComponents.join('.')
            };

            pathbase = path.relative(baseDir, this.meta.path)
                           .replace(RegExp('\\\\', 'g'), '.');
            filebase = path.basename(this.meta.filename, this.meta.filename.slice(this.meta.filename.lastIndexOf('.')))
            
            const createRstLinkName = name => {
                const rln = filebase + '.' + name;
                return pathbase ? pathbase + '.' + rln : rln;
            }

            if (this.longname.match(/^package:[^~]*$/)) {  // Package definition
                this.rstTypeName = '__package__';
            } else if (this.kind === 'module' && this.longname.match(/module:[^\.~]*$/)) {  // Module definition
                this.rstTypeName = '__module__';
            } else if (this.kind !== 'module' && this.longname.match(/module:[^\.~]*$/)) {  // default defined inside a module
                // memberof is missing
                this.name = moduleConfig.name;
                this.rstTypeName = '__default__';
            } else if (this.longname.match(/module:[^\.~]*(\.|~).*$/)) {  // Something named defined inside a module
                //this.memberof = moduleConfig.name + '.__module__';
                this.rstTypeName = this.name;
            } else if (this.longname === 'module.exports') {  // export default without module definition
                // 'module.exports' is a stupid name: these overwrite each other -.-
                //issueWarning();

                this.name = moduleConfig.name;
                //this.memberof = moduleConfig.name + '.__module__';
                this.rstTypeName = '__default__';
            } else {
                //issueWarning();

                //this.memberof = moduleConfig.name + '.__module__';
                this.rstTypeName = this.name;
            }
            
            this.rstLinkName = createRstLinkName(this.rstTypeName);
            this.rstPath = this.rstLinkName + '.rst';
            this.filebase = filebase;
        }
    }

    return this;
  });

  taffyData.sort('rstLinkName, version, since');

  // If path_type is set to 'short' we generate short path names, to cope
  // with windows' 255 char limit. 
  if (path_type === 'short') {
      const mapping = [];
      const objectCount = {};
      taffyData().update(function() {
          if (this.filebase) {
            const fname = path_file_limit ?
                          this.filebase.substring(0, path_file_limit) :
                          this.filebase;
            const cnt = objectCount[fname] || 0;
            if (cnt === 0) {
              this.rstPath = fname + '.rst';
            } else {
              this.rstPath = fname + '-' + String(cnt) + '.rst';
            }
            objectCount[fname] = cnt + 1;
          }
          mapping.push([this.rstLinkName, this.rstPath]);
          return this;
      });

      fs.writeFile(path.join(options.destination, 'mapping.json'),
                   JSON.stringify(mapping, null, 4));
  }

  // define a global context that should be available by all function
  context = _.extend({
    data: taffyData
  }, options);

  // Augment data with needed informations
  registry = {}
  context.data().each(registerLink);

  _.each(helper.find(context.data, {kind: 'function'}), improveFunc);
  _.each(helper.find(context.data, {kind: 'member'}), improveFunc);

  function improveFunc(doclet) {
    doclet.signature = doclet.name + '(';
    _.each(doclet.params, function(p, i) {
      if (!(p && p.type && p.type.names)) {
        logger.debug('Bad parameter', p, doclet.longname);
        return;
      }
      p.signature = ':param ' + p.type && p.type.names && p.type.names.join('|');
      p.signature += ' ' + p.name;

      if (p.optional) {
        doclet.signature += '[';
      }
      if (i > 0) {
        doclet.signature += ', ';
      }
      doclet.signature += p.name;
      if (p.optional) {
        doclet.signature += ']';
      }
      return p.name;
    });
    doclet.signature += ')';

    _.each(doclet.returns, function(r) {
      if (!(r && r.type && r.type.names)) {
        logger.debug('Bad return', r, doclet.longname);
        return;
      }
      r.signature = ':return ' + r.type && r.type.names && r.type.names.join('|');
    });

  }

  // build the list of page generation actions.
  var actions = [];
  actions.push(generate('__package_index__.rst', require('./view-models/home')));
  //actions.push(generate('conf.py', require('./view-models/sphinx-config')));
  var docletModel = require('./view-models/doclet');

  context.data().each(function(doclet) {
    // var url = helper.longnameToUrl[doclet.longname];
    var url = doclet.rstPath;

    if (url.indexOf('#') > -1) {
        url = url.split(/#/).pop();
    }

    if (!url.endsWith('.rst')) {
      url += '.rst';
    }

    if (doclet.undocumented)
      return;

    if (util.mainDocletKinds.indexOf(doclet.kind) !== -1) {
      actions.push(generate(url, docletModel(doclet)));
    }
  });

  // publish must be synchronous as the caller does not care about callbacks.
  deasync(function(cb) {
    async.parallel(actions, cb);
  })();
}

function generate(target, generator) {
  return function(cb) {
    logger.debug('generate', target);
    generator(context, handleErrorCallback(function(err, data) {
      if(err) {
        logger.error('cannot generate ' + target);
        logger.debug(err);
        return;
      }
      write(target, data, cb);
    }));
  };
}

function registerLink(doclet) {
    var url = doclet.rstPath || helper.createLink(doclet);
    helper.registerLink(doclet.longname, url);
    doclet.rstLink = url.substr(0, url.length - helper.fileExtension.length);
}

/**
 * Handle all write operations.
 *
 * @private
 * @param {string}   relPath Relative path in the ouput directory
 * @param {string}   data    File content
 * @param {publish.writeCallback} cb node fs.write compatible callback
 * @return {undefined}
 */
function write(relPath, data, cb) {
  var target = path.join(context.destination, relPath);

  mkdirp(path.dirname(target), handleErrorCallback(function() {
    fs.writeFileSync(target, data);
    handleErrorCallback(cb)(null, target);
    logger.debug('file written: %s', target);
  }));
}

function handleErrorCallback(cb) {
  return function(err) {
    if (err) {
      logger.error(err);
      return cb(err);
    }
    return cb.apply(this, arguments);
  };
}

/**
 * @callback errCallback
 * The callback function receive an error as first argument if any.
 *
 * @param {error} err The error cause
 */

/**
 * @callback publish.writeCallback
 * @param {error} err The error cause
 * @param {string} filePath The written file path
 */
