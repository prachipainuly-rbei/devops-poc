var _ = require('lodash');
var util = require('../util');
var helper = require('jsdoc/util/templateHelper');
var logger = require('jsdoc/util/logger');
module.exports = docletModel;

function docletModel(doclet) {
  function has(identifier) {
    return doclet['kind'] === identifier;
  }
  
  return function(context, cb) {
    const subDoclets = util.docletChildren(context, doclet, util.subDocletKinds);
    const hasSubDoclet = new Map(
        util.subDocletKinds.map(kind => [kind, subDoclets[kind].length > 0])
    );
 
    function createSignature(f, breakParameters) {
        // XXX: signature is inserted into code-block. this handles code-blocks indentation
        const params = f.hasParams ?
                       f.params.map(param => param.type && (param.type.parsedType || param.type.parsedType.typeExpression) ?
                                             `${param.name}: ${param.type.parsedType.name || param.type.parsedType.typeExpression}` :
                                             param.name
                                   ).join(breakParameters ? ',\n     ' : ', ') :
                                   '';
        f['signature'] = breakParameters ? `   ${f.name}(\n     ${params}\n   )` : `   ${f.name}(${params})`;
        if (f.hasReturns) {
            const returns = (returns => returns.length > 1 ? ('(' + returns.join(', ') + ')') : returns[0])(f.returns.map(return_ => return_.signature));
            f['signature'] += ': ' + returns;
        }
    } 

    const augmentFunctionDoclet = f => {
        // Generate Parameter Info
        f['hasParams'] = f.params && f.params.length > 0;
        if (f.hasParams) 
            f['paramsDescribed'] = f.params.filter(p => p.description);
        f['hasParamsDescribed'] = f.paramsDescribed && f.paramsDescribed.length > 0;

        // Generate Return Info
        f['hasReturns'] = f.returns && f.returns.length > 0;
        if (f.hasReturns) 
            f['returnsDescribed'] = f.returns.filter(r => r.description);
        f['hasReturnsDescribed'] = f.returnsDescribed && f.returnsDescribed.length > 0;

        // Generate See Info
        f['hasSee'] = f.see && f.see.length > 0
        
        // Generate Signature
        // if (f['signature']) {
        //     f['hasSignature'] = true;
        // } else {
        f['hasSignature'] = f.hasParams || f.hasReturns;
        if (f.hasSignature) {
            createSignature(f, f.params && f.params.length > 3);
            if (!(f.params && f.params.length > 3) && f.signature.length > 100)
                createSignature(f, true);
        }
        // }
    }

    subDoclets.function.forEach(augmentFunctionDoclet);
    subDoclets.member.forEach(augmentFunctionDoclet);

    var viewModel = _.extend({},
      util.rstMixin,
      util.docletChildren(context, doclet, util.mainDocletKinds),
      subDoclets, 
      {
        doclet: doclet,
        package: context.package,
//        hasChildren: has('module') || has('namespace'),
        hasContents: util.subDocletKinds.map(kind => subDoclets[kind].length > 0)
                                        .reduce(((v1, v2) => v1 || v2), false),
        hasExtends: doclet.augments && doclet.augments.length > 0,
        extendsString: doclet.augments && doclet.augments.join(', '),
        hasModule: hasSubDoclet.get('module'),
        hasClass: hasSubDoclet.get('class'),
        hasFunction: hasSubDoclet.get('function'),
        hasConstant: hasSubDoclet.get('constant'),
        hasMember: hasSubDoclet.get('member'),
        example: util.example
      }
    );
    logger.debug('doclet', viewModel.doclet);
    util.view('doclet.rst', viewModel, cb);
  };
}
