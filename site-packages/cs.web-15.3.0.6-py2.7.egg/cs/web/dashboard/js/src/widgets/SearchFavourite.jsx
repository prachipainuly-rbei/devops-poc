/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: SearchFavourite.jsx 178124 2018-06-01 07:37:45Z bwf $"
 */

import React from 'react';
import {PropTypes, ImmutablePropTypes, connect} from 'cs-web-components-externals';
import {SearchApi, Button} from 'cs-web-components-base';
import {formatStrWithDomain} from '../i18n.js';
import DashboardItem from '../DashboardItem.jsx';

let instanceCounter = 0;

class SearchFavouriteWidget extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            showConfig: false,
        };
        this.instanceName = `${componentNameSpace}-SearchFavouriteWidget-${++instanceCounter}`;
        this.selectedFavourite = null;
        this.openConfig = this.openConfig.bind(this);
        this.cancelConfig = this.cancelConfig.bind(this);
        this.saveConfig = this.saveConfig.bind(this);
    }

    componentDidMount() {
        const {item, createSearchInstance} = this.props;
        createSearchInstance(this.instanceName);
        const favouriteSettings = item.getIn(['settings', 'favourite']);
        this.triggerSearch(favouriteSettings);
    }

    componentWillReceiveProps(nextProps) {
        const settings = this.props.item.getIn(['settings', 'favourite']);
        const nextSettings = nextProps.item.getIn(['settings', 'favourite']);
        if (settings !== nextSettings) {
            this.triggerSearch(nextSettings);
        }
    }

    triggerSearch(favouriteSettings) {
        if (favouriteSettings !== undefined) {
            const {initClassSearch, selectFavourite} = this.props;
            const classname = favouriteSettings.get('classname');
            const favouriteId = favouriteSettings.get('id');
            if (classname) {
                initClassSearch(classname);
                if (favouriteId) {
                    selectFavourite(this.instanceName, classname, favouriteId);
                }
            }
        }
    }

    openConfig() {
        this.setState({showConfig: true});
    }

    cancelConfig() {
        this.setState({showConfig: false});
    }

    saveConfig(classname, favouriteId) {
        const {item, setSettings} = this.props;
        this.setState({showConfig: false});
        setSettings(item, {favourite: {classname, id: favouriteId}});
    }

    renderInputDialog(title) {
        if (!this.state.showConfig) {
            return null;
        }
        const {item} = this.props;
        return (
            <SearchApi.FavouriteSelectorDialog
                instanceName={this.instanceName}
                initialClassname={item.getIn(['settings', 'favourite', 'classname'])}
                initialFavouriteId={item.getIn(['settings', 'favourite', 'id'])}
                title={title}
                onSave={this.saveConfig}
                onCancel={this.cancelConfig} />
        );
    }

    render() {
        const defaultTitle = formatStrWithDomain('select_search_favourite', 'base');
        return (
            <SearchApi.SearchByFavourite instanceName={this.instanceName}>
                {(title, resultArea) => (
                    <DashboardItem
                        item={this.props.item}
                        title={title || defaultTitle}
                        configCallback={this.openConfig}
                    >
                        {this.renderInputDialog(defaultTitle)}
                        {resultArea ?
                        <div className={`${componentNameSpace}-search-favourite`}>
                            {resultArea}
                            </div> :
                            <Button.TextButton
                                buttonStyle="link"
                                label={defaultTitle}
                                onClick={this.openConfig}/>
                        }
                    </DashboardItem>
                )}
            </SearchApi.SearchByFavourite>
        );
    }
}

SearchFavouriteWidget.propTypes = {
    // dashboard item API
    item: ImmutablePropTypes.map.isRequired,
    setSettings: PropTypes.func.isRequired,
    // search actions
    initClassSearch: PropTypes.func.isRequired,
    createSearchInstance: PropTypes.func.isRequired,
    selectFavourite: PropTypes.func.isRequired
};

export default connect(null, SearchApi.Actions)(SearchFavouriteWidget);
