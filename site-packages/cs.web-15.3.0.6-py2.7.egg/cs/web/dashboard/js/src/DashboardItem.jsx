/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: DashboardItem.jsx 178730 2018-06-11 09:27:47Z vov $"
 */

import React from 'react';
import {Button, ButtonGroup, ContentBlock, SVGIcon} from 'cs-web-components-base';
import {PropTypes, ImmutablePropTypes, connect, ReactDnD} from 'cs-web-components-externals';
import {
    deleteItem, moveItemBefore, revertMoveItem, finalizeMoveItem, setItemCollapsed,
    duplicateItem
} from './actions.js';
import {DASHBOARD_ITEM_DND_TYPE, DASHBOARD_STORE} from './constants.js';
import {formatStr} from './i18n.js';

import appLinkIcon from '../../resources/cis_open-external.svg';
import cis_trash from '../../resources/cis_trash.svg';
import cis_copy from '../../resources/cis_copy.svg';

const itemSource = {
    beginDrag(props) {
        return {origItem: props.item};
    },
    endDrag(props, monitor) {
        const {origItem} = monitor.getItem();
        if (monitor.didDrop()) {
            props.finalizeMoveItem(origItem);
        }
        else {
            props.revertMoveItem(origItem);
        }
    }
};

const itemTarget = {
    canDrop() {
        return false;
    },
    hover(props, monitor) {
        const {origItem} = monitor.getItem();
        const {item: overItem} = props;
        if (overItem.get('cdb_object_id') !== origItem.get('cdb_object_id')) {
            props.moveItemBefore(origItem.get('cdb_object_id'), overItem.get('cdb_object_id'));
        }
    }
};

function collectDrag(connect, monitor) {
    return {
        connectDragSource: connect.dragSource(),
        connectDragPreview: connect.dragPreview(),
        isDragging: monitor.isDragging()
    };
}

function collectDrop(connect) {
    return {
        connectDropTarget: connect.dropTarget()
    };
}

/**
 * A DashboardItem must be used by every widget implementation to render the
 * outer frame of an element. The react children of the DashboardItem will be
 * rendered as the element's body.
 *
 * React Properties
 * ================
 *
 * +----------------+---------------+---------+-------------------------------------------------------+
 * | Property       | Type          | Default | Use                                                   |
 * +================+===============+=========+=======================================================+
 * | item           | Immutable.Map | -       | Data to be displayed in the element                   |
 * +----------------+---------------+---------+-------------------------------------------------------+
 * | title          | string        | -       | A string to be rendered as the element's title        |
 * +----------------+---------------+---------+-------------------------------------------------------+
 * | configCallback | function      | -       | Configuration callback to store settings              |
 * +----------------+---------------+---------+-------------------------------------------------------+
 * | appLink        | string        | -       | A string containing an application url. If specified  |
 * |                |               |         | a button in the upright corner will be shown to       |
 * |                |               |         | this application.                                     |
 * +----------------+---------------+---------+-------------------------------------------------------+
 * | appNewWindow   | bool          | false   | Specifies wether or not to open the linked            |
 * |                |               |         | application in a new tab / window.                    |
 * +----------------+---------------+---------+-------------------------------------------------------+
 *
 * The `item` holds some system defined properties for use by the framework, and a
 * key `settings` that is also an Immutable.Map, and contains the data for a
 * specific element. This property is passed to the widget implementation by the
 * framework, and must be forwarded as is to the DashboardItem.
 *
 * If `configCallback` is present, the DashboardItem will render a configuration
 * button in the element's header that will call this function. The function
 * should display some UI to configure the element, and finally call the Redux
 * action method `setSettings` to store the configuration.
 */
class DashboardItem extends React.Component {
    constructor(props) {
        super(props);
        this.deleteItem = this.deleteItem.bind(this);
        this.duplicateItem = this.duplicateItem.bind(this);
        this.toggleExpansion = this.toggleExpansion.bind(this);
    }

    deleteItem() {
        this.props.deleteItem(this.props.item);
    }

    duplicateItem() {
        this.props.duplicateItem(this.props.item);
    }

    toggleExpansion(expanded) {
        this.props.setItemCollapsed(this.props.item, !expanded);
    }

    renderTitle() {
        const {title} = this.props;
        return (
            <div className={`${componentNameSpace}-dashboard__item-title`} title={title}>
                {title}
            </div>
        );
    }

    render() {
        const {item, configCallback, connectDropTarget, connectDragSource,
            appLink, appNewWindow, editModeActive} = this.props;
        return connectDropTarget(
            <div className={`${componentNameSpace}-dashboard__item`}>
                <ContentBlock
                        collapsible={this.props.itemCollapsible}
                        expanded={!item.get('collapsed')}
                        title={this.renderTitle()}
                        headerDragger={connectDragSource}
                        onExpansionChanged={this.toggleExpansion}>
                    <ContentBlock.Header>
                        {editModeActive ? (
                            <ButtonGroup>
                                <Button.IconButton
                                    onClick={this.duplicateItem}
                                    iconSrc={cis_copy}
                                    buttonStyle="success"
                                    title={formatStr('duplicate_widget')} />
                                {(configCallback === undefined) ? null : (
                                    <Button.SettingsButton
                                        onClick={configCallback}
                                        title={formatStr('edit_button')} />
                                )}
                                <Button.IconButton
                                    onClick={this.deleteItem}
                                    iconSrc={cis_trash}
                                    title={formatStr('delete_button')}
                                    buttonStyle="danger"/>
                            </ButtonGroup>
                            ) : null
                        }
                        {(appLink === undefined || editModeActive) ? null : (
                            <a href={appLink} onClick={() => {
                                if (appNewWindow) {
                                    window.open(appLink);
                                } else {
                                    window.location = appLink;
                                }
                            }}>
                                <SVGIcon src={appLinkIcon} size="sm" />
                            </a>
                        )

                        }
                    </ContentBlock.Header>
                    <ContentBlock.Body>
                        <div className={`${componentNameSpace}-dashboard__item-body`}>
                            {this.props.children}
                        </div>
                    </ContentBlock.Body>
                </ContentBlock>
            </div>
        );
    }
}
DashboardItem.propTypes = {
    item: ImmutablePropTypes.map.isRequired,
    title: PropTypes.string,
    configCallback: PropTypes.func,
    appLink: PropTypes.string,
    appNewWindow: PropTypes.bool,
    itemCollapsible: PropTypes.bool.isRequired,
    editModeActive: PropTypes.bool.isRequired,
    // injected by connect
    deleteItem: PropTypes.func.isRequired,
    duplicateItem: PropTypes.func.isRequired,
    moveItemBefore: PropTypes.func.isRequired,
    revertMoveItem: PropTypes.func.isRequired,
    finalizeMoveItem: PropTypes.func.isRequired,
    setItemCollapsed: PropTypes.func.isRequired,
    // injected by DnD
    connectDragSource: PropTypes.func.isRequired,
    connectDragPreview: PropTypes.func.isRequired,
    connectDropTarget: PropTypes.func.isRequired
};
DashboardItem.defaultProps = {
    title: '',
    itemCollapsible: true,
    appNewWindow: false
};

function mapStateToProps(state) {
    const store = state[DASHBOARD_STORE];
    const editMode = store.get('editMode', false);
    return {
        editModeActive: editMode
    };
}

const actions = {
    deleteItem, moveItemBefore, revertMoveItem, finalizeMoveItem, setItemCollapsed,
    duplicateItem
};
export default
    connect(mapStateToProps, actions)(
        ReactDnD.DropTarget(DASHBOARD_ITEM_DND_TYPE, itemTarget, collectDrop)(
            ReactDnD.DragSource(DASHBOARD_ITEM_DND_TYPE, itemSource, collectDrag)(
                DashboardItem
            )
        )
    );
