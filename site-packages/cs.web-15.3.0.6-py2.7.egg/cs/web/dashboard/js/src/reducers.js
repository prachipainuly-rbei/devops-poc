/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: reducers.js 185829 2018-10-29 15:15:13Z sla $"
 */

import Immutable from 'immutable';
import {Actions} from './constants.js';

function normalize(state, xpos) {
    const sortedItems =
        state.filter(item => item.get('xpos') === xpos)
            .valueSeq()
            .sortBy(item => item.get('ypos'));
    const positions = Immutable.Range(1, sortedItems.size + 1);
    return state.mergeDeep(
        Immutable.Map(
            sortedItems
                .zipWith((item, ypos) => item.set('ypos', ypos), positions)
                .map(item => [item.get('cdb_object_id'), item]))
    );
}

const initialState = Immutable.fromJS({
    dashboards: {},
    items: {},
    activeIndex: 0,
    errorOccurred: false,
    loadingState: true,
});

export default function(state = initialState, action) {
    switch (action.type) {
        case Actions.SET_DASHBOARD: {
            return state.updateIn(['dashboards'],
                dbs => dbs.mergeDeep(action.payload.dashboards).sortBy(
                    db => db.get('position_index')
                )
            );
        }
        case Actions.CREATED_DASHBOARD: {
            const dashboards = state.get('dashboards').set(
                action.payload.cdb_object_id, Immutable.fromJS(action.payload)
            );
            const new_state = state.set('dashboards', dashboards);
            return new_state.set('activeIndex', dashboards.size - 1);
        }
        case Actions.SWITCH_DASHBOARD:
            return state.set('activeIndex', action.payload);
        case Actions.SET_EDIT_MODE:
            return state.set('editMode', action.payload);
        case Actions.SET_LOADING_STATE:
            return state.set('loadingState', true);
        case Actions.CREATE_DASHBOARD_FAILED:
            return state.set('errorOccurred', true);
        case Actions.DASHBOARD_DELETED: {
            const dashboards = state.get('dashboards').filter((dashboard) => {
                return dashboard.get('cdb_object_id') !== action.payload.dboard_id;
            });
            let new_state = state.set('dashboards', dashboards);
            new_state = new_state.set('editMode', false);
            new_state = new_state.set('activeIndex', 0);
            return new_state;
        }
        case Actions.SWITCH_LAYOUT: {
            const dashboard = state.get('dashboards').get(action.payload.dboard_id).set(
                'layout', action.payload.layout
            );
            const dashboards = state.get('dashboards').set(
                action.payload.dboard_id, dashboard
            );
            return state.set('dashboards', dashboards);
        }
        case Actions.RENAME_DASHBOARD: {
            const dashboard = state.get('dashboards').get(action.payload.dboard_id).set(
                'name', action.payload.name
            );
            const dashboards = state.get('dashboards').set(
                action.payload.dboard_id, dashboard
            );
            return state.set('dashboards', dashboards);
        }
        case Actions.INIT_ITEMS: {
            const items = Immutable.fromJS(action.payload.items);
            const newItems =
                state.get('items')
                    .filter((val, key) => items.has(key))
                    .mergeDeep(items);
            return state.set('items', newItems).set('loadingState', false);
        }
        case Actions.CREATE_ITEM:
            return state.setIn(
                ['items', action.payload.cdb_object_id], Immutable.fromJS(action.payload));
        case Actions.CREATED_ITEM:
            return state
                .deleteIn(['items', action.meta.tempId])
                .setIn(['items', action.payload.cdb_object_id], Immutable.fromJS(action.payload));
        case Actions.CREATE_ITEM_FAILED:
            return state.set('errorOccurred', true).set('loadingState', false);
        case Actions.DELETE_ITEM:
            return state.deleteIn(['items', action.payload.get('cdb_object_id')]);
        case Actions.MOVE_ITEM_BEFORE: {
            const {id, beforeId} = action.payload;
            const newX = state.getIn(['items', beforeId, 'xpos']);
            const newY = state.getIn(['items', beforeId, 'ypos']);
            // Just put the item into the gap, so that no other positions have
            // to be changed. Positions will be normalized later when the drop
            // is successful. If it is not, the move can easily be reverted.
            return state.mergeIn(['items', id], {xpos: newX, ypos: newY - 0.5});
        }
        case Actions.REVERT_MOVE_ITEM: {
            const origItem = action.payload;
            const data = {xpos: origItem.get('xpos'), ypos: origItem.get('ypos')};
            return state.mergeIn(['items', origItem.get('cdb_object_id')], data);
        }
        case Actions.MOVE_ITEM_TO_COLUMN: {
            const {id, column} = action.payload;
            const maxPos =
                state.get('items')
                    .filter(item => item.get('xpos') === column)
                    .filter(item => item.get('cdb_object_id') !== id)
                    .map(item => item.get('ypos'))
                    .valueSeq()
                    .max();
            const data = {xpos: column, ypos: (maxPos === undefined) ? 1 : maxPos + 1};
            return state.mergeIn(['items', id], data);
        }
        case Actions.NORMALIZE_POSITIONS: {
            const origItem = action.payload;
            const origXpos = origItem.get('xpos');
            const newXpos = state.getIn(['items', origItem.get('cdb_object_id'), 'xpos']);
            let newItems = normalize(state.get('items'), origXpos);
            if (newXpos !== origXpos) {
                newItems = normalize(newItems, newXpos);
            }
            return state.set('items', newItems);
        }
        case Actions.SET_SETTINGS: {
            const {item, settings} = action.payload;
            return state.mergeDeepIn(['items', item.get('cdb_object_id'), 'settings'], settings);
        }
        case Actions.UPDATE_ITEM: {
            const item = action.payload;
            return state.mergeDeepIn(['items', item.cdb_object_id], item);
        }
        case Actions.SET_ITEM_COLLAPSED: {
            const {item, collapsed} = action.payload;
            return state.setIn(['items', item.get('cdb_object_id'), 'collapsed'], collapsed);
        }
        default:
            return state;
    }
}
