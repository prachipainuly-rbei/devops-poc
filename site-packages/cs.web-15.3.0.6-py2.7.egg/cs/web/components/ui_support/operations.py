#!/usr/bin/env powerscript
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

"""
Morepath app to access configured operations.
"""

__revision__ = "$Id: operations.py 185872 2018-10-30 12:13:29Z mbr $"

import urllib

from webob.exc import HTTPNotFound, HTTPBadRequest

from cdbwrapc import (Operation, OperationInfo, RelshipContext,
                      kObjectType, kHtmlViewType, kClassType)
from cdb import cmsg
from cdb import constants
from cdb import misc
from cdb import ElementsError
from cdb import sqlapi
from cdb.objects.core import class_from_handle
from cdb.platform.gui import Message
from cdb.platform.mom import SimpleArgument, SimpleArguments
from cdb.platform.mom.entities import CDBClassDef
from cs.platform.web.rest import get_collection_app
from cs.platform.web.rest.generic import convert
from cs.platform.web.rest.support import rest_objecthandle, rest_objecthandles
from cs.platform.web.uisupport.resttable import RestTableWrapper
from cs.platform.web.uisupport import get_ui_link, get_webui_link
from . import App
from .forms import FormSettings, FormSettingsRelship


class SimpleWebUIArguments(SimpleArguments):
    """
    List of SimpleArguments. The constructor automatically adds
    an argument, that gives the operation a hint that it is run
    with the WebUI.
    """
    def __init__(self, **kwargs):
        """
        Converts the key-value pairs given in `kwargs` to
        `SimpleArgument` objects and appends them to `self`.
        """
        SimpleArguments.__init__(self, **kwargs)
        try:
            name = constants.kArgumentUsesWebUI
        except:
            # variable has been introduced with 15.2.21
            name = "cdb::argument.uses_web_ui"
        if name not in kwargs:
            self.append(SimpleArgument(name, "1"))


def _op_info_data(op_info, request,
                  run_operation_model=None,
                  form_settings_model=None):
    """
    Render the information about an operation available to the frontend
    """
    try:
        clname = op_info.get_classname()
        if clname:
            cdef = CDBClassDef(clname)
        else:
            cdef = None
    except AttributeError, e:
        raise HTTPNotFound(unicode(e))
    except ElementsError, e:
        raise HTTPNotFound(unicode(e))

    # We can only add ops without a relship context if we
    # are an IIOP-Server. So only handle this kind of ops
    # if no external models are given
    add_cl_ops = misc.CDBApplicationInfo().rootIsa(misc.kAppl_IIOPServer) and \
                 not run_operation_model and not form_settings_model
    opname = op_info.get_opname()
    iconurls = op_info.get_icon_urls()

    try:
        # New function - not available in previous SLs
        prefer_webui = not add_cl_ops or not op_info.prefer_winui()
    except AttributeError:
        prefer_webui = True

    try:
        menu_visible_webui = op_info.is_visible_webui()
    except:
        # New function - use old value
        menu_visible_webui = op_info.is_visible()

    # Standard values
    essential = False
    form_settings = None
    run_op = None
    presentation_id = None
    url = None
    activation_mode = op_info.get_activation_mode()
    if op_info.offer_in_webui() and prefer_webui:
        if form_settings_model is None:
            form_settings = FormSettings(opname, cdef)
        else:
            form_settings = form_settings_model
        if run_operation_model is None:
            run_op = RunOperationClassModel(clname, opname)
        else:
            run_op = run_operation_model
        essential = op_info.is_essential_op()
        presentation_id = op_info.get_render_comp_id()
    else:
        if add_cl_ops and op_info.is_visible_webui() and cdef:
            msg = cmsg.Cdbcmsg(clname, opname, True)
            # Add the keys for object operations
            if activation_mode == 3:
                # We do not have urls for multi selection so reduce
                # to single selection
                activation_mode = 2
            if activation_mode == 2:
                for key in cdef.getKeyNames():
                    msg.add_item(key, cdef.getPrimaryTable(), "${%s}" % key)
            # We have to unquote because of the {var} syntax
            # We only use variable names so the url cannot contain any
            # other dangerous char
            url = urllib.unquote(msg.cdbwin_url())
            essential = op_info.is_essential_op()

    return {"label": op_info.get_label(),
            "opname": opname,
            "creates_object": op_info.creates_object(),
            "menu_path": op_info.get_label_path(False),
            "menu_visible_winclient": op_info.is_visible(),
            "menu_visible": menu_visible_webui,
            "classname": clname if clname else None,
            "tooltip": op_info.get_tooltip(),
            "icon": ("/%s" % iconurls[0]) if iconurls else None,
            "form_url": request.link(form_settings) if form_settings else None,
            "submit_url": request.link(run_op) if run_op else None,
            "activation_mode": activation_mode,
            "essential": essential,
            "presentation_id": presentation_id,
            "target_url": url,
            "menugroup": op_info.get_menugroup(),
            "ordering": op_info.get_order()}


# access to operations via operation contexts ---


class OpContextModel(object):
    def __init__(self, context_name, classname):
        self.context_name = context_name
        self.classname = classname


@App.path(path="operation/context/{context_name}/{classname}", model=OpContextModel)
def _operation_context_path(context_name, classname):
    return OpContextModel(context_name, classname)


@App.json(model=OpContextModel)
def _get_op_context(model, request):
    try:
        cdef = CDBClassDef(model.classname)
    except ElementsError, e:
        raise HTTPNotFound(unicode(e))
    return [_op_info_data(op_info, request)
            for op_info in cdef.getOperationInfos(False, model.context_name)
            if op_info]


# getting operation infos for a single operation for a class ---


@App.path(path="operation/class/{classname}/{opname}", model=OperationInfo)
def _operation_info_path(classname, opname):
    return OperationInfo(classname, opname)


@App.json(model=OperationInfo)
def _get_op_info(model, request):
    return _op_info_data(model, request)


# getting operation infos for a class ---


class OperationInfoClass(object):
    """
    Morepath model class to retrieve all operations for
    a class (without context)
    """
    def __init__(self, classname):
        self.classname = classname

    def getOperationInfos(self, visible):
        """
        Retrieve all operation infos for the
        class provided during construction.
        If `visible` is ``True`` only the operations
        that are marked as menu visible for the user are returned.
        """
        return CDBClassDef(self.classname).getOperationInfos(visible)


@App.path(path="operation/class/{classname}", model=OperationInfoClass)
def _operation_info_class_path(classname):
    return OperationInfoClass(classname)


@App.json(model=OperationInfoClass)
def _get_op_info_class(model, request):
    try:
        return [_op_info_data(op_info, request)
                for op_info in model.getOperationInfos(False)
                if op_info]

    except ElementsError, e:
        raise HTTPNotFound(unicode(e))


# getting operation info for a single operation in a relationship context

class RSReferenceOperationInfo(object):
    """
    Morepath model class to retrieve a single operation info for the reference
    class of a relationship.
    """
    def __init__(self, parent_classname, keys, relship_name, opname):
        """
        Class used to retrieve operation info for the relationship
        `relship_name` called for the parent object identified by
        `parent_classname` and the REST key `keys`.
        """
        self.parent_classname = parent_classname
        self.keys = keys
        self.relship_name = relship_name
        self.opname = opname


@App.path(path="operation/relship/reference/{parent_classname}/{keys}/{relship_name}/{opname}",
          model=RSReferenceOperationInfo)
def _rs_operation_info_path(parent_classname, keys, relship_name, opname):
    return RSReferenceOperationInfo(parent_classname, keys, relship_name, opname)


@App.json(model=RSReferenceOperationInfo)
def _rs_operation_info_view(model, request):
    """
    """
    oir = OperationInfoRelship(model.parent_classname,
                               model.keys,
                               model.relship_name)
    ref_info = oir.getOperationInfo().get_reference_op_info()
    ois = ref_info.get_opinfo_list()
    for oi in ois:
        if oi.get_configured_opname() == model.opname:
            return (_op_info_data(oi,
                                  request,
                                  oir.run_operation_model(oi),
                                  oir.form_settings_model(oi)))


# getting operation infos for relationships ---

class OperationInfoRelship(object):
    """
    Morepath model class to retrieve the operations for a relationship context
    """
    def __init__(self, parent_classname, keys, relship_name):
        self.parent_classname = parent_classname
        self.keys = keys
        self.relship_name = relship_name

    def getOperationInfo(self):
        """
        Returns the `RelshipOperationInfo` object for the specific operation.
        """
        hndl = rest_objecthandle(CDBClassDef(self.parent_classname), self.keys)
        rc = RelshipContext(hndl, self.relship_name)
        return rc.getOperationInfo()

    def run_operation_model(self, op_info):
        return RunOperationRelshipModel(self.parent_classname,
                                        self.keys,
                                        self.relship_name,
                                        op_info.get_opname())

    def form_settings_model(self, op_info):
        return FormSettingsRelship(self.parent_classname,
                                   self.keys,
                                   self.relship_name,
                                   op_info.get_opname(),
                                   target_classname=op_info.get_classname())


@App.path(path="operation/relship/{parent_classname}/{keys}/{relship_name}",
          model=OperationInfoRelship)
def _relship_operation_info_relship_path(parent_classname, keys, relship_name):
    return OperationInfoRelship(parent_classname, keys, relship_name)


@App.json(model=OperationInfoRelship)
def _get_op_info_relship(model, request):
    def _get_rsopinfo(key, rsopinfo, model, request):
        result = {}
        opinfos = rsopinfo.get_opinfo_list()
        if opinfos:
            result[key] = (rsopinfo.get_label(),
                           [_op_info_data(op_info, request,
                                          model.run_operation_model(op_info),
                                          model.form_settings_model(op_info))
                            for op_info in opinfos if op_info])
        return result

    info = model.getOperationInfo()
    result = {}
    result.update(_get_rsopinfo("link_opinfo",
                                info.get_link_op_info(),
                                model,
                                request))
    result.update(_get_rsopinfo("reference_opinfo",
                                info.get_reference_op_info(),
                                model,
                                request))
    return result


# helper functions for building & executing an operation from a request ---

def _extract_values(request_data):
    # Combine additional_params and values into a single argument list for
    # the operation. For keys that exist in both dicts, values (ie. the
    # values entered by the user in the form fields) take precedence.
    values = request_data.get("additional_params", {})
    values.update(request_data.get("values", {}))
    operation_state = request_data.get("operation_state")
    if operation_state:
        type_info = operation_state.get("json_field_types")
        if type_info:
            for attr, typeinfo in type_info.iteritems():
                if typeinfo == sqlapi.SQL_DATE and attr in values:
                    json_value = values[attr]
                    if json_value:
                        values[attr] = convert.load_datetime(json_value)
                if attr not in values:
                    values[attr] = None
    return (values, operation_state)


def _make_target(request_data, target_classdef, opname):
    # The operation target is either a single object, if a string ID is given,
    # or a list of objects if a list of IDs is given.
    object_navigation_id = request_data.get("object_navigation_id")
    clnames = set()
    if object_navigation_id is None or object_navigation_id == []:
        target = None
        clnames.add(target_classdef.getClassname())
    else:
        if isinstance(object_navigation_id, basestring):
            oids = [object_navigation_id]
        else:
            oids = object_navigation_id
        targets = rest_objecthandles(target_classdef, oids)
        if len(targets) == 1:
            target = targets[0]
        else:
            target = targets
    # Check if the operation is activated for all classes
    for clname in clnames:
        op_cfg = OperationInfo(clname, opname)
        if not op_cfg or not op_cfg.offer_in_webui():
            error = Message.GetMessage("csweb_err_op_not_available",
                                       opname,
                                       clname)
            raise ElementsError(error)
    return target


def _run_operation(request, op):
    op.run()
    result_type, result_value = op.get_result()
    result = {'result_type': result_type}
    if result_type == kObjectType:
        if result_value.is_valid():
            cls = class_from_handle(result_value)
            result_object = cls._FromObjectHandle(result_value)
            result_rest_data = request.view(result_object,
                                            app=get_collection_app(request))
            # Check if result_rest_data is dict.
            # If we operate on CDB_File, it will be a 'Response' object,
            # instead of dict.
            if isinstance(result_rest_data, dict):
                # The operation always returns the web_ui_link. This allows to avoid navigation
                # when using web ui pages in the Windows Client, while custom handlers may use
                # the context-dependent URL. See E041117.
                ui_link = get_ui_link(request, result_object)
                web_ui_link = get_webui_link(request, result_object)
                result['object'] = result_rest_data
                if ui_link:
                    result['ui_link'] = ui_link
                if web_ui_link:
                    result['web_ui_link'] = web_ui_link
    elif result_type == kHtmlViewType:
        # Elements UI uses web_ui_link field, so we provide that too, see E046292
        result.update({'ui_link': result_value[0],
                       'web_ui_link': result_value[0],
                       'view_extern': result_value[1]})
    elif result_type == kClassType:
        request_data = request.json
        tableName = request_data.get("tableName", "")
        rest_table = result_value.as_table(tableName)
        result.update(RestTableWrapper(rest_table).get_rest_data(request))

    return result


# running operations without context ---


class RunOperationClassModel(object):
    """
    Morepath model class to execute an operation without a context
    """
    def __init__(self, classname, opname):
        self.classname = classname
        self.opname = opname


@App.path(path="operation/class/{classname}/{opname}/run", model=RunOperationClassModel)
def _run_operation_class_path(classname, opname):
    return RunOperationClassModel(classname, opname)


@App.json(model=RunOperationClassModel, request_method='POST')
def _run_operation_class(model, request):
    """ To initiate configured operations on an object, a POST request is used.
        The name and classdef of the operation are computed from the URL, the
        arguments to use are contained in the request body.

        The arguments must conform to the internal formats, independent of the
        user's settings like date formats or decimal separators.
    """
    try:
        op = None
        request_data = request.json
        (values, operation_state) = _extract_values(request_data)
        target_classdef = CDBClassDef(model.classname)
        target = _make_target(request_data, target_classdef, model.opname)
        if target is None:
            target = model.classname
        if operation_state:
            op = Operation(operation_state, SimpleWebUIArguments(**values))
        else:
            op = Operation(model.opname, target, SimpleWebUIArguments(**values))
        return _run_operation(request, op)
    except ElementsError, exc:
        @request.after
        def set_status(response):
            response.status_code = 403

        result = op.getOperationResult() if op else {}
        result['message'] = '%s' % exc
        return result


# running operations in relationship context ---


class RunOperationRelshipModel(object):
    """
    Morepath model class to execute an operation in a relationship context
    """
    def __init__(self, parent_classname, keys, relship_name, opname):
        self.parent_classname = parent_classname
        self.keys = keys
        self.relship_name = relship_name
        self.opname = opname


@App.path(path="operation/relship/{parent_classname}/{keys}/{relship_name}/{opname}/run",
          model=RunOperationRelshipModel)
def _run_operation_relship_path(parent_classname, keys, relship_name, opname):
    return RunOperationRelshipModel(parent_classname, keys, relship_name, opname)


@App.json(model=RunOperationRelshipModel, request_method='POST')
def _run_operation_relship(model, request):
    """ See _run_operation_class above
    """
    try:
        op = None
        request_data = request.json
        (values, operation_state) = _extract_values(request_data)
        if operation_state:
            op = Operation(operation_state, SimpleWebUIArguments(**values))
        else:
            parent_handle = rest_objecthandle(CDBClassDef(model.parent_classname), model.keys)
            if not parent_handle.exists():
                msg = "Parent object %s / %s not found" % (model.parent_classname, model.keys)
                raise HTTPBadRequest(detail=msg)
            relship_ctx = RelshipContext(parent_handle, model.relship_name)
            target_classdef = relship_ctx.get_rship_def().get_reference_cldef()
            target = _make_target(request_data, target_classdef, model.opname)
            if target:
                op = relship_ctx.operation(model.opname, target, SimpleWebUIArguments(**values))
            else:
                op = relship_ctx.operation(model.opname, SimpleWebUIArguments(**values))
        return _run_operation(request, op)
    except ElementsError, exc:
        @request.after
        def set_status(response):
            response.status_code = 403

        result = op.getOperationResult() if op else {}
        result['message'] = '%s' % exc
        return result
