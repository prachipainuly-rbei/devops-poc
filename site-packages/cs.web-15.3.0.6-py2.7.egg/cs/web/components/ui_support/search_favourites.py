#!/usr/bin/env powerscript
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

"""
Objects classes and morepath views to manage search favourites.
"""

__revision__ = "$Id: search_favourites.py 180410 2018-07-11 14:36:11Z yaz $"

import itertools
from webob.exc import HTTPNoContent, HTTPForbidden

from cdb import auth
from cdb import sqlapi
from cdb import transactions
from cdb import constants
from cdb.platform.mom.entities import CDBClassDef
from cdb.platform.mom.operations import OperationInfo
from cdb.util import get_roles, PersonalSettings, get_label
from cdb.objects import Object, Reference_N, Forward
from cs.platform.web.uisupport import App as UI_SupportApp, get_uisupport
from cs.platform.web.rest.support import getRESTVisibleClasses
from cs.web.components.history.main import get_history_app
from cs.web.components.history.model import HistoryCollection
from cs.web.components.favorites.main import get_favorites_app
from cs.web.components.favorites.model import FavoriteCollection

SearchFavourite = Forward(__name__ + ".SearchFavourite")
SearchFavouriteParam = Forward(__name__ + ".SearchFavouriteParam")

_SETTINGS_KEY = 'cs.web.search_favourite'

# The stable object id that is used for the special search favourite "recently
# used"
_LAST_OBJECTS_FAVOURITE_ID = '018f6d70-b0a8-11e6-9207-005056c00008'

# The stable object id that is used for the special search favourite "my favorites"
_OBJECT_FAVORITES_FAVOURITE_ID = 'c865c307-6a24-4861-b9e1-fdddde507542'

# The stable object id that is used for the special search favourite "all"
_ALL_OBJECTS_FAVOURITE_ID = '622ab080-d417-11e6-b2c0-e4a471c02050'


class SearchFavourite(Object):
    __maps_to__ = "csweb_search_favourites"
    __classname__ = "csweb_search_favourites"

    Params = Reference_N(SearchFavouriteParam,
                         SearchFavouriteParam.favourite_id == SearchFavourite.cdb_object_id)

    @classmethod
    def LocalNameAttr(cls):
        return cls.name.getLanguageField().name

    @classmethod
    def MyFavourites(cls):
        persno = auth.persno
        pers_clause = "subject_type = 'Person' AND subject_id = '%s'" % sqlapi.quote(persno)
        my_roles = get_roles("GlobalContext", "", persno)
        role_clause = ("subject_type = 'Common Role' AND subject_id in (%s)"
                       % (", ".join(["'%s'" % sqlapi.quote(r) for r in my_roles])))
        qry = "((%s) OR (%s))" % (pers_clause, role_clause)
        return cls.Query(qry)

    def is_readonly(self):
        return self.subject_type != 'Person'

    def to_json(self, params, request):
        """ Return a structure suitable for conversion to JSON. Note that the
            actual position values of the parameters are not transmitted, but
            the order is preserved as the order in the list.
        """
        return {'@id': request.link(self),
                'cdb_object_id': self.cdb_object_id,
                'name': self.name,
                'classname': self.classname,
                'readonly': self.is_readonly(),
                'params': [{'attribute': param.attribute,
                            'value': param.value}
                           for param in sorted(params, key=lambda p: p.position)]
                }

    def update_from_request(self, request):
        """ Update this favourite from an HTTP PUT request. Only the name and
            the params may change, plus the setting for the default favourite.
            All other values from the frontend are ignored.
        """
        request_data = request.json
        if request_data['name'] != self.name:
            name_attr = SearchFavourite.LocalNameAttr()
            self.Update(**{name_attr: request_data['name']})
        # Just drop the params and create new entries from the request. This is
        # not performance critical, so avoid complex logic to determine the
        # minimal set of updates,
        self.Params.Delete()
        new_params = SearchFavouriteParam.ParamsFromData(self.cdb_object_id,
                                                         request_data['params'])
        return self.to_json(new_params, request)


class SearchFavouriteParam(Object):
    __maps_to__ = "csweb_search_fav_params"
    __classname__ = "csweb_search_fav_params"

    @classmethod
    def ParamsFromData(cls, favourite_id, request_data):
        return [SearchFavouriteParam.Create(favourite_id=favourite_id,
                                            attribute=param['attribute'],
                                            value=param['value'],
                                            position=pos)
                for (param, pos) in itertools.izip(request_data,
                                                   itertools.count())]


class SearchFavouriteCollection(object):
    def __init__(self, classname):
        self.classname = classname

    def make_link(self, request):
        return request.link(self, app=get_uisupport(request))

    @classmethod
    def template_link(cls, request):
        return request.class_link(SearchFavouriteCollection,
                                  {"classname": "${classname}"},
                                  app=get_uisupport(request))

    @classmethod
    def add_special_favourites(cls, classname, result, request):
        """ Add entries that should appear as a search favourite in the UI, but
            is defined by special logic in the backend. The UI looks at the
            `resultLink` key to distinguish between the normal and the special
            entries, and to retrieve the objects that correspond to the search.
        """
        rest_name = CDBClassDef(classname).getRESTName()

        # A search favourite that returns objects from the history
        last_objects = {
            'cdb_object_id': _LAST_OBJECTS_FAVOURITE_ID,
            'name': get_label('web.favorites.history'),
            'iconName': 'csweb_history',
            'classname': classname,
            'readonly': True,
            'params': [],
            'resultLink': request.class_link(HistoryCollection,
                                             {'rest_name': rest_name,
                                              'as_table': ''},
                                             app=get_history_app(request))
        }
        result.append(last_objects)

        # A search favourite that returns objects that the user stored as favourites
        favorite_objects = {
            'cdb_object_id': _OBJECT_FAVORITES_FAVOURITE_ID,
            'name': get_label('web.favorites.favorites'),
            'iconName': 'csweb_favorite_added',
            'classname': classname,
            'readonly': True,
            'params': [],
            'resultLink': request.class_link(FavoriteCollection,
                                             {'rest_name': rest_name,
                                              'as_table': ''},
                                             app=get_favorites_app(request))
        }
        result.append(favorite_objects)

        # trigger_search field is a hack: the frontend logic does not trigger the search if no
        # input is given (See E041295, E041413). Since we want the all_objects search favorite
        # to trigger the search nonetheless, the frontend will do this if trigger_search is set.
        all_objects = {
            'cdb_object_id': _ALL_OBJECTS_FAVOURITE_ID,
            'name': get_label('web.favorites.all'),
            'classname': classname,
            'readonly': True,
            'params': [],
            'trigger_search': True
        }
        result.append(all_objects)
        return result

    def to_json(self, request):
        favorites = SearchFavourite.MyFavourites().KeywordQuery(classname=self.classname)
        fav_ids = [f.cdb_object_id for f in favorites]
        if fav_ids:
            params = SearchFavouriteParam.KeywordQuery(favourite_id=fav_ids)
            fav_list = [f.to_json([p for p in params
                                   if p.favourite_id == f.cdb_object_id],
                                  request)
                        for f in favorites]
        else:
            fav_list = []
        fav_list = self.add_special_favourites(self.classname, fav_list, request)
        return {
            'favourites': fav_list,
            'classname': self.classname,
            'classDesignation': CDBClassDef(self.classname).getDesignation(),
            'defaultFavouriteId':
                PersonalSettings().getValueOrDefault(_SETTINGS_KEY,
                                                     self.classname,
                                                     None)
        }

    def new_favourite(self, request):
        request_data = request.json
        name_attr = SearchFavourite.LocalNameAttr()
        data = {name_attr: request_data['name'],
                'classname': self.classname,
                'subject_type': 'Person',
                'subject_id': auth.persno}
        with transactions.Transaction():
            new_fav = SearchFavourite.Create(**data)
            new_params = SearchFavouriteParam.ParamsFromData(new_fav.cdb_object_id,
                                                             request_data['params'])
            return new_fav.to_json(new_params, request)


class AllSearchFavouriteCollection(object):

    def _to_json_by_classname(self, favourites, params, classname, request):
        class_favourites = [f.to_json([p for p in params if p.favourite_id == f.cdb_object_id],
                             request) for f in favourites if f.classname == classname]
        class_favourites = SearchFavouriteCollection.add_special_favourites(classname,
                                                                            class_favourites,
                                                                            request)
        return {
            'favourites': class_favourites,
            'classname': classname,
            'classDesignation': CDBClassDef(classname).getDesignation(),
            'defaultFavouriteId':
                PersonalSettings().getValueOrDefault(_SETTINGS_KEY,
                                                     classname,
                                                     None)
        }

    # Cache for rest enabled classes with search operation allowed
    _Searchable_REST_Activ_Class_Cache = None

    @classmethod
    def get_searchable_classnames(cls):
        if cls._Searchable_REST_Activ_Class_Cache is not None:
            return cls._Searchable_REST_Activ_Class_Cache
        cls._Searchable_REST_Activ_Class_Cache = []
        for cls_name in getRESTVisibleClasses().keys():
            search_config = OperationInfo(cls_name, constants.kOperationSearch)
            if search_config and search_config.offer_in_webui():
                cls._Searchable_REST_Activ_Class_Cache.append(cls_name)
        return cls._Searchable_REST_Activ_Class_Cache

    def to_json(self, request):
        classnames = self.get_searchable_classnames()
        favorites = SearchFavourite.MyFavourites()
        fav_ids = [f.cdb_object_id for f in favorites]
        params = SearchFavouriteParam.KeywordQuery(favourite_id=fav_ids)
        return [self._to_json_by_classname(favorites, params, classname, request)
                          for classname in classnames]

    def make_link(self, request):
        return request.link(self, app=get_uisupport(request))


@UI_SupportApp.path(path="search_favourites/",
                    model=AllSearchFavouriteCollection)
def _all_search_favourites_path():
    return AllSearchFavouriteCollection()


@UI_SupportApp.json(model=AllSearchFavouriteCollection)
def _get_all_search_favourites(model, request):
    return model.to_json(request)


@UI_SupportApp.path(path="search_favourites/by_class/{classname}",
    model=SearchFavouriteCollection)
def _search_favourites_path(classname):
        return SearchFavouriteCollection(classname)


@UI_SupportApp.json(model=SearchFavouriteCollection)
def _get_search_favourites(model, request):
    return model.to_json(request)


@UI_SupportApp.json(model=SearchFavouriteCollection, request_method='POST')
def _new_search_favourite(model, request):
    return model.new_favourite(request)


@UI_SupportApp.json(model=SearchFavouriteCollection, request_method='PUT')
def _set_default_favourite(model, request):
    request_data = request.json
    defaultFavouriteId = request_data.pop('defaultFavouriteId', None)
    if defaultFavouriteId is None:
        del PersonalSettings()[_SETTINGS_KEY, model.classname]
    else:
        PersonalSettings()[_SETTINGS_KEY, model.classname] = defaultFavouriteId
    return {'defaultFavouriteId': defaultFavouriteId}


@UI_SupportApp.path(path="search_favourites/by_id/{cdb_object_id}",
                    model=SearchFavourite)
def _search_favourite_path(cdb_object_id):
    # make sure the caller can't see other users favorites
    result = SearchFavourite.MyFavourites().KeywordQuery(cdb_object_id=cdb_object_id).Execute()
    return result[0] if result else None


@UI_SupportApp.json(model=SearchFavourite)
def _get_search_favourite(model, request):
    return model.to_json(model.Params, request)


@UI_SupportApp.json(model=SearchFavourite, request_method='PUT')
def _change_search_favourite(model, request):
    if model.is_readonly():
        # may only change own favourites
        return HTTPForbidden(detail="Only the callers own favourites may be changed")
    with transactions.Transaction():
        return model.update_from_request(request)


@UI_SupportApp.view(model=SearchFavourite, request_method='DELETE')
def _delete_search_favourite(model, _request):
    if model.is_readonly():
        # may only delete own favourites
        return HTTPForbidden(detail="Only the callers own favourites may be deleted")
    with transactions.Transaction():
        model.Params.Delete()
        model.Delete()
    return HTTPNoContent()
