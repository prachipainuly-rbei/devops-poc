# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
This module contains functions that implements the catalog REST-API.
This API is instable at this time.

Note that POST request are used because the form informations might be too
large to be transferred using the request parameters. They do not alter the
database state as it might be expected during a POST request.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: catalogs.py 177839 2018-05-29 09:57:28Z heiko $"


__all__ = ["CatalogConfig",
           "CatalogItemsModel",
           "CatalogSelectedValuesModel"
           ]

from collections import deque

from cdb import cdbuuid
from cdb import constants
from cdb import misc
from cdb import ElementsError
from cdb import sqlapi
from cdb import typeconversion
from cdb.platform import mom
from cdbwrapc import Operation
from cdbwrapc import RestCatalog
from cdb.platform import gui
from cs.platform.web.rest.generic import convert
from cs.platform.web.rest import get_collection_app, support
from cs.platform.web.uisupport.resttable import RestTableWrapper, TableRowObject
from webob.exc import HTTPForbidden, HTTPGone
from cdb.objects.core import class_from_handle
from cdb.objects.iconcache import IconCache, _LabelValueAccessor
from . import App


class CatalogWithUUID(object):
    """
    Class to provide cached catalogs.
    """
    def __init__(self, catalog):
        self.catalog = catalog
        self.id = cdbuuid.create_uuid()


class CatalogCache(object):
    """
    A cache for catalogs.
    """
    __metaclass__ = misc.Singleton

    def __init__(self):
        self.catalogs = deque()
        self.cache_limit = 5  # the number of catalogs to be cached

    def clear(self):
        """
        Clears the cached structure objects. At this time this is a
        feature for tests that checks if a node can be expanded when
        the structure ist not there.
        """
        self.catalogs = deque()

    def get_catalog(self, catalog_id):
        """
        Returns the catalog stored with the given `catalog_id`.
        """
        result = None
        first = True
        for catalog in self.catalogs:
            if catalog_id == catalog.id:
                result = catalog
                break
            first = False

        if not first and result:
            # Sort to access the recently used elements at the beginning
            self.catalogs.remove(result)
            self.catalogs.appendleft(result)

        if result:
            return result.catalog
        return None

    def add_catalog(self, catalog):
        """
        Adds a catalog to the cache and returns the id that
        has to be used to get the catalog from the cache calling
        `get_catalog`.
        """
        c = CatalogWithUUID(catalog)
        self.catalogs.appendleft(c)
        if len(self.catalogs) > self.cache_limit:
            self.catalogs.pop()
        return c.id

    def remove_catalog(self, catalog_id):
        """
        Remove the catalog with the given `catalog_id`
        from the cache.
        """
        result = None
        for catalog in self.catalogs:
            if catalog_id == catalog.id:
                result = catalog
                break
        if result:
            self.catalogs.remove(result)


class CatalogConfig(object):
    """
    Class to retrieve the catalog configuration.
    Actually the class is used to provide link generation.
    """
    def __init__(self, catalog_name):
        self.catalog_name = catalog_name


@App.path(path="catalog/{catalog_name}", model=CatalogConfig)
def _path_catalog_config(catalog_name):
    """
    """
    return CatalogConfig(catalog_name)


@App.json(model=CatalogConfig, request_method='GET')
def _view_catalog_config(self, request):
    """
    At this time only to provide link generation. In the future we might
    use the call to access the catalog configuration.
    """
    raise HTTPForbidden("Not yet implemented")


class CatalogBaseModel(object):
    """
    Base class for all CatalogModels.
    """
    def __init__(self, catalog_name, extra_parameters):
        """
        Initializes the catalog. `request_para`
        are used to paremtrize the kernel catalog.
        You can retrieve them by calling `get_request_parameter`.
        """
        self.catalog_name = catalog_name
        if extra_parameters:
            self.extra_parameters = extra_parameters
        else:
            self.extra_parameters = {}

    def get_request_parameters(self):
        """
        Return the parameter of the request that
        had consructed the model.
        """
        return self.extra_parameters

    def get_catalog(self, request):
        """
        Returns the catalog object. The request must contain json data.
        This data is a dictionary. The dictionary key for the field the catalog belongs
        to is ``catalog_field``. The form data is stored with the key ``form_data``. The
        form data value is a dictionary that maps attribute names to their values.
        """
        catalog_cache_id = self.extra_parameters.get("catalog_id", None)
        if catalog_cache_id:
            catalog = CatalogCache().get_catalog(catalog_cache_id)
            if catalog:
                return catalog
            else:
                # The id is only provided if we cant run without a cached
                # catalog so raise an error
                msg = gui.Message.GetMessage("web_err_outdated")
                raise HTTPGone(msg)
        input_field = request.json.get("catalog_field", "")
        operation_state = request.json.get("operation_state", None)
        if operation_state:
            op = Operation(operation_state)
        else:
            op = None
        return RestCatalog(self.catalog_name,
                           input_field,
                           mom.SimpleArguments(**request.json.get("form_data",
                                                                  {})),
                           op)


class CatalogItemWithValuesModel(CatalogBaseModel):
    pass


@App.path(path="catalog/{catalog_name}/items_with_values", model=CatalogItemWithValuesModel)
def _path_catalog_items_with_values(catalog_name, extra_parameters):
    return CatalogItemWithValuesModel(catalog_name, extra_parameters)


@App.json(model=CatalogItemWithValuesModel, request_method='POST')
def _view_catalog_items_with_values(self, request):
    """
    """
    try:
        c = self.get_catalog(request)
        result = {}
        result["items_with_values"] = c.do_onecolumn_simple_browse_select()
        return result
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))


class CatalogItemsModel(CatalogBaseModel):
    """
    Specialization to retrieve only the string values of a combobox
    """
    pass


@App.path(path="catalog/{catalog_name}/items", model=CatalogItemsModel)
def _path_catalog_items(catalog_name, extra_parameters):
    return CatalogItemsModel(catalog_name, extra_parameters)


@App.json(model=CatalogItemsModel, request_method='POST')
def _view_catalog_items(self, request):
    """
    Get the items of a catalog. If the request parameters contain ``as_objects``
    the call returns a list of object information. A list of strings is returned otherwise.
    The request has to contain the data `get_catalog` needs.
    """
    def _obj_info(obj):
        return {"oid": o.get_object_id(),
                "icon": IconCache.getIcon(obj.getClassDef().getObjectIconId(),
                                          accessor=_LabelValueAccessor(obj)),
                "label": obj.getDesignation()}

    try:
        c = self.get_catalog(request)
        result = {}
        if "as_objects" in self.get_request_parameters():
            objs = c.do_object_browse()
            result["items"] = [_obj_info(o) for o in objs]
        elif "as_strings" in self.get_request_parameters():
            result["items"] = c.do_onecolumn_simple_browse()
        else:
            raise HTTPForbidden("No valid representation when retrieving catalog items")
        return result
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))


class CatalogSelectedValuesModel(CatalogBaseModel):
    """
    Specialization to retrieve the values to be filled.
    """
    def get_object_result(self, objs, request):
        result = []
        app = get_collection_app(request)
        for obj in objs:
            cls = class_from_handle(obj)
            result_object = cls._FromObjectHandle(obj)
            result.append(request.view(result_object,
                                       app=app))
        return result


@App.path(path="catalog/{catalog_name}/selected_values", model=CatalogSelectedValuesModel)
def _path_catalog_selected_values(catalog_name, extra_parameters):
    return CatalogSelectedValuesModel(catalog_name, extra_parameters)


@App.json(model=CatalogSelectedValuesModel, request_method='POST')
def _view_catalog_selected_values_post(self, request):
    """
    Returns the fields to be filled or if the request parameters contain
    ``as_objects`` the selected objects.
    """
    try:
        result = {}
        c = None
        as_objects = "as_objects" in self.get_request_parameters()
        catalog_id = request.json.get("catalog_id", None)
        if catalog_id:
            c = CatalogCache().get_catalog(catalog_id)
        if not c:
            c = self.get_catalog(request)
        if "selected_objects" in request.json:
            objects = request.json.get("selected_objects", [])
            ohs = [mom.CDBObjectHandle(oid) for oid in objects]
            if as_objects:
                result["selected_objects"] = self.get_object_result(ohs, request)
            else:
                result["selected_values"] = c.do_objects_select(ohs)
        elif "selected_string" in request.json:
            selected_string = request.json.get("selected_string", "")
            result["selected_values"] = c.do_onecolumn_simple_select(selected_string)
        elif "selected_ids" in request.json:
            selection_ids = request.json.get("selected_ids", [])
            if "as_objects" in self.get_request_parameters():
                ohs = c.get_selection_as_objects(selection_ids)
                result["selected_objects"] = self.get_object_result(ohs, request)
            else:
                result["selected_values"] = c.do_select(selection_ids)
        # After the selection we can remove the catalog from the cache
        if catalog_id:
            CatalogCache().remove_catalog(catalog_id)
        return result
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))


@App.json(model=CatalogSelectedValuesModel, request_method='GET')
def _view_catalog_selected_values_get(self, request):
    """
    """
    try:
        result = {}
        c = self.get_catalog(request)
        selection_id = self.extra_parameters.get("selection_id")
        as_objects = "as_objects" in self.extra_parameters
        if selection_id:
            if as_objects:
                ohs = c.get_selection_as_objects([selection_id])
                result["selected_objects"] = self.get_object_result(ohs,
                                                                    request)
            else:
                result["selected_values"] = c.do_select([selection_id])
            # We do not need the catalog any longer
            catalog_id = self.extra_parameters.get("catalog_id")
            if catalog_id:
                CatalogCache().remove_catalog(catalog_id)
        return result
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))


class CatalogQueryFormModel(CatalogBaseModel):
    """
    Specialization to retrieve the catalogs query form
    """
    pass


@App.path(path="catalog/{catalog_name}/query_form", model=CatalogQueryFormModel)
def _path_catalog_queryform(catalog_name, extra_parameters):
    return CatalogQueryFormModel(catalog_name, extra_parameters)


@App.json(model=CatalogQueryFormModel, request_method='POST')
def _get_catalog_form(self, request):
    """
    """
    from cs.web.components.ui_support.forms import FormInfoBase
    result = {}
    c = self.get_catalog(request)
    sargs = mom.SimpleArguments()
    sargs.append(mom.SimpleArgument(constants.kArgumentDialogUseWebUICfg, "1"))

    dav = c.get_dialog_and_values(False, sargs)
    fib = FormInfoBase(c.getSearchClassDef())
    result = fib.get_forminfo_dict(request,
                                   dav["dialog"],
                                   dav["values"],
                                   {})
    result["display_mapping_url"] = request.link(CatalogDisplayMappingModel(self.catalog_name, {}))
    # At this time we do not support a real operation state
    # so remove them from the generic result
    op_state = result.pop("operation_state", {})
    ft = op_state.get("json_field_types", None)
    if ft:
        result["json_field_types"] = ft
    # Give a hint if "no search" is set in the catalogs configuration
    af = typeconversion.to_bool(c.get_definition_value("no_search"))
    result["activate_search_form"] = af
    return result


class CatalogTableDefWithValuesModel(CatalogBaseModel):
    """
    Specialization to retrieve table definition with values
    """
    pass


@App.path(path="catalog/{catalog_name}/tabular_with_values", model=CatalogTableDefWithValuesModel)
def _path_catalog_tabdef(catalog_name, extra_parameters):
    return CatalogTableDefWithValuesModel(catalog_name, extra_parameters)


@App.json(model=CatalogTableDefWithValuesModel, request_method='POST')
def _get_catalog_tabdef(self, request):
    """
    """
    try:
        result = {}
        c = self.get_catalog(request)
        if c:
            query_data = request.json.get("query_data", {})
            values = query_data.get("values", {})
            type_info = query_data.get("json_field_types")
            if type_info:
                for attr, typeinfo in type_info.iteritems():
                    if typeinfo == sqlapi.SQL_DATE and attr in values:
                        json_value = values[attr]
                        if json_value:
                            values[attr] = convert.load_datetime(json_value)
            tab_browse = c.do_table_browse(mom.SimpleArguments(**values))
            if tab_browse:
                result = RestTableWrapper(tab_browse).get_rest_data(request)
                result['multiselect'] = c.is_multiselect()
                result['preview'] = c.is_preview()
                result['catalog_id'] = CatalogCache().add_catalog(c)
        return result
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))


class CatalogTableDefWithProposalsModel(CatalogBaseModel):
    """
    Specialization to retrieve table definition with proposals
    """
    pass


@App.path(path="catalog/{catalog_name}/tabular_with_proposals", model=CatalogTableDefWithProposalsModel)
def _path_catalog_proposal_tabdef(catalog_name, extra_parameters):
    return CatalogTableDefWithProposalsModel(catalog_name, extra_parameters)


@App.json(model=CatalogTableDefWithProposalsModel, request_method='POST')
def _get_catalog_proposal_tabdef(self, request):
    """
    """
    try:
        result = {}
        c = self.get_catalog(request)
        if c:
            tab_browse = c.get_proposal_table()
            if tab_browse:
                result = RestTableWrapper(tab_browse).get_rest_data(request)
                result['multiselect'] = c.is_multiselect()
        return result
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))


class CatalogTypeAheadModel(CatalogBaseModel):
    """
    Specialization to retrieve type ahead proposals
    """
    pass


@App.path(path="catalog/{catalog_name}/typeAhead", model=CatalogTypeAheadModel)
def _path_catalog_type_ahead(catalog_name):
    """
    """
    return CatalogTypeAheadModel(catalog_name, {})


@App.json(model=CatalogTypeAheadModel, request_method='POST')
def _get_type_ahead_entries(self, request):
    """
    """
    try:
        result = {}
        c = self.get_catalog(request)
        user_input = request.json.get("user_input", "")
        max_count = request.json.get("max_count", 25)
        result["proposals"] = c.get_type_ahead_proposals(user_input, max_count)
        return result
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))


class CatalogValueCheckModel(CatalogBaseModel):
    """
    Specialization to do a value check.
    """
    pass


@App.path(path="catalog/{catalog_name}/valueCheck", model=CatalogValueCheckModel)
def _path_catalog_value_check(catalog_name):
    """
    """
    return CatalogValueCheckModel(catalog_name, {})


@App.json(model=CatalogValueCheckModel, request_method='POST')
def _get_value_check_result(self, request):
    """
    """
    try:
        c = self.get_catalog(request)
        return c.do_value_check()
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))


class CatalogDisplayMappingModel(CatalogBaseModel):
    """
    Specialization to retrieve a display mapping
    """
    pass


@App.path(path="catalog/{catalog_name}/displaymapping",
          model=CatalogDisplayMappingModel)
def _path_display_mapping(catalog_name):
    return CatalogDisplayMappingModel(catalog_name, {})


@App.json(model=CatalogDisplayMappingModel,
          request_method='POST')
def _get_display_mapping_result(self, request):
    try:
        mapping_id = request.json.get("mapping_id")
        value = request.json.get("value")
        c = self.get_catalog(request)
        return {'new_value': c.getDisplayMapping(mapping_id, value)}
    except ElementsError:
        @request.after
        def set_status(response):
            response.status_code = 403


class CatalogStructureModel(CatalogBaseModel):
    """
    Specialization to retrieve values for structure catalogs
    """
    def _adjust_node(self, node, catalog_id, request):
        """
        Prepares the node for REST. Remove the fields
        we do not need and add further fields if necessary.
        """
        extra = self.extra_parameters.copy()
        extra["parent_node_id"] = node["id"]
        # We have to cache the catalogs id
        extra["catalog_id"] = catalog_id
        expand_model = CatalogStructureModel(self.catalog_name,
                                             extra)
        node["expand_url"] = request.link(expand_model)
        selection_id = node.get("selection_id")
        if selection_id:
            extra["selection_id"] = selection_id
            sel_model = CatalogSelectedValuesModel(self.catalog_name,
                                                   extra)
            node["selectURL"] = request.link(sel_model)

        no_of_subitems = node.pop("no_of_subitems", -1)
        if no_of_subitems == 0:
            node["subnodes"] = []
        else:
            node["subnodes"] = None

        # No one needs the internal id
        node.pop("id")

        oid = node.get("oid")
        if oid:
            obj = TableRowObject(oid)
            if obj:
                restLink = support.get_restlink(obj, request)
                if restLink is not None:
                    node["restLink"] = restLink

    def get_nodes(self, request):
        """Returns a list of dictionaries where every dictionary represents a
        node.

        If you provide a ``parent_node_id`` in `__init__` the nodes returned
        are the subnodes of this node. The root-nodes are returned otherwiese.
        Raises a `cdb.ElementsError` if the structure is not available.
        """
        result = []
        if self.extra_parameters:
            parent_node_id = self.extra_parameters.get("parent_node_id")
            catalog_id = self.extra_parameters.get("catalog_id")
        else:
            parent_node_id = ""
            catalog_id = ""

        c = self.get_catalog(request)
        if not catalog_id:
            catalog_id = CatalogCache().add_catalog(c)

        if not parent_node_id:
            # Get the root
            root_node = c.get_root()
            result.append(root_node)
        else:
            # Retrieve the subnodes
            result = c.get_nodes(parent_node_id)
        for node in result:
            self._adjust_node(node, catalog_id, request)
        return result


@App.path(path="catalog/{catalog_name}/structure", model=CatalogStructureModel)
def _path_catalog_tabdef(catalog_name, extra_parameters):
    return CatalogStructureModel(catalog_name, extra_parameters)


@App.json(model=CatalogStructureModel, request_method='POST')
def _view_structure_catalog(self, request):
    """
    """
    try:
        result = self.get_nodes(request)
        return result
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))
