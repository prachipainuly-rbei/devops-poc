# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Support to access the UI-Structures of the kernel via REST
"""

import json
from collections import deque
import logging

from cdbwrapc import RestStructure, kNodeTypeObject
from cdb import misc
from cdb import ElementsError
from cdb.objects.core import class_from_handle
from cdb.platform.mom import CDBObjectHandle
from cs.platform.web import JsonAPI
from cs.platform.web.rest import support, get_collection_app
from cs.platform.web.rest.generic.main import App
from cs.platform.web.uisupport import get_ui_link
from webob.exc import HTTPForbidden

__docformat__ = "restructuredtext en"
__revision__ = "$Id: __init__.py 168155 2017-11-09 15:05:09Z heiko $"

__all__ = []


class StructureCache(object):
    """
    A cache for structures.
    """
    __metaclass__ = misc.Singleton

    def __init__(self):
        self.structures = deque()
        self.structure_cache_limit = 5  # the number of structures to be cached

    def clear(self):
        """
        Clears the cached structure objects. At this time this is a
        feature for tests that checks if a node can be expanded when
        the structure ist not there.
        """
        self.structures = deque()

    def _add_rest_node_id(self, node):
        """We have to build an id that allow us to navigate stateless which
        means that we have to include the object id. This call adds this
        id to the node if we are able to build such an id.

        """
        if node.get("node_type") == kNodeTypeObject:
            snode_id = node.get("id", "")
            oid = node.get("oid", "")
            node["rest_node_id"] = json.dumps([snode_id, oid])

    def _adjust_node(self, node, structure):
        """
        Prepares the node for REST. Remove the fields
        we do not need and add further fields if necessary.
        """
        no_of_subitems = node.pop("no_of_subitems", -1)
        if no_of_subitems == 0:
            node["subnodes"] = []
        elif node["node_type"] != kNodeTypeObject:
            node["subnodes"] = self._get_nodes(structure, node["id"])
        else:
            node["subnodes"] = None

        self._add_rest_node_id(node)
        # No one needs the internal id
        node.pop("id")

    def get_structure(self, structure_name, root_obj, from_cache=True):
        """
        Checks if the cache provides a structure with
        the given `structure_name` and the root `root_obj`.
        If not the structure will be created automatically.
        Returns the `cdbwrapc.RestStructure` or raises an
        `cdb.ElementsError` if the structure is not
        available.
        """
        result = None
        oid = root_obj.ToObjectHandle().get_object_id()
        pos = 0
        structure = None
        for structure in self.structures:
            if (structure.get_id() == structure_name) and \
               (structure.get_root_node().get_object_id() == oid):
                result = structure
                break
            pos += 1

        if result:
            if pos > 0 or not from_cache:
                self.structures.remove(structure)
            if from_cache:
                # Sort to access the recently used elements at the beginning
                self.structures.appendleft(structure)
            else:
                result = None

        if not result:
            result = RestStructure(structure_name, root_obj.ToObjectHandle())
            self.structures.appendleft(result)
            if len(self.structures) > self.structure_cache_limit:
                self.structures.pop()

        return result

    def get_root(self, structure_name, root_obj):
        """
        Returns the root node of the given structure.
        Raises an `cdb.ElementsError` if the structure is not
        available.
        """
        # If someone asks for the root node we have to create a new
        # structure (E044613)
        structure = self.get_structure(structure_name, root_obj, False)
        result = structure.get_root()
        self._adjust_node(result, structure)
        return result

    def _get_nodes(self, structure, parent_node_id):
        """
        Retrieve the subnodes of `parent_node_id` that
        is part of the `cdbwrac.RestStructure` structure.
        """
        nodes = structure.get_nodes(parent_node_id)
        for node in nodes:
            self._adjust_node(node, structure)
        return nodes

    def get_nodes(self, structure_name, root_obj, parent_node_id):
        """
        Return a list of subnodes of the node with the id `parent_node_id`.
        Raises a `cdb.ElementsError` if the structure is not
        available.
        """
        structure = self.get_structure(structure_name, root_obj)
        try:
            parent_node_info = json.loads(parent_node_id)
            if isinstance(parent_node_info, list) and len(parent_node_info) == 2:
                if structure.contains_node(parent_node_info[0]):
                    return self._get_nodes(structure, parent_node_info[0])
                else:
                    obj = CDBObjectHandle(parent_node_info[1])
                    node_id = structure.add_node(obj)
                    return self._get_nodes(structure, node_id)
            else:
                raise ValueError("We expect a JSON coded list of 2 elements "
                                 "for parent_node_id.")
        except ElementsError as e:
            logging.getLogger(__name__).warning(
                "Failed to retrieve subnodes of '%s': %s", parent_node_id,
                str(e))
            raise e
        except Exception as e:
            logging.getLogger(__name__).exception("Failed to receive subnodes "
                                                  "of %s", parent_node_id)
            raise ValueError("%s is not a valid parent_node_id in this "
                             "structure." % parent_node_id)


class StructureApp(JsonAPI):
    """
    The morepath app that provides the structures
    configured in the kernel in the REST API.
    """
    def __init__(self, parent_object):
        """
        Initializes the app with the object that
        is the root object of the structure.
        """
        self.parent_object = parent_object


class StructureModel(object):
    """
    Morepath model for a structure.
    """
    def __init__(self, root_object, structure_name, extra_parameters=None):
        """
        Initializes the structure `structure_name`
        that starts with the given `root_object`.
        `extra_parameters` is a dictionary that where
        ``parent_node_id`` is the parent node for retrieving
        more nodes.
        """
        self.root_object = root_object
        self.structure_name = structure_name
        self.extra_parameters = extra_parameters

    def get_struct_info(self):
        """
        Returns a dictionary about further information about
        the structure. The dictionary is only filled if no
        `parent_node_id` is given in the `extra_parameters`.
        """
        result = {}
        if not self.extra_parameters or not self.extra_parameters.get("parent_node_id"):
            s = StructureCache().get_structure(self.structure_name, self.root_object)
            if s:
                result["title"] = s.get_op_title()
                result["obj_title"] = s.get_title()
        return result

    def get_nodes(self):
        """Returns a list of dictionaries where every dictionary represents a
        node.

        If you provide a ``parent_node_id`` in `__init__` the nodes returned
        are the subnodes of this node. The root-nodes are returned otherwiese.
        Raises a `cdb.ElementsError` if the structure is not available.

        """
        result = []
        if self.extra_parameters:
            parent_node_id = self.extra_parameters.get("parent_node_id")
        else:
            parent_node_id = ""
        if not parent_node_id:
            # Get the root
            root_node = StructureCache().get_root(self.structure_name, self.root_object)
            result.append(root_node)
        else:
            result = StructureCache().get_nodes(self.structure_name,
                                                self.root_object,
                                                parent_node_id)
        return result


@StructureApp.path(model=StructureModel, path='{structure_name}')
def _get_structure_model(structure_name, app, extra_parameters):
    if not app.parent_object.CheckAccess('read'):
        # no read access to the source object means no access to the structure
        raise HTTPForbidden()
    try:
        return StructureModel(app.parent_object, structure_name, extra_parameters)
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))


def _obj_from_handle(oh):
    """
    An implementation that is usually able to create an cdb.objects.Object
    without doing a select as object_from_handle does.
    """
    cls = class_from_handle(oh)
    return cls._FromObjectHandle(oh)


@StructureApp.json(model=StructureModel)
def _structure_model_json(model, request):
    def _adjust_node(node, request, collection_app):
        """
        Helper that removes useless variables and adds
        some links
        """
        rest_node_id = node.get("rest_node_id")
        if rest_node_id:
            extra = {"parent_node_id": rest_node_id}
            expand_model = StructureModel(model.root_object,
                                          model.structure_name,
                                          extra)
            node["expand_url"] = request.link(expand_model)

        # Add the UI-Link to the object
        if node.get("node_type") == kNodeTypeObject:
            oid = node.pop("oid", "")
            if oid:
                obj = CDBObjectHandle(oid)
                if obj.is_valid():
                    node["ui_link"] = get_ui_link(request, obj)
                    if obj.getClassDef().getRESTName():
                        objects_obj = _obj_from_handle(obj)
                        if objects_obj:
                            node["object_url"] = request.link(objects_obj, app=collection_app)
        # No one need the node type
        node.pop("node_type")

        if node["subnodes"]:
            for subnode in node["subnodes"]:
                _adjust_node(subnode, request, collection_app)

    try:
        nodes = model.get_nodes()
        if nodes:
            collection_app = get_collection_app(request)
            for node in nodes:
                _adjust_node(node, request, collection_app)
        result = model.get_struct_info()
        result["nodes"] = nodes
        return result
    except ElementsError as e:
        raise HTTPForbidden(unicode(e))


@App.mount(app=StructureApp, path="{keys}/structure",
           variables=lambda o: dict(keys=support.rest_key(o.parent_object)))
def _mount_structure(keys, app):
    model = app.get_object(keys)
    return StructureApp(model)


@App.defer_links(model=StructureModel)
def _defer_structure_target(app, model):
    return app.child(StructureApp(model.parent_object))
