/*
 * Copyright (C) 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: instances.js 183705 2018-09-11 14:11:10Z gwe $"
 */

import Immutable from 'immutable';
import {ACTIONS} from '../constants.js';
import {extractAttributesFromSearchOperation} from './util.js';
import {FTS_ATTRNAME} from '../constants.js';

/**
 * Sets the initial search parameters for a search instance from the operation
 * defaults plus the params from the favourite. If there is a favourite, use that
 * for ordering and selection of parameters, but add any fixed values that are
 * missing. Otherwise, use the operation defaults.
 */
function initializeSearchParams(state, {instanceName, opState, favourite}) {
    let attributeOrder;
    let searchValues;
    if (favourite === undefined) {
        // Use default parameters from the operation, but sort according to form
        // ordering (ie. the order defined by visibleAttributes). It is assumed
        // that the form's default values already include the fixed values.
        searchValues = opState.get('defaultValues');
        attributeOrder = opState.get('visibleAttributes')
            .filter(attr => searchValues.has(attr))
            .toList();
    }
    else {
        // Favourite plus missing fixed values. Keep the order from the favourite
        // for those params that it includes.
        searchValues = Immutable.Map(
            favourite.get('params')
                .map(p => [p.get('attribute'), p.get('value')])
        );
        attributeOrder = favourite.get('params').map(p => p.get('attribute'));
        // Determine missing fixed values, in form ordering.
        const missingFixedValues = opState.get('visibleAttributes')
            .filter(attr => opState.hasIn(['fixedValues', attr]))
            .filterNot(attr => searchValues.has(attr))
            .toList();
        // Prepend missing values
        attributeOrder = missingFixedValues.concat(attributeOrder);
        // FTS_ATTRNAME is a possible search parameter in the Favorites,
        // but is treated in a special way.
        attributeOrder = attributeOrder.filterNot(attr => attr === FTS_ATTRNAME);
    }
    return state.mergeIn([instanceName], {searchValues, attributeOrder});
}

/**
 * Make sure the value from the catalog field taht triggered the catalog is stored
 * as a search parameter.
 */
function createCatalogSearchInstance(
    state, {instanceName, catalogTableURL, queryFormURL, callingFormData})
{
    const fieldname = callingFormData.catalog_field;
    const searchValues = (callingFormData.form_data && fieldname) ?
        {[fieldname]: callingFormData.form_data[fieldname]}
        : {};
    return state.set(instanceName, Immutable.fromJS({
        catalogTableURL, queryFormURL, callingFormData,
        searchResult: null,
        searchRunning: false,
        searchError: null,
        notYetSearched: true,
        searchOnNavigate: false,
        searchValues: searchValues,
        attributeOrder: [fieldname]
    }));
}

function createRelshipSearchInstance(state, {instanceName, parentObject, relshipName, tableName}) {
    return state.set(instanceName, Immutable.fromJS({
        parentObject, relshipName, tableName,
        searchResult: null,
        searchRunning: false,
        searchError: null,
        notYetSearched: true,
        searchOnNavigate: false,
        searchValues: {},
        attributeOrder: []
    }));}

/**
 * Initialize search instance data from the search form associated with a catalog.
 */
function initializeCatalogSearchParams(state, {instanceName, searchFormData}) {
    const data = Immutable.fromJS(searchFormData);
    const attrs = extractAttributesFromSearchOperation(data.get('registers'), data.get('values'));
    const searchValues = data.get('values').filter(v => v !== '');
    const attributeOrder = attrs.get('visibleAttributes')
        .filter(attr => searchValues.has(attr))
        .toList();
    return state
        .setIn([instanceName, 'searchFormData'], attrs)
        .setIn([instanceName, 'searchFormData', 'original'], data)
        .setIn([instanceName, 'searchValues'], searchValues)
        .setIn([instanceName, 'attributeOrder'], attributeOrder);
}

function relshipSearchFormLoaded(state, {instanceName, searchFormData}) {
    return initializeCatalogSearchParams(
        state.setIn([instanceName, 'searchValues'], Immutable.Map()),
        {instanceName, searchFormData});
}

export function instances(state = Immutable.Map(), action) {
    switch (action.type) {
        case ACTIONS.CREATE_SEARCH_INSTANCE: {
            const {
                instanceName, classname, favouriteId, searchValues, attributeOrder
            } = action.payload;
            return state.set(instanceName, Immutable.fromJS({
                classname, favouriteId,
                searchResult: null,
                searchRunning: false,
                searchError: null,
                notYetSearched: true,
                searchOnNavigate: false,
                searchValues: Immutable.Map(searchValues),
                attributeOrder: Immutable.List(attributeOrder)
            }));
        }
        case ACTIONS.CREATE_CATALOG_SEARCH_INSTANCE: {
            return createCatalogSearchInstance(state, action.payload);
        }
        case ACTIONS.CREATE_RELSHIP_SEARCH_INSTANCE: {
            return createRelshipSearchInstance(state, action.payload);
        }
        case ACTIONS.REMOVE_SEARCH_INSTANCE: {
            const {instanceName} = action.payload;
            return state.delete(instanceName);
        }
        case ACTIONS.INITIALIZE_SEARCH_PARAMS: {
            return initializeSearchParams(state, action.payload);
        }
        case ACTIONS.CATALOG_SEARCH_FORM_LOADED: {
            return initializeCatalogSearchParams(state, action.payload);
        }
        case ACTIONS.LOAD_RELSHIP_SEARCH_FORM: {
            const {instanceName, formURL, submitURL} = action.payload;
            return state
                .setIn([instanceName, 'formURL'], formURL)
                .setIn([instanceName, 'submitURL'], submitURL);
        }
        case ACTIONS.RELSHIP_SEARCH_FORM_LOADED: {
            return relshipSearchFormLoaded(state, action.payload);
        }
        case ACTIONS.CHANGE_FIELDS: {
            const {instanceName, fields} = action.payload;
            return state.mergeIn([instanceName, 'searchValues'], fields);
        }
        case ACTIONS.ADD_SEARCH_FIELD: {
            const {instanceName, fieldname} = action.payload;
            return state
                .setIn([instanceName, 'searchValues', fieldname], '')
                .updateIn(
                    [instanceName, 'attributeOrder'],
                    lst => lst.push(fieldname));
        }
        case ACTIONS.REMOVE_SEARCH_FIELD: {
            const {instanceName, fieldname} = action.payload;
            return state
                .deleteIn([instanceName, 'searchValues', fieldname])
                .updateIn(
                    [instanceName, 'attributeOrder'],
                    lst => lst.filter(fn => fn !== fieldname));
        }
        case ACTIONS.REMOVE_SEARCH_FIELDS: {
            const {instanceName, fieldnames} = action.payload;
            return state
                .updateIn([instanceName, 'searchValues'],
                m => m.filter((v, k) => !fieldnames.includes(k)))
                .updateIn(
                    [instanceName, 'attributeOrder'],
                    lst => lst.filter(fn => !fieldnames.includes(fn)));
        }
        case ACTIONS.SET_SEARCH_FIELDS: {
            const {instanceName, searchValues, attributeOrder} = action.payload;
            return state
                .setIn([instanceName, 'searchValues'], searchValues)
                .setIn([instanceName, 'attributeOrder'], attributeOrder);
        }
        case ACTIONS.SET_FAVOURITE_ID: {
            const {instanceName, classname, favouriteId} = action.payload;
            return state.mergeIn([instanceName], {classname, favouriteId});
        }
        case ACTIONS.SEARCH_STARTED: {
            const {instanceName} = action.payload;
            return state.mergeIn([instanceName], {
                searchRunning: true,
                notYetSearched: false
            });
        }
        case ACTIONS.SEARCH_DONE:
        case ACTIONS.CATALOG_SEARCH_DONE:
        case ACTIONS.RELSHIP_SEARCH_DONE: {
            const {instanceName, result} = action.payload;
            return state.mergeIn([instanceName], {
                searchResult: Immutable.fromJS(result),
                searchRunning: false,
                searchError: null
            });
        }
        case ACTIONS.SEARCH_FAILED: {
            const {instanceName, err} = action.payload;
            return state.mergeIn([instanceName], {
                searchResult: null,
                searchRunning: false,
                searchError: Immutable.fromJS(err)
            });
        }
        case ACTIONS.REMOVE_FAVOURITE_FROM_CLASS: {
            // When a favourite has been deleted by the user, no search instance
            // may refer to that favourite any longer.
            const {classname, favouriteId} = action.payload;
            return state.map(inst =>
                (inst.get('classname') === classname && inst.get('favouriteId' === favouriteId))
                    ? inst.delete('favouriteId')
                    : inst
            );
        }
        case ACTIONS.SET_SEARCH_ON_NAVIGATE: {
            const {instanceName, value} = action.payload;
            return state.setIn([instanceName, 'searchOnNavigate'], value);
        }
        default:
            return state;
    }
}
