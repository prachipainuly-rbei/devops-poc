/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Font.jsx 184253 2018-09-21 08:57:04Z ssa $"
 */

import React from 'react';
import {MenuItem} from 'react-bootstrap';
import {PropTypes, DraftJS} from 'cs-web-components-externals';
import Overlays from '../../overlays';
import Button from '../../components/Button.jsx';
import ButtonGroup from '../../components/ButtonGroup.jsx';
import {prefixNS} from '../../helpers';
import {formatStr} from '../../i18n';

export const FONTMAP = {
    'FONT_SIZE_8': {fontSize: '8px'},
    'FONT_SIZE_9': {fontSize: '9px'},
    'FONT_SIZE_10': {fontSize: '10px'},
    'FONT_SIZE_11': {fontSize: '11px'},
    'FONT_SIZE_12': {fontSize: '12px'},
    'FONT_SIZE_13': {fontSize: '13px'},
    'FONT_SIZE_14': {fontSize: '14px'},
    'FONT_SIZE_16': {fontSize: '16px'},
    'FONT_SIZE_18': {fontSize: '18px'},
    'FONT_SIZE_20': {fontSize: '20px'},
    'FONT_SIZE_22': {fontSize: '22px'},
    'FONT_SIZE_24': {fontSize: '24px'},
    'FONT_SIZE_26': {fontSize: '26px'},
    'FONT_SIZE_28': {fontSize: '28px'},
    'FONT_SIZE_36': {fontSize: '36px'},
    'FONT_SIZE_48': {fontSize: '48px'},
    'FONT_SIZE_72': {fontSize: '72px'}
};

export const COLORMAP = {
    'FONT_COLOR_#000000': {color: '#000000'},
    'FONT_COLOR_#ff0000': {color: '#ff0000'},
    'FONT_COLOR_#ff7f00': {color: '#ff7f00'},
    'FONT_COLOR_#ffff00': {color: '#ffff00'},
    'FONT_COLOR_#00b400': {color: '#00b400'},
    'FONT_COLOR_#0000ff': {color: '#0000ff'},
    'FONT_COLOR_#4b0082': {color: '#4b0082'},
    'FONT_COLOR_#7f00ff': {color: '#7f00ff'}
};

export default class FontControl extends React.Component {
    constructor() {
        super();
        this.fontsizes = [];
        for (const f of Object.keys(FONTMAP)) {
            const fontsize = f.replace('FONT_SIZE_', '');
            this.fontsizes.push(<MenuItem eventKey={f} key={f}> {fontsize + 'px'} </MenuItem>);
        }
        this.fontcolors = [];
        this.state = {
            showOverlay: false
        };
        this.onSelectSize = this._onSelectSize.bind(this);
    }

    _onSelectSize(eK) {
        const {editorState, onChange} = this.props;
        const selection = editorState.getSelection();
        const nextContentState = Object.keys(FONTMAP)
            .reduce((contentState, font) => {
                return DraftJS.Modifier.removeInlineStyle(contentState, selection, font);
            }, editorState.getCurrentContent());

        let nextEditorState = DraftJS.EditorState.push(
            editorState,
            nextContentState,
            'change-inline-style'
        );

        const currentStyle = editorState.getCurrentInlineStyle();
        if (selection.isCollapsed()) {
            nextEditorState = currentStyle.reduce((state, font) => {
                return DraftJS.RichUtils.toggleInlineStyle(state, font);
            }, nextEditorState);
        }

        if (!currentStyle.has(eK)) {
            nextEditorState = DraftJS.RichUtils.toggleInlineStyle(
                nextEditorState,
                eK
            );
        }

        nextEditorState = DraftJS.EditorState.forceSelection(
            nextEditorState,
            selection.merge({
                hasFocus: true
            })
        );
        onChange(nextEditorState);
    }

    _onSelectColor(color) {
        const colorstyle = color !== '' ?
            'FONT_COLOR_' + color
            : '';
        const {editorState, onChange} = this.props;
        const selection = editorState.getSelection();
        const nextContentState = Object.keys(COLORMAP)
            .reduce((contentState, font) => {
                return DraftJS.Modifier.removeInlineStyle(contentState, selection, font);
            }, editorState.getCurrentContent());

        let nextEditorState = DraftJS.EditorState.push(
            editorState,
            nextContentState,
            'change-inline-style'
        );

        const currentStyle = editorState.getCurrentInlineStyle();
        if (selection.isCollapsed()) {
            nextEditorState = currentStyle.reduce((state, font) => {
                return DraftJS.RichUtils.toggleInlineStyle(state, font);
            }, nextEditorState);
        }

        if (colorstyle !== '' && !currentStyle.has(colorstyle)) {
            nextEditorState = DraftJS.RichUtils.toggleInlineStyle(
                nextEditorState,
                colorstyle
            );
        }

        nextEditorState = DraftJS.EditorState.forceSelection(
            nextEditorState,
            selection.merge({
                hasFocus: true
            })
        );
        onChange(nextEditorState);
        this._overlay.hide();
    }

    render() {
        const {editorState} = this.props;
        const currentStyle = editorState.getCurrentInlineStyle();
        const fontlabel = currentStyle.find((state, font) =>
                                            {return font.startsWith('FONT_SIZE_')});
        const colors = [];
        for (const c of Object.keys(COLORMAP)) {
            colors.push(c.replace('FONT_COLOR_', ''));
        }
        return (
            <ButtonGroup>
                <Button.DropdownTextButton label={fontlabel ? FONTMAP[fontlabel].fontSize : '14px'}
                                           onSelect={this.onSelectSize}
                                           bsSize="xsmall"
                                           title={formatStr('richtext_font_size')}
                                           id={prefixNS('richtext-textsize')}>
                    {this.fontsizes.map(fs => {return fs})}
                </Button.DropdownTextButton>
                <Overlays.Bubble.Dropdown ref={overlay => {this._overlay = overlay}}
                    containerRef={this.props.containerRef}>
                {
                    ({onToggle}) => ([
                        <Button.IconButton iconName='csweb_richtext_text_color'
                                   key='toggle'
                                   buttonStyle="outline"
                                   title={formatStr('richtext_font_color')}
                                   onClick={onToggle}
                                   ref={button => {
                                       this.overlayTarget = button;
                                   }}
                                   id={prefixNS('richtext-textcolor')}/>,
                        <ButtonGroup key='overlay'>
                            <Button.IconButton
                                buttonStyle="auxiliary"
                                iconName={'csweb_remove'}
                                onClick={this._onSelectColor.bind(this, '')}
                                title={''}
                                key={'default'}
                            />
                            {colors.map((c) =>
                                <Button.IconButton style={{'backgroundColor': c}}
                                                   buttonStyle="auxiliary"
                                                   title={''}
                                                   key={c}
                                                   onClick={this._onSelectColor.bind(this, c)}
                                />
                            )}
                        </ButtonGroup>
                    ])
                }
                </Overlays.Bubble.Dropdown>
            </ButtonGroup>
        );
    }
}

FontControl.propTypes = {
    onChange: PropTypes.func.isRequired,
    editorState: PropTypes.object.isRequired,
    containerRef: PropTypes.object
};
