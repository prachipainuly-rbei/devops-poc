/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: ClassApplicationBar.jsx 184312 2018-09-24 10:02:30Z cla $"
 */

import React from 'react';
import Immutable from 'immutable';
import {ApplicationBar} from '../components/navigation/ApplicationBar.jsx';
import {PropTypes, ReactRouter} from 'cs-web-components-externals';
import {getClassViewSetup} from './helpers.js';
import {OperationMenuItem, OperationButton} from '../components/ContentOperationToolbar.jsx';
import Overlays from '../overlays';
import {WithOperationTrigger} from '../form/containers/OperationTrigger.jsx';

class ClassApplicationBar extends React.Component {
    constructor(props) {
        super(props);
        this.toOperationLocation = this.toOperationLocation.bind(this);
    }

    toOperationLocation(opInfo) {
        const target_url = opInfo.get('target_url');
        if (target_url) {
            window.location = target_url;
        } else {
            const location = Object.assign(
                {
                    basename: '',
                    pathname: this.props.location.pathname,
                    search: '',
                    hash: ''
                },
                opInfo.get('uiLink').toJS()
            );
            this.props.history.push(location);
        }
    }

    getStartOperationCb(opInfo) {
        // We treat CDB_Create special, so it routes to
        // ClassViews CDB_Create handler.
        return (
            opInfo.get('presentation_id') === 'editor' ?
            this.toOperationLocation :
            this.props.runOperation
        );
    }

    renderDropdown(opInfos, name) {
        const {isOperationRunning} = this.props;
        const setup = getClassViewSetup();
        // The dropdown might contain the same ops for different classes
        // At this time only for create. We want the Operations that
        // has the same name as the group name to be the first operations
        // in the menu.
        const opnames = [name];
        opInfos.forEach(opInfo => {
            if (opnames.indexOf(opInfo.get('opname')) === -1) {
                opnames.push(opInfo.get('opname'));
            }
        });
        let menuitems = Immutable.List();
        let need_divider = false;
        for (let i = 0; i < opnames.length; i++) {
            const group_ops = opInfos.filter(op => op.get('opname') === opnames[i]);
            const c = group_ops.map(
                opInfo => {
                    const key = `${opInfo.get('opname')}/${opInfo.get('classname')}`;
                    return (
                        <OperationMenuItem
                            key={key}
                            operation={opInfo}
                            runOperation={this.getStartOperationCb(opInfo)}
                            disabled={this.props.isOperationRunning}/>
                    );
                }
            ).toList();
            // If there ist more than one operation in a group we will use
            // a separator
            if (((menuitems.size > 0) && (c.size > 1)) || need_divider) {
                menuitems = menuitems.push((<Overlays.MenuDivider key={`divider-${i}`} />));
            }
            need_divider = (c.size > 1);
            menuitems = menuitems.concat(c);
        }
        return (
            <Overlays.DropdownIconButton
                pullRight
                iconSrc={setup.getIn(['icons', name])}
                key={name}
                id={name}
                title={opInfos.first().get('tooltip')}
                noCaret={true}
                buttonStyle={'success'}
                disabled={isOperationRunning}>
                {menuitems}
            </Overlays.DropdownIconButton>
        );
    }

    renderButton(opInfos) {
        const {isOperationRunning} = this.props;
        const setup = getClassViewSetup();
        const opInfo = opInfos.toList().get(0);
        return (
            <OperationButton
                disabled={isOperationRunning}
                key={opInfo.get('opname')}
                buttonStyle={'success'}
                operation={opInfo}
                runOperation={this.getStartOperationCb(opInfo)}
                iconSize="xs"
                icon={setup.getIn(['icons', opInfo.get('opname')])}/>
        );
    }

    render() {
        const setup = getClassViewSetup();
        const rootClassname = setup.get('rootClassname');
        const items = [
            {
                key: 'app',
                name: setup.getIn(['classInfos', rootClassname, 'title']),
                active: true
            }
        ];

        const operations = setup.get('classOpInfos')
            .filter((_, name) => name !== 'CDB_Search')
            .map(opInfos => opInfos.filter(op => op.get('menu_visible')))
            .filter(opInfos => opInfos.size > 0)
            .map((opInfos, name) =>
                (opInfos.size > 1) ? this.renderDropdown(opInfos, name) :
                                     this.renderButton(opInfos)
            )
            .toList();
        return (
            <ApplicationBar items={items}>
                {operations.unshift(this.props.additionalElement)}
            </ApplicationBar>
        );
    }
}
ClassApplicationBar.propTypes = {
    runOperation: PropTypes.func,
    isOperationRunning: PropTypes.bool,
    additionalElement: PropTypes.element,

    // injected by ReactRouter.withRouter
    location: PropTypes.object.isRequired,
    history: PropTypes.object.isRequired
};
ClassApplicationBar.defaultProps = {
    isOperationRunning: false,
};

export default ReactRouter.withRouter(WithOperationTrigger(ClassApplicationBar));
