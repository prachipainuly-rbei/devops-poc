/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: wrapProps.js 181856 2018-08-08 13:26:19Z gwe $"
 */

import {classNames} from 'cs-web-components-externals';
import fieldTypes, {isFilled, isMandatory} from '../fieldTypes';
import {prefixNS} from '../../helpers.js';

const ExcludeOperationForModifiedHint = ['CDB_Search', 'CDB_Create', 'CDB_ShowObject'];
const TextReadOnlyControls = [fieldTypes.CATALOG, fieldTypes.COMBOBOX, fieldTypes.ENUMCOMBOBOX];

function valueIsSet(value) {
    return value !== "" && value !== undefined && value !== null;
}

function checkModification(value, initValue) {
    if (!valueIsSet(value) && !valueIsSet(initValue)) {
        return false;
    }
    return value !== initValue;
}

export function deleteProps(obj, ...propNames) {
    for (const name of propNames) {
        delete obj[name];
    }
    return obj;
}

export default function wrapProps(props, initValue) {
    const {
        setting, values, readOnly,
        operationState, ...others
    } = props;
    const name = setting.get('attribute');
    const label = setting.get('label');
    // The Backend provides the configured string as is, ie. '\n' is delivered
    // as 2 characters '\' and 'n'. See E041877.
    const tooltip = setting.get('tooltip').replace(/\\n/g, '\n');
    let value = undefined;
    if (values) {
        value = values.get(name);
    }
    const mandatory = isMandatory(setting);
    // form is in modify mode: mandatory field must be filled
    const validationState = mandatory && !readOnly && !isFilled(setting, values) ?
        'warning' : undefined;
    const combinedReadOnly = readOnly || setting.get('readonly') === 1;
    const textReadOnly = (setting.get('readonly') > 0 && !combinedReadOnly &&
                         TextReadOnlyControls.indexOf(setting.get('fieldtype')) > -1) ||
                         (setting.get('fieldtype') === fieldTypes.ENUMCOMBOBOX && !readOnly);
    // exclude onNavigateLink, displayMappingURL
    // should be included on demand

    let setModifiedHint = true;
    if (operationState && operationState.get('opname')) {
        if (ExcludeOperationForModifiedHint.indexOf(operationState.get('opname')) > -1) {
            setModifiedHint = false;
        }
    }

    let className = undefined;
    if (combinedReadOnly) {
        className = prefixNS('form-input-read-only');
    }
    if (checkModification(value, initValue) && setModifiedHint) {
        className = prefixNS('form-input-modified');
    }
    if (textReadOnly) {
        className = prefixNS('form-input-text-read-only');
    }
    if (mandatory && !value) {
        if (textReadOnly || combinedReadOnly) {
            className = classNames(prefixNS('form-input-text-ro-mandatory'), className);
        } else {
            className = prefixNS('form-input-mandatory');
        }
    }

    const mandatoryEmptyHint = mandatory && value !== 0 && !value;

    deleteProps(others,
        'formats', 'displayMappingURL', 'onNavigateLink', 'onFieldsChange',
        'getPlaceholderCB', 'calendarValueFormat', 'contextObjects');

    return {
        label, value, name, mandatory,
        mandatoryEmptyHint, validationState,
        readOnly: combinedReadOnly,
        className, tooltip,
        ...others
    };
}
