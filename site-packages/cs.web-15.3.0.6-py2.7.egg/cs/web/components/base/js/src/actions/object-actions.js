/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: object-actions.js 180829 2018-07-23 07:08:48Z khi $"
 */

/**
 * This module provides actions to manipulate the global object store.
 * Use this module's action creators to access objects via the REST API
 * from the frontend.
 *
 * The reducers that store these objects are defined in
 * :ref:`cs-web-components-base-reducers.object-store.__module__`. See
 * this modules description on how the object-actions API handles
 * errors and pending requests.
 *
 * All actions in the store will return thenable objects that will resolve
 * if the operation is completed, or be rejected, if the operation fails.
 *
 * @module object-actions
 */
import {putJSON, postJSON, deleteObject, urlWithParams} from '../fetch.js';
import {makeSequence, createLinkWithPattern} from '../helpers.js';
import {fetchError, singleFetch} from './fetching.js';

export const RECEIVED_OBJECT = `${componentNameSpace}-RECEIVED_OBJECT`;
export const RECEIVED_COLLECTION = `${componentNameSpace}-RECEIVED_COLLECTION`;
export const RECEIVED_RELSHIP_N = `${componentNameSpace}-RECEIVED_RELSHIP_N`;
export const RECEIVED_RELSHIP_1 = `${componentNameSpace}-RECEIVED_RELSHIP_1`;
export const RECEIVED_TYPE = `${componentNameSpace}-RECEIVED_TYPE`;
export const EDITING_OBJECT = `${componentNameSpace}-EDITING_OBJECT`;
export const DELETED_OBJECT = `${componentNameSpace}-DELETED_OBJECT`;
export const RECEIVED_CLASS_RELSHIPS = `${componentNameSpace}-RECEIVED_CLASS_RELSHIPS`;

export function receivedObject(url, object) {
    return {
        type: RECEIVED_OBJECT,
        payload: object,
        meta: {url: url}
    };
}

function deletedObject(url, object) {
    return {
        type: DELETED_OBJECT,
        payload: object,
        meta: {url: url}
    };
}

function editingObject(object, newValues) {
    return {
        type: EDITING_OBJECT,
        payload: {object, values: newValues}
    };
}

function receivedType(url, type) {
    return {
        type: RECEIVED_TYPE,
        payload: type,
        meta: {url: url}
    };
}

function receivedClassRelships(url, classname, relships) {
    return {
        type: RECEIVED_CLASS_RELSHIPS,
        payload: {classname, relships},
        meta: {url: url}
    };
}

export function receivedCollection(url, objects) {
    return {
        type: RECEIVED_COLLECTION,
        payload: objects,
        meta: {url: url}
    };
}

function receivedRelshipN(url, targets) {
    return {
        type: RECEIVED_RELSHIP_N,
        payload: targets,
        meta: {url: url}
    };
}

function receivedRelship1(url, target) {
    return {
        type: RECEIVED_RELSHIP_1,
        payload: target,
        meta: {url: url}
    };
}

export function receivedRelship(url, data) {
    if (data.hasOwnProperty('targets')) {
        return receivedRelshipN(url, data.targets);
    } else {
        return receivedRelship1(url, data.target);
    }
}

/**
 * This action creator loads the type identified by ``url``. By
 * default the type will not be reloaded (as we assume this data
 * to be static), if the action is executed multiple times. To
 * reload an already loaded type, set ``force`` to ``true``.
 *
 * Type URLs are usually obtained from an object's type field:
 *
 * .. code-block:: javascript
 *
 *   const object = state.objectById(some_url);
 *   fetchType(object.get('@type')).then(some_func);
 *
 * @param url {string} - The url of the type to be ensured.
 * @param force {boolean} - reload an already loaded type if set
 * @return {ReduxAction}
 * @see :ref:`cs-web-components-base-reducers.object-store.typesById`
 */
export function fetchType(url, force = false) {
    return (dispatch, getState) => {
        // Already loaded this type
        if (!force && getState().typesById.has(url)) {
            return Promise.resolve(getState().typesById.get(url));
        }

        return dispatch(singleFetch(
            url,
            data => {
                dispatch(receivedType(url, data));
                return data;
            }
        ));
    };
}

/**
 * Fetch a list of types.
 *
 * @param urls {array} - an array of urls
 * @param force {boolean} - set true to reload
 * @return {ReduxAction}
 * @see :ref:`cs-web-components-base-actions.object-actions.fetchType`
 */
export function fetchTypes(urls, force = false) {
    return dispatch => {
        const callables = urls.map(
            url =>
                () => dispatch(fetchType(url, force))

        );
        // THINKABOUT: maybe fetch in parallel with Promise.all()?
        // Currently nearly useless, as the server is sequential anyway.
        return makeSequence(callables);
    };
}

/**
 * Fetch from the backend the relationship metadata for a given class
 * @param  {String}  classname     The name of the class for which to get the data
 * @param  {Boolean} [force=false] If true, reload if already stored
 * @return {ReduxAction}
 */
export function fetchClassRelships(classname, force = false) {
    const url = createLinkWithPattern('relshipConfigurationPattern', {class_name: classname});
    return (dispatch, getState) => {
        // Already loaded?
        if (!force && getState().relshipsByClass.has(classname)) {
            return Promise.resolve(getState().relshipsByClass.get(classname));
        }

        return dispatch(singleFetch(
            url,
            data => {
                dispatch(receivedClassRelships(url, classname, data));
                return data;
            }
        ));
    };
}

/**
 * Retrieve an object from the server and store it in the global store.
 * If fetching fails an error will be stored in
 * :ref:`cs-web-components-base-reducers.fetching.errorsById`
 * for the url used to fetch the object.
 *
 * If an object is already in the store, a new fetchObject call will reload the
 * object from the server. The @type link for the object will be fetched when the
 * object is returned from the server.
 *
 * @param url {string}
 * @param viewname {string}
 * @param withFiles {string}
 * @return {ReduxAction}
 * @see :ref:`cs-web-components-base-reducers.object-store.objectsById`
 */
export function fetchObject(url, viewname = null, withFiles = null) {
    const requestUrlBase = viewname ? (url + '/+' + viewname) : url;
    const requestUrl = withFiles ? (requestUrlBase + '?withFiles=' + withFiles) : requestUrlBase;
    return dispatch => {
        return dispatch(singleFetch(
            requestUrl,
            data => {
                dispatch(receivedObject(url, data));
                // Make sure the DD information for the object's type is there
                const typeUrl = data['@type'];
                if (typeUrl !== undefined) {
                    // Note: fetchType checks if the type was already fetched,
                    // and does nothing in that case.
                    dispatch(fetchType(typeUrl));
                }
                return data;
            }
        ));
    };
}

/**
/**
 * Search for the object in the global store. If that object is not
 * part of the global store or the object does not contain the
 * key ``targets`` in the ``relship:files`` section `fetchObject` is
 * called.
 *
 * @param objectId {string}
 * @return {ReduxAction}
 * @see :ref:`cs-web-components-base-reducers.object-store.objectsById`
 */
export function ensureFileTargetsAvailable(objectId) {
    return (dispatch, getState) => {
        const obj = getState().objectsById.get(objectId, null);
        if (!obj ||
            (obj.has('relship:files') &&
            !obj.hasIn(['relship:files', 'targets']))) {
            dispatch(fetchObject(objectId, null, "complete"));
        }
    };
}

/**
 * Fetch a collection of objects and store them in
 * :ref:`cs-web-components-base-reducers.object-store.objectsById`.
 *
 * Parameter ``getter`` should only be used for special cases where the
 * collection data are accessible via another key as ``objects``.
 * E.g. in activitystream the result should be accessed by providing
 * ``data => data.postings``.

 * @param url {string} - url of the collection to fetch
 * @param params {object} - an object specifying additional query parameters
 * @return {ReduxAction}
 * @see :ref:`cs-web-components-base-reducers.object-store.objectsById`
 */
export function fetchCollection(url, params = undefined, getter = (data) => data.objects) {
    const requestUrl = urlWithParams(url, params);
    return dispatch => {
        return dispatch(singleFetch(
            requestUrl,
            data => {
                const unwrappedData = getter(data);
                dispatch(receivedCollection(url, unwrappedData));
                return data;
            }
        ));
    };
}

/**
 * Fetch a relship defined on an object. The url parameter should be retrieved
 * from an object retrieved via REST API.
 *
 * .. code-block:: javascript
 *
 *    import { fetchRelship, connect } from 'cs-web-components-base';
 *
 *    const ExampleComponent = props => {
 *      const object = props.objectsById.get(props.objectId);
 *      const objectUrl = object.getIn(['system:relships', 'relships', props.relshipId]);
 *      this.props.fetchRelship().then(() => {
 *
 *      });
 *    };
 *
 *    const mapStateToProps = state => {
 *      return {getObjectById: objectId => state.objectsById.get(objectId)};
 *    };
 *
 *    connect(mapStateStateToProps, {fetchRelship})(ExampleComponent);
 *
 * @param url {string} - url of the relship to fetch
 * @param viewname {string} - the backend view to load
 * @param params {object}
 */
export function fetchRelship(url, viewname = 'embed-target', params = undefined) {
    // we don't store relations with their viewname attached, as these are stored in the object.
    // additional data (due to different views) is merged into the existing object.
    // therefore url to received* actions is without viewname.
    const requestUrl = urlWithParams(viewname ? (url + '/+' + viewname) : url, params);
    return dispatch => {
        return dispatch(singleFetch(
            requestUrl,
            data => {
                dispatch(receivedRelship(url, data));
                return data;
            }
        ));
    };
}

/**
 * Fetch an array of relships. Each relship should be an object
 * specifying the parameters for
 * :ref:`cs-web-components-base-actions.object-actions.fetchRelship`
 *
 * @param relships {array}
 * @return {ReduxAction}
 * @see :ref:`cs-web-components-base-actions.object-actions.fetchRelship`
 */
export function fetchRelships(relships) {
    return dispatch => {
        const callables = relships.map(relship =>
            () => dispatch(
                fetchRelship(relship.url, relship.viewName || 'embed-target', relship.params))
        );
        // THINKABOUT: maybe fetch in parallel with Promise.all()?
        // Currently nearly useless, as the server is sequential anyway.
        return makeSequence(callables);
    };
}

/**
 * This action creator fetches the object identified by the provided URL,
 * and -- if successfull -- the relations provided in array ``relships``.
 *
 * @param url {string}
 * @param viewname {string}
 * @param relships {array}
 * @return {ReduxAction}
 * @see :ref:`cs-web-components-base-actions.object-actions.fetchRelship`
 * @see :ref:`cs-web-components-base-actions.object-actions.fetchObject`
 */
export function fetchObjectWithRelships(url, viewname, relships) {
    return () => {
        return fetchObject(url, viewname).then(
            data => {
                const rsDefs = relships.map(ref => {
                    const refAndView = ref.split('/');
                    const ref_url = data['system:relships'].relships[refAndView[0]];
                    const view = (refAndView.length > 1) ? refAndView[1] : 'embed-target';
                    return {url: ref_url, viewName: view};
                });
                return fetchRelships(rsDefs);
            }
        );
    };
}

/**
 * This action creator sends a DELETE request for the object
 * identified by ``url`` to the server, and -- if successfull --
 * removes the deleted object from the store.
 *
 * @param url {string}
 * @return {ReduxAction}
 */
export function deleteObjectFromStore(url) {
    return (dispatch, getState) => {
        const obj = getState().objectsById.get(url);
        return deleteObject(url).then(
            data => {
                dispatch(deletedObject(url, obj));
                return data;
            },
            err => dispatch(fetchError(url, err)));
    };
}

/**
 * Sends a POST request to modify the given object to the server.
 *
 * @param obj {object} - a REST API object to be modified
 * @param newValues {object} - an object specifying the
 *                             new values for this object
 * @return {ReduxAction}
 */
export function editObject(obj, newValues) {
    // TODO(cla): should modify on server first, and modify
    // local object only on success
    // TODO(cla): we should perhaps store that we're editing while the request is pending.
    // This should block/serialize further modifiy requests. We could also defer other
    //fetch requests to the stored Promise
    const url = obj.get('@id');
    return (dispatch) => {
        dispatch(editingObject(obj, newValues));
        return putJSON(url, newValues).then(
            data => {
                dispatch(receivedObject(url, data));
                return data;
            },
            err => {
                dispatch(fetchError(url, err));
                throw err;
            });
    };
}

/**
 * Sends a PUT request to create the provided object from the server.
 *
 * @param collectionUrl {string}
 * @param values {object}
 * @param refetchRelships {array}
 * @return {ReduxAction}
 */
export function createObject(collectionUrl, values, refetchRelships = []) {
    // TODO maybe enhance similarly to suggestions in editObject
    return (dispatch) => {
        return postJSON(collectionUrl, values).then(
            data => {
                dispatch(receivedObject(collectionUrl, data));
                refetchRelships.forEach(urlAndView => {
                    dispatch(fetchRelship(...urlAndView));
                });
                return data;
            },
            err => {
                dispatch(fetchError(collectionUrl, err));
                throw err;
            });
    };
}
