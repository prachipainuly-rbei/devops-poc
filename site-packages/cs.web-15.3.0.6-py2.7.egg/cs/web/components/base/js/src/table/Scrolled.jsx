/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Scrolled.jsx 171949 2018-01-19 11:09:05Z mbr $"
 */

import React from 'react';
import Immutable from 'immutable';
import {PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import {prefixNS} from '../helpers';
import {getVisibleColumns} from './common/reducers.js';
import {classNames} from 'cs-web-components-externals';
import connect from './connect';

/**
 * Usage:
 *
 * .. code-block: javascript
 *
 *      // Can be used as <ScrolledHeaderTable />
 *      const ScrolledHeaderTable = Table.Manager({
 *          Table: Table.Scrolled(Table.Table)
 *      });
 *
 * @memberof module:Table
 * @module Scrolled
 */
export default function(WrappedTable) {
    class Scrolled extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                containerHeight: 0,
                rowCount: 0,
                virtualHeight: 0,
                rowBegin: 0,
                rows: Immutable.List(),
                visibleOriginRows: Immutable.List(),
                headerHeight: 0,
                showFixedColumns: false
            };
            this.tableViewportScroller = null;
            this.onScroll = this.onScroll.bind(this);
            this.scrollRows = this.scrollRows.bind(this);
            this.calcStateOnResize = this.calcStateOnResize.bind(this);
            this.calcStateLater = this.calcStateLater.bind(this);
            this.getContainerHeight = this.getContainerHeight.bind(this);
            this.onWheel = this.onWheel.bind(this);
            this.onTouchMove = this.onTouchMove.bind(this);
            this.onTouchStart = this.onTouchStart.bind(this);
            this.isInViewport = this.isInViewport.bind(this);
            this._resizeTrigger = null;
            // use instance attr. to ensure sync. changes
            // always use the specified value on props
            this.rowHeight = props.minRowHeight;
            this.yOrigin = 0;
        }

        componentDidMount() {
            // rowHeight not set, try to measure it
            if (this.rowHeight === undefined) {
                this.setRowHeight();
            }
            this.calcState(this.props, true);
            this._resizeTrigger.contentWindow.addEventListener(
                'resize', this.calcStateOnResize
            );
        }

        componentWillUnmount() {
            this.rowHeight = undefined;
            if (this.calcStateTimeout) {
                clearTimeout(this.calcStateTimeout);
            }
            this._resizeTrigger.contentWindow.removeEventListener(
                'resize', this.calcStateOnResize
            );
        }

        componentWillReceiveProps(nextProps) {
            if (nextProps.condensed !== this.props.condensed) {
                // rowHeight maybe get changed!
                // if nextProps.minRowHeight is undefined the
                // measuring will begin
                this.rowHeight = nextProps.minRowHeight;
                this.calcState(nextProps, true);
            } else if (nextProps.minRowHeight !== undefined &&
                nextProps.minRowHeight !== this.rowHeight) {
                this.rowHeight = nextProps.minRowHeight;
                this.calcState(nextProps, true);
            } else if (nextProps.rows !== this.props.rows ||
                nextProps.hiddenRows !== this.props.hiddenRows) {
                this.calcState(nextProps, true);
            } else if (nextProps.fixedColumns !== this.props.fixedColumns) {
                this.calcState(nextProps);
            }

            // Scroll when we are approaching top or bottom rows
            if (nextProps.focusedRow &&
                this.props.focusedRow !== nextProps.focusedRow) {
                this.scrollRowIntoView(nextProps);
            }

            if (nextProps.focusedRow && nextProps.focusedColumn &&
                this.props.focusedColumn !== nextProps.focusedColumn) {
                this.scrollColumnIntoView(nextProps);
            }
        }

        /*
         * If we are approaching top or bottom of the visible rows, we may need to adjust
         * the viewport vertically to be able to continue keyboard navigation.
         */
        scrollRowIntoView(nextProps) {
            const {focusedRow, rows} = nextProps;
            const visibleRows = this.state.rows;
            // Get index of focusedRows and boundary rows
            const focusedRowIndex = rows.findIndex(row => row.get('id') === focusedRow);
            const upperBoundaryRow = visibleRows.get(visibleRows.size - 3);
            const upperBoundaryIndex =
                upperBoundaryRow ?
                rows.findIndex(row => row.get('id') === upperBoundaryRow.get('id')) :
                -1;
            const lowerBoundaryIndex = rows.findIndex(
                row => row.get('id') === visibleRows.get(0).get('id'));
            if (upperBoundaryIndex !== -1 && focusedRowIndex > upperBoundaryIndex) {
                const delta = focusedRowIndex - upperBoundaryIndex;
                this.tableViewportScroller.scrollTop += delta * this.rowHeight;  // Scroll down.
            } else if (focusedRowIndex <= lowerBoundaryIndex) {
                this.tableViewportScroller.scrollTop +=
                    Math.min((focusedRowIndex - (lowerBoundaryIndex + 1)) * this.rowHeight, 0);
            }
        }

        scrollColumnIntoView(nextProps) {
            if (!this._tableDivRef) {
                return;
            }

            // Prevent scrolling when fixed columns get focused
            const {visibleColumns, fixedColumns} = nextProps;
            const fixed = fixedColumns > 0 ?
                          visibleColumns.take(fixedColumns) :
                          visibleColumns;
            if (fixed.contains(nextProps.focusedColumn)) {
                return;
            }

            // Get DOM Element for focused cell
            const element = this._tableDivRef.querySelector(
                `tr[data-row-id="${CSS.escape(nextProps.focusedRow)}"]
                 td[data-column-id="${CSS.escape(nextProps.focusedColumn)}"]`
            );

            if (!element) {
                return;
            }

            // When scrolling left, we need to take the fixed column table into account
            const fixedWidth = this._fixedTableDivRef ? this._fixedTableDivRef.clientWidth : 0;

            if (this._tableDivRef.scrollLeft > element.offsetLeft - fixedWidth) {
                this._tableDivRef.scrollLeft = Math.max(element.offsetLeft - fixedWidth, 0);
            } else if (this._tableDivRef.scrollLeft + this._tableDivRef.offsetWidth <
                element.offsetLeft + element.offsetWidth) {

                this._tableDivRef.scrollLeft =
                    element.offsetLeft + element.offsetWidth - this._tableDivRef.offsetWidth;
            }
        }

        componentDidUpdate() {
            if (this.state.containerHeight === 0 && !this.isInViewport()) {
                // Viewport not ready yet(due to animation etc.),
                // try state calculation later
                this.calcStateLater();
            }
            // rowHeight not set, try to measure it
            // check against 0: maybe set during animation, so measure it again
            else if (this.rowHeight === undefined || this.rowHeight === 0) {
                const prev = this.rowHeight;
                this.setRowHeight();
                if (this.rowHeight !== undefined && this.rowHeight !== prev) {
                    this.calcState(this.props);
                }
            }
        }

        isInViewport() {
            if (!this._tableDivRef) {
                return false;
            }
            const cRect = this._tableDivRef.getBoundingClientRect();
            return Math.max(cRect.top, cRect.left, cRect.height, cRect.width) > 0;
        }

        getTHeadHeight() {
            const theadElement = this._tableDivRef
                .getElementsByTagName('thead')[0];
            return theadElement ?
                theadElement.getBoundingClientRect().height : 38;
        }

        setRowHeight() {
            const tdElement = this._tableDivRef
                .getElementsByTagName('td')[0];
            if (tdElement) {
                this.rowHeight = tdElement.getBoundingClientRect().height;
            }
        }

        calcStateOnResize() {
            // Do not schedule event if container height hasn't changed.
            // NOTE (cla): This may cause problems when used in
            // animations. This is of concern especially when the Table is
            // used in a resizable modal.
            if (this.getContainerHeight() === this.state.containerHeight) {
                return;
            }

            if (this.calcStateTimeout) {
                clearTimeout(this.calcStateTimeout);
            }

            this.calcStateTimeout = setTimeout(() => {
                const containerHeight = this.getContainerHeight();
                if (containerHeight !== this.state.containerHeight) {
                    this.calcState(this.props);
                }
            }, 100);
        }

        calcStateLater() {
            if (this.calcStateTimeout) {
                clearTimeout(this.calcStateTimeout);
            }

            this.calcStateTimeout = setTimeout(() => {
                this.calcState(this.props);
            }, 200);
        }

        getContainerHeight() {
            return this._tableDivRef.clientHeight - this.getTHeadHeight();
        }

        calcState(props, force = false) {
            let {visibleOriginRows} = this.state;
            if (force) {
                const originRows = props.rows;
                const hiddenRows = props.hiddenRows;
                visibleOriginRows = this.getVisibleOriginRows(
                    originRows, hiddenRows);
            }
            const headerHeight = this.getTHeadHeight();
            const containerHeight = this.getContainerHeight();
            const scrollTop = this.tableViewportScroller.scrollTop;
            const rowHeight = this.rowHeight;
            let rowCount = 1;
            let virtualHeight = 1;
            let rowBegin = 0;
            if (rowHeight !== undefined && rowHeight !== 0) {
                rowCount = Math.ceil(containerHeight / rowHeight) + 1;
                virtualHeight = rowHeight * visibleOriginRows.count();
                rowBegin = this.getRowBegin(
                    virtualHeight,
                    scrollTop ? this.adjustScrollTop(scrollTop) : 0,
                    visibleOriginRows.count()
                );
            }
            // Handle fixed columns on left side if required.
            // If there is a H-scrollbar, show the fixed columns,
            // otherwise not necessary
            const showFixedColumns =
                props.fixedColumns > 0 &&
                this._tableDivRef &&
                this._tableDivRef.clientHeight !== this._tableDivRef.offsetHeight;
            const viewArea = {
                visibleOriginRows,
                rowCount,
                rowBegin
            };
            const others = {
                headerHeight,
                containerHeight,
                virtualHeight,
                showFixedColumns
            };
            // something really changed?
            let changed = false;
            if (Object.keys(viewArea).some(attr => viewArea[attr] !== this.state[attr])) {
                viewArea.rows = this.getRows(visibleOriginRows, rowBegin, rowCount);
                changed = true;
            } else {
                changed = Object.keys(others).some(attr => others[attr] !== this.state[attr]);
            }
            if (changed) {
                this.setState(Object.assign(viewArea, others));
            }
        }

        getVisibleOriginRows(rows, hidden) {
            return rows.filterNot(row => hidden.contains(row.get('id')));
        }

        getRowBegin(virtualHeight, scrollTop, allRows) {
            return Math.ceil(
                virtualHeight === 0 ?
                    0 : (scrollTop / virtualHeight * 1.0) * allRows);
        }

        getRows(rows, rowBegin, rowCount) {
            return rows.slice(Math.max(0, rowBegin), rowBegin + rowCount);
        }

        onScroll(event) {
            const scrollTop = event.target.scrollTop;
            this.scrollRows(scrollTop);
        }

        onWheel(event) {
            const {deltaY, deltaMode} = event;
            if (deltaY !== 0 && this.tableViewportScroller) {
                const rowHeight = this.rowHeight || 1;
                // normalize delta in line mode to pixels
                // in Firefox the first move scrolls possibly
                // 4 instead of 3 lines
                // page mode not really supported yet
                const factor = deltaMode > 0 ?
                    rowHeight * deltaMode : 1.0;
                this.tableViewportScroller.scrollTop += deltaY * factor;
            }
        }

        onTouchStart(event) {
            this.yOrigin = event.touches[0].clientY;
        }

        onTouchMove(event) {
            const currentY = event.changedTouches[0].clientY;
            const deltaY = this.yOrigin - currentY;
            this.tableViewportScroller.scrollTop += deltaY;
            this.yOrigin = currentY;
        }

        adjustScrollTop(scrollTop) {
            const rowHeight = this.rowHeight || 1;
            const {virtualHeight, containerHeight} = this.state;
            return scrollTop +
                scrollTop * rowHeight / (virtualHeight - containerHeight);
        }

        scrollRows(scrollTop) {
            const {virtualHeight, rowCount} = this.state;
            const scrollTopNew = this.adjustScrollTop(scrollTop);
            const rowBegin = this.getRowBegin(
                virtualHeight, scrollTopNew, this.state.visibleOriginRows.count());
            if (rowBegin !== this.state.rowBegin) {
                this.setState({
                    rowBegin: rowBegin,
                    rows: this.getRows(this.state.visibleOriginRows, rowBegin, rowCount)
                });
            }
        }

        render() {
            const {id, fixedColumns, ...others} = this.props;
            const selectableRowIDs = this.props.selectableRowIDs ?
              this.props.selectableRowIDs : others.rows.map(r => r.get('id'));
            delete others.rows;
            delete others.height;
            delete others.minRowHeight;
            // hiddenRows are already filtered out
            delete others.hiddenRows;
            const {virtualHeight, headerHeight, containerHeight, showFixedColumns} = this.state;
            const size = {
                height: virtualHeight + headerHeight
            };
            const contentClasses = classNames(
                prefixNS('table-viewport-content'),
                {
                    [prefixNS('table-viewport-content-hide-scrollbar')]:
                    virtualHeight < containerHeight
                }
            );
            const tableHeight = containerHeight + headerHeight;
            return (
                <div className={prefixNS('table-viewport-container')}
                     id={id}
                     onWheel={this.onWheel}
                     onTouchStart={this.onTouchStart}
                     onTouchMove={this.onTouchMove}>
                    <div className={prefixNS('table-viewport-scroller')}
                         ref={node => this.tableViewportScroller = node}
                         onScroll={this.onScroll}>
                        <div className={prefixNS('table-viewport-sizer')}
                             style={size}/>
                    </div>
                    <div className={contentClasses}
                         ref={n => this._tableDivRef = n}>
                        <WrappedTable
                            {...others}
                            rows={this.state.rows}
                            selectableRowIDs={selectableRowIDs}
                            height={tableHeight}/>
                        {(showFixedColumns) ? (
                            <div className={prefixNS('table-viewport-content-fixer')}>
                                <div className={prefixNS('table-viewport-content-fixer__wrapper')}
                                     ref={n => this._fixedTableDivRef = n}>
                                    <WrappedTable
                                        {...others}
                                        onlyShowColumns={fixedColumns}
                                        rows={this.state.rows}
                                        height={tableHeight}
                                        className="table-unspread"/>
                                </div>
                            </div>
                        ) : null}
                        <iframe tabIndex={-1}
                                className={prefixNS('table-viewport-resizetrigger')}
                                ref={n => this._resizeTrigger = n} />
                    </div>
                </div>
            );
        }
    }

    Scrolled.propTypes = {
        rows: ImmutablePropTypes.list,
        selectableRowIDs: ImmutablePropTypes.list,
        hiddenRows: ImmutablePropTypes.set,
        minRowHeight: PropTypes.number,
        id: PropTypes.string,
        condensed: PropTypes.bool,
        fixedColumns: PropTypes.number,
        focusedRow: PropTypes.string,
        focusedColumn: PropTypes.string,
        visibleColumns: ImmutablePropTypes.orderedSet,
    };

    Scrolled.defaultProps = {
        hiddenRows: Immutable.Set()
    };

    const mapStateToProps = (state) => {
        return ({
            fixedColumns: state.fixedColumns,
            focusedRow: state.focusedRow,
            focusedColumn: state.focusedColumn,
            visibleColumns: getVisibleColumns(state),
        });
    };

    return connect(mapStateToProps)(Scrolled);
}
