/*
 * Copyright (C) 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: menus.js 184640 2018-10-02 09:02:39Z cla $"
 */

import {HorizontalAlignment, VerticalAlignment, ALIGNED_OVERLAY_DIST} from '../constants.js';

// This depends on the width of the arrow defined in Overlay.scss
// (.#{$componentNameSpace}-overlay)
const MENU_BORDER = 2;

function getLeftPosition(layoutConfig, parentRect, overlayRect) {
    // Incorporate additional space to accomodate scrollbars
    const overlayWidth = overlayRect.width + window.CE_SCROLLBAR_WIDTH;

    // Try default alignment
    const defaultLeft = parentRect.left;
    // Check if right side has enough space
    const defaultRight = defaultLeft + overlayWidth;
    if (defaultRight <= window.innerWidth) {
        return {
            left: defaultLeft,
            width: overlayWidth + 2,
        };
    }

    // Try alternate alignment
    if (!layoutConfig.noSwapHorizontal) {
        const alternateLeft = parentRect.left + parentRect.width - overlayWidth;
        // Check if left side has enough space
        if (alternateLeft >= 0) {
            return {
                left: alternateLeft,
                width: overlayWidth + 2,
            };
        }
    }

    // default alignment with scrollbar
    return {
        left: defaultLeft,
        width: window.innerWidth - defaultLeft,
        overflowX: "auto",
    };
}

function getRightPosition(layoutConfig, parentRect, overlayRect) {
    // Incorporate additional space to accomodate scrollbars
    const overlayWidth = overlayRect.width + window.CE_SCROLLBAR_WIDTH;

    // Try default alignment
    const defaultLeft = parentRect.left + parentRect.width - overlayWidth;
    // Check if right side has enough space
    if (defaultLeft >= 0) {
        return {
            left: defaultLeft,
            width: overlayWidth + 2, // FIXME border hack
        };
    }

    // Try alternate alignment
    if (!layoutConfig.noSwapHorizontal) {
        const alternateLeft = parentRect.left;
        // Check if right side has enough space
        const alternateRight = alternateLeft + overlayWidth;
        if (alternateRight <= window.innerWidth) {
            return {
                left: alternateLeft,
                width: overlayWidth + 2, // FIXME border hack
            };
        }
    }

    // default alignment with scrollbar
    return {
        left: 0,
        width: overlayWidth + defaultLeft,
        overflowX: "auto",
    };
}

export function getBottomPosition(layoutConfig, parentRect, overlayRect, hasScrollbar) {
    const overlayHeight =
        overlayRect.height +
        MENU_BORDER +  // include overlay-border
        (hasScrollbar ? window.CE_SCROLLBAR_WIDTH : 0); // include scrollbar size if scrolling is active

    // Try default alignment
    const defaultTop = parentRect.top + parentRect.height + ALIGNED_OVERLAY_DIST;
    // Check if bottom side has enough space
    if (defaultTop + overlayHeight <= window.innerHeight) {
        return {
            top: defaultTop,
            paddingRight: window.CE_SCROLLBAR_WIDTH,
        };
    }

    // Try alternate alignment
    if (!layoutConfig.noSwapVertical) {
        const alternateTop = parentRect.top - overlayHeight - ALIGNED_OVERLAY_DIST * 2;
        // Check if top side has enough space
        if (alternateTop >= 0) {
            return {
                top: alternateTop,
                paddingRight: window.CE_SCROLLBAR_WIDTH,
            };
        }
    }

    // Default alignment with scrollbar
    return {
        top: defaultTop,
        maxHeight: window.innerHeight - defaultTop,
        overflowY: "auto",
    };
}

export function getTopPosition(layoutConfig, parentRect, overlayRect, hasScrollbar) {
    const overlayHeight =
        overlayRect.height +
        MENU_BORDER + // include overlay-border
        (hasScrollbar ? window.CE_SCROLLBAR_WIDTH : 0);  // include scrollbar size if scrolling is active

    // Try default alignment
    const defaultTop = parentRect.top - overlayHeight - ALIGNED_OVERLAY_DIST * 2;
    // Check if top side has enough space
    if (defaultTop >= 0) {
        return {
            top: defaultTop,
            paddingRight: window.CE_SCROLLBAR_WIDTH,
        };
    }

    // Try alternate alignment
    if (!layoutConfig.noSwapVertical) {
        const alternateTop = parentRect.top + parentRect.height + ALIGNED_OVERLAY_DIST;
        // Check if bottom side has enough space
        if (alternateTop + overlayHeight <= window.innerHeight) {
            return {
                top: alternateTop,
                paddingRight: window.CE_SCROLLBAR_WIDTH,
            };
        }
    }

    return {
        top: 0,
        maxHeight: overlayRect.height + defaultTop,
        overflowY: "auto",
    };
}

export default function layout(
    layoutConfig,
    horizontalAlign,
    verticalAlign,
    parentRect,
    overlayRect
) {
    // We calculate horizontal style before vertical style, as it allows us to
    // know when a horizontal scrollbar is displayed. That way we can calculate
    // the correct position for top alignment without having a constant margin
    // when horizontal rendering is inactive.
    // Rendering a margin on the right side of the overlay on the other hand is
    // not looking as out of place.
    const style = {};

    switch (horizontalAlign) {
        case HorizontalAlignment.LEFT:
            Object.assign(
                style,
                getLeftPosition(layoutConfig, parentRect, overlayRect)
            );
            break;
        case HorizontalAlignment.RIGHT:
            Object.assign(
                style,
                getRightPosition(layoutConfig, parentRect, overlayRect)
            );
            break;
    }

    const hasScrollbar = style['overflowX'] !== undefined;
    switch (verticalAlign) {
        case VerticalAlignment.BOTTOM:
            Object.assign(
                style,
                getBottomPosition(layoutConfig, parentRect, overlayRect, hasScrollbar)
            );
            break;
        case VerticalAlignment.TOP:
            Object.assign(
                style,
                getTopPosition(layoutConfig, parentRect, overlayRect, hasScrollbar)
            );
            break;
    }

    return style;
}
