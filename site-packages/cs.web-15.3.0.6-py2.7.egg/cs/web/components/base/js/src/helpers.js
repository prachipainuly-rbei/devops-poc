/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: helpers.js 184815 2018-10-08 13:37:00Z cla $"
 */

/**
 * Various helper functions.
 *
 * @module
 */

import {Registry} from './registry.js';
import Immutable from 'immutable';
import moment from 'moment';
import {DATA_TYPES, SUPPORTED_IMAGE_TYPES, SUPPORTED_VIDEO_TYPES} from './constants';
import {qs} from 'cs-web-components-externals';
import NumberType from './types/NumberType';

const APPSETUP = Immutable.fromJS(window.appSetup || {});

/**
 * Return application setup values(window.appSetup)
 * as an immutable object.
 */
export function getAppSetup() {
    return APPSETUP;
}

export const debugMode = getAppSetup().getIn(['appSettings', 'debugMode']);

const onlyInDebug = fn =>
    debugMode ? fn : () => {};

/**
 * Wrapper around environments console object
 */
export const Console = {
    log: onlyInDebug(console.log.bind(window.console)),      // eslint-disable-line
    warn: onlyInDebug(console.warn.bind(window.console)),    // eslint-disable-line
    error: onlyInDebug(console.error.bind(window.console)),  // eslint-disable-line
};

export function getScrollBarWidth() {
    // Create a scrolling container
    const inner = document.createElement('p');
    inner.style.width = "100%";
    inner.style.height = "200px";

    const outer = document.createElement('div');
    outer.style.position = "absolute";
    outer.style.top = "0px";
    outer.style.left = "0px";
    outer.style.visibility = "hidden";
    outer.style.width = "150px";
    outer.style.height = "150px";
    outer.style.overflow = "hidden";
    outer.appendChild(inner);

    // Calculate scroll properties
    document.body.appendChild(outer);
    const w1 = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    const w2 =
        w1 === inner.offsetWidth ?
        outer.clientWidth :
        inner.offsetWidth;
    document.body.removeChild(outer);

    return (w1 - w2);
}

/**
 * If container may be document, use this instead of ``Node.contains``
 * to ensure compatibility with Internet Explorer.
 *
 * See also:
 * https://developer.mozilla.org/en-US/docs/Web/API/Document#Internet_Explorer_notes
 *
 * @param {Node} container - The node which may be containing ``component``.
 * @param {Node} component - The node which may be contained by ``container``.
 */
export function contains(container, component) {
    return (container === window.document ? container.body : container)
        .contains(component);
}

/**
 * Create a component by applying a list of HOCs to a
 * provided base component.
 *
 * Signature:
 *
 * .. code-block:: javascript
 *
 *    compose(
 *      base: ReactComponent,
 *      ...hocs: (ReactComponent => ReactComponent)
 *    ): ReactComponent
 *
 * Usage Example:
 *
 * .. code-block:: none
 *
 *    const AsHeading =
 *      Component => props => <h1><Component ...props /></h1>;
 *    const MyComponent =
 *      props => props.title;
 *    const MyHeadingComponent = compose(
 *      MyComponent,
 *      AsHeading
 *    );
 *
 * @param {ReactComponent} base - A component to which the HOCs are applied
 * @param {array} hocs - A list of HOCs which are applied to the
 *                       component
 * @return {ReactComponent}
 * @function
 */
export const compose = (base, ...hocs) =>
    hocs.reduce((base, hoc) => hoc(base), base);

/**
 * ``componentNameSpace`` should be a constant defined in your
 * ``webpack.config.js``. This function creates a namespaced name
 * based on this constant. You should use this for all components you register
 * in the :ref:`cs-web-components-base-registry.__module__`, as well as your
 * CSS classes.
 *
 * @param name {string}
 * @return {string}
 */
export function prefixNS(name) {
    return `${componentNameSpace}-${name}`;
}

export function getRelshipUrl(object, relshipName) {
    return object.getIn(['system:relships', 'relships', relshipName]);
}

export function referencedObjects(state, object, relshipName) {
    const relshipId = getRelshipUrl(object, relshipName);
    const refVal = state.relshipsById.get(relshipId);
    if (refVal === null || refVal === undefined) {
        return refVal;
    }
    if (typeof refVal === 'string') {
        return state.objectsById.get(refVal);
    }
    return refVal
        .map(ref => state.objectsById.get(ref))
        .filter(obj => obj !== undefined);
}

export function getDisplayName(SomeComponent) {
    return SomeComponent.displayName || SomeComponent.name || 'Component';
}

export function timeToDisplayFormat(timeString) {
    if (!(timeString)) {
        return "";
    }
    let displayFormat;
    if (timeString.endsWith("T00:00:00")) {
        displayFormat = getAppSetup().getIn(['formats', 'dateFormat']);
    } else {
        displayFormat = getAppSetup().getIn(['formats', 'dateTimeFormat']).replace("hh", "HH");
    }
    const converted = moment(timeString, moment.ISO_8601).format(displayFormat);
    return "Invalid date" === converted ? timeString : converted;
}

export function getPhysQuantText(value) {
    if (value) {
        const pqval = value.get('value');
        if (pqval !== undefined) {
            return pqval.get(0) + ' ' + pqval.get(1);
        }
    }
    return '';
}

export function floatToDisplayFormat(value) {
    if (value !== undefined) {
        let valueStr = (new NumberType(value)).formatVariableFixed();
        valueStr = NumberType.removeTrailingDecimalsZeros(valueStr);
        return valueStr;
    }
    return value;
}

export function intToDisplayFormat(value) {
    return floatToDisplayFormat(value);
}

/**
 * Helper function to personalize a value.
 */
export function toDisplayFormat(value, data_type) {
    if (data_type === DATA_TYPES.PQ) {
        return getPhysQuantText(value);
    }
    if (data_type === DATA_TYPES.DATE) {
        return timeToDisplayFormat(value);
    }
    if (data_type === DATA_TYPES.FLOAT) {
        return floatToDisplayFormat(value);
    }
    if (data_type === DATA_TYPES.INTEGER) {
        return intToDisplayFormat(value);
    }
    return value;
}

/**
 * Helper function to make a promise cancelable. For reasoning and usage see
 * https://github.com/facebook/react/issues/5465#issuecomment-157888325
 *
 * NOTE: In a promise chain, make the LAST promise cancelable! Otherwise a promise
 * may resolve even when already cancelled (see E045116).
 *
 * @param promise {Promise}
 * @return {object}
 */
export function makeCancelable(promise) {
    let hasCanceled_ = false;

    const wrappedPromise = new Promise((resolve, reject) => {
        promise.then(val =>
            hasCanceled_ ? reject({isCanceled: true}) : resolve(val)
        );
        promise.catch(error =>
            hasCanceled_ ? reject({isCanceled: true}) : reject(error)
        );
    });

    return {
        promise: wrappedPromise,
        cancel() {
            hasCanceled_ = true;
        }
    };
}

/**
 * Use promise chaining to issue the upload calls sequentially, see
 * http://www.html5rocks.com/en/tutorials/es6/promises/#toc-creating-sequences
 *
 * Usage is like this:
 *
 * .. code-block:: javascript
 *
 *    const callables =
 *      someArray.map(item => () => doSomething(item, [other args]));
 *    const promise =
 *      makeSequence(callables).then(...);
 *
 * @param callables {array}
 * @return {thenable}
 */
export function makeSequence(callables) {
    let sequence = Promise.resolve();
    callables.forEach(callable => {
        sequence = sequence.then(() => callable.call());
    });
    return sequence;
}

export function makeSequenceWithResults(callables) {
    const results = [];
    let hasErrors = false;
    let sequence = Promise.resolve();

    function onResolve(result) {
        results.push(result);
        return result;
    }

    function onReject(error) {
        hasErrors = true;
        return onResolve(error);
    }

    callables.forEach(callable => {
        sequence = sequence.then(() => callable.call().then(
            onResolve, onReject
        ));
    });
    return sequence.then(
        () => hasErrors ? Promise.reject(results) : Promise.resolve(results)
    );
}

/**
 * Helper function to calculate the route path for given URL.
 * If the possible path is found, it can be use for e.g. in-page
 * navigation(client side routing). Otherwise `undefined` will
 * be return.
 */
export function getLocalPathForURL(targetURL, basePath) {
    const baseUrl = window.location.origin + basePath;
    if (targetURL.indexOf(baseUrl) === 0) {
        return targetURL.substr(window.location.origin.length);
    }
    return undefined;
}

/**
 * Return the first plugin component in the pluginConfiguration for ``context``
 * that is matched by predicate. Returns ``fallback`` if no match is found.
 * predicate must be a function: predicate(value, index, iterable) -> bool
 *
 * Usage example::
 *
 *    getPlugin('content-view', re => contentType.search(new RegExp(re, 'i')) !== -1);
 *
 * @param {string} context - The plugin ID that is to be searched
 * @param {callable} predicate - A callable to filter the entries
 * @param {ReactComponent} fallback - Component to return if no match is found
 *
 * @returns {ReactComponent} the plugin component to use, or undefined
 */
export function getPlugin(context, predicate, fallback) {
    const config = getAppSetup().getIn(['pluginConfiguration', context]);
    if (config === undefined) {
        return fallback;
    }
    return config.toSeq() // use toSeq for lazy evaluation
        .filter(entry => predicate(entry.get('discriminator')))
        .map(entry => Registry.findComponent(entry.get('component')))
        .filter(entry => entry !== undefined)
        .get(0, fallback);
}

/**
 * Return the URL to retrieve a configured icon by its ID from the backend. The
 * icon configuration may contain variables, in this case the suitable values
 * must be given also.
 *
 * @param {string} iconID - The icon ID from the backend
 * @param {object} iconParams - Optional variables used by the icon configuration
 */
export function getIcon(iconID, iconParams = '') {
    const paramString = !iconParams ? '' : `?${qs.stringify(iconParams)}`;
    const iconBase = getAppSetup().getIn(['links', 'common', 'iconBase']);
    // TODO: use path template from backend instead of hard-coded string
    return `${iconBase}${iconID}${paramString}`;
}

/**
 * Return whether the current application is running in Contact Element Desktop.
 */
export function isCEDesktop() {
    return getAppSetup().getIn(['appSettings', 'isCEDesktop']);
}

/**
 * Return whether the image content type is currently supported.
 */
export function isSupportedImageType(imgType) {
    return imgType &&
        SUPPORTED_IMAGE_TYPES.indexOf(imgType.toLowerCase()) > -1;
}

/**
 * Return whether the media content type is currently supported.
 */
export function isSupportedVideoType(videoType) {
    return videoType &&
        SUPPORTED_VIDEO_TYPES.indexOf(videoType.toLowerCase()) > -1;
}

/**
 * Returns image file associated with object.
 */
export function getObjectImage(obj, fallBackImg = null) {
    const imgFiles =
        obj.getIn(['relship:files', 'targets'], Immutable.List())
        .filter(cdb_file => isSupportedImageType(cdb_file.get('system:content_type')));
    return imgFiles.size > 0 ? imgFiles.first().get('@id') : fallBackImg;
}

/**
 * Parse query parameters from search string of a location object
 */
export function parseQuery(location) {
    const search = location ? location.search.substring(1) : '';
    return qs.parse(search);
}

/**
 * update query parameters on a location object
 */
export function updateQuery(location, queries, merge = true) {
    const search = location ? location.search.substring(1) : '';
    const prev = qs.parse(search);
    const updated = merge ? Object.assign(prev, queries) : queries;
    return Object.assign({}, location, {search: qs.stringify(updated)});
}

/*
 * Returns the label of a form field that has to be used
 * if the field is displayed standalone, e.g. as a search attribute
 * button.
 */
export function getStandaloneLabel(field) {
    const lbl = field ? field.get('label', '') : '';
    // Unfortunately CDB::Empty is delivered as ' '
    return (lbl.trim() !== '') ? lbl : field ? field.get('attribute_label', '') : '';
}

/*
 * Create link using specified pattern and given parameters.
 */
export function createLinkWithPattern(link, params) {
    const linkPattern = getAppSetup().getIn(['links', 'common', link]);
    if (linkPattern === undefined) {
        Console.warn(`appSetup.links.common.${link} is undefined!`);
    }

    return Object.keys(params).reduce(
        (pattern, key) => pattern.replace(`$\{${key}}`, params[key]),
        linkPattern
    );
}

/*
 * Replaces occurences of ${<varname>}) in the link with
 * the result of data.get(<varname>) or an empty string if
 * data does not contain the parameter
 */
export function substitute_link_variables(link, data) {
    return link.replace(/\${[^}]+}/g,
             function(match) {
                 if (data) {
                     return data.get(match.substring(2, match.length - 1), "");
                 } else {
                     return "";
                 }
             }
    );
}


const PROTOCOL_RE = new RegExp('^[A-Za-z]+:\\/\\/');
/**
 * For links that are stored in an attribute somewhere, relative paths don't make
 * much sense; these cases mean most of the time that the "http" part was forgotten.
 * This function checks the input parameter to see if it is either an absolute path,
 * or contains a protocol part. If not, "http" is prepended.
 */
export function ensureLinkProtocol(targetLink) {
    if (!(targetLink.startsWith('/') ||
          PROTOCOL_RE.test(targetLink))) {
        return 'http://' + targetLink;
    }
    return targetLink;
}
