/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: ConfiguredForm.jsx 184286 2018-09-21 13:59:56Z cla $"
 */

import React from 'react';
import Immutable from 'immutable';
import {
    PropTypes, connect, ImmutablePropTypes
} from 'cs-web-components-externals';
import {formatStr} from '../../i18n.js';
import {prefixNS} from '../../helpers.js';
import {addNotification, removeNotificationNow} from '../../actions/notification.js';
import {isHidden} from '../fieldTypes';
import ConfiguredFormActions from '../components/ConfiguredFormActions';
import Button from '../../components/Button';
import CancelQuery from '../helpers/CancelQuery.jsx';
import PreSubmitDialog from '../helpers/PreSubmitDialog.jsx';
import {preSubmitOperation} from '../actions/form_with_operations.js';
import {ButtonActions} from '../constants.js';
import WizardProgressPanel from './WizardProgressPanel.jsx';
import {hasModifiedValues} from '../../operations/helpers.js';
import {DisplayFormRaw} from './DisplayForm.jsx';

const MANDATORY_FIELDS_ID = prefixNS('ConfiguredForm__mandatory');
const GENERAL_ERROR_ID = prefixNS('ConfiguredForm__error');

class ConfiguredForm_ extends React.Component {
    constructor(props) {
        super(props);
        this.leaveCheck = this.leaveCheck.bind(this);
        this.preSubmitDialogButtonPressed = this.preSubmitDialogButtonPressed.bind(this);
    }

    componentDidMount() {
        window.addEventListener('beforeunload', this.leaveCheck);
    }

    componentWillReceiveProps(nextProps) {
        // Check for changed value errors
        if (nextProps.operationState.get('valueErrors') !==
                this.props.operationState.get('valueErrors')) {
            this.updateValueErrors(nextProps);
        }

        // Check for changed general errors
        if (nextProps.operationState.get('generalErrors') !==
                this.props.operationState.get('generalErrors')) {
            this.updateGeneralErrors(nextProps, this.props);
        }
    }

    leaveCheck(event) {
        const {operationState} = this.props;
        if (operationState.get('displayForm') && hasModifiedValues(operationState)) {
            const prompt = formatStr("form_leave_page");
            event.returnValue = prompt;
            return prompt;
        }
        return undefined;
    }

    updateValueErrors(props) {
        props.removeNotificationNow(MANDATORY_FIELDS_ID);
        if (!props.operationState.get('valueErrors')) {
            return;
        }
        const valueErrors = props.operationState.get('valueErrors');
        const fields = valueErrors.map(f => f.get('field'));
        const visibleFields = fields.filter(field => !isHidden(field));
        const hiddenFields = visibleFields.size ? [] : fields.filter(field => isHidden(field));
        const missing_visible_fields = visibleFields.size ? (<p>{visibleFields.map((field, idx) => (
                <Button.TextButton key={idx}
                                   onClick={() => this.setFocusField(field)}
                                   title={field.get('label')}/>
            ))}</p>) : null;
        const missing_hidden_fields = hiddenFields.size ? (<p>{formatStr('mandatory_hidden_hint')}:
                    {hiddenFields.map(field => (
                         <label key={field.get('attribute')}>
                             {field.get('label')}
                         </label>
                     ))}</p>) : null;
        const msg = (
            <div>
                <p>{formatStr('mandatory_fields_not_filled')}</p>
                {missing_visible_fields}
                {missing_hidden_fields}
            </div>
        );
        props.addNotification(
            MANDATORY_FIELDS_ID,
            formatStr('form_name'),
            msg,
            'danger',
            2,
            null,
            null);
    }

    updateGeneralErrors(props, oldProps) {
        const prevErrors = oldProps.operationState.get('generalErrors');
        if (prevErrors) {
            prevErrors.forEach(
                (err, key) => {
                    props.removeNotificationNow(`${GENERAL_ERROR_ID}-${key}`);
                }
            );
        }

        const nextErrors = props.operationState.get('generalErrors');
        if (nextErrors) {
            nextErrors.forEach(
                (err, key) => {
                    props.addNotification(
                        `${GENERAL_ERROR_ID}-${key}`,
                        err.get('title') || formatStr('default_error_title'),
                        err.get('message'),
                        'danger',
                        2,
                        null,
                        null,
                    );
                }
            );
        }
    }

    componentWillUnmount() {
        const nextErrors = this.props.operationState.get('generalErrors');
        if (nextErrors) {
            nextErrors.forEach((_, key) => {
                this.props.removeNotificationNow(`${GENERAL_ERROR_ID}-${key}`);
            });
        }
        this.props.removeNotificationNow(MANDATORY_FIELDS_ID);

        window.removeEventListener('beforeunload', this.leaveCheck);
    }

    /**
     * The user pressed one of the buttons in a dialog shown from a pre-submit
     * hook. The operation state has mode CHECKING at this point in time, this
     * function is responsible to switch to another mode.
     */
    preSubmitDialogButtonPressed(action, value) {
        const {operationState} = this.props;
        const name = operationState.get('query').argumentName;
        switch (action) {
            case ButtonActions.Submit:
                this.props.preSubmitDialogSubmit({name, value});
                break;
            case ButtonActions.Cancel:
                this.props.preSubmitDialogCancel();
                break;
            case ButtonActions.CallServer:
                this.props.preSubmitDialogCallServer({name, value});
                break;
            case ButtonActions.BackToDialog:
                this.props.preSubmitDialogBackToDialog({name, value});
                break;
        }
    }

    setFocusField(field) {
        // If we use props to let component set focus by itself
        // on e.g. componentDidUpdate, we must then clear that
        // prop after focus set, otherwise a modal can cause
        // endless recursion of rerendering/updating. Probably
        // a react or react-bootstrap bug. To clear that prop
        // it will trigger another rerendering, and also difficult
        // to tell all of the places where focus prop is used.
        // So we just let DOM do it supposed to: set focus once
        // directly on DOM element.
        const selector =
          `textarea[name="${field.get('attribute')}"],input[name="${field.get('attribute')}"]`;
        const target = this._form.querySelector(selector);
        if (target && target.focus) {
            target.focus();
        }
    }

    render() {
        const {
            operationState, onSubmit, onCancel, onChangeValues,
            queryCancelBack, queryCancelForce,
            hideButtons, uiExtensions, readOnly, allowCancel,
            containerRef,
        } = this.props;

        const registers = operationState.get('registers');
        const buttons = operationState.getIn(['state', 'buttons']);
        const wizardProgress = operationState.get('wizardProgress');
        const values = operationState.get('values');
        const displayMappingURL = operationState.getIn(['state', 'display_mapping_url']);
        const uncheckedValues = operationState.getIn(['unchecked']);
        const preventSubmitReasons = operationState.getIn(['preventSubmitReasons']);
        const preSubmitDialog = operationState.getIn(['query']);
        const intOperationState = operationState.get('operationState');
        const queryCancel = operationState.get('queryCancel');
        const submitDisabled = operationState.get('submitDisabled');
        const contextObjects = operationState.getIn(['params', 'contextObjects']);

        const wizardSteps = wizardProgress ? wizardProgress.get('steps') : null;
        const wizardPosition = wizardProgress ? wizardProgress.get('position') : 0;
        const actionButtons = wizardProgress && wizardProgress.get('button_label')
            ? buttons.map(b =>
                b.get('button_type') === 0
                  ? b.set('label', wizardProgress.get('button_label'))
                  : b)
            : buttons;
        if (registers) {
            const allowSubmit =
                !submitDisabled && preventSubmitReasons.size === 0;
            return this.props.children(
                <form className={prefixNS('configured-form')}
                      ref={(c) => {this._form = c}}>
                    {queryCancel ? (
                         <CancelQuery
                             forceCancel={queryCancelForce}
                             cancelQuery={queryCancelBack} />
                     ) : null}
                    {(preSubmitDialog) ? (
                         <PreSubmitDialog
                             dialog={preSubmitDialog}
                             buttonPressed={this.preSubmitDialogButtonPressed} />
                     ) : null}
                    {wizardSteps ?
                        <WizardProgressPanel steps={wizardSteps}
                                     position={wizardPosition}/>
                                 : null}
                    <DisplayFormRaw
                        operationInstance={this.props.operationInstance}
                        registers={registers}
                        onChangeValues={onChangeValues}
                        uncheckedValues={uncheckedValues}
                        values={values}
                        displayMappingURL={displayMappingURL}
                        operationState={intOperationState}
                        replaceContentOnNavigate={readOnly}
                        containerRef={containerRef}
                        readOnly={readOnly}
                        contextObjects={contextObjects} />
                    {uiExtensions}
                </form>,
                hideButtons ? null :
                <ConfiguredFormActions readOnly={readOnly}
                                       allowCancel={allowCancel}
                                       allowSubmit={allowSubmit}
                                       buttons={actionButtons}
                                       onSubmit={onSubmit}
                                       onCancel={onCancel}
                                       submitRunning={submitDisabled} />,
                onSubmit,
                onCancel,
            );
        }
        // TODO: message: Form not found
        return (
            <div></div>
        );
    }
}

// NOTE: If a contextObject is passed into the form, we reload form data if it changes.
// This should only be done when no operation is running and current operation is
// CDB_ShowObject

ConfiguredForm_.propTypes = {
    operationInstance: PropTypes.string.isRequired,
    operationMode: PropTypes.string.isRequired,
    operationState: ImmutablePropTypes.map,
    requestData: PropTypes.object,
    onSubmit: PropTypes.func,
    onCancel: PropTypes.func,
    onChangeValues: PropTypes.func,
    readOnly: PropTypes.bool,

    queryCancelBack: PropTypes.func,
    queryCancelForce: PropTypes.func,

    preSubmitDialogBackToDialog: PropTypes.func.isRequired,
    preSubmitDialogCallServer: PropTypes.func.isRequired,
    preSubmitDialogCancel: PropTypes.func.isRequired,
    preSubmitDialogSubmit: PropTypes.func.isRequired,

    promptCancel: PropTypes.bool,
    allowCancel: PropTypes.bool,
    hideButtons: PropTypes.bool,  // In some contexts, we want to hide operation buttons
    uiExtensions: PropTypes.node,
    values: PropTypes.instanceOf(Immutable.Map),
    // actions
    addNotification: PropTypes.func.isRequired,
    removeNotificationNow: PropTypes.func.isRequired,
    //preSubmitOperation: PropTypes.func.isRequired,

    containerRef: PropTypes.object,
};

ConfiguredForm_.defaultProps = {
    allowCancel: false,
    readOnly: false,
    hideButtons: false,
    requestData: {},
    promptCancel: true
};

function mapStateToProps(state, ownProps) {
    return {
        operationMode: state.formWithOperations.getIn([ownProps.operationInstance, 'mode'])
    };
}

const actions = {
    addNotification, removeNotificationNow, preSubmitOperation,
};

export const ConfiguredFormRaw = connect(mapStateToProps, actions)(ConfiguredForm_);

export const ConfiguredForm = props => (
    <ConfiguredFormRaw {...props}>
        {(form, buttons) => (
             <div>
                 {form}
                 {buttons}
             </div>)}
    </ConfiguredFormRaw>
);

export default ConfiguredForm;
