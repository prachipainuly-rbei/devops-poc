/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: CatalogField.jsx 184390 2018-09-26 07:48:44Z cla $"
 */

import React, {Component} from 'react';
import ReactDOM from 'react-dom';
import Immutable from 'immutable';
import {PropTypes, ImmutablePropTypes, connect} from 'cs-web-components-externals';
import {formatStr} from '../i18n';
import {postJSON, getJSON} from '../fetch.js';
import {Console, makeCancelable, prefixNS} from '../helpers.js';
import TextInput, {combineInputExtensions} from './TextInput';
import TextArea from './TextArea';
import WithTypeAhead from './WithTypeAhead';
import {sharedTextInputProps, sharedCatalogProps} from './sharedPropTypes';
import {addNotification, removeNotificationNow} from '../actions/notification.js';
import Button from '../components/Button';
import {formCheckPending, formCheckDone} from '../form/actions/form_with_operations.js';
import {addLocalShortcut, removeLocalShortcut} from '../key-handlers.js';
import CatalogDialog from '../catalogs/CatalogDialog.jsx';
import Catalog from '../catalogs/Catalog.jsx';

const TypeAheadInputText = WithTypeAhead(TextInput);
const TypeAheadInputArea = WithTypeAhead(TextArea);

// the minimal length of the input to trigger type ahead
const requiredInputLength = 1;

function TypeAheadItem(props) {
    const {inputString, item} = props;
    const lower = inputString.toLowerCase();
    const desc = item.get('description', '');
    const value = item.get('value', '');
    const matchIdx = value.toLowerCase().indexOf(lower);
    const lengthIdx = matchIdx + lower.length;
    return (
        <span className={prefixNS('formcontrols-withtypeahead-menu-item')}>
            {value.substring(0, matchIdx)}
            <b>{value.substring(matchIdx, lengthIdx)}</b>
            {value.substr(lengthIdx)}<br/>
            <i className="text-muted">{desc}</i>
        </span>
    );
}
TypeAheadItem.propTypes = {
    inputString: PropTypes.string.isRequired,
    item: ImmutablePropTypes.map.isRequired
};

const EMPTY_PROPOSAL_IDS = Immutable.List();
const EMPTY_IDS = Immutable.List();

/**
 * This component contains a text input field and a button to open a catalog, which let the user to
 * select data from a table. The selection will be processed then on the server side and possible
 * changes will be returned. The processing of the data is based on catalog configuration and
 * its logic in |elements|. This component has following properties in addition to properties of
 * <:ref:`cs-web-components-base-formcontrols.TextInput.__default__`>:
 *
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | Property          | Type          | Default | Required | Use                                                                                                    |
 * +===================+===============+=========+==========+========================================================================================================+
 * | textReadOnly      | bool          | -       | -        | Whether to set the input field as readonly                                                             |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | formData          | Immutable.Map | -       | -        | Form data to be used to query catalog data entries, including the output fields the catalog should set |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | contextClass      | string        | -       | -        | Class of context objects for catalog data                                                              |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | activeLanguage    | string        | -       | -        | In which language should catalog data be loaded                                                        |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | selectURL         | string        | -       | -        | URL to submit the user selection, as result the changed fields and values would be returned as mapping |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | onCatalogChange   | func          | -       | -        | A callback fired when a catalog entry is selected                                                      |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | typeAheadURL      | string        | -       | -        | URL to load suggested entries supporting type ahead                                                    |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | catalogTableURL   | string        | -       | yes      | URL to load table data and configuration for displaying the catalog entries                            |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | proposalCatalogURL| string        | -       | -        | URL to load table data and configuration for displaying the proposal table entries                     |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | proposalLabel     | string        | -       | -        | Proposal table title                                                                                   |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 * | userSettings      | string        | -       | -        | Additional user settings                                                                               |
 * +-------------------+---------------+---------+----------+--------------------------------------------------------------------------------------------------------+
 *
 */
class CatalogField extends Component {
    constructor(props) {
        super(props);
        this.state = {
            showModal: false,
            selectedIDs: EMPTY_IDS,
            selectedProposalIDs: EMPTY_PROPOSAL_IDS,
            selectedURL: undefined,
            matches: Immutable.List()
        };
        this.valueForCheck = props.value;
        this.valueCheckNotificationID = "NOTIFICATION_VALUE_CHECK" + props.label;
        this.singleSelection = false;
        // type ahead request
        this.requestPromise = null;
        this.openCatalog = this.openCatalog.bind(this);
        this.closeCatalog = this.closeCatalog.bind(this);
        this.onSelectionChanged = this.onSelectionChanged.bind(this);
        this.onTreeSelectionChanged = this.onTreeSelectionChanged.bind(this);
        this.onProposalSelectionChanged = this.onProposalSelectionChanged.bind(this);
        this.clearSelected = this.clearSelected.bind(this);
        this.select = this.select.bind(this);
        this.selectStructure = this.selectStructure.bind(this);
        this.fetchMatches = this.fetchMatches.bind(this);
        this.onTypeAheadSelect = this.onTypeAheadSelect.bind(this);
        this.onValueCheck = this.onValueCheck.bind(this);
        this.onEnter = this.onEnter.bind(this);
        this.onBlur = this.onBlur.bind(this);
        this.onButtonBlur = this.onButtonBlur.bind(this);
        this.onCatalogChange = this.onCatalogChange.bind(this);
        this.onClickInputField = this.onClickInputField.bind(this);
        this.setSingleSelection = this.setSingleSelection.bind(this);
        this.onValueChange = this.onValueChange.bind(this);
    }

    componentDidMount() {
        addLocalShortcut(
            ReactDOM.findDOMNode(this.textInput),  // eslint-disable-line react/no-find-dom-node
            'ArrowDown',
            this.openCatalog
        );
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.value !== this.props.value) {
            if (!nextProps.unchecked) {
                this.valueForCheck = nextProps.value;
            }
        }
    }

    componentWillUnmount() {
        removeLocalShortcut(
            ReactDOM.findDOMNode(this.textInput),  // eslint-disable-line react/no-find-dom-node
            'ArrowDown'
        );

        this.clearRequest();
        this.cancelRequest();
    }

    cancelRequest() {
        if (this.requestPromise !== null) {
            this.requestPromise.cancel();
            this.requestPromise = null;
        }
    }

    fetchMatches(props, value) {
        if (props.typeAheadURL && value.length >= requiredInputLength) {
            this.cancelRequest();

            const formData = this.prepareData();
            formData[props.name] = value;
            formData.user_input = value;
            this.requestPromise = makeCancelable(
                postJSON(props.typeAheadURL, formData));
            this.requestPromise.promise.then(
                data => {
                    this.requestPromise = null;
                    if (this.valueForFetch !== value) {
                        return;
                    }

                    this.setState({
                        matches: Immutable.fromJS(data.proposals)
                    });
                },
                err => {
                    this.requestPromise = null;
                    if (this.valueForFetch !== value) {
                        return;
                    }

                    if (err.isCanceled !== true) {
                        Console.log(err);
                    }
                });
        } else {
            this.setState({
                matches: this.state.matches.clear()
            });
        }
    }

    clearRequest() {
        if (this._request) {
            clearTimeout(this._request);
        }
    }

    onValueChange(value) {
        const {onValueChange, valueCheckURL} = this.props;
        if (onValueChange) {
            // only mark field as unchecked if a valueCheckURL is provided
            // if we have no valueCheckURL we are not running checks
            onValueChange(value, valueCheckURL !== undefined);

            this.valueForFetch = value;
            this.clearRequest();
            this._request = setTimeout(() => this.fetchMatches(this.props, value), 300);
        }
    }

    onTypeAheadSelect(idx) {
        const hit = this.state.matches.get(idx);
        const selected = Immutable.OrderedSet([hit.get('selection_id')]);
        this.setState({
            matches: this.state.matches.clear().push(hit)
        });
        this.onSelectionChanged(selected);
        this.change(selected);
    }

    closeCatalog() {
        this.setState({showModal: false});
    }

    openCatalog() {
        this.cancelRequest();
        if (this.props.catalogTableURL === '') {
            this.props.removeNotificationNow(
                this.valueCheckNotificationID + "##structure_error"
            );
        }
        this.setState({
            showModal: true,
            selectedIDs: EMPTY_IDS,
            selectedProposalIDs: EMPTY_PROPOSAL_IDS,
            selectedURL: undefined,
            catalogId: ''
        });
    }

    onSelectionChanged(selected, catalogId = '') {
        const selectedProposalIDs = this.singleSelection && selected.size !== 0 ?
            EMPTY_PROPOSAL_IDS : this.state.selectedProposalIDs;
        this.setState({selectedIDs: selected, selectedProposalIDs, catalogId});
    }

    onProposalSelectionChanged(selected) {
        const selectedIDs = this.singleSelection && selected.size !== 0 ?
            EMPTY_IDS : this.state.selectedIDs;
        this.setState({selectedProposalIDs: selected, selectedIDs});
    }

    onTreeSelectionChanged(selectedURL) {
        this.setState({
            selectedURL: selectedURL
        });
    }

    onEnter() {
        this.onValueCheck();
    }

    onCatalogChange(values) {
        const {operationInstance, formCheckDone, name,
               removeNotificationNow, onCatalogChange} = this.props;
        // Received Value is assumed to be valid
        this.valueForCheck = values[name];
        if (this.state.matches.count()) {
            this.setState({
                matches: this.state.matches.clear()
            });
        }
        formCheckDone(operationInstance, name);
        removeNotificationNow(this.valueCheckNotificationID);
        onCatalogChange(values);
    }

    onBlur(event) {
        if (event !== null && event.currentTarget !== null && event.relatedTarget !== null &&
            event.currentTarget.getAttribute('data-ce-id') === "CatalogField.textinput" &&
            event.currentTarget.getAttribute('data-ce-attribute') === this.props.name &&
            event.relatedTarget.getAttribute('data-ce-id') === "CatalogField.opencatalog" &&
            event.relatedTarget.getAttribute('data-ce-attribute') === this.props.name) {
            return;
        }

        this.onValueCheck();
    }

    onButtonBlur(event) {
        if (event !== null && event.currentTarget !== null && event.relatedTarget !== null &&
            (event.relatedTarget.getAttribute("data-ce-id") === "CatalogField.modal" &&
             event.relatedTarget.getAttribute('data-ce-attribute') === this.props.name ||
             event.relatedTarget.getAttribute("data-ce-id") === "CatalogField.textinput" &&
             event.relatedTarget.getAttribute('data-ce-attribute') === this.props.name)) {
            return;
        }
        this.onValueCheck();
    }

    onValueCheck() {
        const {valueCheckURL, value, label, name,
               formCheckPending, operationInstance} = this.props;
        if (valueCheckURL) {
            if (this.valueForCheck !== value) {
                formCheckPending(operationInstance, name);

                const jsonData = this.prepareData();
                postJSON(valueCheckURL, jsonData)
                    .then(result => {
                        if (result.result === 1) {
                            this.onCatalogChange(result.new_values);
                        }
                        else if (result.result === 2) {
                            this.openCatalog();
                        }
                        else {
                            this.props.addNotification(this.valueCheckNotificationID,
                                                       label, result.message, 'warning');
                        }
                    });
            } else {
                // Value corresponds to checked value, we may remove any notifications
                this.props.removeNotificationNow(this.valueCheckNotificationID);
            }
        }
    }

    onClickInputField(event) {
        if (event.target.selectionStart === event.target.selectionEnd) {
            this.openCatalog();
        }
    }

    setSingleSelection(single) {
        this.singleSelection = single;
    }

    renderCatalog() {
        const {readOnly, catalogTableURL} = this.props;
        if (readOnly || !this.state.showModal) {
            return null;
        }

        const {selectedIDs, selectedProposalIDs, selectedURL} = this.state;
        const submitDisabled = catalogTableURL ?
            (selectedIDs.count() === 0 && selectedProposalIDs.count() === 0)
            : (selectedURL === undefined || selectedURL === '');
        const modalSubmit = catalogTableURL ? this.select : this.selectStructure;
        return (
            <CatalogDialog
                label={this.props.label}
                submitDisabled={submitDisabled}
                modalSubmit={modalSubmit}
                clearSelected={this.clearSelected}
                closeCatalog={this.closeCatalog}
                userSettings={this.props.userSettings}
            >
                <Catalog
                    catalogTableURL={catalogTableURL}
                    proposalCatalogURL={this.props.proposalCatalogURL}
                    proposalLabel={this.props.proposalLabel}
                    structureRootURL={this.props.structureRootURL}
                    queryFormURL={this.props.queryFormURL}
                    formData={this.prepareData()}
                    operationState={this.props.operationState}
                    selectedIDs={selectedIDs}
                    selectedProposalIDs={selectedProposalIDs}
                    selectedURL={selectedURL}
                    setSingleSelection={this.setSingleSelection}
                    onSelectionChanged={this.onSelectionChanged}
                    onTreeSelectionChanged={this.onTreeSelectionChanged}
                    onProposalSelectionChanged={this.onProposalSelectionChanged} />
            </CatalogDialog>
        );
    }

    render() {
        const {
            readOnly, textReadOnly, afterControl, typeAheadURL, lines, ...others
        } = this.props;

        // delete props that should not be passed to subcomponents
        [
            'contextClass', 'activeLanguage', 'selectURL', 'formData',
            'onCatalogChange', 'onValueChange', 'onChange', 'valueCheckURL',
            'operationState', 'addNotification', 'removeNotificationNow',
            'formCheckPending', 'formCheckDone',
            'unchecked', 'structureRootURL', 'proposalCatalogURL', 'proposalLabel',
            'queryFormURL', 'catalogTableURL', 'userSettings'
        ].forEach(prop => {
            delete others[prop];
        });

        if (lines > 1) {
            others['rows'] = lines;
        }

        const catalogButton = readOnly ? null : (
            <Button.IconButton className={prefixNS('form-control-button')}
                               data-ce-id={"CatalogField.opencatalog"}
                               data-ce-type="button"
                               data-ce-attribute={this.props.name}
                               onClick={this.openCatalog}
                               onBlur={this.onButtonBlur}
                               key="catalogTrigger"
                               title={formatStr('tabcatalog_open')}
                               iconName="csweb_select_catalog"
                               buttonStyle="success"/>
        );
        const buttonGroup = combineInputExtensions(catalogButton, afterControl);

        const inputReadonly = readOnly || textReadOnly;
        const activeButReadOnly = textReadOnly && !readOnly;
        const placeholder = activeButReadOnly ? formatStr("tabcatalog_select_hint") : null;
        const onClickInputField = activeButReadOnly ? this.onClickInputField : null;
        const TypeAheadInput = lines > 1 ? TypeAheadInputArea : TypeAheadInputText;
        const InputElement = lines > 1 ? TextArea : TextInput;
        const inputComponent =
            typeAheadURL && !inputReadonly ?
            (
                <TypeAheadInput
                    ref={ref => {this.textInput = ref}}
                    TypeAheadItemRenderer={TypeAheadItem}
                    onValueChange={this.onValueChange}
                    onSelectAt={this.onTypeAheadSelect}
                    matched={this.state.matches}
                    onEnter={this.onEnter}
                    afterControl={buttonGroup}
                    readOnly={inputReadonly}
                    onBlur={this.onBlur}
                    {...others}/>
            ) :
            (
                <InputElement ref={ref => {this.textInput = ref}}
                           afterControl={buttonGroup}
                           readOnly={inputReadonly}
                           placeholder={placeholder}
                           onClick = {onClickInputField}
                           onValueChange={this.onValueChange}
                           {...others}/>
            );
        return (
            <React.Fragment>
                {inputComponent}
                {this.renderCatalog()}
            </React.Fragment>
        );
    }

    prepareData() {
        const {contextClass, activeLanguage, name, value} = this.props;
        const formData = this.props.formData.toJS();
        formData['cdb::argument.catalogcall_cldef'] = contextClass;
        formData['cdb::argument.catalogfieldactivelang'] = activeLanguage;
        formData[name] = value;
        return {
            'form_data': formData,
            'catalog_field': name,
            'operation_state': this.props.operationState
        };
    }

    change(selected_ids, catalogId = "") {
        const {selectURL} = this.props;
        this.closeCatalog();
        this.props.removeNotificationNow(this.valueCheckNotificationID);
        const jsonData = this.prepareData();
        jsonData['selected_ids'] = selected_ids.toArray();
        if (catalogId) {
            jsonData['catalog_id'] = catalogId;
        }
        postJSON(selectURL, jsonData)
            .then(result => {
                this.onCatalogChange(result.selected_values);
            });
    }

    clearSelected() {
        this.change(Immutable.OrderedSet());
    }

    select() {
        this.change(this.state.selectedIDs.concat(this.state.selectedProposalIDs),
                    this.state.catalogId);
    }

    selectStructure() {
        this.closeCatalog();
        getJSON(this.state.selectedURL)
            .then(
                result => this.onCatalogChange(result.selected_values),
                error => {
                    error.response.json().then(json => {
                        this.props.addNotification(
                            this.valueCheckNotificationID + "##structure_error",
                            this.props.label, json.detail, 'danger', 0, undefined
                        );
                    });
                }
            );
    }
}

CatalogField.propTypes = {
    ...sharedTextInputProps,
    ...sharedCatalogProps,
    typeAheadURL: PropTypes.string,
    catalogTableURL: PropTypes.string.isRequired,
    proposalCatalogURL: PropTypes.string,
    proposalLabel: PropTypes.string,
    unchecked: PropTypes.bool,
};

CatalogField.defaultProps = {
    unchecked: false
};

const actions = {addNotification, removeNotificationNow, formCheckDone, formCheckPending};
export default connect(null, actions)(CatalogField);
