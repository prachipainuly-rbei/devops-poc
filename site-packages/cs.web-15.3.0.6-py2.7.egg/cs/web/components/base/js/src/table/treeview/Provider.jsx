/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Provider.jsx 161163 2017-07-03 10:55:19Z yzh $"
 */

import React from 'react';
import {PropTypes, ImmutablePropTypes,
    connect as globalConnect, classNames} from 'cs-web-components-externals';
import Immutable from 'immutable';
import TreeColumn from './TreeColumn';
import connect from '../connect';
import {addColumnRenderer, setRowClassName,
    addUnhidableColumns, removeUnhidableColumns,
    setTableUserSettings} from '../common/actions';
import {setTreeNodes, filterOutNodes,
    expandTreeNodes, collapseTreeNodes, expandTreeLevel} from './actions';
import {addSortFunction, removeSortFunction} from '../sortable/actions';
import {addFilterFunction, removeFilterFunction} from '../filterable/actions';
import {getFilter} from '../filterable/reducers';
import {isTreeViewOff, sortTree, filterTree, isGrouped} from './helpers';
import {addNotification} from '../../actions/notification.js';
import {notificationTimeout} from '../constants';
import {prefixNS} from '../../helpers';
import {formatStr} from '../../i18n';

function getRow(rows, rowID) {
    return rows.find(row => row.get('id') === rowID);
}

function getRows(nodes, rows, states) {
    if (!nodes) {
        return Immutable.List();
    }
    return nodes.flatMap(node => {
        const row = getRow(rows, node.get('id'));
        let result = Immutable.List();
        if (row) {
            result = result.push(row);
            const rowState = states.get(row.get('id'));
            if (rowState && rowState.get('expanded')) {
                result = result.concat(getRows(node.get('children'), rows, states));
            }
        }
        return result;
    });
}

export default function(WrappedTable) {
    class TreeView extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                rows: props.rows
            };
            // this.onSelect = this.onSelect.bind(this);
            this.sort = this.sort.bind(this);
            this.filter = this.filter.bind(this);
            this.setFiltered = this.setFiltered.bind(this);
        }

        componentWillMount() {
            this.props.setTreeNodes(this.props.treeNodes);
            this.props.addSortFunction(this.sort);
            this.props.addFilterFunction(this.filter);
            this.addTreeColumn(this.props);
            this.createTreeRows(this.props);
            this.pinTreeColumn(this.props.treeViewOff);
            this.props.expandTreeLevel(this.props.initTreeExpandLevel);
            this.props.setTableUserSettings('treeViewOff');
        }

        componentWillUnmount() {
            this.props.removeSortFunction(this.sort);
            this.props.removeFilterFunction(this.filter);
            this.pinTreeColumn(false);
        }

        addTreeColumn(props) {
            const {addColumnRenderer, treeColumnID} = props;
            addColumnRenderer(treeColumnID, TreeColumn);
        }

        pinTreeColumn(hidable) {
            const {treeColumnID,
                addUnhidableColumns, removeUnhidableColumns} = this.props;
            if (hidable) {
                removeUnhidableColumns(Immutable.Set([treeColumnID]));
            } else {
                addUnhidableColumns(Immutable.Set([treeColumnID]));
            }
        }

        createTreeRows(props) {
            const {rows, treeNodes, treeViewOff, treeViewState} = props;
            let treeRows = rows;
            if (!treeViewOff && treeNodes !== undefined) {
                treeRows = getRows(treeNodes, rows, treeViewState);
            }
            this.setState({
                rows: treeRows
            });
        }

        sort(sorting, rows, {columnIndex, desc, cmp}) {
            const {treeNodes, treeViewState, treeViewOff} = this.props;
            if (treeViewOff) {
                return rows;
            }
            return sortTree(treeNodes, treeViewState, sorting, rows, {columnIndex, desc, cmp});
        }

        filter(filtered, allRows) {
            const {treeNodes, treeViewState, treeViewOff,
                expandTreeNodes, collapseTreeNodes, filterOutNodes} = this.props;
            if (treeViewOff) {
                return filtered;
            }
            const {parents, collapsed, original, rows} =
                filterTree(treeNodes, treeViewState, filtered, allRows);
            if (expandTreeNodes && parents.count() > 0) {
                expandTreeNodes(parents);
            }
            if (collapseTreeNodes && collapsed.count() > 0) {
                collapseTreeNodes(collapsed);
            }
            if (filterOutNodes) {
                filterOutNodes(collapsed.subtract(original));
            }
            this.setFiltered(this.props, original);
            return rows;
        }

        setFiltered(props, rows) {
            const {setRowClassName} = props;
            if (setRowClassName) {
                setRowClassName(prefixNS('table-treeview-filtered-row'), rows);
            }
        }

        componentWillReceiveProps(nextProps) {
            if (nextProps.treeNodes !== this.props.treeNodes) {
                nextProps.setTreeNodes(nextProps.treeNodes);
            }
            if (nextProps.treeViewOff !== this.props.treeViewOff) {
                // calling callback to notify parent about toggling
                if (nextProps.onToggleTreeView) {
                    nextProps.onToggleTreeView(!nextProps.treeViewOff);
                }
                this.pinTreeColumn(nextProps.treeViewOff);
            }
            if (nextProps.rows !== this.props.rows ||
                nextProps.treeViewState !== this.props.treeViewState ||
                nextProps.treeViewOff !== this.props.treeViewOff) {
                this.createTreeRows(nextProps);
            }
            if (nextProps.filter !== this.props.filter &&
                !nextProps.filter) {
                this.setFiltered(nextProps, Immutable.List());
                if (nextProps.filterOutNodes) {
                    nextProps.filterOutNodes(Immutable.Set());
                }
            }
            if (nextProps.groupingTreeView && !this.props.groupingTreeView) {
                // notify view breaking
                nextProps.addNotification(
                    null,
                    formatStr('table_grouped_by'),
                    formatStr('table_treeview_grouping_msg'),
                    'info',
                    3,
                    null,
                    notificationTimeout
                );
            }
            if (nextProps.initTreeExpandLevel !== this.props.initTreeExpandLevel) {
                nextProps.expandTreeLevel(nextProps.initTreeExpandLevel);
            }
        }

        render() {
            const {className, filter, ...props} = this.props;
            delete props.setTreeNodes;
            delete props.expandTreeNodes;
            delete props.collapseTreeNodes;
            delete props.rows;
            delete props.treeColumnID;
            delete props.treeNodes;
            delete props.treeViewState;
            delete props.treeViewOff;
            delete props.addColumnRenderer;
            delete props.setRowClassName;
            delete props.onToggleTreeView;
            delete props.addSortFunction;
            delete props.removeSortFunction;
            delete props.addFilterFunction;
            delete props.removeFilterFunction;
            delete props.addNotification;
            delete props.groupingTreeView;
            delete props.addUnhidableColumns;
            delete props.removeUnhidableColumns;
            delete props.filterOutNodes;
            delete props.expandTreeLevel;
            delete props.initTreeExpandLevel;
            delete props.setTableUserSettings;

            const clsname = classNames(
                className,
                {
                    [prefixNS('table-treeview-filtered')]: Boolean(filter)
                }
            );
            return (
                <WrappedTable
                    {...props}
                    className={clsname}
                    rows={this.state.rows}/>
            );
        }
    }

    TreeView.propTypes = {
        rows: ImmutablePropTypes.list,
        treeColumnID: PropTypes.string.isRequired,
        treeNodes: ImmutablePropTypes.list,
        treeViewState: ImmutablePropTypes.map,
        treeViewOff: PropTypes.bool,
        setTreeNodes: PropTypes.func,
        expandTreeNodes: PropTypes.func,
        collapseTreeNodes: PropTypes.func,
        addColumnRenderer: PropTypes.func,
        setRowClassName: PropTypes.func,
        onToggleTreeView: PropTypes.func,
        addSortFunction: PropTypes.func,
        removeSortFunction: PropTypes.func,
        addFilterFunction: PropTypes.func,
        removeFilterFunction: PropTypes.func,
        addNotification: PropTypes.func,
        addUnhidableColumns: PropTypes.func,
        removeUnhidableColumns: PropTypes.func,
        groupingTreeView: PropTypes.bool,
        filter: PropTypes.string,
        className: PropTypes.string,
        filterOutNodes: PropTypes.func,
        expandTreeLevel: PropTypes.func,
        initTreeExpandLevel: PropTypes.number,
        setTableUserSettings: PropTypes.func
    };

    TreeView.defaultProps = {
        initTreeExpandLevel: 0
    };

    const mapStateToProps = (state) => {
        return ({
            treeViewState: state.treeViewState,
            treeViewOff: isTreeViewOff(state),
            groupingTreeView: isGrouped(state) && !state.treeViewOff,
            filter: getFilter(state)
        });
    };

    return connect(mapStateToProps,
        {
            setTreeNodes, addColumnRenderer, setRowClassName,
            expandTreeNodes, collapseTreeNodes,
            addUnhidableColumns, removeUnhidableColumns,
            addSortFunction, removeSortFunction,
            addFilterFunction, removeFilterFunction,
            filterOutNodes, expandTreeLevel,
            setTableUserSettings
        })(globalConnect(null, {addNotification})(TreeView));
}
