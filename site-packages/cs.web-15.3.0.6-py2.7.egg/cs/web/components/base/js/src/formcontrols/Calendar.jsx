/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Calendar.jsx 184286 2018-09-21 13:59:56Z cla $"
 */

import React, {Component} from 'react';
import CalendarConverter from '../types/CalendarConverter';
import TextInput, {combineInputExtensions} from './TextInput';
import {PropTypes} from 'cs-web-components-externals';
import {sharedTextInputProps} from './sharedPropTypes';
import moment from 'moment';
import {prefixNS} from '../helpers';
import Button from '../components/Button';
import DayPicker from '../components/DayPicker';
import {FORM_CONTROL_VALIDATION_STATE} from '../constants';
import {formatStr} from '../i18n.js';
import Overlays from '../overlays';

/**
 * This component can be used to enter a date. It also provides a date picker/calendar
 * view for date selection.
 * It has following properties in addition to properties of
 * <:ref:`cs-web-components-base-formcontrols.TextInput.__default__`>:
 *
 * React Properties
 * ----------------
 *
 * +------------------+------------+-------------------+------------------------------------------+
 * | Property         | Type       | Default           | Use                                      |
 * +==================+============+===================+==========================================+
 * | valueFormat      | string     | ISO 8601          | Format of the value for data exchange    |
 * +------------------+------------+-------------------+------------------------------------------+
 * | displayFormat    | string     | ISO 8601          | Format to display the value              |
 * +------------------+------------+-------------------+------------------------------------------+
 * | dateOnlyFormat   | string     | \-                | Format to display the value without time |
 * |                  |            |                   | parts if the time parts are ``00``       |
 * +------------------+------------+-------------------+------------------------------------------+
 * | onDateChange     | func       | \-                | A callback fired when the date value     |
 * |                  |            |                   | gets changed. The value is formated to   |
 * |                  |            |                   | ``valueFormat``.                         |
 * +------------------+------------+-------------------+------------------------------------------+
 * | allowExpression  | boolean    | \-                | Allow search expression like             |
 * |                  |            |                   | '>=01.08.2017 AND <=25.08.2017'          |
 * |                  |            |                   | See dateConverter                        |
 * +------------------+------------+-------------------+------------------------------------------+
 * | onInvalidInput   | func       | \-                | A callback fired when the input value    |
 * |                  |            |                   | changes but is invalid. The input value  |
 * |                  |            |                   | is passed to that function. In this case |
 * |                  |            |                   | the ``onDateChange`` won't be called.    |
 * +------------------+------------+-------------------+------------------------------------------+
 * | dateConverter    | class      | CalenderConverter | Expression convert and parse methods     |
 * +------------------+------------+-------------------+------------------------------------------+
 *
 * .. note::
 *     ``onDateChange`` will be called, if the date is changed via date picker, or when the input
 *     field loses focus after the value gets modified there.
 *
 */


export default class Calendar extends Component {
    constructor(props) {
        super(props);
        this.state = {
            editing: false,
            editingValue: '',
            editingRange: false
        };
        this.setOverlayRef = this.setOverlayRef.bind(this);
        this.onChange = this.onChange.bind(this);
        this.onBlur = this.onBlur.bind(this);
        this.onPickerChange = this.onPickerChange.bind(this);
        this.stopBlurring = false;
    }

    setOverlayRef(ref) {
        this._overlay = ref;
    }

    onBlur(event) {
        if (this.stopBlurring) {
            this.stopBlurring = false;
            return undefined;
        }
        event.persist();
        if (!this.state.editing) {
            return this.props.onBlur && this.props.onBlur(event);
        }
        const dateStr = this.state.editingValue;
        this.setState({
            editing: false,
            editingValue: ''
        }, () => {
            if (this.props.allowExpression) {
                this.changeRangeDateStr(dateStr);
            } else {
                this.changeDateStr(dateStr);
            }
            return this.props.onBlur && this.props.onBlur(event);
        });
        return undefined;
    }

    onChange(event) {
        event.persist();
        this.setState({
            editing: true,
            editingValue: event.target.value
        }, () => this.props.onChange && this.props.onChange(event));
    }

    ignoreBlurring() {
        this.stopBlurring = true;
    }

    quitEditing() {
        this.setState({
            editing: false,
            editingValue: ''
        });
    }

    changeDate(newDate) {
        const {onDateChange, value, valueFormat} = this.props;
        const dateStr = newDate.format(valueFormat);
        if (value !== dateStr) {
            onDateChange(dateStr);
        }
    }

    changeRangeDateStr(dateRangeStr) {
        const {onDateChange, onInvalidInput, value, dateConverter,
               valueFormat, displayFormat, dateOnlyFormat} = this.props;
        // eslint-disable-next-line new-cap
        const converter = new dateConverter(valueFormat, displayFormat, dateOnlyFormat);
        const valid = converter.checkDisplayValue(dateRangeStr);
        if (!valid && onInvalidInput) {
            onInvalidInput(dateRangeStr);
        } else {
            const valueStr = converter.convertToValue(dateRangeStr);
            if (value !== valueStr) {
                onDateChange(valueStr);
            }
        }
    }

    changeDateStr(dateStr) {
        const {onDateChange, onInvalidInput, value, displayFormat} = this.props;
        const dateObj = moment(dateStr, displayFormat);
        if (dateObj.isValid()) {
            this.changeDate(dateObj);
        } else if (!(dateStr && dateStr.trim().length)) {
            // keep empty calendar value
            if (value !== '') {
                onDateChange('');
            }
        } else if (onInvalidInput) {
            onInvalidInput(dateStr);
        }
    }

    changeRange(dateRange) {
        if (dateRange) {
            const fromMoment = dateRange.getStart();
            const toMoment = dateRange.getEnd();
            const {onDateChange, dateConverter,
                   valueFormat, displayFormat, dateOnlyFormat} = this.props;
            if (fromMoment.isSame(toMoment)) {
                this.changeDate(toMoment);
            } else {
                onDateChange(
                    // eslint-disable-next-line new-cap
                    new dateConverter(valueFormat, displayFormat, dateOnlyFormat)
                        .convertRangeToValue(dateRange));
            }
            this._overlay.hide();
            this.setState({editingRange: false});
        } else {
            this.setState({editingRange: true});
        }
    }

    onPickerChange(dateRange) {
        if (!this.props.allowExpression) {
            // single date
            this.changeDate(dateRange.getEnd());
            this._overlay.hide();
        } else {
            this.changeRange(dateRange);
        }
    }

    renderButton(dateRange) {
        const {readOnly, allowExpression, containerRef} = this.props;
        if (readOnly && !dateRange) {
            // read only, and nothing can be displayed on DayPicker
            return null;
        }

        const selectedDates = dateRange ? [dateRange] : undefined;
        // reference date to calculate month days
        const showMonthOf = dateRange ?
                            (dateRange.getStart() || dateRange.getEnd()) : null;

        return (
            <Overlays.Bubble.Dropdown ref={this.setOverlayRef}
                                      containerRef={containerRef}>
                {
                    ({onToggle}) => ([
                        <Button.IconButton key='toggle'
                                           className={prefixNS('form-control-button')}
                                           title={formatStr('formcontrol_open_calendar')}
                                           iconName="csweb_calendar"
                                           buttonStyle="success"
                                           onClick={onToggle} />,
                        <DayPicker key='overlay'
                                   currentDate={showMonthOf || moment()}
                                   selectedDates={selectedDates}
                                   selectRange={allowExpression}
                                   readOnly={readOnly}
                                   onChange={this.onPickerChange}/>
                    ])
                }
            </Overlays.Bubble.Dropdown>
        );
    }

    render() {
        const {
            value, valueFormat, displayFormat, dateOnlyFormat,
            afterControl, allowExpression,
            validationState, dateConverter: DateConverter, ...inputProps
        } = this.props;
        delete inputProps.onDateChange;
        delete inputProps.displayFormat;
        delete inputProps.dateOnlyFormat;
        delete inputProps.onInvalidInput;
        delete inputProps.containerRef;
        const converter = new DateConverter(valueFormat, displayFormat, dateOnlyFormat);
        const dateRange = converter.getRangeFromValue(value);
        let valueState = validationState;
        let dateStr = value ? value : '';
        if (this.state.editing) {
            dateStr = this.state.editingValue;
        } else if (!allowExpression) {
            if (dateRange !== null && dateRange.duration() === 0) {
                // valid single day
                dateStr = converter.formatDisplayDate(dateRange.getStart());
            } else if (value && value.trim().length && validationState === undefined) {
                // invalid date expression
                valueState = FORM_CONTROL_VALIDATION_STATE.ERROR;
            }
        } else {
            // convert date expression
            dateStr = converter.convertToDisplay(dateStr);
        }
        return (
            <TextInput
                {...inputProps}
                afterControl={
                  combineInputExtensions(
                    this.renderButton(dateRange), afterControl
                  )}
                value={dateStr}
                onBlur={this.onBlur}
                onChange={this.onChange}
                validationState={valueState}
            />
        );
    }
}

Calendar.defaultProps = {
    allowExpression: false,
    dateConverter: CalendarConverter
};

Calendar.propTypes = {
    ...sharedTextInputProps,
    valueFormat: PropTypes.string,
    displayFormat: PropTypes.string,
    dateOnlyFormat: PropTypes.string,
    onDateChange: PropTypes.func,
    allowExpression: PropTypes.bool,
    onInvalidInput: PropTypes.func
};
