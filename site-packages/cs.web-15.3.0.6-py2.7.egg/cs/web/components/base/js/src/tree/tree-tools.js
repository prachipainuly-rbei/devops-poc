/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: tree-tools.js 170594 2017-12-18 12:15:41Z yzh $"
 */

export const walkBottomUpDepthFirstCustom = iterate => {
    return function* (node) {
        const children = [];
        iterate(node).forEach(child => {
            children.push(child);
        });

        for (const child of children) {
            yield *walkBottomUpDepthFirstCustom(iterate)(child);
        }
        yield node;
    };
};

export const walkBottomUpDepthFirst = walkBottomUpDepthFirstCustom(node => node.get('children'));

export const walkTopDownDepthFirstCustom = iterate => {
    return function* (node) {
        yield node;

        const children = [];
        iterate(node).forEach(child => {
            children.push(child);
        });

        for (const child of children) {
            yield *walkTopDownDepthFirstCustom(iterate)(child);
        }
    };
};

export const walkTopDownDepthFirst = walkTopDownDepthFirstCustom(node => node.get('children'));

export function visitBottomUpDepthFirst(node, callback, depth = 0, parent = undefined) {
    const sub_depth = depth + 1;
    return callback(
        node.set('children',
                 node.get('children').map(
                     child => visitBottomUpDepthFirst(child, callback, sub_depth, node)
                 )
        ),
        depth,
        parent
    );
}

export function visitTopDownDepthFirst(node, callback, depth = 0, parent = undefined) {  // depth first
    const sub_depth = depth + 1;
    const newNode = callback(node, depth, parent);
    return newNode.set(
        'children',
        newNode.get('children').map(
            child => visitTopDownDepthFirst(child, callback, sub_depth, newNode)
        )
    );
}

export function visit(node, callbacks, depth = 0, parent = undefined) {
    const sub_depth = depth + 1;
    const nodeDesc = callbacks.descending ? callbacks.descending(node, depth, parent) : node;
    const newNode = nodeDesc.set(
        'children',
        nodeDesc.get('children')
                .map(child => visit(child, callbacks, sub_depth, nodeDesc))
    );
    return callbacks.ascending ? callbacks.ascending(newNode, depth, parent) : newNode;
}
