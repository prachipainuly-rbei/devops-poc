/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: sagas.js 184636 2018-10-01 15:40:38Z eab $"
 */

import React from 'react';
import Immutable from 'immutable';
import {ReduxSaga, cuid, browserHistory, qs} from 'cs-web-components-externals';
import {Registry} from '../registry.js';
import {formatStr} from '../i18n.js';
import {
    fetchUserSetting, storeUserSetting, USER_SETTING_FETCHED
} from '../actions/user-settings-actions.js';
import {ACTIONS as SEARCH_ACTIONS} from '../search/constants.js';
import {
    createSearchInstance, doInitializeSearchParams, setSearchOnNavigate
} from '../search/actions/instances.js';
import {
    getClassname, getSearchValues, getAttributeOrder, getFavouriteId, getNotYetSearched
} from '../search/selectors/instances.js';
import {updateLocationAllowed} from '../search/selectors/context.js';
import {getFavouriteName} from '../search/selectors/favourites.js';
import {ACTIONS, NOTIFICATION_ID} from './constants.js';
import {addNotification} from '../actions/notification.js';
import ErrorNotification from './ErrorNotification.jsx';
import {getClassOpInfo} from './helpers.js';
import {OPERATION_NAMES} from '../constants.js';

const {all, call, put, select, take, takeEvery} = ReduxSaga.effects;
const USER_SETTING_KEY = 'search_tabs';

function nextInstanceName(classname) {
    return `search-${classname}-${cuid()}`;
}

function* createDefaultTabs(classname) {
    const {favouritesByClass} = yield select(state => state.search);
    const specialFavourites =
        favouritesByClass.getIn([classname, 'favourites'], Immutable.Map())
        .filter(fav => fav.get('resultLink') !== undefined)
        .valueSeq().toJS();
    const tabs = specialFavourites.map(fav => ({
        instanceName: nextInstanceName(classname),
        favouriteId: fav.cdb_object_id,
        name: fav.name,
        iconName: fav.iconName,
        kind: 'SPECIAL'
    }));
    if (getClassOpInfo(classname, OPERATION_NAMES.kOperationSearch)) {
        tabs.unshift({
            instanceName: nextInstanceName(classname),
            name: formatStr('do_extended_search'),
            iconName: 'csweb_search_icon_svg',
            kind: 'SEARCH'
        });
    }
    return {tabs, active_tab: tabs[0].instanceName};
}

export function* loadTabsForClass({payload}) {
    const {classname} = payload;

    yield put(fetchUserSetting(USER_SETTING_KEY, classname));
    const {payload: {value}} = yield take(action => (
        action.type === USER_SETTING_FETCHED
        && (action.payload.componentId === USER_SETTING_KEY)
        && (action.payload.settingKey === classname)));
    const loaded = (value !== '');

    const {active_tab, tabs} = loaded ? value : yield call(createDefaultTabs, classname);
    yield call(createSearchInstancesForTabs, classname, tabs);
    yield put({
        type: ACTIONS.LOADED_TABS_FOR_CLASS,
        payload: {classname, tabs}
    });
    const activeTabFromUrl = yield call(setStateFromLocation, classname, tabs);
    yield put({
        type: ACTIONS.SET_ACTIVE_TAB,
        payload: {
            classname,
            instanceName: activeTabFromUrl || active_tab,
            storeSettings: (!loaded || (activeTabFromUrl && (activeTabFromUrl !== active_tab)))
        }
    });
}

function* createSearchInstancesForTabs(classname, tabs) {
    yield all(
        tabs.map(tab => put.resolve(createSearchInstance(
            tab.instanceName, classname, tab.favouriteId, tab.searchValues, tab.attributeOrder)))
    );
    yield all(
        tabs.filter(tab => tab.searchValues === undefined).map(tab => put(
            doInitializeSearchParams(tab.instanceName)))
    );
}

function* addTabForClass({payload}) {
    const {classname} = payload;
    const tab = newSearchTab(classname);
    yield put.resolve(createSearchInstance(tab.instanceName, classname));
    yield put.resolve(doInitializeSearchParams(tab.instanceName));
    yield put.resolve({
        type: ACTIONS.CREATED_TAB_FOR_CLASS,
        payload: {classname, tab}
    });
    yield call(storeUserSettings, classname);
    yield call(updateWindowLocation, classname);
}

function newSearchTab(classname) {
    return {
        instanceName: nextInstanceName(classname),
        name: formatStr('do_extended_search'),
        iconName: 'csweb_search_icon_svg',
        kind: 'SEARCH'
    };
}

function* removeTabForClass({payload}) {
    // Note: the tab is already gone from the store when this function is called,
    // see the docs: "when an action is dispatched to the store, the middleware
    // first forwards the action to the reducers and then notifies the Sagas".
    const {classname, instanceName} = payload;
    const {tabsByClass, currentTabByClass} = yield select();
    yield put({
        type: SEARCH_ACTIONS.REMOVE_SEARCH_INSTANCE,
        payload: {instanceName, classname}
    });
    if (currentTabByClass.get(classname) === instanceName) {
        // For now, if the active tab was deleted, set the last tab to active.
        // It might be better to use one nearer the old position, but that would
        // require an additional action that does not manipulate the store (see
        // above).
        const tabs = tabsByClass.get(classname);
        const next = (tabs.size === 0) ? null : tabs.last().get('instanceName');
        yield put({
            type: ACTIONS.SET_ACTIVE_TAB,
            payload: {classname, instanceName: next}
        });
    }
}

function* reOrderTabsForClass({payload}) {
    const {classname, draggedInstanceName} = payload;
    yield put({
        type: ACTIONS.SET_ACTIVE_TAB,
        payload: {
            instanceName: draggedInstanceName,
            storeSettings: true,
            classname
        }
    });
}

/**
 * When a search favourite is selected, set the name for the corresponding tab to
 * the name of the favourite.
 */
function* selectFavourite({payload}) {
    const {instanceName, favouriteId} = payload;
    const state = yield select();
    const classname = getClassname(state, instanceName);
    const name = getFavouriteName(state, classname, favouriteId);
    yield put({
        type: ACTIONS.SET_TAB_NAME,
        payload: {classname, instanceName, name}
    });
}

function* activeTabSet({payload}) {
    // Active Tab has been set in the store, propagate that to the backend
    const {classname, storeSettings} = payload;
    if (storeSettings) {
        yield call(storeUserSettings, classname);
    }
    yield call(updateWindowLocation, classname);
}

function* storeUserSettings(classname) {
    const state = yield select();
    const {tabsByClass, currentTabByClass} = state;
    const tabs = tabsByClass.get(classname).map(tab => {
        const instanceName = tab.get('instanceName');
        return tab.merge({
            searchValues: getSearchValues(state, instanceName),
            attributeOrder: getAttributeOrder(state, instanceName),
            favouriteId: getFavouriteId(state, instanceName)
        });
    });
    const data = {
        active_tab: currentTabByClass.get(classname),
        tabs
    };
    yield put(storeUserSetting(USER_SETTING_KEY, classname, data));
}

function* updateWindowLocation(classname) {
    const state = yield select();
    if (updateLocationAllowed(state)) {
        const {currentTabByClass} = state;
        const query = {active_tab_id: currentTabByClass.get(classname)};
        const values = getSearchValues(state, query.active_tab_id);
        const attributes = getAttributeOrder(state, query.active_tab_id);
        query.search_attributes = attributes.toArray();
        query.search_values = attributes.map(attr => values.get(attr)).toArray();
        if (!getNotYetSearched(state, query.active_tab_id)) {
            query.search_on_navigate = true;
        }
        browserHistory.replace({
            pathname: browserHistory.location.pathname,
            search: qs.stringify(query),
            state: browserHistory.location.state
        });
    }
}

function* setStateFromLocation(classname, tabs) {
    const {instanceName, searchOnNavigate, attributes, values} =
        extractQueryParams(browserHistory.location.search);
    const state = yield select();
    const searchValues = getSearchValues(state, instanceName);
    const attributeOrder = getAttributeOrder(state, instanceName);

    if (searchOnNavigate) {
        yield put.resolve(setSearchOnNavigate(instanceName, true));
    }

    if (tabs.some(t => t.instanceName === instanceName)
        && queryParamsMatchTab(attributes, values, attributeOrder, searchValues))
    {
        return instanceName;
    }
    if (attributes.length === 0) {
        return null;
    }
    const newTab = newSearchTab(classname);
    yield put.resolve(createSearchInstance(
        newTab.instanceName, classname, undefined, values, attributes));
    yield put.resolve({
        type: ACTIONS.CREATED_TAB_FOR_CLASS,
        payload: {classname, tab: newTab}
    });
    return newTab.instanceName;
}

function queryParamsMatchTab(query_attrs, query_values, attributeOrder, searchValues) {
    return (query_attrs.length === 0
        || (attributeOrder.equals(Immutable.fromJS(query_attrs))
            && (searchValues.equals(Immutable.fromJS(query_values))))
    );
}

function extractQueryParams(queryString) {
    const query = qs.parse(queryString, {ignoreQueryPrefix: true});
    let attributes = [];
    let values = {};
    if (Array.isArray(query.search_attributes) && Array.isArray(query.search_values)) {
        attributes = query.search_attributes;
        values = attributes.reduce(
            (acc, val, idx) => ({...acc, [val]: query.search_values[idx]}),
            {}
        );
    }
    return {
        instanceName: query.active_tab_id,
        searchOnNavigate: query.search_on_navigate,
        attributes,
        values
    };
}

function* searchDone({payload}) {
    const {instanceName} = payload;
    const state = yield select();
    const classname = getClassname(state, instanceName);
    yield call(storeUserSettings, classname);
    yield call(updateWindowLocation, classname);
}

function* handleSubmitSaga(action) {
    const {info, result} = action.payload.operation;
    const name = info.get('opname');
    // On CDB_Create, display notification and add new object to history
    if (name === 'CDB_Create' && result.object) {
        const description = result.object["system:description"];
        yield ReduxSaga.effects.put(addNotification(
            NOTIFICATION_ID,
            formatStr(
                'op_object_created_title',
                {class_label: description}),
            React.createElement(ErrorNotification, {result}),
            'success',
            1,
            null,
            20000
        ));
    }
}

function* watcher() {
    yield takeEvery(SEARCH_ACTIONS.INIT_CLASS_SEARCH_DONE, loadTabsForClass);
    yield takeEvery(ACTIONS.ADD_TAB_FOR_CLASS, addTabForClass);
    yield takeEvery(ACTIONS.REMOVE_TAB_FOR_CLASS, removeTabForClass);
    yield takeEvery(ACTIONS.REORDER_TABS_FOR_CLASS, reOrderTabsForClass);
    yield takeEvery(ACTIONS.SET_ACTIVE_TAB, activeTabSet);
    yield takeEvery(SEARCH_ACTIONS.SELECT_FAVOURITE, selectFavourite);
    yield takeEvery(SEARCH_ACTIONS.SEARCH_DONE, searchDone);
    yield ReduxSaga.effects.takeEvery(ACTIONS.HANDLE_SUBMIT, handleSubmitSaga);
}

Registry.registerSaga(watcher);
