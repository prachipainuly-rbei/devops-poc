/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: NodeRenderer.jsx 178335 2018-06-04 12:54:10Z cla $"
 */

import Immutable from 'immutable';
import React from 'react';
import {PropTypes, ImmutablePropTypes, classNames} from 'cs-web-components-externals';
import {compose, getDisplayName, prefixNS} from '../helpers.js';
import Navigation from '../components/navigation';
import SVGIcon from '../components/SVGIcon.jsx';

const HIGHLIGHT_NO_MATCHES = 0;
const HIGHLIGHT_SELECTED_MATCH = 1;
const HIGHLIGHT_ALL_MATCHES = 2;

/**
 * Tree Renderer API. This allows to create custom tree renderers. The
 * high level functions provided in this module can be used to generate
 * custom tree renderers.
 *
 * The concepts used here are Renderers, Enhancements and Extractors.
 *
 * Renderers
 * ---------
 *
 * Renderers are either base renderers or enhancements. Base Renderers
 * are renderers, while enhancements are HOCs that return a renderer if
 * provided a renderer as parameter. Available components are:
 *
 * Base Renderers:
 *
 * - :ref:`cs-web-components-base-tree.NodeRenderer.NodeRenderer`: Renders a text
 *   string. Search results are highlighted.
 *
 * Enhancements:
 *
 * - :ref:`cs-web-components-base-tree.NodeRenderer.WithHoverLink`: Render a link
 *   to the right of the content, when mouse
 *   is hovered over over content.
 * - :ref:`cs-web-components-base-tree.NodeRenderer.WithLink`: Render a link
 *   to the right of the content.
 * - :ref:`cs-web-components-base-tree.NodeRenderer.WithIcons`: Render a set
 *   of icons to the left of content.
 *
 * Renderers and enhancements are usually provided as HOCs that need to
 * be parametrized to obtain a renderer or enhancements.
 *
 * Extractors
 * ----------
 *
 * An extractor is usually provided as argument to a generator. It extracts
 * the relevant information for rendering from a node.
 *
 * An extractor may either be provided as an array of strings - then
 * it will be used as argument to the getIn function of the node to
 * extract the information required by the generator - or as a function.
 * This function will be applied to each node to extract the information
 * for the generator.
 *
 * As an array an extractor looks like this:
 *
 * .. code-block:: javascript
 *
 *    const e = ['content', 'icon'];
 *
 * The equivalent function is:
 *
 * .. code-block:: javascript
 *
 *    const e = node => node.getIn(['content', 'icon']);
 *
 * Composing Renderers and Enhancements
 * ------------------------------------
 *
 * Node renderers may be created using the create function. This function
 * takes as argument a renderer and a list of enhancement, and returns the
 * renderer, by applying the provided enhancements to the renderer.
 *
 * Suppose we want to render a node which has the following content field:
 *
 * .. code-block:: none
 *
 *    {
 *        label: <string>,
 *        icon_url: <string>,
 *        link: <string>
 *    }
 *
 * In order to render a node for this structure with link and icon, the
 * following renderer component may be used:
 *
 * .. code-block:: javascript
 *
 *     const RestNodeRenderer =
 *         NodeRenderer.create(
 *             NodeRenderer.NodeRenderer(['content', 'label']),
 *             NodeRenderer.WithIcons(node =>
 *                 [
 *                     {
 *                         url: node.getIn(['content', 'icon_url']),
 *                         title: node.getIn(['content', 'label'])
 *                     }
 *                 ]
 *             ),
 *             NodeRenderer.WithHoverLink(['content', 'link'])
 *     );
 *
 * Implementing custom renderers
 * -----------------------------
 *
 * It is also possible to implement custom renderers. An elaborate example can be found in
 * cs.sharing: RecipientListTree provides a delete button for each node, which issues a REST
 * call to delete this node.
 *
 * A custom renderer enhancement is a function that takes a NodeRenderer as a parameter and
 * returns a component that renders the provided NodeRenderer, usually along additional
 * components:
 *
 * .. code-block:: javascript
 *
 *   const MyNodeRendererEnhancement(props) => {
 *     return props => <NodeRenderer {...props} />
 *   }
 *
 * This example is a no-op: It simply renders the provided node. Simple enhancements can be
 * realized easily. Suppose you want to render a folder or file-icon, depending on wether your
 * node has children:
 *
 * .. code-block:: none
 *
 *   const WithFsIcon(props) => {
 *     return props => (
 *       <span>
 *         {
 *           <Icon src={props.get('has_children') ?
 *                      "path/to/folder.svg" :
 *                      "path/to/file.png"}/>
 *         }
 *         <NodeRenderer {...props} />
 *       </span>
 *     );
 *   }
 *
 * Note that this particular example may be easily achieved using the WithIcons enhancement.
 *
 * @module
 */

export const NodeRendererType = PropTypes.oneOfType([
    PropTypes.func,
    PropTypes.instanceOf(React.Component)
]);

/**
 *
 * Input is a function or array - an extractor. If it is an array, it
 * returns a function that retrieves the value at that path from
 * a provided node. If it is a function the function itself is returned.
 * Used so either Paths for Immutable.Map.getIn or functions may be
 * passed to Renderer-Generators.
 *
 * Use this to create your own API compliant Renderer-Generators.
 *
 * @param fnOrArray
 * @return {function}
 */
export function generateExtractor(fnOrArray) {
    return Array.isArray(fnOrArray) ?
           (node => node.getIn(fnOrArray)) :
           fnOrArray;
}

function extractorToString(fnOrArray) {
    return Array.isArray(fnOrArray) ?
           `[${fnOrArray.join(', ')}]` :
           fnOrArray;
}

/**
 *
 * Create an enhanced renderer from a base renderer and a list of enhancements.
 *
 * @param renderer {ReactComponent} - a base renderer, e.g.,
 *        :ref:`cs-web-components-base-tree.NodeRenderer.DefaultRenderer`
 * @param enhancements {array} - an array of HOCs
 * @return {ReactComponent}
 * @function
 */
const create = compose;

// Split a label according to a match using the trees search function
// This enables highlighting the matched part of the label.
const splitForMatch = (label, match) => (
    {
        prefix: label.substring(0, match.value.start),              // Before match
        match: label.substring(match.value.start, match.value.end), // Matched substring
        suffix: label.substring(match.value.end)                    // After match
    }
);

/**
 * HOC that creates a base renderer component. This simply displays the
 * extracted label.
 *
 * @param nodeToLabel - extractor returning a string or component
 *                      used as label by the renderer.
 * @return {ReactComponent}
 * @function
 */
export const NodeRenderer = (
    nodeToLabel, highlightMatchMode = HIGHLIGHT_SELECTED_MATCH, nodeToTitle = undefined
) => {
    const Component = props => {
        const isSelected = props.node.get('is_selected');
        const label = generateExtractor(nodeToLabel)(props.node);
        const classNames = [prefixNS('tree-node-renderer')];
        let renderedLabel = label;
        if (props.searchMatch && (highlightMatchMode === HIGHLIGHT_ALL_MATCHES ||
                                  (highlightMatchMode === HIGHLIGHT_SELECTED_MATCH &&
                                   props.getSelectedSearchResult().get('id') ===
                                       props.node.get('id')))) {
            classNames.push(prefixNS('matched-tree-node'));
            if (props.searchMatch.type && props.searchMatch.type === 'substring') {
                // Create spans for highlighting
                const splittedLabel = splitForMatch(label, props.searchMatch);
                renderedLabel = [
                    <span key="prefix">{splittedLabel.prefix}</span>,
                    <span key="match"
                          className={isSelected ?
                                     prefixNS('selected-tree-node-highlight') :
                                     prefixNS('matched-tree-node-highlight')}>
                        {splittedLabel.match}
                    </span>,
                    <span key="suffix">{splittedLabel.suffix}</span>
                ];
            }
        }

        if (props.node.get('is_selected')) {
            classNames.push('selected_tree_node');
        }

        const title = (nodeToTitle && generateExtractor(nodeToTitle)(props.node)) || label;

        return (
            <span className={classNames.join(' ')}
                  title={title}>
                {renderedLabel}
            </span>
        );
    };

    Component.propTypes = {
        getSelectedSearchResult: PropTypes.func,
        node: ImmutablePropTypes.map,
        searchMatch: PropTypes.shape({
            type: PropTypes.string,
            value: PropTypes.shape({
                start: PropTypes.number,
                end: PropTypes.number
            })
        })
    };

    Component.displayName =
        `NodeRenderer(${extractorToString(nodeToLabel)}, ${highlightMatchMode})`;

    return Component;
};

/**
 * This Generator enhances a given NodeRenderer with a link
 * symbol rendered to the right of the component.
 *
 * @param nodeToLink - should extract a string representing a
 *                     URL from the node.
 * @return {HOC}
 * @function
 */
export const WithLink = nodeToLink => NodeRenderer => {
    const Component = props => {
        const link = generateExtractor(nodeToLink)(props.node);
        return link ? (
            <span className={prefixNS('tree-node-renderer-component')}>
                <NodeRenderer {...props} />
                &nbsp;
                <Navigation.Link className="object-link"
                                 to={link}>
                    <SVGIcon name="csweb_link" size="sm"/>
                </Navigation.Link>
            </span>
        ) : (
            <NodeRenderer {...props} />
        );
    };

    Component.propTypes = {
        node: ImmutablePropTypes.map
    };

    Component.displayName =
        `WithLink(${extractorToString(nodeToLink)}, ${getDisplayName(NodeRenderer)})`;

    return Component;
};

/**
 * This Generator enhances a given NodeRenderer with a link
 * symbol rendered to the right of the component. The link is
 * only visible when the mouse is over the component.
 *
 * @param nodeToLink - should extract a string representing a
 *                     URL from the node.
 * @return {HOC}
 * @function
 */
export const WithHoverLink = nodeToLink => NodeRenderer => {
    class _WithHoverLink extends React.Component {
        constructor(props) {
            super(props);
            this.extractor = generateExtractor(nodeToLink);
            this.state = {
                isLinkVisible: false
            };
        }

        setLinkVisible(visible) {
            this.setState({
                isLinkVisible: visible
            });
        }

        render() {
            const iconClassName = classNames(
                {
                    [prefixNS('tree-node-renderer-link-unselected')]:
                    !(this.state.isLinkVisible || this.props.node.get('is_selected'))
                }
            );
            const link = this.extractor(this.props.node);
            return link ? (
                <span onMouseEnter={this.setLinkVisible.bind(this, true)}
                      onMouseLeave={this.setLinkVisible.bind(this, false)}
                      className={prefixNS('tree-node-renderer-component')}>
                    <NodeRenderer {...this.props} />
                    &nbsp;
                    <Navigation.Link disabled={!this.state.isLinkVisible}
                                     className="object-link"
                                     to={link}>
                        <SVGIcon className={iconClassName}
                                 name="csweb_link" size="sm" />
                    </Navigation.Link>
                </span>
            ) : (
                <NodeRenderer {...this.props} />
            );
        }
    }

    _WithHoverLink.propTypes = {
        node: ImmutablePropTypes.map
    };

    _WithHoverLink.displayName =
        `WithHoverLink(${extractorToString(nodeToLink)}, ${getDisplayName(NodeRenderer)})`;

    return _WithHoverLink;
};

/**
 * This generator enhances a given NodeRenderer with a list of
 * icons that will be rendered left to the component
 *
 * The list generated by the provided exctractor should have the
 * form:
 *
 * .. code-block: json
 *
 *    [
 *      Immutable.fromJS({
 *        url: 'http://example.com/some_link_to_a_png',
 *        title: 'an optional text explaining the icon'
 *      }),
 *      ...
 *    ]
 *
 * @param nodeToIcons - extractor that generates a list like the above
 * @return {HOC}
 * @function
 */
export const WithIcons = nodeToIcons => {
    const extractor = generateExtractor(nodeToIcons);
    return NodeRenderer => {
        const _WithIcons = props => {
            const icons = extractor(props.node);
            const clsnames = classNames(
                prefixNS('tree-node-with-icons'),
                {[prefixNS('selected-tree-node')]: props.node.get('is_selected')}
            );
            return icons ? (
                <span className={clsnames}>
                    {icons
                        .filter(icon => Boolean(icon))                                   // Remove undefined entries
                        .map(icon => Immutable.Map.isMap(icon) ? icon.toJS() : icon)     // Convert immutable to plain
                        .filter(icon => icon['url'])                                     // Filter entries without url
                        .map(icon => <SVGIcon key={props.node.get('id') + '-' + icon['url']}
                                              size="sm"
                                              src={icon['url']}
                                              title={icon['title']}
                                              alt={icon['title']}/>)}
                    <NodeRenderer {...props} />
                </span>
            ) : (
                <NodeRenderer {...props} />
            );
        };

        _WithIcons.propTypes = {
            node: ImmutablePropTypes.map
        };

        _WithIcons.displayName =
            `WithIcons(${extractorToString(nodeToIcons)}, ${getDisplayName(NodeRenderer)})`;

        return _WithIcons;
    };
};

/**
 * Simple default renderer that uses the nodes `content`
 * field as label.
 * @param props {object}
 * @function
 */
const DefaultRenderer = NodeRenderer(['content']);
DefaultRenderer.WithIcons = WithIcons;
DefaultRenderer.WithHoverLink = WithHoverLink;
DefaultRenderer.WithLink = WithLink;
DefaultRenderer.NodeRenderer = NodeRenderer;
DefaultRenderer.create = create;
DefaultRenderer.generateExtractor = generateExtractor;
DefaultRenderer.NodeRendererType = NodeRendererType;
DefaultRenderer.HIGHLIGHT_NO_MATCHES = HIGHLIGHT_NO_MATCHES;
DefaultRenderer.HIGHLIGHT_SELECTED_MATCH = HIGHLIGHT_SELECTED_MATCH;
DefaultRenderer.HIGHLIGHT_ALL_MATCHES = HIGHLIGHT_ALL_MATCHES;

export default DefaultRenderer;
