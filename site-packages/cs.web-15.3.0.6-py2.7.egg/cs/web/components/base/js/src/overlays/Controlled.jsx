/*
 * Copyright (C) 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Controlled.jsx 184286 2018-09-21 13:59:56Z cla $"
 */

import React from 'react';
import ReactDOM from 'react-dom';
import {PropTypes} from 'cs-web-components-externals';
import {addLocalShortcut, removeAllLocalShortcuts} from '../key-handlers.js';

/**
 * This module provides a HOC that provides functionality to display
 * and hide overlays as a result of user interaction.
 *
 * The main point of this HOC is the ``onHide`` callback. This will allow you to
 * close the overlay according to user's expectations:
 *
 * - Either by pressing the ``Escape`` key, when the overlay is focused
 * - or by focusing another element.
 *
 * Note that the actual visibility state has to be stored by the user, so you are
 * able to handle the ``onHide`` callback to your liking.
 *
 * Removed React Properties
 * ========================
 *
 * - onBlur: Used for ``onHide``.
 *
 * Added React Properties
 * ======================
 *
 * ================= ========================= =========================================
 *    Name              Type                      Description
 * ================= ========================= =========================================
 *  grabFocus         bool, default ``false``   Should focus be set to the overlay
 *                                              on show
 *  onHide            function                  Called when the overlay should be
 *                                              hidden
 *  hideOnScroll      boolean                   If set, ``onHide`` will be invoked when
 *                                              scrolling happens in a container.
 * ================= ========================= =========================================
 *
 * .. warning::
 *
 *    This component is not considered part of the supported cs.web API. This documentation
 *    is solely provided for informational purposes and the documented interfaces may be
 *    subject to change without prior notification.
 *
 * @module
 */
export default function Controlled(Component) {
    class Controlled extends React.Component {
        constructor(props) {
            super(props);
            this.overlayElement = null;
            this.setOverlayRef = this.setOverlayRef.bind(this);
            this.onScroll = this.onScroll.bind(this);
            this.onHide = this.onHide.bind(this);
            this.onFocusOut = this.onFocusOut.bind(this);
            this.onEscape = this.onEscape.bind(this);
            this.onOverlayVisible = this.onOverlayVisible.bind(this);
        }

        componentDidMount() {
            const {hideOnScroll} = this.props;
            if (hideOnScroll) {
                window.addEventListener('scroll', this.onScroll, true);
            }
        }

        componentWillReceiveProps(nextProps) {
            if (nextProps.hideOnScroll && !this.props.hideOnScroll) {
                window.addEventListener('scroll', this.onScroll, true);
            } else if (!nextProps.hideOnScroll && this.props.hideOnScroll) {
                window.removeEventListener('scroll', this.onScroll, true);
            }
        }

        componentWillUnmount() {
            const {hideOnScroll} = this.props;
            if (hideOnScroll) {
                window.removeEventListener('scroll', this.onScroll, true);
            }
        }

        onScroll(event) {
            if (this.props.visible && !this.overlayElement.contains(event.target)) {
                this.onHide(event);
            }
        }

        onFocusOut(event) {
            // If focus moves out of overlay hide it.
            if (event && event.type === 'focusout' &&
                this.overlayElement.contains(event.relatedTarget)) {
                return;
            }

            this.onHide(event);
        }

        onEscape(event) {
            this.onHide(event);
            event.stopImmediatePropagation();
        }

        onHide(event) {
            const {onHide} = this.props;
            if (onHide) {
                onHide(event);
            }
        }

        onOverlayVisible() {
            const {grabFocus} = this.props;
            if (grabFocus) {
                this.overlayElement.focus();
            }
        }

        setOverlayRef(c) {
            if (c) {
                this.overlayElement = ReactDOM.findDOMNode(c);  // eslint-disable-line react/no-find-dom-node
                addLocalShortcut(this.overlayElement, 'Escape', this.onEscape);
            } else {
                removeAllLocalShortcuts(this.overlayElement);
                this.overlayElement = null;
            }

            const {setOverlayRef} = this.props;
            if (setOverlayRef) {
                setOverlayRef(c);
            }
        }

        render() {
            return (
                <Component {...this.props}
                           hideOnScroll={undefined}
                           grabFocus={undefined}
                           onFocusOut={this.onFocusOut}
                           onOverlayVisible={this.onOverlayVisible}
                           setOverlayRef={this.setOverlayRef} />
            );
        }
    }

    Controlled.propTypes = {
        hideOnScroll: PropTypes.bool,
        setOverlayRef: PropTypes.func,
        onHide: PropTypes.func,
        grabFocus: PropTypes.bool,
        visible: PropTypes.bool,
    };

    Controlled.defaultProps = {
        grabFocus: true,
        hideOnScroll: false,
    };

    return Controlled;
}
