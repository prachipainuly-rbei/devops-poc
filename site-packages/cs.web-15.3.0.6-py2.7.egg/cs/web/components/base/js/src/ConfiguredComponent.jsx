/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: ConfiguredComponent.jsx 184899 2018-10-10 09:44:06Z bwf $"
 */

import Immutable from 'immutable';
import React from 'react';
import {Registry} from './registry';
import {Console, debugMode, prefixNS} from './helpers.js';
import {PropTypes, ImmutablePropTypes, classNames} from 'cs-web-components-externals';
import SVGIcon from './components/SVGIcon.jsx';
import {formatStr} from './i18n.js';

import component_icon from '../../resources/cis_puzzle.svg';

let instanceCounter = 0;

/**
 * Generate a unique instance name for components, so that each component can
 * hold its own local state in the global store.
 */
function nextInstanceName() {
    const result = `instance-${instanceCounter}`;
    instanceCounter++;
    return result;
}

export function makeConfiguredComponentClass(conf) {
    return function ConfiguredComponentClass(props) {
        return <ConfiguredComponent configuration={conf} {...props} />;
    };
}

function getIssueMessage(issueType) {
    switch (issueType) {
        case 'not-found':
            return (
                <div className={classNames(
                    prefixNS('component-issue__message'),
                    prefixNS('component-issue__message--not-found'))}>
                    {formatStr('configuredcomponent_notfound')}
                </div>);
        case 'error':
            return (
                <div className={classNames(
                    prefixNS('component-issue__message'),
                    prefixNS('component-issue__message--error'))}>
                    {formatStr('configuredcomponent_error')}
                </div>);
    }
    return null;
}

function ComponentIssue(props) {
    const {issueType, componentName} = props;
    return (
        <div className={prefixNS('component-issue')}>
            <SVGIcon
                className={prefixNS(`component-issue__visual--` + issueType)}
                src={component_icon}
                size="lg"
            />
            {getIssueMessage(issueType)}
            <div className={prefixNS('component-issue__name')}>
                {componentName}
            </div>
            <div className={prefixNS('component-issue__issue')}>
                {formatStr('configuredcomponent_issue')}
            </div>
        </div>
    );
}
ComponentIssue.propTypes = {
    issueType: PropTypes.string.isRequired,
    componentName: PropTypes.string.isRequired
};

function ComponentNotFound(props) {
    const {componentName} = props;
    return (
        <ComponentIssue
            issueType="not-found"
            componentName={componentName}
        />
    );
}
ComponentNotFound.propTypes = {
    componentName: PropTypes.string
};

function ComponentError_Debug(props) {
    const {componentName} = props;
    return (
        <ComponentIssue
            issueType="error"
            componentName={componentName}
        />
    );
}
ComponentError_Debug.propTypes = {
    componentName: PropTypes.string,
    error: PropTypes.object
};

function ComponentError(props) {
    const {componentName} = props;
    return (
        <ComponentIssue
            issueType="error"
            componentName={componentName}
        />
    );
}
ComponentError.propTypes = {
    componentName: PropTypes.string,
    error: PropTypes.object
};

/**
 * Takes an application configuration, and returns a React component that
 * renders this configuration.
 * Configuration members:
 * * name: name for the root component, looked up in the registry
 * * properties: properties for the root component
 * * children: List of configurations for child components, rendered as normal children
 * * components: Map with named configurations, resulting elements become props
 * * componentClasses: like components, but classes are passed, not elements
 */
export default class ConfiguredComponent extends React.Component {
    constructor(props) {
        super(props);
        this._instanceName = nextInstanceName();
        this.state = this.fromConfiguration(props.configuration);
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.configuration !== this.props.configuration) {
            this.setState(this.fromConfiguration(nextProps.configuration));
        }
    }

    componentDidCatch(error) {
        this.setState({
            RootComponent: debugMode ? ComponentError_Debug : ComponentError,
            staticProps: {
                instanceName: this._instanceName,
                componentName: this.props.configuration.get('name'),
                error,
            },
            configuredChildren: Immutable.List(),
            components: Immutable.Map(),
            componentName: this.props.configuration.get('name'),
        });
    }

    fromConfiguration(conf) {
        let componentName;
        let RootComponent;
        let configuredChildren;
        let components;
        let componentClasses;
        let properties;
        if (conf) {
            componentName = conf.get('name');
            RootComponent = Registry.findComponent(componentName);
            if (RootComponent === undefined) {
                Console.warn(`Component ${componentName} is undefined.`);
                return {
                    RootComponent: ComponentNotFound,
                    staticProps: {
                        instanceName: this._instanceName,
                        componentName
                    },
                    configuredChildren: Immutable.List(),
                    components: Immutable.Map(),
                    componentName,
                };
            }

            properties = conf.get('properties', Immutable.Map()).toJS();
            // components configured as children of the root
            configuredChildren = conf.get('children', Immutable.List());
            // configured components are React elements that are given as props to the
            // root
            components = conf.get('components', Immutable.Map());
            // componentClasses are not instantiated as react elements here, but are
            // given to the root component as props holding react classes
            componentClasses = conf
                .get('componentClasses', Immutable.Map())
                .map(c => makeConfiguredComponentClass(c))
                .toObject();
        }
        // collect statically computable properties to give to the root component
        const staticProps = Object.assign(
            {
                instanceName: this._instanceName
            },
            properties,
            componentClasses
        );
        return {
            componentName, // save name in state only for debugging
            RootComponent,
            configuredChildren,
            components,
            staticProps
        };
    }

    render() {
        const {
            RootComponent,
            configuredChildren,
            components,
            staticProps
        } = this.state;
        const {children, ...otherProps} = this.props;
        delete otherProps.configuration;
        const cchildren = configuredChildren
            .map((conf, idx) => (
                <ConfiguredComponent
                    key={idx}
                    configuration={conf}
                    {...otherProps}
                />
            ))
            .toArray();
        const allChildren = cchildren.concat(React.Children.toArray(children));
        /* eslint-disable react/jsx-key */
        const componentEls = components
            .map(conf => (
                <ConfiguredComponent configuration={conf} {...otherProps} />
            ))
            .toObject();
        /* eslint-enable react/jsx-key */
        return React.createElement(
            RootComponent,
            {...staticProps, ...componentEls, ...otherProps},
            ...allChildren
        );
    }
}

ConfiguredComponent.propTypes = {
    configuration: ImmutablePropTypes.map
};
