/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: PasswordChange.jsx 174212 2018-03-08 10:50:39Z vov $"
 */


import {formatStr} from '../i18n';
import React from 'react';
import Immutable from 'immutable';
import {
    Popover,
    FormControl,
    FormGroup,
    ControlLabel,
    OverlayTrigger
} from 'react-bootstrap';
import {PropTypes, connect, classNames} from 'cs-web-components-externals';
import Dialog from '../dialogs';
import SVGIcon from './SVGIcon.jsx';
import {sharedTextInputProps} from '../formcontrols/sharedPropTypes';
import {postForm, getJSON} from '../fetch';
import {prefixNS} from '../helpers';
import {addNotification} from '../actions/notification.js';


const initialState = {
    authRules: Immutable.List(),
    rulesFetched: false,
    passwordFormDisabled: true,
    oldPassword: "",
    newPassword: "",
    passwordConfirm: "",
    oldPasswordWrong: false,
    rulesViolated: false,
    passwordMismatch: false,
    submittingPassword: false,
};


class PasswordInput extends React.Component {
    constructor(props) {
        super(props);
        this.formControl = null;
        this.onKeyDown = this.onKeyDown.bind(this);
        this.onChange = this.onChange.bind(this);
    }

    onKeyDown(event) {
        const {onEnter, onKeyDown} = this.props;
        // Dispatch Event itself
        if (onKeyDown) {
            onKeyDown(event);
            // onKeyDown may prevent default
            if (event.isDefaultPrevented()) {
                return;
            }
        }
        // Call special handler
        if (event.key === 'Enter') {
            event.preventDefault();
            if (onEnter) {
                onEnter();
            }
        }
        // The IE calls the previous page if the field is read only
        if (event.key === 'Backspace' && this.props.readOnly) {
            event.preventDefault();
        }
    }

    onChange(event) {
        const {onChange, onValueChange} = this.props;
        if (onValueChange) {
            onValueChange(event.target.value);
        }
        if (onChange) {
            event.persist();
            return onChange(event);
        }
        return undefined;
    }

    grabFocus() {
        this.formControl.focus();
        this.formControl.select();
    }

    componentDidMount() {
        if (this.props.validationState === 'error') {
            this.grabFocus();
        }
    }

    componentDidUpdate(prevProps) {
        if (prevProps.validationState === null
                && this.props.validationState === 'error') {
            this.grabFocus();
        }
    }

    render() {
        const {
            label, tooltip, validationState,
            mandatory, mandatoryEmptyHint, className,
            compact, feedbackControl, overlayTrigger, overlayPlacement,
            overlay, ...others
        } = this.props;

        delete others.onKeyDown;
        delete others.onEnter;
        delete others.onValueChange;
        delete others.operationInstance;
        delete others.uncheckedValues;
        delete others.children;

        // XXX Note that we use onInput to handle changes on FormControl
        // as a workaround to https://github.com/facebook/react/issues/7027

        const classes = classNames(className, 'no-ie-text-input-clear-button');
        let inputControl = null;
        if (overlay !== null) {
            inputControl = (
                <OverlayTrigger trigger={overlayTrigger}
                                placement={overlayPlacement}
                                overlay={overlay}>
                    <FormControl type="text"
                                 {...others}
                                 className={classes}
                                 onKeyDown={this.onKeyDown}
                                 onInput={this.onChange}
                                 inputRef={input => {this.formControl = input}} />
                </OverlayTrigger>
            );
        } else {
            inputControl = (
                <FormControl type="text"
                             {...others}
                             className={classes}
                             onKeyDown={this.onKeyDown}
                             onInput={this.onChange}
                             inputRef={input => {this.formControl = input}} />
            );
        }
        const groupClass = classNames({
            [prefixNS('formcontrols-textinput-compact')]: compact
        });
        return (
            <FormGroup className={groupClass}
                       validationState={validationState}
                       data-mandatory={mandatory}
                       data-mandatory-empty-hint={mandatoryEmptyHint}>
                <ControlLabel title={tooltip}>{label}</ControlLabel>
                {inputControl}
                {feedbackControl}
            </FormGroup>
        );
    }
}

PasswordInput.propTypes = {
    ...sharedTextInputProps,
    onKeyDown: PropTypes.func,
    onEnter: PropTypes.func,
    onValueChange: PropTypes.func,
    feedbackControl: PropTypes.node,
    validationState: PropTypes.oneOf(['success', 'warning', 'error', null]),
    overlayTrigger: PropTypes.oneOfType([
        PropTypes.oneOf(["manual", "click", "hover", "focus"]),
        PropTypes.arrayOf(PropTypes.oneOf(["click", "hover", "focus"]))
    ]),
    overlayPlacement: PropTypes.oneOf(["top", "right", "bottom", "left"]),
    overlay: PropTypes.node,
};

PasswordInput.defaultProps = {
    compact: false
};

class PasswordChange extends React.Component {

    constructor(props) {
        super(props);
        this.state = initialState;
        this.state.ruleFetchError = false;
        this.submitPassword = this.submitPassword.bind(this);
        this.close = this.close.bind(this);
    }

    close() {
        this.setState(initialState);
        this.props.onClose();
    }

    componentDidUpdate() {
        if (this.props.show && !this.state.rulesFetched) {
            getJSON('/changepwd/rules').then(
                (rules) => {
                    this.setState({
                        rulesFetched: true,
                        authRules: Immutable.List(rules),
                        passwordFormDisabled: false,
                    });
                },
                (error) => {
                    this.close();
                    this.props.onLoadError();
                    throw error;
                }
            );
        }
    }

    doSubmit() {
        if (this.state.newPassword !== this.state.passwordConfirm) {
            this.setState({
                passwordMismatch: true,
                passwordFormDisabled: false,
            });
            return;
        }

        const formData = new FormData();
        formData.append('username', this.props.userLogin);
        formData.append('old_password', this.state.oldPassword);
        formData.append('new_password', this.state.newPassword);

        postForm('/changepwd', formData).then(
            () => {
                this.props.addNotification('pwdchange',
                    formatStr('pwd_changed_title'),
                    formatStr('pwd_changed'),
                    'success',
                    null,
                    null,
                    5000);
                this.close();
            },
            (err) => {
                if (err.response.status === 401) {
                    this.setState({
                        passwordFormDisabled: false,
                        oldPasswordWrong: true,
                        oldPassword: "",
                    });
                } else if (err.response.status === 409) {
                    err.response.json().then((data) => {
                        this.setState({
                            passwordFormDisabled: false,
                            rulesViolated: true,
                            authRules: Immutable.List(data),
                            newPassword: "",
                            passwordConfirm: "",
                        });
                    });
                }
            }
        );
    }

    submitPassword() {
        // Split resetting the form and submitting the request to get
        // proper reset and rendering of the error state
        this.setState({
            passwordFormDisabled: true,
            oldPasswordWrong: false,
            passwordMismatch: false,
            rulesViolated: false,
        }, this.doSubmit);
    }

    renderPopover(id, content, className = 'popover-error') {
        return <Popover id={id} className={prefixNS(className)}>
                   {content}
               </Popover>;
    }

    renderRules() {
        return this.state.authRules.map((r) => {
            const ruleString = r.value > 0 ?
                formatStr(r.label, {count: r.value}) : formatStr(r.label);

            if (this.state.rulesViolated) {
                if (r.error) {
                    return (
                        <div key={r.label}
                                    className={prefixNS('password-rule')}>
                            <p>{ruleString}</p>
                            <SVGIcon name="csweb_remove" size="sm"/>
                        </div>
                    );
                } else {
                    return (
                        <div key={r.label}
                                    className={prefixNS('password-rule')}>
                            <p>{ruleString}</p>
                            <SVGIcon name="csweb_check" size="sm"/>
                        </div>
                    );
                }
            } else {
                return (
                    <div key={r.label}
                                className={prefixNS('password-rule')}>
                        <p>{ruleString}</p>
                    </div>
                );
            }
        }).toArray();
    }

    getFeedback(failure) {
        let validationState = null;
        let feedbackControl = null;

        if (failure) {
            validationState = "error";
            feedbackControl = <FormControl.Feedback>
                <SVGIcon
                    name='csweb_remove'
                    size="sm"
                /></FormControl.Feedback>;
        }
        return {validationState, feedbackControl};
    }

    renderPasswordForm() {
        const oldPasswordFB = this.getFeedback(this.state.oldPasswordWrong);
        const passwordConfirmFB = this.getFeedback(this.state.passwordMismatch);
        const newPasswordFB = this.getFeedback(this.state.rulesViolated);

        const oldPasswordOverlay = this.state.oldPasswordWrong ?
            this.renderPopover('old-password-popover', formatStr('pwd_password_fail'))
            : null;

        let newPasswordOverlay = null;
        const rules = this.renderRules();
        if (this.state.rulesViolated) {
            newPasswordOverlay = this.renderPopover(
                'password-rules-popover', rules);
        } else if (rules.length > 0) {
            newPasswordOverlay = this.renderPopover(
                'password-rules-popover', rules, 'popover-info');
        }

        const confirmOverlay = this.state.passwordMismatch ?
            this.renderPopover('password-mismatch-popover', formatStr('pwd_no_match'))
            : null;

        return (
            <form className={prefixNS('password-form')}>
                <PasswordInput
                    label={formatStr('pwd_old_password')}
                    name="oldpassword"
                    type="password"
                    className={prefixNS('old-password')}
                    overlayTrigger="focus"
                    overlayPlacement="right"
                    overlay={oldPasswordOverlay}
                    {...oldPasswordFB}
                    disabled={this.state.passwordFormDisabled}
                    value={this.state.oldPassword}
                    onValueChange={(val) => this.setState({oldPassword: val})}
                    onEnter={this.submitPassword}/>
                <PasswordInput
                    label={formatStr('pwd_new_password')}
                    name="newpassword"
                    type="password"
                    overlayTrigger="focus"
                    overlayPlacement="right"
                    overlay={newPasswordOverlay}
                    {...newPasswordFB}
                    disabled={this.state.passwordFormDisabled}
                    value={this.state.newPassword}
                    onValueChange={(val) => this.setState({newPassword: val})}
                    onEnter={this.submitPassword}/>
                <PasswordInput
                    label={formatStr('pwd_confirm_password')}
                    name="passwordconfirm"
                    type="password"
                    overlayTrigger="focus"
                    overlayPlacement="right"
                    overlay={confirmOverlay}
                    {...passwordConfirmFB}
                    disabled={this.state.passwordFormDisabled}
                    value={this.state.passwordConfirm}
                    onValueChange={(val) => this.setState({passwordConfirm: val})}
                    onEnter={this.submitPassword}/>
            </form>
        );
    }

    render() {
        return (
            <Dialog.Dialog title={formatStr('change_password')}
                           buttons={[
                               <Dialog.Buttons.Ok
                                   key="ok"
                                   onClick={this.submitPassword}
                                   disabled={this.state.passwordFormDisabled}/>,
                               <Dialog.Buttons.Cancel
                                   key="cancel"
                                   onClick={this.close}/>
                           ]}
                           show={this.props.show}
                           size={Dialog.Dialog.SIZE_SMALL}
                           onAction={this.submitPassword}
                           onHide={this.close}>
                <div className={prefixNS('password-change-userinfo')}>
                    <p className={prefixNS('password-username')}>{this.props.userName}</p>
                    <p className={prefixNS('password-userrole')}>{this.props.userRole}</p>
                </div>
                {this.renderPasswordForm()}
            </Dialog.Dialog>
        );
    }
}

PasswordChange.propTypes = {
    onClose: PropTypes.func.isRequired,
    onLoadError: PropTypes.func.isRequired,
    userLogin: PropTypes.string.isRequired,
    userName: PropTypes.string,
    userRole: PropTypes.string,
    userPasswordRule: PropTypes.string.isRequired,
    show: PropTypes.bool,
    addNotification: PropTypes.func.isRequired,
};

export default connect(null, {addNotification})(PasswordChange);
