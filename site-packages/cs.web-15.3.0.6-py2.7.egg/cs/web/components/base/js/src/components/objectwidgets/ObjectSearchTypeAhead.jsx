/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: ObjectSearchTypeAhead.jsx 177438 2018-05-22 12:17:58Z mbr $"
 */

import React from 'react';
import {Dropdown, MenuItem} from 'react-bootstrap';
import {PropTypes, ImmutablePropTypes, classNames} from 'cs-web-components-externals';
import {prefixNS} from '../../helpers';
import {formatStr} from '../../i18n.js';
import {SVGIconAndLabel} from '../IconAndLabel';

class ObjectResultRenderer extends React.Component {

    render() {
        const objectResult = this.props.item;
        return (
            <SVGIconAndLabel className={prefixNS('object-search-item-renderer')}
                src={objectResult.get("icon", '')}
                label={objectResult.get("title", '')}/>
        );
    }
}

ObjectResultRenderer.propTypes = {
    item: ImmutablePropTypes.map
};

class TypeDropDownMenu extends React.Component {
    render() {
        const {
            inputString, matched, activated, leadingComponent,
            ...others
        } = this.props;
        delete others.hasMoreMatches;
        return (
            <Dropdown.Menu
                className={prefixNS('formcontrols-withtypeahead-menu')}
                {...others}>
                <div>{leadingComponent}</div>
                {matched.map((item, idx) => (
                    <MenuItem eventKey={idx}
                              key={idx}
                              active={idx === activated}
                              disabled={!item.get('rest_url')}>
                        <ObjectResultRenderer inputString={inputString} item={item} />
                    </MenuItem>
                ))}
                {
                    this.props.hasMoreMatches ?
                    <div className={prefixNS("formcontrols-withtypeahead-has-more")}>
                        {formatStr("has_more")}
                    </div>
                    : null
                }
            </Dropdown.Menu>
        );
    }
}

TypeDropDownMenu.propTypes = {
    inputString: PropTypes.string,
    activated: PropTypes.number,
    matched: ImmutablePropTypes.list,
    hasMoreMatches: PropTypes.bool,
    leadingComponent: PropTypes.node
};

let typeAheadCounter = 0;


export default function(WrappedComponent) {
    class ObjectSearchTypeAhead extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                matchActive: -1,
                hide: false,
                selected: false
            };
            this.dropdownID = ++typeAheadCounter;
            // use local var to keep selecting state
            // to tell ignore input blur
            // setState does not work because of run loop
            this.selecting = false;
            this.onKeyDown = this.onKeyDown.bind(this);
            this.onChange = this.onChange.bind(this);
            this.onToggle = () => {};
            this.onSelect = this.onSelect.bind(this);
            this.onBlur = this.onBlur.bind(this);
            this.onSelecting = this.onSelecting.bind(this);
            this._wrappedElement = null;
            this._wrappedComponent = null;
        }

        isOpen() {
            const withtypeahead =
                document.querySelector('.' + prefixNS('object-search-withtypeahead'));
            const searchInput =
                document.querySelector('.' + prefixNS('object-search-input'));
            const focused = withtypeahead && withtypeahead.classList.contains('focus');
            const focused1 = searchInput && document.activeElement === searchInput;
            return (!this.state.hide && !this.state.selected && (focused || focused1));
        }

        stepMatch(step) {
            const count = this.props.matched.count();
            let nextMatch = this.state.matchActive + step;
            if (nextMatch >= count) {
                nextMatch = -1;
            }
            else if (nextMatch < -1) {
                nextMatch = count - 1;
            }
            this.setState({
                matchActive: nextMatch
            });
            if (this.props.onTAStepAt) {
                this.props.onTAStepAt(nextMatch);
            }
        }

        onKeyDown(event) {
            const {onKeyDown} = this.props;
            this.setState({
                selected: false
            });
            if (this.isOpen()) {
                switch (event.key) {
                    case 'ArrowDown':
                        this.stepMatch(1);
                        event.preventDefault();
                        return undefined;
                    case 'ArrowUp':
                        this.stepMatch(-1);
                        event.preventDefault();
                        return undefined;
                    // case 'ArrowRight':
                    //     return;
                    case 'Enter':
                        this.setState({hide: true});
                        if (this.state.matchActive > -1) {
                            event.preventDefault();
                            return this.onSelectAt(this.state.matchActive);
                        }
                        break;
                    case 'Escape':
                        this.setState({hide: true});
                        event.preventDefault();
                        if (this.props.onTACancel) {
                            this.props.onTACancel();
                        }
                        return undefined;
                    default:
                        break;
                }
            } else {
                switch (event.key) {
                    case 'ArrowDown':
                        this.setState({
                            hide: false
                        });
                        event.preventDefault();
                        return undefined;
                    default:
                        break;
                }
            }
            if (onKeyDown) {
                event.persist();
                return onKeyDown(event);
            }
            return undefined;
        }

        onChange(event) {
            const {onChange} = this.props;
            this.setState({
                matchActive: -1
            });
            if (onChange) {
                event.persist();
                return onChange(event);
            }
            return undefined;
        }

        onSelect(eventKey) {
            return this.onSelectAt(eventKey);
        }

        onSelectAt(idx) {
            const {matched, onSelectItem} = this.props;
            if (idx < 0 || idx >= matched.count()) {
                return undefined;
            }
            this.setState({
                selected: true,
                matchActive: -1
            }, () => {
                if (this._wrappedComponent && this._wrappedComponent.quitEditing) {
                    this._wrappedComponent.quitEditing();
                }
                this._wrappedElement &&
                    this._wrappedElement.querySelector('input').focus();
            });
            this.selecting = false;
            if (onSelectItem) {
                return onSelectItem(matched.get(idx));
            }
            return undefined;
        }

        onBlur(event) {
            const {onBlur} = this.props;
            if (!this.selecting) {
                this.setState({
                    hide: true,
                    matchActive: -1
                });
                if (onBlur) {
                    return onBlur(event);
                }
            }
            return undefined;
        }

        onSelecting() {
            this.selecting = true;
            if (this._wrappedComponent && this._wrappedComponent.ignoreBlurring) {
                this._wrappedComponent.ignoreBlurring();
            }
        }

        componentWillReceiveProps(nextProps) {
            if (nextProps.matched !== this.props.matched) {
                this.setState({
                    hide: false
                });
            }
            this.selecting = false;
        }

        render() {
            const {
                value, typeAheadDropdownClass, matched,
                leadingComponent, ...others
            } = this.props;
            delete others.onSelectItem;
            delete others.hasMoreMatches;
            delete others.onTAStepAt;
            delete others.onTACancel;
            const {matchActive} = this.state;
            const isOpen = this.isOpen();
            // set autoComplete = "off" to disable browser auto fill
            const clsnames =
                classNames(
                    prefixNS('formcontrols-withtypeahead'),
                    prefixNS('object-search-withtypeahead')
                  );
            return (
                <Dropdown className={clsnames}
                          id={`${this.dropdownID}`}
                          open={isOpen}
                          onToggle={this.onToggle}
                          componentClass={typeAheadDropdownClass}>
                    <div ref={(c) => {this._wrappedElement = c}}>
                        <WrappedComponent
                            value={value}
                            {...others}
                            onKeyDown={this.onKeyDown}
                            onChange={this.onChange}
                            onBlur={this.onBlur}
                            autoComplete="off"
                            ref={(c) => {this._wrappedComponent = c}}
                        />
                    </div>
                    <Dropdown.Toggle
                        className={prefixNS('formcontrols-withtypeahead-toggle')}/>
                    <TypeDropDownMenu
                        inputString={value}
                        bsRole="menu"
                        matched={matched}
                        activated={matchActive}
                        onSelect={this.onSelect}
                        onMouseDown={this.onSelecting}
                        hasMoreMatches={this.props.hasMoreMatches}
                        leadingComponent={leadingComponent} />
                </Dropdown>
            );
        }
    }

    ObjectSearchTypeAhead.propTypes = {
        typeAheadDropdownClass: PropTypes.oneOfType([
            PropTypes.string,
            PropTypes.element
        ]),
        onBlur: PropTypes.func,
        onKeyDown: PropTypes.func,
        onChange: PropTypes.func,
        onSelectItem: PropTypes.func,
        onTAStepAt: PropTypes.func,
        onTACancel: PropTypes.func,
        value: PropTypes.any,
        matched: ImmutablePropTypes.list,
        hasMoreMatches: PropTypes.bool,
        leadingComponent: PropTypes.node
    };

    ObjectSearchTypeAhead.defaultProps = {
        hasMoreMatches: false
    };

    return ObjectSearchTypeAhead;
}
