/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: favourites.js 172771 2018-02-02 12:56:06Z gwe $"
 */

import Immutable from 'immutable';
import {ReduxSaga} from 'cs-web-components-externals';
import {getJSON, putJSON, deleteObject} from '../../fetch.js';
import {getAppSetup, createLinkWithPattern} from '../../helpers.js';
import {ACTIONS} from '../constants.js';
import {loadedFavouritesForClass, loadedAllFavourites} from '../actions/favourites.js';

export function* loadFavouritesForClass({payload}) {
    const {classname} = payload;
    const url = createLinkWithPattern('searchFavouritesTemplate', {classname});
    const data = yield ReduxSaga.effects.call(getJSON, url);
    const {favourites, defaultFavouriteId, classDesignation} = data;
    const action = loadedFavouritesForClass(
        classname, favourites, defaultFavouriteId, classDesignation);
    yield ReduxSaga.effects.put(action);
}

export function* loadAllFavourites() {
    const url = getAppSetup().getIn(['links', 'common', 'searchFavourites']);
    const data = yield ReduxSaga.effects.call(getJSON, url);
    yield ReduxSaga.effects.put(loadedAllFavourites(data));
}

function* editedSearchFavourites({payload}) {
    const {classname, oldFavourites, changedFavourites} = payload;
    const newFavourites = changedFavourites
        .toOrderedMap()
        .mapEntries(([, fav]) => [fav.get('cdb_object_id'), fav]);

    // Delete favourites that are no longer there in the backend, and remove them
    // from the store. The backend does not return anything, so we have to manage
    // the store actions explicitly.
    const favouritesToDelete = oldFavourites.filterNot((fav, id) => newFavourites.has(id));
    yield ReduxSaga.effects.all(
        favouritesToDelete
            .map(fav => ReduxSaga.effects.call(deleteObject, fav.get('@id')))
            .toArray()
    );
    yield ReduxSaga.effects.all(
        favouritesToDelete
            .map((fav, favouriteId) =>
                ReduxSaga.effects.put({
                    type: ACTIONS.REMOVE_FAVOURITE_FROM_CLASS,
                    payload: {classname, favouriteId}
                }))
            .toArray()
    );

    // Update changed favourites, and collect the backend answers
    const results = yield ReduxSaga.effects.all(
        newFavourites
            .filterNot((fav, id) => Immutable.is(fav, oldFavourites.get(id)))
            .map(fav => ReduxSaga.effects.call(putJSON, fav.get('@id'), fav.toJS()))
            .toArray()
    );
    // Update the local state with the backend data
    yield ReduxSaga.effects.all(
        results.map(newFavourite =>
            ReduxSaga.effects.put({
                type: ACTIONS.STORE_FAVOURITE_FOR_CLASS,
                payload: {classname, newFavourite}
            })
        )
    );
}

export default function* watcher() {
    // TODO: should rather use something like "takeFirst", because we can't really
    // cancel backend requests. Also, if two tasks are started in a short interval,
    // the result will probably be the same.
    yield ReduxSaga.effects.takeEvery(ACTIONS.LOAD_FAVOURITES_FOR_CLASS, loadFavouritesForClass);
    yield ReduxSaga.effects.takeEvery(ACTIONS.LOAD_ALL_FAVOURITES, loadAllFavourites);
    yield ReduxSaga.effects.takeEvery(ACTIONS.EDITED_SEARCH_FAVOURITES, editedSearchFavourites);
}
