/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Provider.jsx 158306 2017-05-08 08:29:40Z gwe $"
 */

import React from 'react';
import {PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import {setFilter} from './actions';
import {setTableUserSettings} from '../common/actions';
import {getFilter} from './reducers';
import connect from '../connect';
import {getFormattedValue} from '../helpers';

// TODO: case sensitive?
const defaultFilter = (value, loweredText, row, colDef) => {
    const formatted = getFormattedValue(value, colDef, value);
    const valueStr = typeof formatted === 'string' ?
        formatted : JSON.stringify(formatted);
    return valueStr.toLowerCase().indexOf(loweredText) > -1;
};

const getFilterFunction = (colDef) => {
    if (colDef.get("filterFunction")) {
        return colDef.get("filterFunction");
    }
    const renderer = colDef.get('contentRenderer');
    return renderer && renderer.filterFunction ? renderer.filterFunction : defaultFilter;
};

const matchRow = (row, loweredText, columns) =>
    row.get('columns').findIndex((col, idx) => {
        const colDef = columns.get(idx);
        if (colDef === undefined) {
            return false;
        }
        return getFilterFunction(colDef)(col, loweredText, row, colDef);
    }) > -1;

export default function(WrappedTable) {
    class Filter extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                filtered: props.rows
            };
        }

        componentWillMount() {
            this.props.setFilter(this.props.initFilter);
            //this.props.setTableUserSettings('filter');
        }

        componentWillReceiveProps(nextProps) {
            if (nextProps.initFilter !== this.props.initFilter) {
                this.props.setFilter(nextProps.initFilter);

            }
            if (nextProps.filter !== this.props.filter ||
                nextProps.columns !== this.props.columns ||
                nextProps.rows !== this.props.rows) {
                this.doFilter(nextProps.rows, nextProps.filter);
            }
        }

        doFilter(rows, text) {
            const {columns, filterFunctions} = this.props;
            if (!text) {
                this.setState({filtered: rows});
            } else {
                const lowerText = text.toLowerCase();
                let filtered = rows.filter(row => matchRow(row, lowerText, columns));
                if (filterFunctions && filterFunctions.count() > 0) {
                    filtered = filterFunctions.reduce(
                        (result, filterFunc) => filterFunc(result, rows, lowerText, columns),
                        filtered);
                }
                this.setState({
                    filtered: filtered
                });
            }
        }

        render() {
            const {...others} = this.props;
            delete others.rows;
            delete others.filter;
            delete others.initFilter;
            delete others.columns;
            delete others.setFilter;
            delete others.setTableUserSettings;
            delete others.filterFunctions;
            return (
                <WrappedTable
                    {...others}
                    rows={this.state.filtered}/>
            );
        }
    }

    Filter.propTypes = {
        initFilter: PropTypes.string,
        filter: PropTypes.string,
        rows: ImmutablePropTypes.list,
        setFilter: PropTypes.func,
        setTableUserSettings: PropTypes.func,
        columns: ImmutablePropTypes.list,
        filterFunctions: ImmutablePropTypes.orderedSet
    };

    const mapStateToProps = (state) => ({
        filter: getFilter(state),
        columns: state.columns,
        filterFunctions: state.filterFunctions
    });
    return connect(mapStateToProps, {setFilter, setTableUserSettings})(Filter);
}
