/* -*- mode: javascript; coding: utf-8 -*-
 *
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: StructureTree.jsx 183808 2018-09-13 08:21:07Z vov $"
 */

import React from 'react';
import {PropTypes, connect} from 'cs-web-components-externals';
import {fetchObject} from '../actions/object-actions.js';
import Tree from './Tree';
import SimpleTextMatcher from './SimpleTextMatcher';
import Immutable from "immutable";
import {getJSON} from '../fetch';
import NodeRenderer from './NodeRenderer';
import {BackendSearchAdapter} from './SearchAdapter.jsx';
import ContentOperationToolbar from '../components/ContentOperationToolbar.jsx';
import OperationModal from '../components/OperationModal.jsx';
import OperationScope from '../form/containers/OperationScope.jsx';
import {IconButton} from "../components/Button.jsx";
import ButtonToolbar from "../components/ButtonToolbar.jsx";

export const STRUCTURE_ITEM_NO_ACTION = 0;
export const STRUCTURE_ITEM_AUTO_EXPAND = 1; // Beim erstmaligen Anzeigen des Items soll er gleich expandiert werden
export const STRUCTURE_ITEM_SELECT = 2;      // Beim erstmaligen Anzeigen des Items soll er selektiert werden

export class StructureBaseTree extends Tree {
    constructor(props) {
        super(props);
        this.state.title = props.structureTitle || props.structureName || '';
        this._bindInterface({
            fetchNodeChildren: this.fetchNodeChildren.bind(this),
            selectTreeNode: this.selectTreeNode.bind(this)
        });
    }

    componentWillMount() {
        super.componentWillMount();
        this.initStructure(this.props);
    }

    componentWillReceiveProps(nextProps) {
        super.componentWillReceiveProps(nextProps);
        if ((nextProps.structureNode && nextProps.structureNode !== this.props.structureNode) ||
            (nextProps.structureUrl && nextProps.structureUrl !== this.props.structureUrl) ||
            (nextProps.contextObject && nextProps.contextObject !== this.props.contextObject)) {
            this.initStructure(nextProps);
        }
    }

    initStructure(props) {
        const {title, contextObject, structureName, structureUrl, structureNode} = props;
        if (structureNode) {
            this.setStructure(title, structureNode);
        } else if (structureUrl) {
            this.initStructureFromUrl(structureUrl);
        } else if (structureName && contextObject) {
            this.initStructureFromUrl(
                contextObject.get('@id') + '/structure/' + encodeURIComponent(structureName)
            );
        }
    }

    initStructureFromUrl(url) {
        getJSON(url).then(
            structureNodes => {
                this.setStructure(
                    this.props.title || structureNodes['title'],
                    structureNodes.nodes[0]
                );
            }
        );
    }

    setStructure(title, structureNodes) {
        this.setState({
            rootNode: this.createNode(structureNodes, '0', null),
            title: title
        });
    }

    createNode(structureNode, nodeId, parentId = null, expanded = undefined, selected = false) {
        // If structureNode.subnodes is null, it is unknown wether this node is a leaf, so we set children
        // to empty and has_children to true. When the node is expanded fetchChildren will be called
        const id = parentId ? (parentId + '-' + nodeId) : nodeId;

        const _expanded =
              expanded === undefined ?
              ((structureNode.action_flag & STRUCTURE_ITEM_AUTO_EXPAND) ===
               STRUCTURE_ITEM_AUTO_EXPAND) :
              expanded;

        return Immutable.fromJS({
            id: id,
            content: structureNode,
            expanded: _expanded,
            is_selected: selected,
            children: structureNode.subnodes === null ? []
                : structureNode.subnodes.map((child, index) => this.createNode(child, index, id)),
            has_children: structureNode.subnodes === null ? true : structureNode.subnodes.length > 0
        });
    }

    createNodeChildren(treeNode, childStructureNodes) {
        const structureNode = treeNode.get('content');
        const parentId = treeNode.get('id');

        const mutableStructureNode = structureNode.toJS();
        mutableStructureNode.subnodes = childStructureNodes.nodes;
        const nodeWithChildren = this.createNode(mutableStructureNode, parentId, null, true,
                                                 treeNode.get('is_selected'));
        // TODO remove handling of expandChildren in subclass
        return super.updateTreeNode(
            treeNode.get('expandChildren') ?
                nodeWithChildren.set('expandChildren', treeNode.get('expandChildren')) :
                nodeWithChildren
        );
    }

    fetchNodeChildren(treeNode) {
        return getJSON(treeNode.getIn(['content', 'expand_url']))
            .then(
                childStructureNodes => {
                    this.createNodeChildren(treeNode, childStructureNodes);
                }
            );
    }
}

const StructureNodeRenderer = NodeRenderer.create(
    NodeRenderer.NodeRenderer(['content', 'label']),
    NodeRenderer.WithIcons(['content', 'icons']),
    NodeRenderer.WithHoverLink(['content', 'ui_link'])
);

const StructureNodeMatcher = SimpleTextMatcher(node => node.getIn(['content', 'label']));

StructureBaseTree.propTypes = Object.assign(
    {}, Tree.propTypes,
    {
        contextObject: PropTypes.instanceOf(Immutable.Map),
        structureName: PropTypes.string,
        structureUrl: PropTypes.string,
        structureNode: PropTypes.object,
        structureTitle: PropTypes.string,
        onSelect: PropTypes.func
    }
);

StructureBaseTree.defaultProps = Object.assign(
    {}, Tree.defaultProps,
    {
        matcher: StructureNodeMatcher,
        NodeRenderer: StructureNodeRenderer,
        SearchAdapter: BackendSearchAdapter
    }
);


/**
 * Tree class that loads and displays classic structures. It may be used
 * inside a ContextObjectSetter to set the contextObject of other
 * components according to its selection.
 * Additionally, parameter ``structureName`` should be set
 * to the name of the structure to be displayed.
 *
 * Example Usage
 * -------------
 *
 * The following configuration expects an ``organization`` object and
 * displays the structure CDB_Organization, associated with that object.
 *
 * .. code-block:: json
 *
 *    {
 *       "name": "cs-web-components-base-ContextObjectSetter",
 *       "properties": {"setPath": "orgTree"},
 *       "children": [
 *            {
 *               "name": "cs-web-components-base-StructureTree",
 *               "properties": {"structureName": "CDB_Organization"}
 *            }
 *       ]
 *    }
 *
 *
 * React Properties
 * ================
 *
 * +-----------------------+----------+---------+--------------------------------------+
 * | Property              | Type     | Default | Use                                  |
 * +=======================+==========+=========+======================================+
 * | contextObject         | Object   | -       | The REST API object that is the      |
 * |                       |          |         | root of the tree                     |
 * +-----------------------+----------+---------+--------------------------------------+
 * | onSelect              | function | -       | Callback function that will be       |
 * |                       |          |         | invoked when a tree node is selected |
 * +-----------------------+----------+---------+--------------------------------------+
 * | structureName         | string   | -       | The name of the structure to be      |
 * |                       |          |         | displayed                            |
 * +-----------------------+----------+---------+--------------------------------------+
 *
 */
class StructureTree extends StructureBaseTree {
    constructor(props) {
        super(props);
        this._bindInterface({
            selectTreeNode: this.selectTreeNode.bind(this)
        });
        this.reload = this.reload.bind(this);
    }

    selectTreeNode(node) {
        const content = node.get('content');
        let selection = content;
        const deselected = node.get('is_selected');
        if (!deselected && content.has('object_url')) {
            const objectLink = content.get('object_url');
            const object = this.props.objectsById.get(objectLink);
            if (object) {
                selection = object;
                this.setState({selectedObject: object});
            } else {
                this.props.fetchObject(objectLink)
                    .then(
                        () => {
                            selection = this.props.objectsById.get(objectLink);
                            this.setState({selectedObject: selection});
                        },
                        () => {
                            this.setState({selectedObject: undefined});
                        }
                    );
            }
        } else {
            this.setState({selectedObject: undefined});
        }
        if (this.props.onSelect) {
            this.props.onSelect(selection);
        }
        return super.selectTreeNode(node);
    }

    reload() {
        super.initStructure(this.props);
    }

    render() {
        const treeComponent = this.renderTree({
            additionalToolbars: Immutable.List([
                <ButtonToolbar key={1}>
                    <IconButton
                        iconName="csweb_refresh"
                        buttonStyle="info"
                        onClick={this.reload}/>
                </ButtonToolbar>,
                <ButtonToolbar key={2}>
                    <ContentOperationToolbar
                        contextObject={this.state.selectedObject}
                        hideQuickAccess={this.props.hideQuickAccess} />
                </ButtonToolbar>])
        });

        // TODO this operation-scope is a hack for use with FixedSidebarWithEditor,
        // this should not be implemented in the general StructureTree component.
        return (
            <OperationScope>
                {treeComponent}
                <OperationModal handlerName="editor" />
            </OperationScope>
        );
    }
}

StructureTree.propTypes = Object.assign(
    {}, StructureBaseTree.propTypes
);

StructureTree.defaultProps = Object.assign(
    {}, StructureBaseTree.defaultProps
);

const mapStateToComponents = state => {
    return {
        objectsById: state.objectsById
    };
};

export default connect(mapStateToComponents, {fetchObject})(StructureTree);
