/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: RestTree.jsx 174864 2018-03-22 11:24:56Z gwe $"
 */

import Immutable from "immutable";
import {PropTypes, connect} from 'cs-web-components-externals';
import {fetchRelships, fetchType, fetchTypes} from '../actions/object-actions.js';
import {referencedObjects} from '../helpers.js';
import Tree from './Tree.jsx';
import SimpleTextMatcher from './SimpleTextMatcher';
import NodeRenderer from './NodeRenderer';
import {BackendSearchAdapter} from './SearchAdapter.jsx';

/**
 * RestTree is a subclass of ``Tree``, that implements a tree view based on the
 * traversal of references using the generic REST API.
 *
 * Resolving references
 * --------------------
 *
 * TreeDownReferences are specified as a JSON object containing, for each class
 * that may appear in the tree (as it is the root node, or by following
 * treedownreferences) the relationship to follow. An example of the syntax of
 * treeDownReferences is given in
 * :ref:`cs-web-components-base-RestTree.__module__.example`.
 *
 * When a node in the tree should be expanded, treeDownReferences is searched
 * for the class of the object and each of its base classes. Objects that are
 * related via the relations found that way, will be displayed as child nodes.
 *
 * ``checkChildren`` may be set to ``true`` to prefetch Children of not yet
 * expanded nodes. This enables a tree to know if a tree node is a leaf before
 * it is expanded. Note that this may impact performance for large structures.
 *
 * Rendering the title
 * -------------------
 *
 * By default the objects system:description attribute is rendered as the trees title.
 * If the property titleAttribute is specified, this attribute will be rendered as the
 * title instead.  If property title is specified this will be rendered instead of an
 * attribute.
 *
 * If a custom title renderer component is specified, ``titleAttribute`` and ``title``
 * properties will be ignored.
 *
 * .. _`cs-web-components-base-RestTree.__module__.example`:
 *
 * Example Usage
 * -------------
 *
 * **Javascript:**
 *
 * **Configuration:**
 *
 * .. code-block:: json
 *
 *    {
 *      "name": "cs-web-components-base-ContextObjectSetter",
 *      "properties": {"setPath": "orgTree"},
 *      "children": [
 *        {
 *          "name": "cs-web-components-base-RestTree",
 *          "properties": {
 *            "treeDownReferences": {
 *              "cdb_organization": [
 *                {
 *                  "id": "Suborganizations",
 *                  "viewName": "complete-target"
 *                },
 *                {
 *                  "id": "Cdb_organization_to_cdb_person",
 *                  "viewName": "complete-target"
 *                }
 *              ],
 *              "angestellter": [
 *                {
 *                  "id": "someRelation",
 *                  "viewName": "complete-target"
 *                }
 *              ]
 *            }
 *          }
 *        }
 *      ]
 *    }
 *
 * React Properties
 * ================
 *
 * +-----------------------+----------+---------+--------------------------------------+
 * | Property              | Type     | Default | Use                                  |
 * +=======================+==========+=========+======================================+
 * | contextObject         | Object   | -       | The REST API object that is the      |
 * |                       |          |         | root of the tree                     |
 * +-----------------------+----------+---------+--------------------------------------+
 * | titleAttribute        | string   | -       | Specify an object attribute to be    |
 * |                       |          |         | rendered as title.                   |
 * +-----------------------+----------+---------+--------------------------------------+
 * | treeDownReferences    | Object   | -       | Specifies the references that        |
 * |                       |          |         | should be followed                   |
 * +-----------------------+----------+---------+--------------------------------------+
 * | onSelect              | function | -       | Callback function that will be       |
 * |                       |          |         | invoked when a tree node is selected |
 * +-----------------------+----------+---------+--------------------------------------+
 * | checkChildren         | bool     | -       | If set to true prefetch children of  |
 * |                       |          |         | children to decide if expander       |
 * |                       |          |         | should be displayed                  |
 * +-----------------------+----------+---------+--------------------------------------+
 */
class RestTree extends Tree {
    constructor(props) {
        super(props);
        this._bindInterface({
            fetchNodeChildren: this.fetchNodeChildren.bind(this),
            selectTreeNode: this.selectTreeNode.bind(this)
        });
    }

    initRootNode(obj) {
        this.props.fetchType(obj.get('@type')).then(() => {
            this.setState({
                rootNode: this.createTreeNodeFromObject(obj, true),
                title: this.props.title ||
                       obj.get(this.props.titleAttribute || 'system:description')
            });
        });
    }

    componentWillMount() {
        super.componentWillMount();
        const {contextObject} = this.props;
        if (contextObject) {
            this.initRootNode(contextObject);
        }
    }

    componentWillReceiveProps(nextProps) {
        // We only want to rebuild the tree structure when the context object changes. When
        // it is modified, a simple rerender should be enough
        if (nextProps.contextObject &&
                (!this.props.contextObject ||
                 nextProps.contextObject.get('@id') !== this.props.contextObject.get('@id'))) {
            this.initRootNode(nextProps.contextObject);
        }
    }

    generateNodeId(parent_id, obj) {
        return parent_id ? `${parent_id};${obj.get('@id')}` : obj.get('@id');
    }

    getObjectTypes(obj) {
        const type = this.props.typesById.get(obj.get('@type'));
        return [type.get('@id').split('/').pop()]  // This object's class ...
            .concat(type.get('base_classes').map(base => base.get('name')).toJS());  // ... and it's base classes
    }

    getDerivedContext(obj) {
        const {treeDownReferences} = this.props;
        const configuredReferences = new Set();
        this.getObjectTypes(obj).forEach(type => {
            (treeDownReferences[type] || []).forEach(tdr => {
                configuredReferences.add(tdr);
            });
        });

        return {
            derivedObject: obj,
            contentReferences: configuredReferences,
            additionalKey: undefined
        };
    }

    referencedObjectsAsOrderedSet(obj, relshipId) {
        const {relshipsById, objectsById} = this.props;
        const referenceResult = referencedObjects({relshipsById, objectsById}, obj, relshipId);
        if (Immutable.OrderedSet.isOrderedSet(referenceResult)) {
            return referenceResult;
        }
        else if (Immutable.Map.isMap(referenceResult)) {
            // single item ref -> interpret as set
            return Immutable.OrderedSet([referenceResult]);
        }
        else {
            return Immutable.OrderedSet();
        }
    }

    getMissingReferenceDownRelships(ctx) {
        const configuredEntityRelships = ctx['contentReferences'];
        const missingRelships = [];
        configuredEntityRelships.forEach(reference => {
            const url = ctx['derivedObject'].getIn(
                ['system:relships', 'relships', reference['id']]);
            if (this.props.relshipsById.get(url) === undefined) {
                // Note: the original implementation from cs.vp.variants had an
                // option to propagate "context parameters" down the tree, that
                // would be used when the property "useContextParams" was set in
                // the treeDownReferences. The context parameters would be used
                // as the "params" value below.
                // This feature is currently removed, because the use case is
                // not clear.
                missingRelships.push({
                    'url': url,
                    'viewName': reference['viewName'],
                    'params': {}
                });
            }
        });
        return missingRelships;
    }

    createTreeNodeFromObject(obj, expanded, parent_id = null) {
        const nodeId = this.generateNodeId(parent_id, obj);
        const treeChildren = [];
        let _has_children = false;

        /* Evaluate derivedContext for references */
        const derivedContext = this.getDerivedContext(obj);
        let fakeChildren = false;
        if (expanded) {
            // It is expanded: Generate child list
            this.forEachChildFromContext(derivedContext, (relship, child) => {
                treeChildren.push(this.createTreeNodeFromObject(child, false, nodeId));
            });
        } else if (this.props.checkChildren) {
            // Not expanded: Determine if it has_children.
            // Children will be loaded attached when node is expanded.
            this.forEachChildFromContext(derivedContext, () => {
                fakeChildren = true;
            });
        } else {
            // Not expanded: Load children on expansion of node.
            fakeChildren = true;
        }

        let notAlreadyLoadedRelships = [];
        if (derivedContext['derivedObject'].get('system:has_children') !== undefined) {
            if (derivedContext['derivedObject'].get('system:has_children')) {
                _has_children = true; // due to backend indicator that there are some children
                notAlreadyLoadedRelships = notAlreadyLoadedRelships.concat(
                    this.getMissingReferenceDownRelships(derivedContext)
                );
                if (notAlreadyLoadedRelships.length === 0) {
                    /* invalidate backend indicator when all relships are loaded
                     * and indicate no children to prevent endless waiting
                     */
                    _has_children = false;
                }
            } else {
                /* ignore missing children relships when indicated by backend
                 * i.e. not updating notAlreadyLoadedRelships
                 */
            }
        } else {
            notAlreadyLoadedRelships = notAlreadyLoadedRelships.concat(
                    this.getMissingReferenceDownRelships(derivedContext)
            );
        }

        const additionalContent = {};
        if (derivedContext['additionalKey'] !== undefined) {
            additionalContent[derivedContext['additionalKey']] = derivedContext['derivedObject'];
        }

        /* Create and return node */
        const has_children =
            _has_children ?
                _has_children :
                (notAlreadyLoadedRelships.length > 0) ?
                        true :
                        (treeChildren.length > 0);

        return Immutable.fromJS({
            id: nodeId,
            content: obj,
            expanded,
            children: fakeChildren ? [] : notAlreadyLoadedRelships.length === 0 ? treeChildren : [],
            has_children: fakeChildren ? true : has_children,
            additional_content: additionalContent
        });
    }

    updateTreeNode(obj, node, parentId, expanded) {
        const nodeExpandState = expanded === undefined ? node.get('expanded') : expanded;
        const treeNode = this.createTreeNodeFromObject(obj, nodeExpandState, parentId);
        // TODO remove handling of expandChildren in subclass
        return super.updateTreeNode(node.get('expandChildren') ?
                                    treeNode.set('expandChildren', node.get('expandChildren')) :
                                    treeNode);
    }

    forEachChildFromContext(ctx, fn) {
        ctx['contentReferences'].forEach(relship => {
            const res = this.referencedObjectsAsOrderedSet(ctx['derivedObject'], relship['id']);
            res.forEach((relship, child) => {
                fn(relship, child);
            });
        });
    }

    fetchNodeChildren(node) {
        const nodeContentId = node.getIn(['content', '@id']);
        const parentId = this.getParentId(node.get('id'));
        const obj = this.props.objectsById.get(nodeContentId);
        if (obj) {
            // Update the tree with relship data
            return this.props.fetchType(obj.get('@type')).then(
                () => {
                    const derivedContext = this.getDerivedContext(obj);
                    const missingRelships = this.getMissingReferenceDownRelships(derivedContext);
                    const notAlreadyFetchingRelships =
                        missingRelships.filter(
                            relship => !this.props.fetchingById.has(relship.url));
                    if (notAlreadyFetchingRelships.length > 0) {
                        // fetch tree children and their types, then update tree node afterwards
                        return this.props.fetchRelships(notAlreadyFetchingRelships).then(
                            () => {
                                // Load me some child types
                                const childTypesToFetch = new Set();
                                this.forEachChildFromContext(derivedContext, (relship, child) => {
                                    childTypesToFetch.add(child.get('@type'));
                                });

                                return this.props.fetchTypes([...childTypesToFetch])
                                           .then(
                                               () => this.updateTreeNode(obj, node, parentId, true)
                                           );
                            });
                    }
                    else {
                        return Promise.resolve(this.updateTreeNode(obj, node, parentId));
                    }
                }
            );
        } else {
            // TODO why fail?
            return Promise.reject("fetchNodeChildren failed.");
        }
    }

    getParentId(nodeId, delimiter = ';') {
        const idSegments = nodeId.split(delimiter);
        if (idSegments.length > 1) {
            return idSegments.slice(0, idSegments.length - 1).join(delimiter);
        }
        else {
            return '';
        }
    }

    generateNode(oldNode, obj, expanded) {
        const parentId = this.getParentId(oldNode.get('id'));
        const nodeExpandState =
            expanded === undefined ? (oldNode ? oldNode.get('expanded') : false) : expanded;
        return this.createTreeNodeFromObject(obj, nodeExpandState, parentId);
    }
}

const RestNodeRenderer = NodeRenderer.create(
    NodeRenderer.NodeRenderer(['content', 'system:description']),
    NodeRenderer.WithIcons(node =>
        [
            {
                url: node.getIn(['content', 'system:icon_link']),
                title: undefined
            }
        ]
    ),
    NodeRenderer.WithHoverLink(['content', 'system:ui_link'])
);

const RestNodeMatcher = SimpleTextMatcher(
    node => node.getIn(['content', 'system:description'])
);

RestTree.propTypes = Object.assign(
    {}, Tree.propTypes,
    {
        contextObject: PropTypes.instanceOf(Immutable.Map).isRequired,
        titleAttribute: PropTypes.string,
        treeDownReferences: PropTypes.object.isRequired,
        checkChildren: PropTypes.bool.isRequired,
        onSelect: PropTypes.func
    }
);

RestTree.defaultProps = Object.assign(
    {}, Tree.defaultProps,
    {
        titleAttribute: undefined,
        matcher: RestNodeMatcher,
        NodeRenderer: RestNodeRenderer,
        SearchAdapter: BackendSearchAdapter,
        checkChildren: false
    }
);

function mapStateToProps(state) {
    return {
        objectsById: state.objectsById,
        typesById: state.typesById,
        relshipsById: state.relshipsById,
        fetchingById: state.fetchingById,
    };
}

export default connect(mapStateToProps, {fetchRelships, fetchType, fetchTypes})(RestTree);
