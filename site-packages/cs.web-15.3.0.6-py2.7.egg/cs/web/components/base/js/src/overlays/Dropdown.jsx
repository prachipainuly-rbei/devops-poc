/*
 * Copyright (C) 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Dropdown.jsx 185125 2018-10-16 09:13:25Z cla $"
 */

import React from 'react';
import ReactDOM from 'react-dom';
import {PropTypes} from 'cs-web-components-externals';
import AlignedOverlay from './AlignedOverlay.jsx';
import menuLayout from './layouting/menus.js';

function mergeRef(Component, newRef) {
    const oldRef = Component.ref;
    return [
        (typeof oldRef === 'function' ?
         ((c) => {
             newRef(c);
             oldRef(c);
         }) : newRef),
        oldRef
    ];
}

/**
 * A general component for rendering dropdowns.
 *
 * Alignment on this component is as follows: Vertical Alignment dictates, wether
 * the dropdown should be rendered on top or on the bottom side of the anchor
 * component. Horizontal alignment dictates on which side the component should be
 * aligned flush with the parent component. For example, when aligned left,
 * both the overlay and the anchors absolute x position will be equal. If aligned right,
 * both (element.absx + element.width) will be equal for anchor and overlay.
 *
 * The layouting algorithm used for this type of overlay takes into account
 * the space available in the browser's viewport: If the content of the dropdown
 * does not fit the available space horizontally or vertically, it will try the
 * following:
 *
 * - If there is enough space when using a different alignment mode (e.g. horizontal bottom
 *   instead of horizontal top), it will used that.
 * - If it does not fit in the other mode, it will use a scrollbar along that axis of
 *   alignment and use the original alignment option.
 *
 * Passing Children as FACC
 * ========================
 *
 * To enable both the layouting component, as well as the component rendered inside
 * the dropdown to control the state of the dropdown, these components are passed
 * to Dropdown via ``props.children`` inside a function.
 *
 * This function receives the following parameters:
 *
 * .. code-block:: none
 *
 *    {
 *      onShow: func,
 *      onHide: func,
 *      onToggle: func,
 *    },
 *    visible: boolean
 *
 * When called, ``onShow`` opens the dropdown if it is closed,
 * ``onHide`` closes the dropdown if it is open
 * and ``onToggle`` toggles its visibility state.
 *
 * The parameter ``visible`` reflects the current state
 * of the dropdown. An example is found at the end of the
 * section.
 *
 * React Properties
 * ================
 *
 * ================= ========================= ========================================
 *    Name              Type                      Description
 * ================= ========================= ========================================
 *  containerRef      object                    Optional reference to scroll container
 *  toggleRef         function                  Called to set a reference to the
 *                                              toggle component.
 *  horizontalAlign   HorizontalAlignmentType   Horizontal Alignment of Dropdown
 *  verticalAlign     VerticalAlignmentType     Vertical Alignment of Dropdown
 * ================= ========================= ========================================
 *
 * Example
 * =======
 *
 * .. code-block:: none
 *
 *    function MyComponent(props){
 *      return (
 *        <Dropdown>
 *          {
 *            ({onToggle, onHide}, visible) => {
 *              // Button should look pressed, when dropdown is open.
 *              const clsNames = classNames(
 *                {
 *                  [className]: Boolean(className),
 *                  [prefixNS('open')]: visible,
 *                },
 *                prefixNS('dropdown-toggle')
 *              );
 *              return ([
 *                <IconButton key={'toggle'}
 *                            className={clsNames}
 *                            {...others}
 *                            onClick={onToggle}/>,
 *                <div>I am a dropdown</div>
 *              ]);
 *            }
 *          }
 *        </Dropdown>
 *      );
 *    }
 *
 */
export default class Dropdown extends React.Component {
    constructor(props) {
        super(props);
        this.state = {visible: false};
        this.onShow = this.onShow.bind(this);
        this.hide = this.hide.bind(this);
        this.onHide = this.onHide.bind(this);
        this.onToggle = this.onToggle.bind(this);
        this.controlFns = {
            onShow: this.onShow,
            onHide: this.onHide,
            onToggle: this.onToggle,
        };
        this.setToggleRef = this.setToggleRef.bind(this);
        this.toggleRef = null;
        this.toggleElement = null;
    }

    setToggleRef(component) {
        this.toggleRef = component;
        if (this.toggleRef) {
            this.toggleElement = ReactDOM.findDOMNode(this.toggleRef);  // eslint-disable-line react/no-find-dom-node
        } else {
            this.toggleElement = null;
        }

        // Call ref that was passed in the original Toggle Component
        const {toggleRef} = this.props;
        if (toggleRef) {
            toggleRef(component);
        }
    }

    show() {
        this.onShow();
    }

    onShow() {
        if (!this.state.visible) {
            const {onShow} = this.props;
            if (onShow) {
                onShow();
            }

            this.setState({visible: true});
        }
    }

    hide() {
        const {onHide} = this.props;
        if (onHide) {
            onHide();
        }

        this.setState({visible: false});
    }

    onHide(event) {
        // Only hide if we didn't click on toggle
        const isToggleClicked =
            (event &&
             (event.type === 'blur' || event.type === 'focusout') &&
             this.toggleElement.contains(event.relatedTarget));
        if (this.state.visible && !isToggleClicked) {
            this.hide();
        }
    }

    toggle() {
        this.onToggle();
    }

    onToggle(evt = undefined) {
        const {onShow, onHide} = this.props;
        const newState = !this.state.visible;
        if (newState) {
            if (onShow) {
                onShow();
            }
        } else if (onHide) {
            onHide();
        }

        if (evt !== undefined) {
            evt.stopPropagation();
        }

        this.setState({visible: newState});
    }

    render() {
        const {
            OverlayContainer,
            parentRef,
            children,
            visible,
            ...others
        } = this.props;

        const ChildInstances =
            typeof children === 'function' ?
            children(this.controlFns, this.state.visible) :
            children;
        const [Toggle, Content] = ChildInstances;
        const OverlayContent = (
            OverlayContainer ?
            OverlayContainer(Content, others) :
            React.Children.only(Content)
        );

        // When props.visible is set, this overrides internal state
        // This is useful for debugging :)
        const visibility = visible || this.state.visible;

        return [
            React.cloneElement(
                React.Children.only(Toggle),
                {
                    key: 'toggle',
                    ref: this.setToggleRef,
                }
            ),
            <AlignedOverlay.Controlled key={'overlay'}
                                       parentRef={parentRef || this.toggleRef}
                                       visible={visibility}
                                       {...others}
                                       onHide={this.onHide}>
                {OverlayContent}
            </AlignedOverlay.Controlled>
        ];
    }
}

Dropdown.propTypes = {
    OverlayContainer: PropTypes.func,
    layoutFunc: PropTypes.func,
    parentRef: PropTypes.element,
    toggleRef: PropTypes.func,
    onShow: PropTypes.func,
    onHide: PropTypes.func,
    visible: PropTypes.bool,  // Override internal visibility state.
};

Dropdown.defaultProps = {
    layoutFunc: menuLayout,
    visible: false,
};


/**
 * A component that replicates the Anchor/Overlay interface of Dropdown,
 * but removes the visibility state management.
 */
class Static extends React.Component {
    constructor(props) {
        super(props);
        this.setAnchorRef = this.setAnchorRef.bind(this);
        this.state = {anchorRef: null};
    }

    setAnchorRef(anchorRef) {
        if (anchorRef !== this.state.anchorRef) {
            this.setState({anchorRef});
        }
    }

    updateRef(Anchor) {
        const [mergedRef, oldRef] = mergeRef(Anchor, this.setAnchorRef);
        if (this._oldRef !== oldRef || this._mergedRef === undefined) {
            this._oldRef = oldRef;
            this._mergedRef = mergedRef;
        }
    }

    render() {
        const {
            OverlayContainer,
            parentRef,
            children,
            ...others
        } = this.props;

        const [Anchor, Content] = children;
        const OverlayContent = (
            OverlayContainer ?
            OverlayContainer(Content, others) :
            React.Children.only(Content)
        );

        this.updateRef(Anchor);

        return [
            React.cloneElement(
                React.Children.only(Anchor),
                {
                    key: 'anchor',
                    ref: this._mergedRef,
                }
            ),
            <AlignedOverlay key={'overlay'}
                            parentRef={parentRef || this.state.anchorRef}
                            {...others}>
                {OverlayContent}
            </AlignedOverlay>
        ];
    }
}

Static.propTypes = {
    OverlayContainer: PropTypes.func,
    parentRef: PropTypes.element,
    layoutFunc: PropTypes.func,
};

Static.defaultProps = {
    layoutFunc: menuLayout,
};

Dropdown.Static = Static;
