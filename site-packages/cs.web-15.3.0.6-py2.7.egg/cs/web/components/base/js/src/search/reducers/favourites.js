/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: favourites.js 172771 2018-02-02 12:56:06Z gwe $"
 */

import Immutable from 'immutable';
import {ACTIONS} from '../constants.js';

function strcmp(str1, str2) {
    if (str1.localeCompare !== undefined) {
        // localeCompare might not be available in older browsers
        return str1.localeCompare(str2);
    }
    else {
        return str1 < str2 ? -1 : (str1 > str2 ? 1 : 0);
    }
}

/**
 * sort favourites first by readonly === true (system favourites), then by name
 */
function favouriteComparator(a, b) {
    const systemA = a.get('readonly');
    const systemB = b.get('readonly');
    return (systemA === systemB) ? strcmp(a.get('name'), b.get('name')) : systemA ? -1 : 1;
}

/**
 * Convert the favourite data for one class to the form for the store. Especially,
 * the array of favourites is converted to a sorted map, indexed by ID.
 */
function convertFavouriteData(favourites, defaultFavouriteId, classDesignation) {
    const sortedFavourites = Immutable.Map(
        favourites.map(fav => [fav.cdb_object_id, Immutable.fromJS(fav)]))
        .sort(favouriteComparator);
    return Immutable.fromJS({
        favourites: sortedFavourites,
        defaultFavouriteId, classDesignation});
}

export function favouritesByClass(state = Immutable.Map(), action) {
    switch (action.type) {
        case ACTIONS.LOADED_FAVOURITES_FOR_CLASS: {
            const {classname, favourites, defaultFavouriteId, classDesignation} = action.payload;
            // THINKABOUT: should that be some kind of "intelligent merge", so that
            // unchanged favourites stay the same object? Would need to remove
            // any old dict keys that are not in the new data (recursively!).
            return state.set(classname,
                convertFavouriteData(favourites, defaultFavouriteId, classDesignation));
        }
        case ACTIONS.LOADED_ALL_FAVOURITES: {
            const {allFavourites} = action.payload;
            return state.withMutations(mutableState => {
                allFavourites.forEach(fav => {
                    const {classname, favourites, defaultFavouriteId, classDesignation} = fav;
                    mutableState.set(classname,
                        convertFavouriteData(favourites, defaultFavouriteId, classDesignation));
                });
            });
        }
        case ACTIONS.STORE_FAVOURITE_FOR_CLASS: {
            const {classname, newFavourite} = action.payload;
            return state.setIn(
                [classname, 'favourites'],
                state.getIn([classname, 'favourites'])
                    .set(newFavourite.cdb_object_id, Immutable.fromJS(newFavourite))
                    .sort(favouriteComparator)
            );
        }
        case ACTIONS.REMOVE_FAVOURITE_FROM_CLASS: {
            const {classname, favouriteId} = action.payload;
            return state.deleteIn([classname, 'favourites', favouriteId]);
        }
        default:
            return state;
    }
}
