/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: helpers.js 158631 2017-05-12 10:25:13Z yzh $"
 */

// THINKABOUT: how to get rid of hard dependency like this?
import groupable from '../groupable';
import Immutable from 'immutable';

export function isGrouped(state) {
    const grouping = groupable.getGroupColumns(state);
    return grouping && grouping.count() > 0;
}

export function isTreeViewOff(state) {
    return state.treeViewOff || isGrouped(state);
}

export function sortTree(nodes, nodeMap, sorting, rows, {columnIndex, desc, cmp}) {
    let ranking = 0;
    const rankings = {};
    if (nodes === undefined) {
        return rankings;
    }

    function _sort(ids) {
        if (ids === undefined) {
            return;
        }
        // only sort current visible rows
        const data = ids.map(
            rowID => rows.find(row => row.get('id') === rowID)
        ).filter(entry => entry !== undefined);
        sorting(data, {columnIndex, desc, cmp}).forEach(
            row => {
                const rowID = row.get('id');
                rankings[rowID] = ++ranking;
                _sort(nodeMap.get(rowID).get('children'));
            }
        );
    }
    _sort(nodes.map(node => node.get('id')));
    return rankings;
}

export function filterTree(nodes, nodeMap, filtered, rows) {
    if (nodes === undefined) {
        return filtered;
    }
    const filteredIDs = filtered.map(row => row.get('id')).toSet();
    let parentIDs = Immutable.Set();
    let collapseIDs = Immutable.Set();
    const rowIDs = filteredIDs.map(
        rowID => {
            const treeNode = nodeMap.get(rowID);
            const parents = treeNode.get('parents');
            const children = treeNode.get('children');
            parentIDs = parentIDs.concat(parents);
            // node without visible child nodes should be collapsed
            if (children && filteredIDs.subtract(children) === filteredIDs) {
                collapseIDs = collapseIDs.add(rowID);
            }
            // direct children should be visible now or later by expanding
            collapseIDs = collapseIDs.concat(children);
            return parents.add(rowID).concat(children);
        }
    ).flatten(true);
    // nested visible nodes force their parents visible
    collapseIDs = collapseIDs.subtract(parentIDs);
    return {
        parents: parentIDs,
        collapsed: collapseIDs,
        original: filteredIDs,
        rows: rows.filter(
            row => rowIDs.contains(row.get('id'))
        )
    };
}

