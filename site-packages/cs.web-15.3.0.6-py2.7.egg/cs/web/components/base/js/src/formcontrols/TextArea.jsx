/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: TextArea.jsx 166800 2017-10-17 08:25:36Z cla $"
 */

import React from 'react';
import {FormGroup, ControlLabel, FormControl, InputGroup} from 'react-bootstrap';
import {sharedDefaultProps, sharedTextInputProps} from './sharedPropTypes';
import {classNames, PropTypes} from 'cs-web-components-externals';
import {prefixNS} from '../helpers';

/**
 * The component ``<TextArea>`` allows textual inputs in multiple lines, works like a standard
 * ``<textarea>`` HTML tag. It has following properties besides those defined in
 * :ref:`form_control_common_props`:
 *
 * +------------------+--------------+--------------+---------------------------------------------+
 * | Property         | Type         | Default      | Use                                         |
 * +==================+==============+==============+=============================================+
 * | value            | any          | -            | Data to be displayed                        |
 * +------------------+--------------+--------------+---------------------------------------------+
 * | compact          | bool         | false        | Display in compact mode without label and   |
 * |                  |              |              | bottom margin                               |
 * +------------------+--------------+--------------+---------------------------------------------+
 * | rows             | number       | -            | To extend the size of this component to     |
 * |                  |              |              | bottom margin                               |
 * +------------------+--------------+--------------+---------------------------------------------+
 * | beforeControl    | node         | -            | A component or a list of components to be   |
 * |                  |              |              | display specific lines of text, compare     |
 * |                  |              |              | the ``rows`` attribute on ``<textare>``     |
 * +------------------+--------------+--------------+---------------------------------------------+
 * | afterControl     | node         | -            | A component or a list of components to be   |
 * |                  |              |              | placed after the input field                |
 * +------------------+--------------+--------------+---------------------------------------------+
 * | onValueChange    | func         | -            | Equivalent callback of `onChange`, called   |
 * |                  |              |              | with the field value instead of the event   |
 * +------------------+--------------+--------------+---------------------------------------------+
 *
 * Example:
 *
 * .. code-block:: none
 *
 *     import {TextArea} from 'cs-web-components-base';
 *     import {Button} from 'react-bootstrap';
 *     ...
 *     // in render method of some component
 *     render() {
 *         const myButton = <Button onClick={this.openSomeDialog}>Open Dialog</Button>;
 *         return (
 *             <TextArea label="Some Field"
 *                        value={this.state.someValue}
 *                        onChange={this.handleChangeSomeValue}
 *                        afterControl={myButton} />);
 *     }
 *
 */
export default class TextArea extends React.Component {
    constructor(props) {
        super(props);
        this.onKeyDown = this.onKeyDown.bind(this);
        this.onChange = this.onChange.bind(this);
    }

    onKeyDown(event) {
        const {onKeyDown} = this.props;
        // Dispatch Event itself
        if (onKeyDown) {
            onKeyDown(event);
            // onKeyDown may prevent default
            if (event.isDefaultPrevented()) {
                return;
            }
        }
        // The IE calls the previous page if the field is read only
        if (event.key === 'Backspace' && this.props.readOnly) {
            //event.preventDefault();
        }
    }

    onChange(event) {
        const {onChange, onValueChange} = this.props;
        if (onValueChange) {
            onValueChange(event.target.value);
        }
        if (onChange) {
            event.persist();
            return onChange(event);
        }
        return undefined;
    }

    render() {
        const {
            beforeControl, afterControl,
            label, tooltip, validationState,
            mandatory, mandatoryEmptyHint, className,
            compact, ...others
        } = this.props;

        delete others.onKeyDown;
        delete others.onEnter;
        delete others.onValueChange;
        delete others.operationInstance;
        delete others.uncheckedValues;

        const classes = classNames(
            className,
            prefixNS('form-input'),
            'no-ie-text-input-clear-button'
        );
        let inputControl = null;
        if (!beforeControl && !afterControl) {
            inputControl = <FormControl componentClass="textarea"
                                        {...others}
                                        className={classes}
                                        onKeyDown={this.onKeyDown}
                                        onChange={this.onChange}/>;
        } else {
            const before = beforeControl ?
                (
                    <InputGroup.Button className={prefixNS('formcontrols-textarea-buttons')}>
                        {beforeControl}
                    </InputGroup.Button>
                ) : null;
            const after = afterControl ?
                (
                    <InputGroup.Button className={prefixNS('formcontrols-textarea-buttons')}>
                        {afterControl}
                    </InputGroup.Button>
                ) : null;
            inputControl = (
                <InputGroup>
                    {before}
                    <FormControl componentClass="textarea"
                                 {...others}
                                 className={classes}
                                 onKeyDown={this.onKeyDown}
                                 onChange={this.onChange}/>
                    {after}
                </InputGroup>
            );
        }
        const groupClass = classNames({
            [prefixNS('formcontrols-textinput-compact')]: compact
        });
        return (
            <FormGroup className={groupClass}
                       validationState={validationState}
                       data-mandatory={mandatory}
                       data-mandatory-empty-hint={mandatoryEmptyHint}>
                <ControlLabel title={tooltip}>{label}</ControlLabel>
                {inputControl}
            </FormGroup>
        );
    }
}

TextArea.propTypes = {
    ...sharedTextInputProps,
    onKeyDown: PropTypes.func,
    onEnter: PropTypes.func,
    onValueChange: PropTypes.func
};

TextArea.defaultProps = Object.assign(
    {compact: false},
    sharedDefaultProps
);

export function combineInputExtensions(prev, curr) {
    if (curr) {
        return prev ? [prev, curr] : curr;
    }
    return prev;
}
