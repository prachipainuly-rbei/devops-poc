/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Organizer.jsx 161953 2017-07-20 12:55:37Z yzh $"
 */

import React from 'react';
import {prefixNS} from '../helpers';
import {PropTypes, classNames, ImmutablePropTypes, ReactDnD} from 'cs-web-components-externals';
import Immutable from 'immutable';

const DefaultRenderer = ({item, onMoveBackwards, onMoveForwards}) => {
    const clsBack = classNames(
        prefixNS('organizer-item-default__mover'),
        prefixNS('organizer-item-default__mover--back')
    );
    const clsForward = classNames(
        prefixNS('organizer-item-default__mover'),
        prefixNS('organizer-item-default__mover--forward')
    );
    return (
        <div className={prefixNS('organizer-item-default')}>
            {onMoveBackwards ?
                <span className={clsBack}
                      onClick={() => onMoveBackwards(item)}>&#9668;</span> :
                null
            }
            <div className={prefixNS('organizer-item-default__label')}
                 title={item.get('tooltip')}>
                {item.get('label')}
            </div>
            {onMoveForwards ?
                <span className={clsForward}
                      onClick={() => onMoveForwards(item)}>&#9658;</span> :
                null
            }
        </div>
    );
};

DefaultRenderer.propTypes = {
    onMoveBackwards: PropTypes.func,
    onMoveForwards: PropTypes.func,
    item: PropTypes.any
};

const ITEM = prefixNS('organizer-item');

const itemSource = {
    beginDrag(props) {
        return {
            item: props.item,
            fromList: props.listIndex
        };
    },

    endDrag(props, monitor) {
        const didDrop = monitor.didDrop();
        if (!didDrop) {
            props.onCancelDragItem();
        }
    },

    isDragging(props, monitor) {
        return props.item === monitor.getItem().item;
    }
};

const itemTarget = {
    hover(props, monitor) {
        if (monitor.canDrop()) {
            const dragging = monitor.getItem().item;
            if (dragging !== props.item) {
                props.onMoveItem(dragging, props.index);
            }
        }
    },

    drop(props, monitor) {
        const item = monitor.getItem().item;
        const fromList = monitor.getItem().fromList;
        return {
            item,
            fromList,
            toList: props.listIndex,
            toIndex: props.index
        };
    },

    canDrop(props, monitor) {
        if (props.sortable) {
            return true;
        }
        return monitor.getItem().fromList !== props.listIndex;
    }
};

class OrganizerItem extends React.Component {
    constructor(props) {
        super(props);
    }

    render() {
        const {
            item, isDragging, connectDropTarget, connectDragSource,
            onMoveBackwards, onMoveForwards
        } = this.props;
        const clsname = classNames(
            prefixNS('organizer-item'),
            {
                [prefixNS('organizer-item--dragging')]: isDragging
            });
        const Renderer = item.get('renderer') || DefaultRenderer;
        return connectDragSource(connectDropTarget(
            <div className={clsname}>
                <div className={prefixNS('organizer-item__content')}>
                    <Renderer {...{item, onMoveBackwards, onMoveForwards}}/>
                </div>
            </div>
        ));
    }
}

OrganizerItem.propTypes = {
    item: PropTypes.any,
    index: PropTypes.number,
    listIndex: PropTypes.number,
    sortable: PropTypes.bool,
    onMoveItem: PropTypes.func.isRequired,
    onMoveBackwards: PropTypes.func,
    onMoveForwards: PropTypes.func,
    onCancelDragItem: PropTypes.func.isRequired,
    isDragging: PropTypes.bool,
    connectDropTarget: PropTypes.func,
    connectDragSource: PropTypes.func
};

const DNDOrganizerItem =
    ReactDnD.DragSource(
        ITEM, itemSource, (connect, monitor) => ({
            connectDragSource: connect.dragSource(),
            isDragging: monitor.isDragging()
        })
    )(ReactDnD.DropTarget(
        ITEM, itemTarget, connect => ({
            connectDropTarget: connect.dropTarget()
        })
    )(OrganizerItem));

const listTarget = {
    hover(props, monitor) {
        if (monitor.canDrop()) {
            if (monitor.isOver({shallow: true})) {
                const dragging = monitor.getItem().item;
                props.onMoveItem(dragging, props.index, 0);
            }
        }
    },

    drop(props, monitor) {
        const didDrop = monitor.didDrop();
        let result;
        if (didDrop) {
            result = monitor.getDropResult();
        } else {
            const item = monitor.getItem().item;
            const fromList = monitor.getItem().fromList;
            result = {
                item,
                fromList,
                toList: props.index,
                toIndex: 0
            };
        }
        props.onConfirmDrop(result);
        return result;
    },

    canDrop(props, monitor) {
        if (props.itemList.get('unsortable')) {
            return monitor.getItem().fromList !== props.index;
        }
        return true;
    }
};

class OrganizerItemList extends React.Component {
    constructor(props) {
        super(props);
        this.moveItem = this.moveItem.bind(this);
        this.moveBackwards = this.moveBackwards.bind(this);
        this.moveForwards = this.moveForwards.bind(this);
    }

    moveItem(dragged, toIndex) {
        const {index, onMoveItem} = this.props;
        if (toIndex > -1) {
            onMoveItem(dragged, index, toIndex);
        }
    }

    moveBackwards(item) {
        const {index, onConfirmDrop} = this.props;
        if (index > 0) {
            onConfirmDrop({
                item,
                fromList: index,
                toList: index - 1,
                toIndex: 0
            });
        }
    }

    moveForwards(item) {
        const {index, forwardIndex, onConfirmDrop} = this.props;
        if (forwardIndex > 0) {
            onConfirmDrop({
                item,
                fromList: index,
                toList: forwardIndex,
                toIndex: 0
            });
        }
    }

    componentWillReceiveProps(nextProps) {
        if (this.props.isOver && !nextProps.isOver) {
            nextProps.onDragMoveOut(nextProps.index);
        }
    }

    render() {
        const {
            itemList, onCancelDragItem,
            connectDropTarget, index, isOver,
            forwardIndex
        } = this.props;
        const items = itemList.get('items');
        const label = itemList.get('label');
        const clsname = classNames(
            prefixNS('organizer-itemlist'),
            {
                [prefixNS('organizer-itemlist--over')]: isOver
            });
        const moveBackwards = index === 0 ? undefined : this.moveBackwards;
        const moveForwards = forwardIndex === undefined ?
            undefined : this.moveForwards;
        const phCls = prefixNS('organizer-itemlist-container__placeholder');
        const sortable = !itemList.get('unsortable');
        return (
            connectDropTarget(
                <div className={clsname}>
                    <label>{label}</label>
                    <div className={prefixNS('organizer-itemlist-container')}>
                        {items.count() ?
                            items.map((item, itemIdx) => (
                                <DNDOrganizerItem
                                    key={item.get('id')}
                                    onMoveItem={this.moveItem}
                                    onMoveBackwards={moveBackwards}
                                    onMoveForwards={moveForwards}
                                    listIndex={index}
                                    index={itemIdx}
                                    sortable={sortable}
                                    {...{item, onCancelDragItem}} />
                            )) : (
                            <div className={phCls}>
                                {this.props.placeholder}
                            </div>
                        )}
                    </div>
                </div>
            )
        );
    }
}

OrganizerItemList.propTypes = {
    itemList: ImmutablePropTypes.map,
    index: PropTypes.number,
    forwardIndex: PropTypes.number,
    placeholder: PropTypes.string,
    onMoveItem: PropTypes.func.isRequired,
    onCancelDragItem: PropTypes.func.isRequired,
    onDragMoveOut: PropTypes.func.isRequired,
    onConfirmDrop: PropTypes.func.isRequired,
    isOver: PropTypes.bool,
    isOverCurrent: PropTypes.bool,
    connectDropTarget: PropTypes.func
};

const DNDOrganizerItemList = ReactDnD.DropTarget(
    ITEM, listTarget, (connect, monitor) => ({
        connectDropTarget: connect.dropTarget(),
        isOver: monitor.isOver(),
        isOverCurrent: monitor.isOver({shallow: true})
    })
)(OrganizerItemList);

/**
 * A component to allow reorganize items between different lists via
 * Drag & Drop.
 *
 * React Properties
 * ----------------
 *
 * +-------------------+--------------------+---------------------+------------------------------------------------+
 * | Property          | Type               | Default             | Use                                            |
 * +===================+====================+=====================+================================================+
 * | itemLists         | Immutable.List     | \-                  | Lists of items to be displayed                 |
 * +-------------------+--------------------+---------------------+------------------------------------------------+
 * | placeholder       | string             | \-                  | Placeholder text if a list is empty            |
 * +-------------------+--------------------+---------------------+------------------------------------------------+
 * | onItemListsChange | func               | \-                  | Callback fires if the itemLists has been       |
 * |                   |                    |                     | changed. The changed lists is passed in.       |
 * +-------------------+--------------------+---------------------+------------------------------------------------+
 *
 *  Each list in the `itemLists` should be an Immutable.Map and contain `label`, `items` and optionally,
 *  `id` and `unsortable`. If `unsortable` is set to true, the items can not be dragged to sort in its hosted
 *  list.
 *
 *  The `items` in each list should be an Immutable.List of item objects. Each such object
 *  should be an Immutable.Map and contain `id` and optionally, `label` and `renderer`.
 *  If no `renderer` exists, the item would be displayed using a default renderer. The default renderer
 *  will render `label` of that item, which can be e.g string or components. As fallback the `id` would
 *  be displayed.
 *
 *  .. code-block:; javascript
 *
 *      import React from 'react';
 *      import {Organizer} from 'cs-web-components-base';
 *      import Immutable from 'immutable';
 *
 *      const initState = Immutable.fromJS([
 *      {
 *              id: 'list1',
 *              label: 'List 1',
 *              items: [
 *                  {id: 'item1-1'},
 *                  {id: 'item1-2'},
 *                  {id: 'item1-3'},
 *                  {id: 'item1-4'}
 *              ]
 *          },
 *      {
 *              id: 'list2',
 *              label: 'List 2',
 *              items: [
 *                  {id: 'item2-1', label: 'apple'},
 *                  {id: 'item2-2', label: 'banana'},
 *                  {id: 'item2-3', label: 'orange'},
 *                  {id: 'item2-4', label: 'pear'}
 *              ]
 *          }
 *      ]);
 *
 *      export default class Tester extends React.Component {
 *          constructor(props) {
 *              super(props);
 *              this.state = {
 *                  items: Immutable.List(initState)
 *              };
 *              this.onChange = this.onChange.bind(this);
 *          }
 *
 *          onChange(itemLists) {
 *              this.setState({
 *                  items: itemLists
 *              });
 *          }
 *
 *          render() {
 *              return (
 *                  <Organizer itemLists={this.state.items} onItemListsChange={this.onChange} />
 *              );
 *          }
 *      }
 *
 */
export default class Organizer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            itemLists: undefined
        };
        this.moveItem = this.moveItem.bind(this);
        this.resetItemLists = this.resetItemLists.bind(this);
        this.resetItemList = this.resetItemList.bind(this);
        this.confirmDrop = this.confirmDrop.bind(this);
    }

    componentWillMount() {
        this.resetItemLists();
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.itemLists !== this.props.itemLists) {
            this.resetItemLists(nextProps);
        }
    }

    moveItem(dragged, toList, toIndex) {
        const itemList = this.state.itemLists.get(toList);
        let items = itemList.get('items');
        const sourceIdx = items.indexOf(dragged);
        if (sourceIdx > -1) {
            items = items.splice(sourceIdx, 1);
        }
        items = items.splice(toIndex, 0, dragged);
        if (items !== itemList.get('items')) {
            this.setState({
                itemLists: this.state.itemLists.set(
                    toList, itemList.set('items', items))
            });
        }
    }

    resetItemLists(nextProps) {
        const props = nextProps === undefined ? this.props : nextProps;
        this.setState({
            itemLists: Immutable.List(props.itemLists)
        });
    }

    resetItemList(index) {
        if (index > -1) {
            this.setState({
                itemLists: this.state.itemLists.set(
                    index, this.props.itemLists.get(index))
            });
        }
    }

    confirmDrop(dropResult) {
        const {item, fromList, toList, toIndex} = dropResult;
        const {itemLists, onItemListsChange} = this.props;
        if (onItemListsChange) {
            let newLists = Immutable.List(itemLists);
            const oriFrom = newLists.get(fromList);
            newLists = newLists.set(
                fromList,
                oriFrom.set(
                    'items',
                    oriFrom.get('items').filter(oItem => oItem !== item)
                )
            );
            const oriTo = newLists.get(toList);
            newLists = newLists.set(
                toList,
                oriTo.set(
                    'items',
                    oriTo.get('items').splice(toIndex, 0, item)
                )
            );
            onItemListsChange(newLists);
        }
    }

    render() {
        const last = this.state.itemLists.count() - 1;
        return (
            <div className={prefixNS('organizer')}>
                {this.state.itemLists.map((itemList, idx) => {
                    return (
                        <DNDOrganizerItemList
                            key={itemList.get('id', idx)}
                            index={idx}
                            forwardIndex={idx < last ? idx + 1 : undefined}
                            itemList={itemList}
                            placeholder={this.props.placeholder}
                            onMoveItem={this.moveItem}
                            onDragMoveOut={this.resetItemList}
                            onCancelDragItem={this.resetItemLists}
                            onConfirmDrop={this.confirmDrop}/>
                    );
                })}
            </div>
        );
    }
}

Organizer.propTypes = {
    itemLists: ImmutablePropTypes.list,
    placeholder: PropTypes.string,
    onItemListsChange: PropTypes.func
};
