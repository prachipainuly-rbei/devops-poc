/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: OperationScope.jsx 183808 2018-09-13 08:21:07Z vov $"
 */

import React from 'react';
import {PropTypes} from 'cs-web-components-externals';
import {Console} from '../../helpers.js';

let operationProviderCounter = 0;

function generateInstanceName() {
    // We do not use instanceName here, as this is only available in a
    // configured-ui context
    return `operationProvider-${++operationProviderCounter}`;
}

/*
 * TODO thinkabout: register operationproviders optionally for a specific operation.
 * e.g. if provider A is registered as editor, and B is registered as
 * editor/CDB_Modify CDB_Modify will be executed by B, while other editor-operations
 * will be executed by A.
 *
 */

/**
 * The OperationScope provides a context for the execution of kernel operations
 * across a hierarchy of components.
 *
 * Using the React Context, OperationScope provides a function for components
 * to register themselves as OperationHandlers. OperationTrigger components
 * use the surrounding OperationScope to trigger operation execution for
 * operation handlers, registered in the scope.
 *
 * @name OperationScope
 * @module
 */

class OperationScope extends React.Component {

    constructor(props) {
        super(props);
        this.registerOperationHandler = this.registerOperationHandler.bind(this);
        this.unregisterOperationHandler = this.unregisterOperationHandler.bind(this);
        this.getOperationHandler = this.getOperationHandler.bind(this);

        this.operationHandlers = new Map();
    }

    registerOperationHandler(handlerName) {
        if (this.operationHandlers.has(handlerName)) {
            Console.warn(
                `Multiple calls to registerOperationHandler` +
                `(${handlerName}) in one OperationScope.`
            );
        }

        const operationHandlerInstance = generateInstanceName();
        this.operationHandlers.set(handlerName, operationHandlerInstance);
        return operationHandlerInstance;
    }

    unregisterOperationHandler(handlerName) {
        const operationHandlerInstance = this.operationHandlers.get(handlerName);
        this.operationHandlers.delete(handlerName);
        return operationHandlerInstance;
    }

    getOperationHandler(handlerName) {
        // Does handler exist?
        const instanceName = this.operationHandlers.get(handlerName);
        if (instanceName) {
            return instanceName;
        }

        // If not, does this scope have a wildcarded handler?
        const wildcardInstanceName = this.operationHandlers.get('*');
        if (wildcardInstanceName) {
            return wildcardInstanceName;
        }

        // Ask surrounding scope
        if (this.context.getOperationHandler) {
            return this.context.getOperationHandler(handlerName);
        }

        return undefined;
    }

    getChildContext() {
        return {
            registerOperationHandler: this.registerOperationHandler,
            unregisterOperationHandler: this.unregisterOperationHandler,
            getOperationHandler: this.getOperationHandler
        };
    }

    render() {
        return (
            <React.Fragment>
                {this.props.children}
            </React.Fragment>
        );
    }
}

OperationScope.contextTypes = {
    getOperationHandler: PropTypes.func
};

OperationScope.childContextTypes = {
    registerOperationHandler: PropTypes.func,
    unregisterOperationHandler: PropTypes.func,
    getOperationHandler: PropTypes.func,
};

export default OperationScope;
