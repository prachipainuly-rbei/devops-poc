/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: TextInput.jsx 185125 2018-10-16 09:13:25Z cla $"
 */

import React from 'react';
import {FormGroup, ControlLabel, FormControl, InputGroup} from 'react-bootstrap';
import {sharedDefaultProps, sharedTextInputProps} from './sharedPropTypes';
import {PropTypes, classNames} from 'cs-web-components-externals';
import {prefixNS} from '../helpers';

/**
 * The component ``<TextInput>`` allows textual inputs and has following properties in addition to those
 * defined in :ref:`form_control_common_props`:
 *
 * +------------------+--------------+--------------+---------------------------------------------+
 * | Property         | Type         | Default      | Use                                         |
 * +==================+==============+==============+=============================================+
 * | value            | any          | \-           | Data to be displayed                        |
 * +------------------+--------------+--------------+---------------------------------------------+
 * | compact          | bool         | false        | Display in compact mode without label and   |
 * |                  |              |              | bottom margin                               |
 * +------------------+--------------+--------------+---------------------------------------------+
 * | beforeControl    | node         | \-           | A component or a list of components to be   |
 * |                  |              |              | placed before the input field               |
 * +------------------+--------------+--------------+---------------------------------------------+
 * | afterControl     | node         | \-           | A component or a list of components to be   |
 * |                  |              |              | placed after the input field                |
 * +------------------+--------------+--------------+---------------------------------------------+
 * | onValueChange    | func         | \-           | Equivalent callback of `onChange`, called   |
 * |                  |              |              | with the field value instead of the event   |
 * +------------------+--------------+--------------+---------------------------------------------+
 * | onEnter          | func         | \-           | Callback that is invoked when the user      |
 * |                  |              |              | pushes 'Enter'. Function will receive       |
 * |                  |              |              | current value of the field as parameter.    |
 * +------------------+--------------+--------------+---------------------------------------------+
 *
 * Example:
 *
 * .. code-block:: none
 *
 *     import {TextInput} from 'cs-web-components-base';
 *     import {Button} from 'react-bootstrap';
 *     ...
 *     // in render method of some component
 *     render() {
 *         const myButton = <Button onClick={this.openSomeDialog}>Open Dialog</Button>;
 *         return (
 *             <TextInput label="Some Field"
 *                        value={this.state.someValue}
 *                        onChange={this.handleChangeSomeValue}
 *                        afterControl={myButton} />);
 *     }
 *
 */
export default class TextInput extends React.Component {
    constructor(props) {
        super(props);
        this.onKeyDown = this.onKeyDown.bind(this);
        this.onChange = this.onChange.bind(this);
        this.onFocus = this.onFocus.bind(this);
        this.onBlur = this.onBlur.bind(this);
        this.setInputRef = this.setInputRef.bind(this);
        this.state = {focused: false};
    }

    onKeyDown(event) {
        const {onEnter, onCancel, onKeyDown, value} = this.props;
        // Dispatch Event itself
        if (onKeyDown) {
            onKeyDown(event);
            // onKeyDown may prevent default
            if (event.isDefaultPrevented()) {
                return;
            }
        }
        // Call special handler
        if (event.key === 'Enter') {
            event.preventDefault();
            if (onEnter) {
                onEnter(value);
            }
        }
        if (event.key === "Escape" || event.key === "Esc") {
            event.preventDefault();
            if (onCancel) {
                onCancel();
            }
        }
        // The IE calls the previous page if the field is read only
        if (event.key === 'Backspace' && this.props.readOnly) {
            event.preventDefault();
        }
    }

    onChange(event) {
        const {onChange, onValueChange} = this.props;
        if (onValueChange) {
            onValueChange(event.target.value);
        }
        if (onChange) {
            event.persist();
            return onChange(event);
        }
        return undefined;
    }

    setInputRef(c) {
        this.inputRef = c;
    }

    focus() {
        if (this.inputRef) {
            this.inputRef.focus();
        }
    }

    setSelectionRange(selectionStart, selectionEnd) {
        if (this.inputRef) {
            this.inputRef.setSelectionRange(selectionStart, selectionEnd);
        }
    }

    onFocus(event) {
        const {onFocus} = this.props;
        this.setState({focused: true});
        if (onFocus) {
            onFocus(event);
        }
    }

    onBlur(event) {
        const {onBlur} = this.props;
        this.setState({focused: false});
        if (onBlur) {
            onBlur(event);
        }
    }

    render() {
        const {
            ['data-ce-id']: data_ce_id,
            ['data-ce-type']: data_ce_type,
            beforeControl, afterControl,
            afterLabelControl,
            label, tooltip, validationState,
            mandatory, mandatoryEmptyHint,
            className, groupClassName,
            compact, ...others
        } = this.props;

        delete others.onKeyDown;
        delete others.onEnter;
        delete others.onValueChange;
        delete others.operationInstance;
        delete others.uncheckedValues;

        // XXX Note that we use onInput to handle changes on FormControl
        // as a workaround to https://github.com/facebook/react/issues/7027
        const classes = classNames(
            className,
            prefixNS('form-input'),
            'no-ie-text-input-clear-button'
        );
        let inputControl = null;
        if (!beforeControl && !afterControl) {
            inputControl = <FormControl type="text"
                                        inputRef={this.setInputRef}
                                        {...others}
                                        className={classes}
                                        onFocus={this.onFocus}
                                        onBlur={this.onBlur}
                                        onKeyDown={this.onKeyDown}
                                        onInput={this.onChange}/>;
        } else {
            const before = beforeControl ?
                (
                    <InputGroup.Button>
                        {beforeControl}
                    </InputGroup.Button>
                ) : null;
            const after = afterControl ?
                (
                    <InputGroup.Button>
                        {afterControl}
                    </InputGroup.Button>
                ) : null;
            inputControl = (
                <InputGroup>
                    {before}
                    <FormControl type="text"
                                 inputRef={this.setInputRef}
                                 {...others}
                                 className={classes}
                                 onFocus={this.onFocus}
                                 onBlur={this.onBlur}
                                 onKeyDown={this.onKeyDown}
                                 onInput={this.onChange}/>
                    {after}
                </InputGroup>
            );
        }

        // We need to manage focus manually for component styling, as IE11 does not support
        // the :focus-within selector
        const groupClass = classNames(
            prefixNS('formcontrols-formcontrol'),  // CSS class to identify formcontrol in css
            groupClassName,
            {
                [prefixNS('formcontrols-formcontrol-readonly')]: others.readOnly,
                [prefixNS('formcontrols-formcontrol-focused')]: this.state.focused,
                [prefixNS('formcontrols-textinput-compact')]: compact
            }
        );
        return (
            <FormGroup className={groupClass}
                       validationState={validationState}
                       data-ce-id={data_ce_id}
                       data-ce-type={data_ce_type}
                       data-mandatory={mandatory}
                       data-mandatory-empty-hint={mandatoryEmptyHint}>
                {label ? (
                    <span className={prefixNS('formcontrols-label-aftercontrol')}>
                        <ControlLabel title={tooltip}>
                            {label}
                        </ControlLabel>
                        {afterLabelControl}
                    </span>
                ) : null}
                {inputControl}
            </FormGroup>
        );
    }
}

TextInput.propTypes = {
    ...sharedTextInputProps,
    onKeyDown: PropTypes.func,
    onEnter: PropTypes.func,
    onCancel: PropTypes.func,
    onValueChange: PropTypes.func,
    groupClassName: PropTypes.string,
};

TextInput.defaultProps = Object.assign(
    {compact: false},
    sharedDefaultProps
);

export function combineInputExtensions(prev, curr) {
    if (curr) {
        return prev ? [prev, curr] : curr;
    }
    return prev;
}
