/*
 * Copyright (C) 1990-2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: FileList.jsx 184308 2018-09-24 09:25:42Z gwe $"
 */

import {addNotification, notifyError} from '../../actions/notification.js';
import React from "react";
import {PropTypes} from 'cs-web-components-externals';
import Dialog from '../../dialogs';
import {makeSequence, makeCancelable, prefixNS} from '../../helpers';
import {DefaultTable, getDefaultTableOptions} from '../../table/PredefinedTables.jsx';
import {postForm, getJSON, fetchAndCheck} from '../../fetch';
import {formatStr} from '../../i18n';
import {fetchObject, ensureFileTargetsAvailable} from '../../actions/object-actions';
import {classNames, connect} from 'cs-web-components-externals';
import Immutable from "immutable";
import FileDropzone from '../FileDropzone';
import FileConflictDialog from './FileConflictDialog';
import FileQuickAccessMenu from './FileQuickAccessMenu';
import FileDropdownMenu from './FileDropdownMenu';
import getColumns from './FileListColumns.jsx';
import * as FH from './FileListHelpers';
import * as ActionFactory from './FileListActionFactory';
import {OPERATION_ACTIVATION_MODES} from '../../constants.js';


/**
 * Render a list of files attached to an object via ``relship:files``.
 * This control can also trigger operations for these files. The available
 * operations are defined in the operation context ``WebUIFileControl``.
 *
 * React Properties
 * ----------------
 *
 * +---------------+-----------+------------------------------------------------+----------------------------------------------+
 * |    Property   |    Type   |                    Default                     |                     Use                      |
 * +===============+===========+================================================+==============================================+
 * | contextObject | JS object | \-                                             | The object whose relship:files should be     |
 * |               |           |                                                | displayed                                    |
 * +---------------+-----------+------------------------------------------------+----------------------------------------------+
 * | quickAccess   | JS Array  | ``["CDB_Import", "CDB_Export", "CDB_Delete"]`` | Names of operations to be displayed as icons |
 * |               |           |                                                | in the panel header of the filelist          |
 * +---------------+-----------+------------------------------------------------+----------------------------------------------+
 * | uploadURL     | JS string | \-                                             | URL to upload files to. If not provided, the |
 * |               |           |                                                | URL of the context object will be used.      |
 * +---------------+-----------+------------------------------------------------+----------------------------------------------+
 */
class FileList extends React.Component {

    constructor(props) {
        super(props);

        this.selectionChanged = this.selectionChanged.bind(this);
        this.askDeleteConfirm = this.askDeleteConfirm.bind(this);
        this.toggleFilter = this.toggleFilter.bind(this);
        this.updateContextObject = this.updateContextObject.bind(this);
        this.cancelConflictResolving = this.cancelConflictResolving.bind(this);
        this.renameConflictedFile = this.renameConflictedFile.bind(this);
        this.overwriteConflictedFile = this.overwriteConflictedFile.bind(this);
        this.registerOperationMenu = this.registerOperationMenu.bind(this);
        this.getMenuOperations = this.getMenuOperations.bind(this);
        this.registerQuickAccessMenu = this.registerQuickAccessMenu.bind(this);
        this.getQuickAccessOperations = this.getQuickAccessOperations.bind(this);

        this.requestPromise = null;
        this.operations = null;
        this.dropzone = null;
        this.columns = getColumns();
        this.state = {
            opContextUrl: null,
            enableFilterField: false,
            showDeleteDialog: false,
            showRenameInput: false,
            originalFilename: "",
            renameURL: null,
            deleteURL: null,
            showProgress: false,
            maxFiles: 0,
            currentFile: 0,
            hoverRow: -1,
            table: this.prepareTable(),
            minifiedTable: FH.prepareMinifiedTable(),
            initSelected: undefined,
            expanded: props.expanded,
            contextObject: this.props.contextObject,
            conflicted_filenames: Immutable.List(),
            queued_for_upload: Immutable.List(),
            queued_for_overwrite: Immutable.List()
        };

        this.selectedRows = [];
        this.selectionInfo = OPERATION_ACTIVATION_MODES.NO_SELECTION;
        this.uploadInProgress = false;

        this.operationMenu = null;
        this.quickAccessMenu = null;

        FH.registerWindowUnloadListener();
        if (props.contextObject !== undefined) {
            props.ensureFileTargetsAvailable(props.contextObject.get("@id"));
        }
    }

    componentWillReceiveProps(nextProps) {
        const co = this.state.contextObject;

        if (!nextProps.contextObject) {
            this.setState({contextObject: undefined});
        } else if (co !== nextProps.contextObject) {
            if (!co ||
                (co.get("@id") !== nextProps.contextObject.get("@id")) ||
                (!co.hasIn(["relship:files", "targets"]))) {
                nextProps.ensureFileTargetsAvailable(nextProps.contextObject.get("@id"));
                this.setState({contextObject: nextProps.contextObject});
            }
        }
    }

    prepareTable() {
        const tableOptions = getDefaultTableOptions();
        const tableDropdown = (
            <FileDropdownMenu
                ref={this.registerOperationMenu}
                getMenuOperations={this.getMenuOperations}/>
        );

        tableOptions.toolbarButtons.push(
            {toolbarButtons: [() => {
                return (
                    <FileQuickAccessMenu
                        ref={this.registerQuickAccessMenu}
                        getMenuOperations={this.getQuickAccessOperations}
                        dropdown={tableDropdown} />
                );
            }]});
        return DefaultTable(tableOptions);
    }

    registerQuickAccessMenu(menu) {
        this.quickAccessMenu = menu;
    }

    registerOperationMenu(menu) {
        this.operationMenu = menu;
    }

    getQuickAccessOperations() {
        return this.operations ? FH.getQuickAccessOps(
            this.mapOperationsToActions(), this.props.quickAccess,
            this.selectionInfo) : [];
    }

    getMenuOperations() {
        return this.operations ?
            FH.getMenuOps(this.mapOperationsToActions(), this.selectionInfo) :
            [];
    }

    cancelRequest() {
        if (this.requestPromise !== null) {
            this.requestPromise.cancel();
            this.requestPromise = null;
        }
    }

    updateOpContext(opContextUrl) {
        this.setState({opContextUrl: opContextUrl});
        this.cancelRequest();
        this.requestPromise = makeCancelable(getJSON(opContextUrl));
        this.requestPromise.promise.then(
            data => {
                this.requestPromise = null;
                this.operations = Immutable.fromJS(data);
                this.setState({table: this.prepareTable()});
            },
            err => {
                this.requestPromise = null;
                if (err.isCanceled !== true) {
                    this.props.notifyError(err, null, 'Error', 'danger');
                }
            });
    }

    componentDidMount() {
        this.updateOpContext(FH.getOpContextUrl());
    }

    componentWillUnmount() {
        this.cancelRequest();
    }

    cancelConflictResolving() {
        this.setState(FH.NO_CONFLICTS);
    }

    proceedWithUpload() {
        if (this.state.conflicted_filenames.count() === 0) {
            this.createFile(this.state.queued_for_upload.toJS());
        }
    }

    renameConflictedFile(file, newName) {
        file.name_alt = newName;
        this.setState({
            conflicted_filenames: this.state.conflicted_filenames.remove(0),
            queued_for_upload: this.state.queued_for_upload.push(file)
        }, () => {
            this.proceedWithUpload();
        });
    }

    overwriteConflictedFile(file) {
        this.setState({
            conflicted_filenames: this.state.conflicted_filenames.remove(0),
            queued_for_overwrite: this.state.queued_for_overwrite.push(file)
        }, () => {
            this.proceedWithUpload();
        });
    }

    updateContextObject() {
        this.props.fetchObject(this.state.contextObject.get("@id")).then((data) => {
            this.setState({contextObject: Immutable.fromJS(data)});
        });
    }

    toggleFilter() {
        this.setState({enableFilterField: !this.state.enableFilterField});
    }

    downloadFiles() {
        const file_ids = this.selectedRows.map(
            idx => FH.files(this.state.contextObject).get(idx).get("@id")
        );
        for (const fid of file_ids) {
            window.open(fid);
        }
        this.selectedRows = [];
        this.setState({selectionInfo: OPERATION_ACTIVATION_MODES.NO_SELECTION,
            initSelected: Immutable.OrderedSet()
        }, () => this.setState({
            initSelected: undefined}) // We need to perform this hack, to reset table selection
        );
    }

    showRenameDialog(modifyURL) {
        const currentFile = FH.files(this.state.contextObject).get(this.selectedRows[0]);
        this.setState({
            renameURL: modifyURL,
            originalFilename: currentFile.get("cdbf_name"),
            showRenameInput: true
        });
    }

    renameFile(value) {
        const original = this.state.originalFilename;
        if (this.state.renameURL) {
            this.performOperation(this.state.renameURL,
                {cdbf_name: FH.baseToFileName(value, original)})
                .then(() => {
                    this.setState({
                        showRenameInput: false,
                        renameURL: null,
                        selectionInfo: OPERATION_ACTIVATION_MODES.NO_SELECTION,
                        initSelected: Immutable.OrderedSet()
                    }, () => this.setState({
                        initSelected: undefined}) // We need to perform this hack, to reset table selection
                    );
                    this.selectedRows = [];
                    this.updateContextObject();
                });
        }
    }

    deleteFiles() {
        if (this.state.deleteURL) {
            this.performOperation(this.state.deleteURL, {}).then(() => {
                this.setState({
                    showDeleteDialog: false,
                    deleteURL: null,
                    selectionInfo: OPERATION_ACTIVATION_MODES.NO_SELECTION,
                    initSelected: Immutable.OrderedSet()
                }, () => this.setState({
                    initSelected: undefined}) // We need to perform this hack, to reset table selection
                );
                this.selectedRows = [];
                this.updateContextObject();
            });
        }
    }

    createFile(files) {
        if (files) {
            // Check conflicting filenames
            let queued_for_upload = Immutable.List();
            let conflicted_filenames = Immutable.List();

            files.map(new_file => {
                let conflicted = false;
                FH.files(this.state.contextObject).map(file => {
                    if (new_file.name === file.get('cdbf_name', '')) {
                        if (new_file.name_alt) {
                            if (new_file.name_alt === file.get('cdbf_name', '')) {
                                conflicted = true;
                            }
                        } else {
                            conflicted = true;
                        }
                        new_file.overwrite_url = file.get('@id');
                    }
                    return conflicted_filenames;
                });

                if (conflicted) {
                    conflicted_filenames = conflicted_filenames.push(new_file);
                } else {
                    queued_for_upload = queued_for_upload.push(new_file);
                }

                return conflicted_filenames;
            });

            // Check if upload should be aborted due to conflicts!
            if (conflicted_filenames.count() > 0) {
                this.setState({
                    conflicted_filenames: conflicted_filenames,
                    queued_for_upload: queued_for_upload,
                    queued_for_overwrite: Immutable.List()
                });
                return;
            }

            // Upload new files
            this.setState({
                showProgress: true,
                maxFiles: files.length + this.state.queued_for_overwrite.count(),
                currentFile: 0
            });
            this.uploadInProgress = true;

            const {uploadURL, contextObject} = this.props;
            const fileUploadUrl = uploadURL ? uploadURL : contextObject.get('@id') + '/files';

            let callables = files.map(file => {
                return () => {
                    this.setState({currentFile: this.state.currentFile + 1});
                    return postForm(fileUploadUrl, FH.getFileUploadFormData(file));
                };
            });

            // Process overwrite operations
            const overwrite_ops = this.state.queued_for_overwrite.map(file => {
                return () => {
                    this.setState({currentFile: this.state.currentFile + 1});
                    const options = {
                        method: 'PUT',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/octet-stream',
                            'Content-Length': file.size
                        },
                        body: file
                    };
                    return fetchAndCheck(file.overwrite_url, options).then(response => {
                        return response.text().then((text) => {
                            return text ? Promise.resolve(JSON.parse(text)) : Promise.resolve(text);
                        });
                    });
                };
            });

            callables = callables.concat(overwrite_ops.toJS());

            makeSequence(callables)
                .catch(err => this.props.notifyError(err, null, 'Error', 'danger'))
                .then(() => {
                    this.updateContextObject();
                    this.setState({
                        showProgress: false,
                        initSelected: Immutable.OrderedSet(),
                        conflicted_filenames: Immutable.List(),
                        queued_for_upload: Immutable.List(),
                        queued_for_overwrite: Immutable.List()
                    }, () => this.setState({
                        initSelected: undefined}) // We need to perform this hack, to reset table selection
                    );
                    this.uploadInProgress = false;
                });
        }
    }

    selectionChanged(selected) {
        this.selectedRows = selected.toJS();
        this.selectionInfo = FH.getSelectionInfo(this.selectedRows.length);

        if (this.quickAccessMenu) {
            this.quickAccessMenu.updateContext();
        }

        if (this.operationMenu) {
            this.operationMenu.updateContext();
        }

        if (this.props.onSelect) {
            this.props.onSelect(selected.map(idx => FH.files(this.state.contextObject).get(idx)));
        }
    }

    askDeleteConfirm() {
        this.setState({showDeleteDialog: true});
    }

    wrappedPerformOperation(id, values) {
        const operationMap = Immutable.Map(this.operations.map(op => [op.get("opname"), op]));
        const modifyURL = operationMap.get("CDB_Modify").get("submit_url");

        this.selectedRows = [id];
        this.performOperation(modifyURL, values);
    }

    performOperation(submitUrl, values) {
        const fileObjs = this.selectedRows.map(idx => FH.files(this.state.contextObject).get(idx));
        return makeSequence(FH.performOpCallables(submitUrl, values, fileObjs))
            .catch(err => this.props.notifyError(err, null, 'Error', 'danger'))
            .then(() => {
                this.selectedRows = [];
                this.setState({
                    selectionInfo: OPERATION_ACTIVATION_MODES.NO_SELECTION,
                    initSelected: Immutable.OrderedSet()
                }, () => this.setState({
                    initSelected: undefined}) // We need to perform this hack, to reset table selection
                );
                this.updateContextObject();
            });
    }

    getSpecialActions(operationMap) {
        const modifyURL = operationMap.get("CDB_Modify").get("submit_url");
        return {
            CDB_Delete: [{
                callback: () => {
                    this.setState({deleteURL: operationMap.get("CDB_Delete").get("submit_url")},
                                  this.askDeleteConfirm);
                }
            }],
            CDB_Modify: [
                ActionFactory.getFileRenameAction(this.showRenameDialog.bind(this, modifyURL)),
                ActionFactory.getSetMainFileAction(
                    this.performOperation.bind(this, modifyURL, {cdbf_primary: "1"})),
                ActionFactory.getUnsetMainFileAction(
                    this.performOperation.bind(this, modifyURL, {cdbf_primary: "0"}))
            ],
            CDB_Import: [ActionFactory.getCDBImportAction(() => this.dropzone.choose())],
            CDB_Export: [ActionFactory.getCDBExportAction(this.downloadFiles.bind(this))]
        };
    }

    mapOperationsToActions() {
        const operationMap = Immutable.Map(this.operations.map(op => [op.get("opname"), op]));
        const specials = this.getSpecialActions(operationMap);
        let fileEditingAllowed = false;
        const opMap = operationMap.map((op, opname) => {
            if (opname === "CDB_Edit") {
                if (op.get("submit_url")) {
                    fileEditingAllowed = true;
                }
                return [];
            }
            if (opname in specials) {
                const newActions = [];
                for (const action of specials[opname]) {
                    newActions.push(op.merge(action).toObject());
                }
                return newActions;
            } else {
                return [{
                    label: op.get("label"),
                    icon: op.get("icon"),
                    tooltip: op.get("tooltip"),
                    callback: this.performOperation.bind(this, op.get("submit_url"), {}),
                    activation_mode: op.get("activation_mode")
                }];
            }
        });

        if (fileEditingAllowed) {
            return FH.addEditAction(opMap, this.state.contextObject, this.selectedRows);
        } else {
            return opMap;
        }
    }

    fillRows() {
        if (this.props.minified) {
            return FH.files(this.state.contextObject).map((f, index) =>
                FH.generateMinifiedRowEntry(f, index)
            );
        }

        return FH.files(this.state.contextObject).map((f, index) =>
            FH.generateRowEntry(f, index)
        );
    }

    getOverlay() {
        if (!this.state.expanded || !this.state.showProgress) {
            return null;
        }

        return FH.getFileStepOverlay(this.state.currentFile, this.state.maxFiles);
    }

    expansionChanged(expanded) {
        this.setState({expanded: expanded});
    }

    renderMinified() {
        const FileTable = this.state.minifiedTable;

        return (
            <div className={classNames(prefixNS("filelist"), prefixNS("filelist--minified"))}>
                <FileTable {...this.columns.minified}
                        rows={this.fillRows()}
                        title={formatStr("file_table_panel")}
                        singleSelection={false}
                        expanded={true}
                        onExpansionChanged={this.expansionChanged.bind(this)}
                        initSelected={this.state.initSelected}
                        onSelectRows={this.selectionChanged}>
                </FileTable>
            </div>
        );
    }

    render() {
        if (this.props.minified) {
            return this.renderMinified();
        }

        const FileTable = this.state.table;

        return (
            <div className={prefixNS("filelist")}>
                <FileTable {...this.columns.normal}
                        contentHeight={"200px"}
                        rows={this.fillRows()}
                        title={formatStr("file_table_panel")}
                        settingID={FH.SETTING_ID}
                        withSelector={true}
                        singleSelection={false}
                        expanded={this.state.expanded}
                        onExpansionChanged={this.expansionChanged.bind(this)}
                        initSelected={this.state.initSelected}
                        onSelectRows={this.selectionChanged}>
                </FileTable>
                <FileDropzone autoHide={true}
                              onDrop={this.createFile.bind(this)}
                              className={FH.getDropzoneClass(this.state.expanded)}
                              ref={(c) => {this.dropzone = c}}>
                    <p>{formatStr("file_table_drop")}</p>
                </FileDropzone>
                {this.getOverlay()}
                <Dialog.Alert title={formatStr("file_table_modal_delete_title")}
                              ActionButton={<Dialog.Buttons.Delete />}
                              onConfirm={this.deleteFiles.bind(this)}
                              onHide={() => this.setState({showDeleteDialog: false})}
                              show={this.state.showDeleteDialog}>
                    {formatStr("file_table_modal_delete_text")}
                </Dialog.Alert>
                <Dialog.InputDialog title={formatStr("file_table_rename_file_action")}
                                    value={FH.fileToBaseName(this.state.originalFilename)}
                                    ActionButton={<Dialog.Buttons.Rename />}
                                    showCancel show={this.state.showRenameInput}
                                    onSubmitValue={this.renameFile.bind(this)}
                                    isValueValid={Dialog.InputDialog.NO_EMPTY_VALUE}
                                    onHide={() => this.setState({showRenameInput: false})}>
                    <h4>{formatStr("file_table_rename_dialog_text")}</h4>
                </Dialog.InputDialog>
                <FileConflictDialog visible={this.state.conflicted_filenames.count() > 0}
                                    file={this.state.conflicted_filenames.first()}
                                    onCancel={this.cancelConflictResolving}
                                    onRename={this.renameConflictedFile}
                                    onOverwrite={this.overwriteConflictedFile} />
            </div>
        );
    }
}

FileList.propTypes = {
    contextObject: PropTypes.instanceOf(Immutable.Map).isRequired,
    onSelect: PropTypes.func,
    notifyError: PropTypes.func,
    fetchObject: PropTypes.func,
    ensureFileTargetsAvailable: PropTypes.func,
    uploadURL: PropTypes.string,
    quickAccess: PropTypes.arrayOf(PropTypes.string),
    expanded: PropTypes.bool,
    minified: PropTypes.bool,
};

FileList.defaultProps = {
    quickAccess: ["CDB_Import", "CDB_Export", "CDB_Delete"],
    expanded: false
};

const actions = {addNotification, notifyError, fetchObject, ensureFileTargetsAvailable};
export default connect(undefined, actions)(FileList);
