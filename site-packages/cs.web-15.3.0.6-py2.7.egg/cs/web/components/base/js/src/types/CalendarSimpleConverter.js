///*
// * Copyright (C) 2017 CONTACT Software GmbH
// * All rights reserved.
// * http://www.contact-software.com
// *
// * Revision "$Id: CalendarSimpleConverter.js 174476 2018-03-14 16:00:48Z yzh $"
// */

import moment from 'moment';
import DateRange from './DateRange';

export default class CalendarSimpleConverter {
    constructor(backendFormat, frontendFormat, frontendDateOnlyFormat) {
        this.backendFormat = backendFormat;
        this.frontendFormat = frontendFormat;
        this.frontendDateOnlyFormat = frontendDateOnlyFormat;
    }

    checkDisplayValue(displayValue) {
        const parts = displayValue.split(RegExp(/-\s|\s-/), 2);
        const dateParts = parts.map(p => p.trim());
        if (dateParts.find(dp => dp && !moment(dp, this.frontendFormat).isValid())) {
            return false;
        }
        return true;
    }

    convertRangeToValue(dateRange) {
        return '>=' + dateRange.getStart().format(this.backendFormat) +
               ' AND <=' + dateRange.getEnd().format(this.backendFormat);
    }

    getRangeFromValue(value) {
        if (!value) {
            return null;
        }
        const inputDate = this._getDateObjectStrict(value, this.backendFormat);
        if (inputDate.isValid()) {
            return new DateRange(inputDate, inputDate);
        }
        const re = new RegExp('AND', 'gi');
        const matched = value.match(re);
        if (matched && matched.length > 1) {
            // Only ">= start [AND <= end]" formatted value
            // can be convert to DateRange.
            return null;
        }
        const values = value.split(re);
        const beginParsed = this._normalizeDateOP(
            this._getDateStrAndOperator(values[0]), this.backendFormat);
        if (!beginParsed) {
            // value not parsable
            return null;
        }
        if (values.length === 1) {
            if (beginParsed.op === '>=') {
                // >= someDate
                return new DateRange(beginParsed.date, null);
            } else if (beginParsed.op === '<=') {
                return new DateRange(null, beginParsed.date);
            }
            // no parsable
            return null;
        }
        const endParsed = this._normalizeDateOP(
            this._getDateStrAndOperator(values[1]), this.backendFormat);
        if (!endParsed) {
            // value not parsable
            return null;
        }
        if (beginParsed.op === '>=' && endParsed.op === '<=' &&
            beginParsed.date.isSameOrBefore(endParsed.date)) {
            return new DateRange(beginParsed.date, endParsed.date);
        } else if (beginParsed.op === '<=' && endParsed.op === '>=' &&
            beginParsed.date.isSameOrAfter(endParsed.date)) {
            return new DateRange(endParsed.date, beginParsed.date);
        }
        // no regular parsed value
        return null;
    }

    _normalizeDateOP(dateOP, format) {
        if (dateOP) {
            let mom = this._getDateObjectStrict(dateOP[1], format);
            if (!mom.isValid()) {
                return null;
            }
            let op = dateOP[0];
            if (op === '>' || op === '<') {
                mom = mom.add(op === '>' ? 1 : -1, 'day');
                op += '=';
            }
            return {op, date: mom};
        }
        return null;
    }

    formatDisplayDate(date) {
        // specific date only mode
        const dateMoment = moment(date);
        if (dateMoment.isSame(dateMoment.clone().startOf('day')) &&
            this.frontendDateOnlyFormat !== undefined) {
            return dateMoment.format(this.frontendDateOnlyFormat);
        }
        return dateMoment.format(this.frontendFormat);
    }

    _getDateStrAndOperator(dateString) {
        if (dateString) {
            const dateStart = dateString.search(/\d/);
            if (dateStart !== -1) {
                return [dateString.substring(0, dateStart).trim(),
                    dateString.substring(dateStart).trim()];
            }
        }
        return null;
    }

    _getOnlyDateFromFormat(format) {
        return format.split(' ')[0];
    }

    _getDateObjectStrict(value, valueFormat) {
        const format = valueFormat ?
            this._getOnlyDateFromFormat(valueFormat) : moment.ISO_8601;
        return moment.parseZone(value, format, true);
    }

    convertToDisplay(value) {
        const range = this.getRangeFromValue(value);
        if (!range) {
            return '';
        }
        if (range.duration() === 0) {
            return this.formatDisplayDate(range.getStart());
        }
        const parts = [];
        const start = range.getStart();
        const end = range.getEnd();
        if (start) {
            parts.push(this.formatDisplayDate(start) + ' ');
        } else {
            parts.push('');
        }
        if (end) {
            parts.push(' ' + this.formatDisplayDate(end));
        } else {
            parts.push('');
        }
        return parts.join('-');
    }

    convertToValue(inValue) {
        let result = '';
        if (inValue) {
            const parts = inValue.split(RegExp(/-\s|\s-/), 2);
            const dateParts = parts.map(p => p.trim());
            if (dateParts.length === 1) {
                const dateObj = moment.parseZone(dateParts[0], this.frontendFormat);
                result = dateObj.format(this.backendFormat).trim();
            } else if (dateParts.length === 2) {
                if (dateParts[0]) {
                    const dateObjFrom = moment.parseZone(dateParts[0], this.frontendFormat);
                    result = '>=' + dateObjFrom.format(this.backendFormat).trim();
                }
                if (dateParts[1]) {
                    result += result ? ' AND ' : '';
                    const dateObjTo = moment.parseZone(dateParts[1], this.frontendFormat);
                    result += '<=' + dateObjTo.format(this.backendFormat).trim();
                }
            }
        }
        return result;
    }
}
