/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: SVGIcon.jsx 180632 2018-07-17 10:18:55Z bwf $"
 */

import React from 'react';
import {classNames, PropTypes} from 'cs-web-components-externals';
import {prefixNS, makeCancelable, getIcon, Console} from '../helpers';
import {fetchAndCheck} from '../fetch';

import broken_icon from '../../../resources/cis_broken.svg';

const SVGCACHE = {};
const FETCHING = {};
const SVGTYPE = 'image/svg+xml';
const SVGB64TYPE = "data:image/svg+xml;base64,";
const B64ICONDATAOFFSET = SVGB64TYPE.length;

function getSVG(url) {
    const svg = SVGCACHE[url];
    if (svg === undefined) {
        // If a fetch for this URL is already underway, just return the URL we
        // already have.
        const existingPromise = FETCHING[url];
        if (existingPromise !== undefined) {
            return existingPromise;
        }
        const newPromise = fetchAndCheck(url).then(
            response => {
                delete FETCHING[url];
                if (response.headers.get('Content-Type').startsWith(SVGTYPE)) {
                    SVGCACHE[url] = response.text();
                } else {
                    SVGCACHE[url] = null;
                }
                return SVGCACHE[url];
            },
            err => {
                delete FETCHING[url];
                SVGCACHE[url] = null;
                throw err;
            }
        );
        // Remember the URL, as marker that a fetch is in progress and to return
        // to additional calls with the same URL.
        FETCHING[url] = newPromise;
        return newPromise;
    }
    return Promise.resolve(svg);
}

/**
 * The component display SVG icon in predefined sizes.
 *
 * React Properties
 * ----------------
 *
 * +------------------+--------------+--------------+---------------------------------+
 * | Property         | Type         | Default      | Use                             |
 * +==================+==============+==============+=================================+
 * | name             | string       | -            | Name of configured icon         |
 * +------------------+--------------+--------------+---------------------------------+
 * | src              | string       | -            | URL to load the icon            |
 * +------------------+--------------+--------------+---------------------------------+
 * | size             | string       | sm           | Size of that image. Can be:     |
 * |                  |              |              | sm, md, lg                      |
 * +------------------+--------------+--------------+---------------------------------+
 * | fallbackSVG      | string       | -            | URL to load the fallbackSVG     |
 * +------------------+--------------+--------------+---------------------------------+
 *
 * .. note::
 *    If ``src`` is given, it will be used to load the icon. Otherwise the component tries
 *    to generate the url for configured icon according to the ``name``.
 *    If ``src`` is not an SVG, the component renders ``fallbackSVG``. If ``fallbackSVG`` is not given,
 *    the component renders ``src`` as an image.
 *
 * @module
 */

export default class SVGIcon extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            svg: null,
            src: ''
        };
        this.promise = null;
        const size = props.size;
        if (size === "xs" ||
            size === "xl" ||
            size === "xxs" ||
            size === "xxl") {
            Console.warn(`The prop \`size\` of value \`${size}\` supplied to \`SVGIcon\` `
                + 'is deprecated. Please use one of ["sm","md","lg"]'
            );
        }
        this.onImageError = this.onImageError.bind(this);
    }

    componentDidMount() {
        this.loadSVG(this.props);
    }

    componentWillReceiveProps(nextProps) {
        if (this.getURL(nextProps) !== this.getURL(this.props)) {
            this.loadSVG(nextProps);
        }
    }

    componentWillUnmount() {
        if (this.promise !== null) {
            this.promise.cancel();
            this.promise = null;
        }
    }

    loadEmbeddedSVGData(rawData) {
        const iconData = rawData.substring(B64ICONDATAOFFSET);
        const svgData = atob(iconData);

        this.setState({
            svg: svgData
        });
    }

    loadSVGfromURL(url, props) {
        if (this.promise !== null) {
            this.promise.cancel();
        }
        if (url.startsWith(SVGB64TYPE)) {
            this.loadEmbeddedSVGData(url);
            return;
        }
        this.promise = makeCancelable(getSVG(url));
        this.promise.promise.then(
            data => {
                if (this.promise !== null) {
                    const fallbackSVG = props.fallbackSVG;
                    // We check for the promise to be not null, because the promise
                    // may already have fired, but in the same interpreter cycle
                    // the component was unmounted.
                    // From MDN: "The handler function (...) gets then called
                    // asynchronously (as soon as the stack is empty)".

                    this.promise = null;
                    if (data === null && fallbackSVG !== undefined && fallbackSVG !== url) {
                        this.loadSVGfromURL(fallbackSVG, props);
                    } else {
                        const fallBackUrl = this.getURL(props);
                        this.setState({
                            svg: data || null,
                            src: fallBackUrl
                        });
                    }
                }
            }
        ).catch(() => {
            if (this.promise !== null) {
                this.promise = null;

                const fallBackUrl = this.getURL(props);
                this.setState({
                    svg: null,
                    src: fallBackUrl
                });
            }
        });
    }

    loadSVG(props) {
        const url = this.getURL(props);
        const fallbackSVG = props.fallbackSVG;
        if (url === undefined && fallbackSVG === undefined) {
            return;
        }
        this.loadSVGfromURL(url, props);
    }

    getURL(props) {
        const {src, name} = props;
        return src || (name ? getIcon(name) : undefined);
    }

    renderSVG() {
        return {
            __html: this.state.svg
        };
    }

    onImageError() {
        this.loadEmbeddedSVGData(broken_icon);
    }

    render() {
        const {size, className, ...others} = this.props;
        delete others.name;
        delete others.src;
        delete others.fallbackSVG;
        delete others.onError;
        const clsnames = classNames(
            className, prefixNS('svg-icon'), prefixNS(`icon-size-${size}`));
        if (this.state.svg) {
            return (
                <div
                    dangerouslySetInnerHTML={this.renderSVG()}
                    className={clsnames}
                    {...others}
                />
            );
        } else if (this.state.src) {
            return (
                <img
                    src={this.state.src}
                    className={clsnames}
                    onError={this.onImageError}
                    {...others}
                />
            );
        } else {
            return (
                <div
                    className={clsnames}
                    {...others}
                />
            );
        }
    }
}

SVGIcon.propTypes = {
    name: PropTypes.string,
    src: PropTypes.string,
    fallbackSVG: PropTypes.string,
    className: PropTypes.string,
    size: PropTypes.oneOf([
        'xxs', 'xs', 'sm', 'md', 'lg', 'xl', 'xxl'
    ])
};

SVGIcon.defaultProps = {
    size: 'sm'
};
