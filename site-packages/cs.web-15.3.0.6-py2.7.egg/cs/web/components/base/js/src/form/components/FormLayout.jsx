/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: FormLayout.jsx 184286 2018-09-21 13:59:56Z cla $"
 */

import React from 'react';
import {PropTypes} from 'cs-web-components-externals';
import {Grid, Row, Col} from 'react-bootstrap';
import Immutable from 'immutable';
import FormControlWrapper from '../components/FormControlWrapper';
import {getRelevantAttributes, anyAttributeIsRelevant} from '../fieldTypes';
import HelpReference from '../../components/HelpReference';

function LegendHeader(props) {
    const help_url = props.register.get('help_url');
    const icon_url = props.register.get('icon');

    const icon_html = icon_url ? <img className='elements-register-icon' src={icon_url}/> : null;
    const help_html = help_url ? <HelpReference helpUrl={help_url} /> : null;
    return (
        <legend className='elements-register-legend'>
            { icon_html }
            {props.register.get('label')}
            { help_html }
        </legend>
    );
}

LegendHeader.propTypes = {
    register: PropTypes.instanceOf(Immutable.Map).isRequired
};

function uniqSorted(objList, getter) {
    return objList.map(getter).filter(x => x >= 0).sort().toOrderedSet().toList();
}

function relevantAttrsChanged(fields, nextProps, currProps) {
    if (fields.filter(anyAttributeIsRelevant).size > 0) {
        return true;
    }
    return fields.filter(field =>
            getRelevantAttributes(field).find(
                attr => nextProps.values.get(attr) !== currProps.values.get(attr))
        ).size > 0;
}

function shouldUpdate(nextProps, currProps) {
    return nextProps.onFieldsChange !== currProps.onFieldsChange ||
        nextProps.readOnly !== currProps.readOnly ||
        nextProps.formats !== currProps.formats ||
        nextProps.onNavigateLink !== currProps.onNavigateLink ||
        nextProps.displayMappingURL !== currProps.displayMappingURL ||
        nextProps.operationState !== currProps.operationState ||
        nextProps.containerRef !== currProps.containerRef ||
        typeof nextProps.values !== typeof currProps.values;
}

const sharedPropTypes = {
    formats: PropTypes.instanceOf(Immutable.Map),
    values: PropTypes.instanceOf(Immutable.Map),
    onFieldsChange: PropTypes.func,
    onNavigateLink: PropTypes.func,
    readOnly: PropTypes.bool,
    displayMappingURL: PropTypes.string,
    operationState: PropTypes.instanceOf(Immutable.Map),
    contextObjects: PropTypes.instanceOf(Immutable.List)
};

class FormRow extends React.Component {
    shouldComponentUpdate(nextProps) {
        return nextProps.fields !== this.props.fields ||
            shouldUpdate(nextProps, this.props) ||
            relevantAttrsChanged(
                nextProps.fields.filter(x => x !== undefined),
                nextProps,
                this.props);
    }

    render() {
        const {fields, onFieldsChange, values, uncheckedValues,
            formats, readOnly, onNavigateLink, containerRef,
            displayMappingURL, operationState, contextObjects} = this.props;
        return (
            <Row>
                {fields.map((field) => field === undefined ? null :
                    <Col sm={field.get('span')} key={field.get('attribute')}>
                        <FormControlWrapper
                            operationInstance={this.props.operationInstance}
                            containerRef={containerRef}
                            setting={field}
                            onFieldsChange={onFieldsChange}
                            onNavigateLink={onNavigateLink}
                            values={values}
                            uncheckedValues={uncheckedValues}
                            formats={formats}
                            readOnly={readOnly}
                            displayMappingURL={displayMappingURL}
                            operationState={operationState}
                            contextObjects={contextObjects} />
                    </Col>
                )}
            </Row>
        );
    }
}

FormRow.propTypes = {
    fields: PropTypes.instanceOf(Immutable.List),
    ...sharedPropTypes
};

export default class FormLayout extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            layout: this.buildLayout(props)
        };
    }

    getFields(props) {
        return props.register.get('fields');
    }

    componentWillReceiveProps(nextProps) {
        if (this.getFields(nextProps) !== this.getFields(this.props)) {
            this.setState({
                layout: this.buildLayout(nextProps)
            });
        }
    }

    getColumns(fields) {
        return uniqSorted(fields, field => field.get('column'));
    }

    getRows(fields) {
        return uniqSorted(fields, field => field.get('row'));
    }

    buildRow(fields, row, columns) {
        return Immutable.List(columns.map(col =>
            fields.find(field => field.get('row') === row && field.get('column') === col)
        ));
    }

    buildLayout(props) {
        const fields = this.getFields(props);
        const rows = this.getRows(fields);
        const columns = this.getColumns(fields);
        return rows.map(row => this.buildRow(fields, row, columns));
    }

    shouldComponentUpdate(nextProps) {
        return nextProps.register !== this.props.register ||
            shouldUpdate(nextProps, this.props) ||
            relevantAttrsChanged(this.getFields(nextProps), nextProps, this.props);
    }

    render() {
        const {register, ...others} = this.props;
        const formLayout = this.state.layout;
        return (
            <fieldset>
                <LegendHeader register={register}/>
                <Grid className="elements-formcontrol-grid" fluid={true}>
                    {formLayout.map((row, rowIdx) =>
                        <FormRow key={rowIdx} fields={row} {...others} />
                    )}
                </Grid>
            </fieldset>
        );
    }
}

FormLayout.propTypes = {
    register: PropTypes.instanceOf(Immutable.Map).isRequired,
    operationInstance: PropTypes.string,
    ...sharedPropTypes
};
