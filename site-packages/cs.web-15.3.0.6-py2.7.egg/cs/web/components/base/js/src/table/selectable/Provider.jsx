/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Provider.jsx 175531 2018-04-05 13:41:52Z mbr $"
 */

import React from 'react';
import {PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import Immutable from 'immutable';
import connect from '../connect';
import {setSelectedRows, setOrderedColumns,
    setColumns, setRowClassName
} from '../common/actions';
import {setSingleSelectionMode, selectRow,
    selectRows, setAllSelector} from './actions';
import {formatStr} from '../../i18n';
import Selector from './Selector';
import {SELECTORID} from '../constants.js';

export default function(WrappedTable) {
    class Select extends React.Component {
        constructor(props) {
            super(props);
            this.onSelect = this.onSelect.bind(this);
            this.markRows = this.markRows.bind(this);
            this.dispatchNavigation = this.dispatchNavigation.bind(this);
            this.selectorColumn = Immutable.Map({
                id: SELECTORID,
                label: '',
                width: '1em',
                contentRenderer: Selector,
                tooltip: formatStr('tabcatalog_select_header')  // TODO: i18n own label/tooltip
            });

        }

        componentWillMount() {
            if (this.props.initSelected !== undefined) {
                this.selectRows(this.props.initSelected, this.props);
            }
            this.props.setSingleSelectionMode(this.props.singleSelection);
            this.createSelector(this.props);
            this.props.setAllSelector(this.props.withAllSelector &&
                                      this.props.withSelector &&
                                      !this.props.singleSelection);
        }

        dispatchNavigation(event) {
            const {selectRow, selectRows, singleSelection} = this.props;
            if (event.get('extend')) {
                selectRow(event.get('rowIds').get(0));
            } else {
                if (!singleSelection) {
                    selectRows(Immutable.OrderedSet(event.get('rowIds')),
                               event.get('focusedRow'),
                               event.get('selectionAnchor'));
                } else {
                    selectRow(event.get('focusedRow'));
                }
            }
        }

        // -------------

        createSelector(props) {
            const {
                setColumns, setOrderedColumns,
                columns, orderedColumns, withSelector
            } = props;
            if (!withSelector) {
                return;
            }
            const added = columns.findIndex(
                col => col.get('id') === SELECTORID);
            if (added < 0) {
                const newColumns = columns.push(this.selectorColumn);
                setColumns(newColumns);
                setOrderedColumns(
                    Immutable.OrderedSet([SELECTORID]).union(orderedColumns));
            } else if (orderedColumns.first() !== SELECTORID) {
                setOrderedColumns(
                    Immutable.OrderedSet([SELECTORID]).union(orderedColumns));
            }
        }

        getValidSelection(selected, props) {
            const {rows} = props;
            return selected.filter(
                i => rows.findIndex(row => row.get('id') === i) > -1);
        }

        selectRows(selected, props) {
            const {setSelectedRows} = props;
            const valid = this.getValidSelection(selected, props);
            // only select valid rows or empty selection
            if (setSelectedRows && (selected.count() === 0 || valid.count() > 0)) {
                setSelectedRows(valid);
            }
        }

        // TODO: shouldComponentUpdate
        componentWillReceiveProps(nextProps) {
            if (nextProps.singleSelection !== this.props.singleSelection) {
                nextProps.setSingleSelectionMode(nextProps.singleSelection);
            }
            if (nextProps.columns !== this.props.columns ||
                nextProps.orderedColumns !== this.props.orderedColumns) {
                this.createSelector(nextProps);
            }
            if (!Immutable.is(nextProps.initSelected, this.props.initSelected)) {
                this.selectRows(nextProps.initSelected || Immutable.OrderedSet(), nextProps);
            } else if (nextProps.selectedRows !== this.props.selectedRows) {
                this.markRows(nextProps);
                if (nextProps.onSelectRows) {
                    nextProps.onSelectRows(nextProps.selectedRows);
                }
            } else if (nextProps.rows !== this.props.rows) {
                this.markRows(nextProps, true);
            }

            if (nextProps.withAllSelector !== this.props.withAllSelector ||
                nextProps.withSelector !== this.props.withSelector ||
                nextProps.singleSelection !== this.props.singleSelection) {
                nextProps.setAllSelector(nextProps.withAllSelector &&
                                         nextProps.withSelector &&
                                         !nextProps.singleSelection);
            }

            // Dispatch navigation-Events
            if (nextProps.navigation !== this.props.navigation && nextProps.navigation) {
                this.dispatchNavigation(nextProps.navigation);
            }
        }

        markRows(props, checkSelection = false) {
            const rowIDs = props.rows.map(row => row.get('id'));
            const selected = props.selectedRows === undefined ?
                Immutable.OrderedSet() :
                props.selectedRows.intersect(rowIDs);

            // If rows have changed we remove selection for missing rows
            if (checkSelection && !Immutable.is(selected, props.selectedRows)) {
                props.setSelectedRows(selected);
            } else {
                props.setRowClassName('selected', selected);
                if (!props.singleSelection) {
                    props.setRowClassName('last-selected', Immutable.OrderedSet([selected.last()]));
                }
            }
        }

        onSelect(row, col, event) {
            const {selectRow} = this.props;
            if (this.getValidSelection(Immutable.OrderedSet([row]), this.props).count() > 0) {
                selectRow(row, col, event.shiftKey, event.ctrlKey);
            }
        }

        render() {
            const {...props} = this.props;
            delete props.singleSelection;
            delete props.withSelector;
            delete props.initSelected;
            delete props.setSingleSelectionMode;
            delete props.setColumns;
            delete props.setOrderedColumns;
            delete props.setSelectedRows;
            delete props.selectRow;
            delete props.selectRows;
            delete props.setRowClassName;
            delete props.columns;
            delete props.orderedColumns;
            delete props.selectedRows;
            delete props.onSelectRows;
            delete props.setAllSelector;
            delete props.withAllSelector;
            return (
                <WrappedTable
                    {...props}
                    onSelectRow={this.onSelect}/>
            );
        }
    }

    Select.propTypes = {
        singleSelection: PropTypes.bool,
        withSelector: PropTypes.bool,
        initSelected: ImmutablePropTypes.orderedSet,
        setSingleSelectionMode: PropTypes.func,
        setColumns: PropTypes.func,
        setOrderedColumns: PropTypes.func,
        setSelectedRows: PropTypes.func,
        selectRow: PropTypes.func,
        selectRows: PropTypes.func,
        setRowClassName: PropTypes.func,
        rows: ImmutablePropTypes.list,
        columns: ImmutablePropTypes.list,
        focusedRow: PropTypes.string,
        orderedColumns: ImmutablePropTypes.orderedSet,
        selectedRows: ImmutablePropTypes.orderedSet,
        onSelectRows: PropTypes.func,
        navigation: ImmutablePropTypes.map,
        withAllSelector: PropTypes.bool,
        setAllSelector: PropTypes.func,
    };

    Select.contextTypes = {
        addShortcut: PropTypes.func,
        removeShortcut: PropTypes.func,
    };

    Select.defaultProps = {
        singleSelection: true,
        withSelector: false,
        withAllSelector: true,
    };

    const mapStateToProps = (state) => ({
        selectedRows: state.selectedRows,
        columns: state.columns,
        orderedColumns: state.orderedColumns,
        focusedRow: state.focusedRow,
        navigation: state.navigation,
    });

    return connect(mapStateToProps,
        {setSelectedRows, setSingleSelectionMode, selectRow, selectRows,
            setOrderedColumns, setColumns, setRowClassName,
            setAllSelector})(Select);
}
