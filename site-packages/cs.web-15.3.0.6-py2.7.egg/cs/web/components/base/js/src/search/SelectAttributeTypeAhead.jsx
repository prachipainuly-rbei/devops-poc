/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: SelectAttributeTypeAhead.jsx 184413 2018-09-26 10:21:39Z cla $"
 */

import React from 'react';
import Immutable from 'immutable';
import {ImmutablePropTypes, PropTypes} from 'cs-web-components-externals';
import {prefixNS, getStandaloneLabel} from '../helpers.js';
import {formatStr} from '../i18n.js';
import TextInput from '../formcontrols/TextInput';
import WithTypeAhead from '../formcontrols/WithTypeAhead';
import {FTS_ATTRNAME} from './constants.js';

const TypeAheadText = WithTypeAhead(TextInput);

function TypeAheadItem(props) {
    const {inputString, item} = props;
    const lower = inputString.toLowerCase();
    const label = getStandaloneLabel(item);
    const additionalInformationHint = item.get('additionalInformationHint', false);
    const hint = additionalInformationHint ? item.get('attribute', '') : '';
    const matchIdx = label.toLowerCase().indexOf(lower);
    const lengthIdx = matchIdx + lower.length;
    return (
        <span className={prefixNS('formcontrols-withtypeahead-menu-item')}>
            {label.substring(0, matchIdx)}
            <b>{label.substring(matchIdx, lengthIdx)}</b>
            {label.substr(lengthIdx)}<br/>
            <i className="text-muted">{hint}</i>
        </span>
    );
}
TypeAheadItem.propTypes = {
    inputString: PropTypes.string.isRequired,
    item: ImmutablePropTypes.map.isRequired
};

export default class SelectAttributeTypeAhead extends React.Component {

    constructor(props) {
        super(props);
        this.state = {
            currInput: "",
            matchFields: Immutable.List(),
            unusedFields: this.getUnusedFields(props)
        };
        this.onTextChanged = this.onTextChanged.bind(this);
        this.onSelectAt = this.onSelectAt.bind(this);
        this.onFocus = this.onFocus.bind(this);
        this.onEnter = this.onEnter.bind(this);
    }

    componentWillReceiveProps(nextProps) {
        if ((this.props.visibleAttributes !== nextProps.visibleAttributes)
            || (this.props.searchValues !== nextProps.searchValues)
            || (this.props.fields !== nextProps.fields))
        {
            this.setState({unusedFields: this.getUnusedFields(nextProps)});
        }
    }

    getUnusedFields(props) {
        const {visibleAttributes, searchValues, fields} = props;
        return visibleAttributes
            .remove(FTS_ATTRNAME)
            .filterNot(attr => searchValues.has(attr))
            .map(attr => fields.get(attr))
            .sortBy(field => field.get('label'))
            .toList();
    }

    getMatchedFields(currInput) {
        const {unusedFields} = this.state;
        const fields = unusedFields.filter(
            f => getStandaloneLabel(f).toLowerCase().indexOf(currInput.toLowerCase()) >= 0);
        return fields.map(
            f => f.set("additionalInformationHint",
                fields.filter(f1 => getStandaloneLabel(f1) === getStandaloneLabel(f)).size > 1));
    }

    onTextChanged(text) {
        const {addSearchField} = this.props;
        const {unusedFields} = this.state;

        if (text === this.state.currInput) {
            return;
        }

        const newField = unusedFields.filter(fld => getStandaloneLabel(fld) === text);
        if (newField.length === 1) {
            this.setState({currInput: ""});
            addSearchField(newField[0].get('attribute'));
        } else {
            this.setState({
                currInput: text,
                matchFields: this.getMatchedFields(text)
            });
        }
    }

    onSelectAt(idx) {
        const {addSearchField} = this.props;
        const hit = this.state.matchFields.get(idx);
        if (hit) {
            this.setState({currInput: ""});
            addSearchField(hit.get('attribute'));
        }
    }

    onEnter() {
        if (this.state.matchFields.size === 1) {
            this.onSelectAt(0);
        }
    }

    onFocus() {
        this.setState({
            matchFields: this.getMatchedFields(this.state.currInput)
        });
    }

    render() {
        const {disabled, beforeControl} = this.props;
        const {unusedFields} = this.state;
        return (
            <div className={prefixNS('class-search-area__attribute-selector-div')}>
                <TypeAheadText className={prefixNS('class-search-area__attribute-selector')}
                    value={this.state.currInput}
                    matched={this.state.matchFields}
                    onValueChange={this.onTextChanged}
                    onEnter={this.onEnter}
                    onSelectAt={this.onSelectAt}
                    beforeControl={beforeControl}
                    disabled={disabled || unusedFields.size === 0}
                    id={`search-attribute-select`}
                    placeholder={formatStr('extended_search_add_attr')}
                    TypeAheadItemRenderer={TypeAheadItem}
                    name="attribute_select"
                    onFocus={this.onFocus}
                    forceOpenMatchesOnFocus={true}/>
            </div>
        );
    }
}

SelectAttributeTypeAhead.propTypes = {
    fields: ImmutablePropTypes.map,
    searchValues: ImmutablePropTypes.map,
    visibleAttributes: ImmutablePropTypes.set,
    addSearchField: PropTypes.func,
    disabled: PropTypes.bool,
    beforeControl: PropTypes.node,
};
