/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: reducers.js 184636 2018-10-01 15:40:38Z eab $"
 */

import Immutable from 'immutable';
import {ACTIONS} from './constants.js';

export function tabsByClass(state = Immutable.Map(), action) {
    switch (action.type) {
        case ACTIONS.LOADED_TABS_FOR_CLASS: {
            const {classname, tabs} = action.payload;
            return state.set(classname, Immutable.fromJS(tabs));
        }
        case ACTIONS.CREATED_TAB_FOR_CLASS: {
            const {classname, tab} = action.payload;
            return state.updateIn([classname], tabs => tabs.push(Immutable.fromJS(tab)));
        }
        case ACTIONS.REMOVE_TAB_FOR_CLASS: {
            const {classname, instanceName} = action.payload;
            return state.updateIn([classname],
                tabs => tabs.filter(tab => tab.get('instanceName') !== instanceName));
        }
        case ACTIONS.REORDER_TABS_FOR_CLASS: {
            const {classname, draggedInstanceName, droppedInstanceName} = action.payload;
            /**
             * In the execution of the reorder tabs, a different behavior is observed when
             * draggedIndex is greater than droppedIndex (i.e dragging right to left) and
             * when draggedIndex is less than droppedIndex (i.e dragging left to right).
             * This behavior is intended with an aim to be consistent with known tabs reordering behavior
             * e.g popular browsers, apps etc.
            */
            const draggedIndex = state.get(classname).findIndex(tab => tab.get('instanceName') === draggedInstanceName);
            const droppedIndex = state.get(classname).findIndex(tab => tab.get('instanceName') === droppedInstanceName);
            return state.updateIn(
                [classname],
                tabs => tabs.splice(draggedIndex, 1)
                            .splice(droppedIndex, 0,
                                tabs.get(draggedIndex))
            );
        }
        case ACTIONS.SET_TAB_NAME: {
            const {classname, instanceName, name} = action.payload;
            if (state.has(classname)) {
                return state.updateIn([classname], tabs => tabs.map(
                    tab => (tab.get('instanceName') === instanceName) ? tab.set('name', name) : tab)
                );
            }
            else {
                return state;
            }
        }
        default:
            return state;
    }
}

export function currentTabByClass(state = Immutable.Map(), action) {
    switch (action.type) {
        case ACTIONS.CREATED_TAB_FOR_CLASS: {
            const {classname, tab} = action.payload;
            return state.set(classname, tab.instanceName);
        }
        case ACTIONS.SET_ACTIVE_TAB: {
            const {classname, instanceName} = action.payload;
            return state.set(classname, instanceName);
        }
        default:
            return state;
    }
}
