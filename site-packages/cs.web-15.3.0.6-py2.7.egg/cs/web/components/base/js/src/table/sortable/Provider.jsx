/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Provider.jsx 158766 2017-05-16 09:37:59Z yzh $"
 */

import React from 'react';
import {PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import connect from '../connect';
import {setSortColumns, setInitSortColumns} from './actions';
import {setTableUserSettings} from '../common/actions';
import {getSortColumns} from './reducers';

// TODO: check column.sortable to disable sorting on columns like selection, icon etc.

const defaultCmp = (a, b) => a[0] === b[0] ? 0 : (a[0] > b[0] ? 1 : -1);

const sorting = (data, {columnIndex, desc, cmp}) =>
    data.sortBy(
        entry => [entry.get('columns').get(columnIndex), entry],
        (a, b) => desc ? -1 * cmp(a, b) : cmp(a, b));

function isInvalid(i) {
    return i === undefined || i === null || Number.isNaN(i);
}

function compareRankings(a, b) {
    const aSize = a.count();
    const bSize = b.count();
    const minSize = Math.min(aSize, bSize);
    for (let i = 0; i < minSize; i++) {
        const x = a.get(i);
        const y = b.get(i);
        if (isInvalid(x)) {
            if (!isInvalid(y)) {
                return -1;
            }
        } else {
            if (isInvalid(y) || x > y) {
                return 1;
            } else if (x < y) {
                return -1;
            }
        }
    }
    // till now it's 0
    if (aSize > bSize) {
        return 1;
    } else {
        return aSize < bSize ? -1 : 0;
    }
}

const rankedSorting = (rows, rankings, {columnIndex, desc, cmp}) =>
    rows.sortBy(
        row => [row.get('columns').get(columnIndex), row],
        (a, b) => {
            const aRank = rankings.map(ranking => ranking[a[1].get('id')]).toList();
            const bRank = rankings.map(ranking => ranking[b[1].get('id')]).toList();
            let result = compareRankings(aRank, bRank);
            if (result === 0) {
                result = cmp(a, b);
                result = desc ? -1 * result : result;
            }
            return result;
        });

const getSortFunction = (colDef) => {
    if (colDef.get("sortFunction")) {
        return colDef.get("sortFunction");
    }
    const renderer = colDef.get('contentRenderer');
    return renderer && renderer.sortFunction ? renderer.sortFunction : defaultCmp;
};

export default function Provider(WrappedTable) {
    class Sort extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                sorted: props.rows
            };
        }

        componentWillMount() {
            this.props.setInitSortColumns(this.props.initSortColumns);
            this.props.setTableUserSettings('sortColumns');
        }

        componentWillReceiveProps(nextProps) {
            if (nextProps.initSortColumns !== this.props.initSortColumns) {
                nextProps.setInitSortColumns(this.props.initSortColumns);
            }

            if (nextProps.sortColumns !== this.props.sortColumns ||
                nextProps.columns !== this.props.columns ||
                nextProps.rows !== this.props.rows) {
                this.sort(nextProps);
            }
        }

        sort(props) {
            const {columns, sortColumns, sortFunctions} = props;
            let sorted = props.rows;
            if (sortColumns.count() > 0) {
                sortColumns.forEach(col => {
                    const columnID = col.get('id');
                    const columnIndex = columns.findIndex(
                        c => c.get('id') === columnID);
                    const colDef = columns.get(columnIndex);
                    const cmp = getSortFunction(colDef);
                    const desc = Boolean(col.get('desc'));
                    const rankings = sortFunctions.map(
                        func => func(sorting, sorted, {columnIndex, desc, cmp})
                    );
                    sorted = rankedSorting(
                        sorted,
                        rankings,
                        {columnIndex, desc, cmp}
                    );
                });

            }
            if (sorted !== this.state.sorted) {
                this.setState({
                    sorted: sorted
                });
            }
        }

        render() {
            const {...others} = this.props;
            delete others.rows;
            delete others.columns;
            delete others.setInitSortColumns;
            delete others.initSortColumns;
            delete others.sortColumns;
            delete others.setSortColumns;
            delete others.setTableUserSettings;
            delete others.sortFunctions;
            return (
                <WrappedTable
                    {...others}
                    rows={this.state.sorted}/>
            );
        }
    }

    Sort.propTypes = {
        initSortColumns: ImmutablePropTypes.orderedSet,
        rows: ImmutablePropTypes.list,
        setSortColumns: PropTypes.func,
        setTableUserSettings: PropTypes.func,
        sortColumns: ImmutablePropTypes.orderedSet,
        columns: ImmutablePropTypes.list,
        setInitSortColumns: PropTypes.func,
        sortFunctions: ImmutablePropTypes.orderedSet
    };

    function mapStateToProps(state) {
        const sortColumns = getSortColumns(state);
        const {columns, sortFunctions} = state;
        return {
            sortColumns, columns, sortFunctions
        };
    }

    return connect(
        mapStateToProps,
        {setInitSortColumns, setSortColumns, setTableUserSettings}
    )(Sort);
}
