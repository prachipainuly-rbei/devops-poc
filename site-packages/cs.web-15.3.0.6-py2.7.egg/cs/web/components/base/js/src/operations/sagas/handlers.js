/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: handlers.js 179122 2018-06-18 09:07:47Z cla $"
 */

import {ReduxSaga, browserHistory} from 'cs-web-components-externals';
import {ACTIONS} from '../constants.js';
import Handlers from '../actions/handlers.js';

import {formatStr} from '../../i18n.js';
import Messages from '../../messages';
import {addHistoryItem} from '../../actions/history-actions.js';
import {receivedObject} from '../../actions/object-actions.js';
import {ResultType} from '../../form/constants.js';
import {Console} from '../../helpers.js';
import {selectState} from '../helpers.js';

const {takeEvery, put, call} = ReduxSaga.effects;

/**
 * @module
 */

/**
 * Invoke a handler action from a handler saga.
 *
 * This is useful, if you, e.g., want to invoke another handler from your own custom
 * handler saga.
 *
 * **Example**:
 *
 * .. code-block:: javascript
 *
 *    import {ReduxSaga} from 'cs-web-components-externals';
 *    import Operations from '../operations';
 *    import {Registry} from '../registry.js';
 *
 *    const {takeEvery} = ReduxSaga.effects;
 *
 *    const CUSTOM_HANDLER_ACTION = "CUSTOM_HANDLER_ACTION";
 *
 *    function *myCustomHandlerSaga(action) {
 *       const {dispatchResultHandler, Handlers} = Operations;
 *       if (resultNeedsSpecialHandling(action)) {
 *          // Your handler code here ...
 *       } else {
 *          // Invoke default handler
 *          yield call(
 *            dispatchResultHandler,
 *            Handlers.updateObjectStore,
 *            action
 *          );
 *       }
 *    }
 *
 *    function *myCustomHandlerWatcher() {
 *       yield takeEvery(CUSTOM_HANDLER_ACTION, myCustomHandlerSaga);
 *    }
 *
 *    Registry.registerSaga(myCustomHandlerWatcher);
 *
 * The custom handler in the example above to handle a result in a
 * custom way, if ``resultNeedsSpecialHandling`` evaluates to true,
 * else it updates the object in the store.
 *
 * @param handler - The action creator to be dispatched.
 * @param action - The action with which the handler saga was invoked.
 */
export function* dispatchResultHandler(handler, action) {
    const handlerAction = handler();
    handlerAction.payload.operation = action.payload.operation;
    yield put(handlerAction);
}

function* handleOperationSuccess(action) {
    const resultType = action.payload.operation.result.result_type;
    switch (resultType) {
        case ResultType.NO_TYPE:
            break;
        case ResultType.OBJECT:
            yield call(dispatchResultHandler, Handlers.updateObjectStore, action);
            break;
        case ResultType.HTML_VIEW:
            yield call(dispatchResultHandler, Handlers.navigate, action);
            break;
        default:
            Console.warn('operations.js: Unhandled result type.');
            break;
    }
}

function* handleUpdateObjectStore(action) {
    const contextObject = action.payload.operation.result.object;
    if (contextObject) {
        yield put(receivedObject(contextObject['@id'], contextObject));
    }
}

function* handleNavigate(action) {
    const path = action.payload.path || action.payload.operation.result.web_ui_link;
    if (path) {
        if (action.payload.options.pushHistory) {
            yield call([browserHistory, browserHistory.push], path);
        } else {
            window.location = path;
        }
    }
}

function* handleAddHistoryItem(action) {
    const contextObject = action.payload.operation.result.object;
    if (contextObject) {
        yield put(addHistoryItem({
            classname: contextObject["system:classname"],
            rest_id: contextObject["system:navigation_id"],
            ref_object_id: contextObject["cdb_object_id"],
        }));
    }
}

function* handlePostMessage(action) {
    const {info, error} = action.payload.operation;
    const name = info.get('name');
    const label = info.get('label');

    // We try to parse a JSON object as payload
    // If this fails use the exceptions message
    // and info to construct a notification.
    const message = (
        error.json ?
        {
            id: `${name}`,
            level: Messages.Level.ERROR,
            title: formatStr(
                'op_start_failed',
                {opname: `${label}`}
            ),
            message: error.json.detail || error.json.message,
            global: true,
        } : {
            id: `${name}`,
            level: Messages.Level.ERROR,
            title: formatStr(
                'op_start_failed',
                {opname: `${label}`}
            ),
            message: error.message,
            global: true,
        }
    );

    yield put(Messages.Actions.postMessage(
        message,
        Messages.createNotification({timeout: 5000})
    ));
}

function* executeSuccessHandlerFns(action) {
    const state = yield selectState(action.payload.operation.instanceName);
    const onSuccess = state.get('successHandler');
    if (onSuccess) {
        yield call(onSuccess, {operationState: state});
    } else {
        yield call(dispatchResultHandler, Handlers.handleOperationSuccess, action);
    }
}

function* executeFailureHandlerFns(action) {
    const state = yield selectState(action.payload.operation.instanceName);
    const onFailure = state.get('failureHandler');
    if (onFailure) {
        yield call(onFailure, {operationState: state});
    } else {
        yield call(dispatchResultHandler, Handlers.postError, action);
    }
}

export default function* setupSagas() {
    yield takeEvery(ACTIONS.HANDLE_OPERATION_SUCCESS, handleOperationSuccess);
    yield takeEvery(ACTIONS.POST_ERROR, handlePostMessage);
    yield takeEvery(ACTIONS.NAVIGATE, handleNavigate);
    yield takeEvery(ACTIONS.ADD_HISTORY_ITEM, handleAddHistoryItem);
    yield takeEvery(ACTIONS.UPDATE_OBJECT_STORE, handleUpdateObjectStore);
    yield takeEvery(ACTIONS.EXECUTE_SUCCESS_HANDLER_FNS, executeSuccessHandlerFns);
    yield takeEvery(ACTIONS.EXECUTE_FAILURE_HANDLER_FNS, executeFailureHandlerFns);
}
