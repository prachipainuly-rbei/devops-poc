/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: ClassView.jsx 183693 2018-09-11 12:59:45Z gwe $"
 */

import React from 'react';
import {
    PropTypes, connect, ImmutablePropTypes, ReactRouter
} from 'cs-web-components-externals';
import {prefixNS, parseQuery} from '../helpers.js';
import {removeNotificationNow} from '../actions/notification.js';
import {WithOperationHandler} from '../form/containers/OperationHandler.jsx';
import ConfiguredForm from '../form/containers/ConfiguredForm.jsx';
import ClassApplicationBar from './ClassApplicationBar.jsx';
import SearchTabs from './SearchTabs.jsx';
import {getClassViewSetup, getClassOpInfo} from './helpers.js';
import Operations from '../operations';
import {NOTIFICATION_ID} from './constants.js';
import {handleSubmit} from './actions.js';
import {setSearchContext} from '../search/actions';
import {CONTEXT} from '../search/constants.js';

class ClassView extends React.Component {
    constructor(props) {
        super(props);
        this.runOperation = this.runOperation.bind(this);
        this.rootClassname = getClassViewSetup().get('rootClassname');
        this.classTitle = getClassViewSetup().getIn(['classInfos', this.rootClassname, 'title']);
    }

    componentDidMount() {
        const {setSearchContext} = this.props;
        setSearchContext({[CONTEXT.UPDATE_LOCATION_ALLOWED]: true});
        this.startOperation(this.props);
    }

    componentWillReceiveProps(nextProps) {
        this.startOperation(nextProps, this.props);
        this.removeNotification(nextProps, this.props);
    }

    removeNotification(nextProps, thisProps) {
        // Remove last create notification if it is still
        // displayed and a new operation is started
        if (nextProps.isOperationRunning &&
            !thisProps.isOperationRunning) {
            this.props.removeNotificationNow(NOTIFICATION_ID);
        }
    }

    startOperation(props, oldProps) {
        const query = parseQuery(props.location);
        const oldQuery = oldProps ? parseQuery(oldProps.location) : {};
        if (query.action && query.action !== oldQuery.action && !props.isInstanceActive) {
            // This component triggers operation by navigation,
            // but operation is not started, call startOperation.
            const opInfo = getClassOpInfo(query.cdb_class, query.action);
            this.runOperation(opInfo);
        }
        else if (query.action !== oldQuery.action && props.isInstanceActive) {
            // Another trigger has initiated an operation here.
            // Adjust URL accordingly

            // TODO broken when navigating directly to URL.

            const currentOperation = props.operationState.get('info');
            const opInfo = getClassOpInfo(
                currentOperation.get('classname'), currentOperation.get('opname'));
            const newURL = Object.assign({
                pathname: props.location.pathname,
                search: '',
                hash: ''
            }, opInfo.get('uiLink').toJS());
            this.props.history.push(newURL);
        }
    }

    runOperation(operationInfo, operationParameters) {
        this.props.runOperation(
            operationInfo,
            Object.assign(
                {
                    successActions: [
                        Operations.Handlers.updateObjectStore(),
                        Operations.Handlers.addObjectToHistory(),
                        handleSubmit(),
                    ],
                    generalActions: [
                        Operations.Handlers.navigate(
                            this.getSearchLocation(),
                            {pushHistory: true}
                        ),
                    ]
                },
                operationParameters,
            ),
        );
    }

    getSearchLocation() {
        return {pathname: this.props.location.pathname};
    }

    render() {
        const toolbarElement =
            this.props.toolbarComponent ?
            React.cloneElement(
                this.props.toolbarComponent,
                {
                    key: 'class-view:toolbar-component',
                    runOperation: this.runOperation,
                    isOperationRunning: this.props.isOperationRunning,
                }
            ) : undefined;
        const containerClass =
            this.props.operationState.get('displayForm') ?
            "" : prefixNS('class-view');
        return (
            <div className={containerClass}>
                <ClassApplicationBar
                    additionalElement={toolbarElement}
                    isInstanceRunning={this.props.isInstanceRunning} />
                {this.props.operationState.get('displayForm') ?
                    <ConfiguredForm {...this.props} />
                    : <SearchTabs
                            rootClassname={this.rootClassname}
                            classTitle={this.classTitle}
                            detail={this.props.detail}
                            childConfiguration={this.props.childConfiguration}
                        />}
            </div>
        );
    }
}

ClassView.propTypes = {
    operationInstance: PropTypes.string,
    runOperation: PropTypes.func.isRequired,
    detail: PropTypes.element,
    removeNotificationNow: PropTypes.func,
    continueOperation: PropTypes.func,
    onFailure: PropTypes.func,
    isInstanceActive: PropTypes.bool,
    isInstanceRunning: PropTypes.bool,
    operationState: ImmutablePropTypes.map,
    childConfiguration: PropTypes.object,
    toolbarComponent: PropTypes.element,
    isOperationRunning: PropTypes.bool,
    // store
    setSearchContext: PropTypes.func.isRequired,
    // injected by ReactRouter.withRouter
    location: PropTypes.object.isRequired,
    history: PropTypes.object.isRequired
};

export const ClassViewRaw = ReactRouter.withRouter(
    connect(undefined, {removeNotificationNow, setSearchContext})(ClassView));

export default WithOperationHandler(ClassViewRaw, 'editor');
