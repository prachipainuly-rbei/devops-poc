/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: WithOperations.jsx 184661 2018-10-02 12:30:47Z cla $"
 */

import React from 'react';
import Immutable from 'immutable';
import {PropTypes, connect, ImmutablePropTypes} from 'cs-web-components-externals';
import {
    OPERATION_ACTIVATION_MODES,
    ActivationModeType
} from '../constants.js';
import {
    fetchOperationContext, fetchOperationInfo
} from '../actions/operations.js';

/**
 * This module provides the ``WithOperations`` Higher Order Component. This HOC
 * provides the wrapped component with an operations property that
 * contains a set of operations, selected by WithOperations based on its parameters.
 *
 * .. note::
 *
 *    Operations must be Web-UI enabled, or they will be filtered out of the list,
 *    before passing it to the wrapped component. Operations which are not Web-UI
 *    enabled can be recognized by inspecting the payload of the fetch call.
 *    The field ``submitURL`` will be undefined for this operation.
 *
 * Operations can be restricted by either giving an operation context name, or a
 * list of operation names (or both). The signature of WithOperations is as follows:
 *
 * .. code-block:: none
 *
 *    WithOperations(
 *      Component: Component,
 *      {
 *        contextType: String,
 *        operationContextName: String,
 *        operationNames: [String]
 *      }
 *    ):Component
 *
 * The structure of the args-parameter is as follows:
 *
 * - contextType: type of the object, if not specified the components
 *   contextObjects will be used to determine the object
 * - operationContextName: string
 * - operationNames: array
 *
 * The parameters ``operationNames`` and ``operationContextName`` specify the method
 * of how to determine the set of operations provided to the wrapped component and
 * should be considered mutually exclusive.
 *
 * Operations always belong to an object class. This class is either given directly
 * as the parameter ``contextType`` to ``WithOperations``, or -- if no ``contextType``
 * is specified -- the component will use the base class of the provided
 * ``contextObjects`` as the class for which to request operations.
 *
 * .. note::
 *
 *    The context type of the objects or classes for which operations should be
 *    fetched must be available for this component to work. If you use objects
 *    without :ref:`cs-web-components-base-actions.object-actions.fetchObject`,
 *    you should use
 *    :ref:`cs-web-components-base-actions.object-actions.fetchType` to fetch
 *    relevant type information.
 *
 * The set of operations provided to the wrapped component is determined either by
 * providing argument ``operationContextName`` or ``operationNames``. If an operation
 * context is specified, all operations listed in the context will be passed to the
 * wrapped component, if a list of operations is specified, these operations will be
 * passed.
 *
 * React Properties passed to the wrapped component
 * ------------------------------------------------
 *
 * +------------------+------------------------+----------------------------------------------+
 * | Property         | Type                   |  Use                                         |
 * +==================+========================+==============================================+
 * | operations       | Immutable.List(opInfo) | The operations requested from the backend    |
 * +------------------+------------------------+----------------------------------------------+
 *
 * React Properties of the wrapping component
 * ------------------------------------------
 *
 * +------------------+------------------+--------------+-----------------------------------------------+
 * | Property         | Type             | Default      | Use                                           |
 * +==================+==================+==============+===============================================+
 * | contextObject    | Immutable.Map    | \-           | For a single select operation on the provided |
 * |                  |                  |              | object.                                       |
 * +------------------+------------------+--------------+-----------------------------------------------+
 * | contextObjects   | Immutable.List(  | \-           | For a multi select operation on the selected  |
 * |                  |   contextObject) |              | objects.                                      |
 * +------------------+------------------+--------------+-----------------------------------------------+
 *
 * Note that contextObject and contextObjects are mutually exclusive, and none should be provided if a
 * ``contextType`` is specified.
 *
 * Example
 * -------
 *
 * .. code-block:: none
 *
 *    const MyOperationList = WithOperations(
 *      props => {
 *        return (
 *          <ul>
 *            props.operations.map(opInfo => (<li>opInfo.get('label')</li>))
 *          </ul>
 *        );
 *      },
 *      ['CDB_ShowObject', 'CDB_Modify', 'CDB_Workflow']
 *    );
 *
 * @module WithOperations
 */

/**
 * Basis of the implementation of WithOperations.
 * Fetches the operation infos requested by the properties, and supplies them
 * to its child components. This component also handles the logic for multi-
 * select operations: if more than one contextObject is given, only those
 * operations that are valid for all objects are provided to the child.
 *
 * Properties:
 *    contextType: CE class for which operations are to be fetched, if no
 *                 contextObjects are given.
 *    contextObjects: an Immutable.List of CE REST object, for which the operations
 *                    are valid
 *    operationContextName: if defined, fetches only operation infos configured
 *                          in the operation context
 *    operationNames: restrict the operations infos provided to the client to
 *                    the ones named here
 *
 * Implemented using the "Function as Child Components" pattern.
 *
 * @private
 */
class _OpInfoWrapper extends React.Component {

    /*
     * Returns an Immutable.Set of class names for which operations should be
     * fetched. It uses ``contextObjects`` to extract the classes from actually
     * relevant objects, and adds ``contextType`` as well as all the base classes
     * of that set.
     */
    getClassNamesToFetch(props) {
        const {contextType, contextObjects, typesById} = props;
        let classnames = (contextObjects === undefined) ?
            Immutable.Set()
            : contextObjects.map(o => o.get('system:classname')).toSet();
        if (contextType !== undefined) {
            classnames = classnames.add(contextType);
        }
        // add all the base classes
        return typesById
            .valueSeq()
            .filter(t => classnames.includes(t.get('name')))
            .map(t => t.get('base_classes').map(b => b.get('name')).toSet())
            .reduce(
                (cns1, cns2) => cns1.union(cns2),
                classnames
        );
    }

    fetchOpInfos(props) {
        const {operationContextName, fetchOperationInfo, fetchOperationContext} = props;
        this.getClassNamesToFetch(props).forEach(cn => {
            // Always trigger the fetch... actions, if the operation infos are
            // already in the store, the action will not fetch again from the
            // backend.
            if (operationContextName === undefined) {
                fetchOperationInfo(cn);
            }
            else {
                fetchOperationContext(cn, operationContextName);
            }
        });
    }

    componentDidMount() {
        this.fetchOpInfos(this.props);
    }

    componentWillReceiveProps(nextProps) {
        const oldCn = this.getClassNamesToFetch(this.props);
        const newCn = this.getClassNamesToFetch(nextProps);
        if (!Immutable.is(newCn, oldCn)
            || (this.props.typesById !== nextProps.typesById)
            || (this.props.operationContextName !== nextProps.operationContextName))
        {
            this.fetchOpInfos(nextProps);
        }
    }

    /*
     * Returns an Immutable.Set of class names that are relevant for the the
     * operations that the child component receives.
     */
    classNamesForChild(props) {
        const {contextType, contextObjects} = props;
        if (contextObjects !== undefined) {
            const result = contextObjects.map(o => o.get('system:classname')).toSet();
            if (result.size > 0) {
                return result;
            }
        }
        if (contextType !== undefined) {
            return Immutable.Set([contextType]);
        }
        else {
            return Immutable.Set();
        }
    }

    /*
     * Return the classname of the most derived common base class of all classes
     * in ``classnames``. Assumes that the @type info is loaded together with the
     * objects in the store.
     */
    commonBaseClass(classnames) {
        if (classnames.size === 1) {
            return classnames.first();
        }

        const baseChain = this.props.typesById
            .valueSeq()
            .filter(t => classnames.includes(t.get('name')))
            // build a set of classname lists, each list a class chain from root
            // to name in ``classnames``.
            .map(t => t.get('base_classes').map(b => b.get('name')).push(t.get('name')))
            // reduce to common prefix
            .reduce((cns1, cns2) => cns1.takeWhile((cn, idx) => cns2.get(idx) === cn));
        // last entry is the most derived one; may be undefined if no common
        // base class exists
        return (baseChain === undefined) ? undefined : baseChain.last();
    }

    isOperationRelevant(op) {
        const {contextType, contextObjects, activationModes} = this.props;
        // helper constants for operation filters: if multiple objects are selected,
        // no single select ops can be used. Class ops only if an explicit
        // contextType is provided.
        const activation_mode = op.get('activation_mode');
        if (activationModes) {
            return this.props.activationModes.includes(activation_mode);
        }

        const isSingleSelect = contextObjects.size === 1;
        const isMultiSelect = contextObjects.size > 1;
        const useClassOps = contextType !== undefined;

        if (isMultiSelect
            && activation_mode === OPERATION_ACTIVATION_MODES.MULTIPLE_SELECTION)
        {
            return true;
        }
        if (isSingleSelect
            && (activation_mode === OPERATION_ACTIVATION_MODES.SINGLE_SELECTION
                || activation_mode === OPERATION_ACTIVATION_MODES.MULTIPLE_SELECTION))
        {
            return true;
        }
        if (useClassOps
            && (activation_mode === OPERATION_ACTIVATION_MODES.NO_SELECTION
                || activation_mode === OPERATION_ACTIVATION_MODES.EVERYTIME))
        {
            return true;
        }
        return false;
    }

    /*
     * Return the operation names that are valid for all the given classes
     */
    commonOperationNames(classnames) {
        const {operationContextName, operationsById, operationContextById} = this.props;
        const opNamesForClassname = (operationContextName === undefined) ?
            cn => operationsById.getIn([cn, 'operations'], Immutable.Map()).keySeq().toSet()
            : cn => operationContextById.getIn([cn, operationContextName], Immutable.Set());
        return classnames
            .map(cn => opNamesForClassname(cn)
                    .map(opName => operationsById.getIn([cn, 'operations', opName]))
                    .filter(op => op !== undefined)
                    .filter(op => (op.get('target_url') || op.get('submit_url')))
                    .map(op => op.get('opname')))
            .reduce((ops1, ops2) => ops1.intersect(ops2));
    }

    /*
     * Return a list of operations, that are valid for all contextObjects. If no
     * contextObjects are given, use the contextType.
     */
    getOperations(classnames, base) {
        const {operationNames, operationsById} = this.props;
        // Determine opnames that are valid for all the classes, and then filter
        // the list down to those defined for the common base class.
        // THINKABOUT: this logic already exists somewhere in the BE or native
        // client - better to reuse it, and accept the cost of an additional
        // round trip??
        const opNames = Immutable.Set(operationNames);
        return this.commonOperationNames(classnames)
            .filter(opName => opNames.size === 0 || opNames.includes(opName))
            .map(opName => operationsById.getIn([base, 'operations', opName]))
            .filter(op => op !== undefined)
            .filter(op => op.get('submit_url') || op.get('target_url'))
            .filter(op => this.isOperationRelevant(op))
            .toList();
    }

    render() {
        const {operationsById} = this.props;
        const classnames = this.classNamesForChild(this.props);
        // Find the common base class, that is the class we want to take the
        // operation infos from.
        const base = this.commonBaseClass(classnames);
        if (base === undefined) {
            // this means no common base class
            return Immutable.List();
        }

        return (
            this.props.children(
                this.getOperations(classnames, base),
                operationsById.getIn([base, 'fetchedAll'], false),
            )
        );
    }
}
_OpInfoWrapper.propTypes = {
    contextType: PropTypes.string,
    contextObjects: ImmutablePropTypes.list,
    operationContextName: PropTypes.string,
    operationNames: PropTypes.arrayOf(PropTypes.string),
    activationModes: ActivationModeType,
    fetchOperationInfo: PropTypes.func.isRequired,
    fetchOperationContext: PropTypes.func.isRequired,
    operationsById: ImmutablePropTypes.map.isRequired,
    operationContextById: ImmutablePropTypes.map.isRequired,
    typesById: ImmutablePropTypes.map.isRequired
};

function mapStateToProps(state) {
    return {
        operationsById: state.operationsById,
        operationContextById: state.operationContextById,
        typesById: state.typesById
    };
}

export const OpInfoWrapper = connect(
    mapStateToProps, {fetchOperationInfo, fetchOperationContext})(_OpInfoWrapper);

/**
 * Implementation of the ``WithOperations`` HOC.
 */
export function WithOperations(Component, {contextType, operationContextName, operationNames}) {
    const WrappedComponent = props => {
        const contextObjects = props.contextObjects ||
                               (props.contextObject ?
                                Immutable.List([props.contextObject]) :
                                Immutable.List());
        const wrapperProps = Object.assign(
            {},
            props,
            (contextType === undefined) ? {} : {contextType},
            (operationContextName === undefined) ? {} : {operationContextName},
            {contextObjects, operationNames});
        return (
            <OpInfoWrapper {...wrapperProps}>
                {(opInfos, operationsFetched) =>
                    <Component {...props}
                               operations={opInfos}
                               operationsFetched={operationsFetched} />}
            </OpInfoWrapper>
        );
    };
    WrappedComponent.propTypes = {
        contextObject: ImmutablePropTypes.map,
        contextObjects: ImmutablePropTypes.list
    };
    WrappedComponent.displayName = 'WithOperations';
    return WrappedComponent;
}
