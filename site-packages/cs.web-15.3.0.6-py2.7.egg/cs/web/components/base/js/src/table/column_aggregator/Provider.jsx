/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Provider.jsx 181707 2018-08-06 13:50:17Z mbr $"
 */

import React from 'react';
import Immutable from 'immutable';
import {PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import connect from '../connect.js';
import {ColumnAggregatorRowID, ColumnAggregatorClass} from '../constants.js';
import {floatToDisplayFormat, intToDisplayFormat} from '../../helpers';

export default function(WrappedTable) {
    class ColumnAggregator extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                rows: props.rows
            };
        }

        componentDidMount() {
            this.computeAggregates(this.props);
        }

        componentWillReceiveProps(nextProps) {
            if (nextProps.columnAggregator !== this.props.columnAggregator ||
                nextProps.columns !== this.props.columns ||
                nextProps.rows !== this.props.rows)
            {
                this.computeAggregates(nextProps);
            }
        }

        computeAggregates(props) {
            const {rows, columns, columnAggregator} = props;
            if (!columnAggregator) {
                this.setState({rows: rows});
            }
            else {
                const aggregateRow = [];
                columns.forEach((col, colIdx) => {
                    let aggregateValue = null;
                    const aggregateType = columnAggregator.aggregationTypes[col.get('attribute')];
                    if (aggregateType !== undefined) {
                        const values =
                            rows.map(row => row.get('columns'))
                                .filter(rowData => (rowData !== undefined))
                                .map(rowData => rowData.get(colIdx))
                                .filter(val => (val !== null && val !== undefined));
                        switch (aggregateType) {
                            case 'count': {
                                const count = intToDisplayFormat(values.size);
                                aggregateValue = `# ${count}`;
                                break;
                            }
                            case 'sum': {
                                const sum = floatToDisplayFormat(
                                    values.reduce((acc, val) => acc + val, 0));
                                aggregateValue = `\u2211 ${sum}`;
                                break;
                            }
                            case 'avg':
                                if (values.size > 0) {
                                    const avg = floatToDisplayFormat(
                                      values.reduce((acc, val) => acc + val, 0) / values.size);
                                    aggregateValue = `\u2300 ${avg}`;
                                }
                                else {
                                    aggregateValue = '\u2300 -';
                                }
                                break;
                        }
                    }
                    aggregateRow.push({text: aggregateValue});
                });
                const insertPos = (columnAggregator.top) ? 0 : rows.size;
                this.setState({
                    rows: rows.insert(
                        insertPos,
                        Immutable.fromJS({
                            id: ColumnAggregatorRowID,
                            columns: aggregateRow,
                            className: ColumnAggregatorClass,
                            functionalRow: true
                        }))
                });
            }
        }

        render() {
            const {...others} = this.props;
            const selectableRowIDs = this.props.selectableRowIDs ?
              this.props.selectableRowIDs : others.rows.map(r => r.get('id'));
            delete others.dispatch;
            delete others.rows;
            delete others.columns;
            delete others.columnAggregatorTypes;
            return (
                <WrappedTable
                    {...others}
                    rows={this.state.rows}
                    selectableRowIDs={selectableRowIDs}/>
            );
        }
    }

    ColumnAggregator.propTypes = {
        rows: ImmutablePropTypes.list,
        selectableRowIDs: ImmutablePropTypes.list,
        columns: ImmutablePropTypes.list,
        columnAggregator: PropTypes.object
    };

    const mapStateToProps = (state) => ({
        columns: state.columns
    });
    return connect(mapStateToProps)(ColumnAggregator);
}
