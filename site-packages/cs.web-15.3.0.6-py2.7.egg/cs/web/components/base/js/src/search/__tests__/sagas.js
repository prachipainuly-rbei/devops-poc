/*
 * Copyright (C) 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: sagas.js 179648 2018-06-27 12:08:28Z mbr $"
 */

/* eslint-env jest */

import Immutable from 'immutable';
import * as matchers from 'jest-immutable-matchers';
import {ReduxSaga} from 'cs-web-components-externals';
import {ACTIONS} from '../constants.js';
import {
    changeFieldsFromDialog, changeFieldsFromSearchBar, runSearch
} from '../sagas/instances.js';

const {call, put, select} = ReduxSaga.effects;

const instanceName = 'some-random string';
const classname = 'someClassname';
const searchOp = {
    fields: {
        fld1: {attribute: 'fld1', label: 'fld1'},
        fld2: {attribute: 'fld2', label: 'fld2'},
        fld3: {attribute: 'fld3', label: 'fld3'}
    },
    visibleAttributes: Immutable.OrderedSet(['fld1', 'fld2', 'fld3']),
    hiddenAttributes: [],
    writeableAttributes: ['fld1', 'fld2', 'fld3'],
    readOnlyAttributes: [],
    defaultValues: {},
    fixedValues: {},
    implicitValues: {}
};
const instance = {
    classname,
    searchValues: {},
    attributeOrder: []
};
const initialState = {
    search: {
        instances: Immutable.fromJS({[instanceName]: instance}),
        operationByClass: Immutable.fromJS({[classname]: searchOp})
    }
};

const stateWithField2Set = {
    search: {
        instances: initialState.search.instances.mergeIn([instanceName, 'searchValues'], {
            fld2: 'value2'
        }),
        operationByClass: initialState.search.operationByClass
    }
};

describe('The setSearchFieldsFromDialog saga', () => {
    beforeEach(() => {
        jest.addMatchers(matchers);
    });

    it('should add new values to the search', () => {
        const action = {
            type: ACTIONS.CHANGE_FIELDS_FROM_DIALOG,
            payload: {instanceName, fields: Immutable.Map({fld2: 'value2'})}
        };
        const generator = changeFieldsFromDialog(action);
        expect(generator.next().value).toEqual(select());
        expect(generator.next(initialState).value).toEqual(put.resolve({
            type: ACTIONS.SET_SEARCH_FIELDS,
            payload: {
                instanceName,
                searchValues: Immutable.Map({fld2: 'value2'}),
                attributeOrder: Immutable.List(['fld2'])
            }
        }));
    });

    it('should overwrite values', () => {
        const action = {
            type: ACTIONS.CHANGE_FIELDS_FROM_DIALOG,
            payload: {instanceName, fields: Immutable.Map({fld2: 'newValue'})}
        };
        const generator = changeFieldsFromDialog(action);
        expect(generator.next().value).toEqual(select());
        expect(generator.next(stateWithField2Set).value).toEqual(put.resolve({
            type: ACTIONS.SET_SEARCH_FIELDS,
            payload: {
                instanceName,
                searchValues: Immutable.Map({fld2: 'newValue'}),
                attributeOrder: Immutable.List(['fld2'])
            }
        }));
    });

    it('should remove empty values', () => {
        const action = {
            type: ACTIONS.CHANGE_FIELDS_FROM_DIALOG,
            payload: {instanceName, fields: Immutable.Map({fld1: 'value1', fld2: ''})}
        };
        const generator = changeFieldsFromDialog(action);
        expect(generator.next().value).toEqual(select());
        expect(generator.next(stateWithField2Set).value).toEqual(put.resolve({
            type: ACTIONS.SET_SEARCH_FIELDS,
            payload: {
                instanceName,
                searchValues: Immutable.Map({fld1: 'value1'}),
                attributeOrder: Immutable.List(['fld1'])
            }
        }));
    });

    it('should order the fields as given in the form', () => {
        const action = {
            type: ACTIONS.CHANGE_FIELDS_FROM_DIALOG,
            payload: {instanceName, fields: Immutable.Map({
                fld3: 'value3', fld2: 'value2', fld1: 'value1'})}
        };
        const generator = changeFieldsFromDialog(action);
        expect(generator.next().value).toEqual(select());

        const effect = generator.next(stateWithField2Set).value;
        expect(effect.PUT.action.payload.searchValues).toEqualImmutable(
            Immutable.Map({fld1: 'value1', fld2: 'value2', fld3: 'value3'})
        );
        expect(effect.PUT.action.payload.attributeOrder).toEqualImmutable(
            Immutable.List(['fld1', 'fld2', 'fld3'])
        );
    });

    it('should run the search after setting the search values', () => {
        const action = {
            type: ACTIONS.CHANGE_FIELDS_FROM_DIALOG,
            payload: {instanceName, fields: Immutable.Map({fld2: 'value2'})}
        };
        const generator = changeFieldsFromDialog(action);
        generator.next();
        expect(generator.next(initialState).value.PUT.resolve).toBe(true);
        expect(generator.next().value).toEqual(call(runSearch, {payload: action.payload}));
    });

});

const stateWithField2_3Set = {
    search: {
        instances: initialState.search.instances.mergeIn([instanceName, 'searchValues'], {
            fld2: 'value2', fld3: 'value3'
        }),
        operationByClass: initialState.search.operationByClass
    }
};

describe('The setSearchFieldsFromSearchBar saga', () => {
    beforeEach(() => {
        jest.addMatchers(matchers);
    });

    it('should add new values to the search', () => {
        const action = {
            type: ACTIONS.CHANGE_FIELDS_FROM_SEARCHBAR,
            payload: {instanceName, fields: Immutable.Map({fld2: 'value2'}), attr: 'fld2'}
        };
        const generator = changeFieldsFromSearchBar(action);
        expect(generator.next().value).toEqual(select());
        expect(generator.next(initialState).value).toEqual(put.resolve({
            type: ACTIONS.SET_SEARCH_FIELDS,
            payload: {
                instanceName,
                searchValues: Immutable.Map({fld2: 'value2'}),
                attributeOrder: Immutable.List(['fld2'])
            }
        }));
    });

    it('should overwrite values', () => {
        const action = {
            type: ACTIONS.CHANGE_FIELDS_FROM_SEARCHBAR,
            payload: {instanceName, fields: Immutable.Map({fld2: 'newValue'}), attr: 'fld2'}
        };
        const generator = changeFieldsFromSearchBar(action);
        expect(generator.next().value).toEqual(select());
        expect(generator.next(stateWithField2Set).value).toEqual(put.resolve({
            type: ACTIONS.SET_SEARCH_FIELDS,
            payload: {
                instanceName,
                searchValues: Immutable.Map({fld2: 'newValue'}),
                attributeOrder: Immutable.List(['fld2'])
            }
        }));
    });

    it('should remove empty values', () => {
        const action = {
            type: ACTIONS.CHANGE_FIELDS_FROM_SEARCHBAR,
            payload: {instanceName, fields: Immutable.Map({fld1: 'value1', fld2: ''}), attr: 'fld1'}
        };
        const generator = changeFieldsFromSearchBar(action);
        expect(generator.next().value).toEqual(select());
        expect(generator.next(stateWithField2Set).value).toEqual(put.resolve({
            type: ACTIONS.SET_SEARCH_FIELDS,
            payload: {
                instanceName,
                searchValues: Immutable.Map({fld1: 'value1'}),
                attributeOrder: Immutable.List(['fld1'])
            }
        }));
    });

    it('should remove empty values, but not the attr value', () => {
        const action = {
            type: ACTIONS.CHANGE_FIELDS_FROM_SEARCHBAR,
            payload: {instanceName, fields: Immutable.Map({fld1: 'value1', fld2: '', fld3: ''}), attr: 'fld3'}
        };
        const generator = changeFieldsFromSearchBar(action);
        expect(generator.next().value).toEqual(select());
        expect(generator.next(stateWithField2_3Set).value).toEqual(put.resolve({
            type: ACTIONS.SET_SEARCH_FIELDS,
            payload: {
                instanceName,
                searchValues: Immutable.Map({fld1: 'value1', fld3: ''}),
                attributeOrder: Immutable.List(['fld1', 'fld3'])
            }
        }));
    });

});
