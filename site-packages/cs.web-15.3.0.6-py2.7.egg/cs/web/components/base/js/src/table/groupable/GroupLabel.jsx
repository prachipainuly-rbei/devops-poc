/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: GroupLabel.jsx 161953 2017-07-20 12:55:37Z yzh $"
 */

import React from 'react';
import {PropTypes, ImmutablePropTypes, classNames, ReactDnD} from 'cs-web-components-externals';
import {Label} from 'react-bootstrap';
import {prefixNS} from '../../helpers';
import connect from '../connect';
import {getGroupColumns} from './reducers';
import {setGroupColumns} from './actions';

const LABELTYPE = prefixNS('table-group-label-type');

const groupLabelSource = {
    beginDrag(props) {
        const {column} = props;
        return {
            columnID: column.get('id')
        };
    }
};

function collectSource(connect, monitor) {
    return {
        connectDragSource: connect.dragSource(),
        isDragging: monitor.isDragging()
    };
}

const groupLabelTarget = {
    canDrop(props, monitor) {
        const {column} = props;
        const item = monitor.getItem();
        return item.columnID !== column.get('id');
    },

    drop(props, monitor) {
        const {column, groupColumns, setGroupColumns} = props;
        const columnID = column.get('id');
        const draggedColumn = monitor.getItem().columnID;
        if (groupColumns &&
            groupColumns.contains(columnID) &&
            groupColumns.contains(draggedColumn)) {
            const removed = groupColumns.delete(draggedColumn).toList();
            const order = removed.indexOf(columnID);
            const newOrder = removed.insert(order, draggedColumn).toOrderedSet();
            if (!newOrder.equals(groupColumns)) {
                setGroupColumns(newOrder);
            }
        }
        return {};
    }
};

function collectTarget(connect) {
    return {
        connectDropTarget: connect.dropTarget()
    };
}

export class GroupLabel extends React.Component {
    constructor(props) {
        super(props);
        this.removeGroup = this.removeGroup.bind(this);
    }

    removeGroup() {
        const {column, groupColumns, setGroupColumns} = this.props;
        const columnID = column.get('id');
        if (groupColumns.contains(columnID)) {
            setGroupColumns(groupColumns.delete(columnID));
        }
    }

    render() {
        const {connectDragSource, connectDropTarget, isDragging, column} = this.props;
        const labelClass = classNames(
            prefixNS('table-group-label'),
            {
                'is-dragging': isDragging
            }
        );
        return connectDragSource(connectDropTarget(
            <div className={labelClass}>
                <Label>
                    {column.get('label')}
                    <span
                        className={prefixNS('table-group-label-remover')}
                        onClick={this.removeGroup}>&times;</span>
                </Label>
            </div>
        ));
    }
}

GroupLabel.propTypes = {
    column: ImmutablePropTypes.map,
    isDragging: PropTypes.bool,
    connectDragSource: PropTypes.func,
    connectDropTarget: PropTypes.func,
    setGroupColumns: PropTypes.func,
    groupColumns: ImmutablePropTypes.orderedSet
};

function mapStateToProps(state) {
    const {columns} = state;
    return {
        columns,
        groupColumns: getGroupColumns(state)
    };
}

export default connect(mapStateToProps, {setGroupColumns})(
    ReactDnD.DropTarget(LABELTYPE, groupLabelTarget, collectTarget)(
        ReactDnD.DragSource(LABELTYPE, groupLabelSource, collectSource)(GroupLabel)));
