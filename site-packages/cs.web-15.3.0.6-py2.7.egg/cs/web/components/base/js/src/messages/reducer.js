/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: reducer.js 168767 2017-11-17 15:25:10Z gwe $"
 */

import Immutable from 'immutable';
import {
    MSG_SRV_FETCH, MSG_POST, MSG_UPDATE_DISPLAY_INFO,
    MSG_REMOVE_FROM_OWNER, MSG_REMOVE_FROM_DISPLAY
} from './actions.js';
import {Global} from './index.js';

const MAX_GLOBAL_MESSAGES = 20;

const DEFAULT_STATE = Immutable.fromJS({
    server: {messages: []},
    messagesById: {},           // This has a maximum number of messages
    messagesByOwner: {},        // Removed when owner is unmounted/owner discards them
    messagesByDisplay: {}       // These are handled by the responsible display
});

export default function messages(state = DEFAULT_STATE, action) {
    switch (action.type) {
        case MSG_SRV_FETCH:
            return state.setIn(['server', 'messages'],
                               action.payload.messages);
        case MSG_POST: {
            if (state.getIn(['messagesById', action.payload])) {
                return state;
            }

            const messageWithDisplayInfos = action.payload;
            const message = messageWithDisplayInfos.delete('displayInfos');
            const messageId = message.get('id');
            const global = message.get('global') !== Global.NONE;
            const owner = message.get('owner');

            // Create an entry for each displayInfo, we assume that for each DisplayId
            // at most one entry exists. The structure of the resulting object is:
            // {displayId => messageId => {message, displayInfo}}
            const getDisplayEntry = displayId => ({
                [displayId]: {[messageId]: {
                    message,
                    displayInfo: messageWithDisplayInfos.getIn(['displayInfos', displayId])
                }}
            });
            const messagesByDisplay = Object.assign({},
                ...(messageWithDisplayInfos.get('displayInfos').keySeq()
                                           .map(getDisplayEntry)).toJS()
            );

            // Create a new state by merging the message into the appropriate fields
            const newState = state.mergeDeep(Immutable.fromJS({
                messagesByDisplay,
                messagesById: global ? {[messageId]: message} : {},
                messagesByOwner: owner ? {[owner]: {[messageId]: message}} : {}
            }));

            // Check if messagesById exceeds MAX_GLOBAL_MESSAGES and delete oldest
            if (newState.get('messagesById').size > MAX_GLOBAL_MESSAGES) {
                const oldestId = newState.get('messagesById')
                                         .minBy(msg => msg.get('ts'))
                                         .get('id');
                if (oldestId) {
                    return newState.deleteIn(['messagesById', oldestId]);
                }
            }

            return newState;
        }
        case MSG_UPDATE_DISPLAY_INFO: {
            const path = [
                'messagesByDisplay', action.payload.displayId,
                action.payload.messageId, 'displayInfo'];
            if (state.hasIn(path)) {
                return state.mergeIn(path, action.payload.displayInfo);
            }
            break;
        }
        case MSG_REMOVE_FROM_OWNER:
            return state.deleteIn([
                'messagesByOwner', action.payload.owner, action.payload.messageId]);
        case MSG_REMOVE_FROM_DISPLAY:
            return state.deleteIn([
                'messagesByDisplay', action.payload.displayId, action.payload.messageId]);
    }
    return state;
}

export function getMessagesForOwner(state, owner) {
    return state.messages.getIn(['messagesByOwner', owner],
                                Immutable.Map());
}

export function getMessagesForDisplay(state, displayId) {
    return state.messages.getIn(['messagesByDisplay', displayId],
                                Immutable.Map());
}
