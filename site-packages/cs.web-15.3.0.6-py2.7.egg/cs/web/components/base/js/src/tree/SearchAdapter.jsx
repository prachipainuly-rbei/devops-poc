
import Immutable from 'immutable';
import {walkTopDownDepthFirst} from './tree-tools.js';

/**
 * The SearchAdapter interface is used as an Interface between the ToolbarSearch
 * widget and arbitrary components that want to support searching. The interface
 * may be used to encapsulate arbitrary search algorithms.
 *
 * The actions provided by the widget are the following (function names in
 * SearchAdapter):
 *
 * - onSendQuery: invoked when a query should be sent. returns a promise on success
 * - nextResult: invoked when next result should be displayed.
 * - previousResult: invoked when previous result should be displayed.
 * - cancelSearch: clear results.
 *
 * The toolbar updates the state of the navigationstate according to the return
 * value of the function, which will be invoked when the promises returned by the
 * interface are resolved:
 *
 * - getNavigationState: returns a JSON object containing boolean values for:
 *
 *   - previousResult
 *   - nextResult
 *
 * TODO use immutable.map for search results
 *
 * @module
 */

export class SearchAdapter {
    constructor(tree, matcher, hideRoot) {
        this.tree = tree;
        this.matcher = matcher;
        this.hideRoot = hideRoot;

        this.getNavigationState = this.getNavigationState.bind(this);
        this.onSendQuery = this.onSendQuery.bind(this);
        this.onPreviousResult = this.onPreviousResult.bind(this);
        this.onNextResult = this.onNextResult.bind(this);
        this.onClearResults = this.onClearResults.bind(this);
        this.isMatch = this.isMatch.bind(this);
    }

    isMatch(node, searchTerm) {
        const matcherResult = this.matcher(node, searchTerm);
        // In addition to the matcher not matching we want to skip a match,
        // if the matching node is the rootNode and the root node is not visible.
        if (matcherResult &&
            (!this.hideRoot ||
             this.tree.getRoot().get('id') !== node.get('id'))) {
            return matcherResult;
        }

        return false;
    }

    getNavigationState() {
        const selected = this.tree.getSelectedSearchResultIndex();
        return {
            previousResult: selected > 0,
            nextResult: selected > -1 && selected < (this.tree.getSearchResultCount() - 1),
            selectedResult: this.tree.getSelectedSearchResultIndex() + 1,
            resultCount: this.tree.getSearchResultCount()
        };
    }

    onPreviousResult() {
        if (this.tree.getSearchResultCount() === 0) {
            return Promise.resolve();
        }

        const nextSearchResult = this.tree.getSelectedSearchResultIndex() - 1;

        return this.tree.setSelectedSearchResultIndex(
            nextSearchResult < 0 ?
            nextSearchResult + this.tree.getSearchResultCount() :
            nextSearchResult
        );
    }

    onNextResult() {
        if (this.tree.getSearchResultCount() === 0) {
            return Promise.resolve();
        }

        return this.tree.setSelectedSearchResultIndex(
            (this.tree.getSelectedSearchResultIndex() + 1) % this.tree.getSearchResultCount());
    }

    onClearResults() {
        this.tree.setSearchResult(Immutable.Map());
    }
}

/**
 * Implements a simple search on a Tree component without using deferred loading.
 * Using this method, the search results are limited to the nodes that have
 * already been loaded.
 */
export class SimpleSearchAdapter extends SearchAdapter {
    onSendQuery(query) {
        const getMatches = () => {
            const gen = walkTopDownDepthFirst(this.tree.getRoot());
            const matches = new Map();
            let child;
            while ((child = gen.next())) {
                if (child.done) {
                    break;
                }
                const match = this.isMatch(child.value, query);
                if (match) {
                    matches.set(child.value.get('id'),
                                match.type ? match : null);
                }
            }
            return matches;
        };

        return this.tree.setSearchResult(getMatches());
    }
}

function backendSearch(tree, isMatch, searchTerm) {
    const searchStack = [tree.getRoot().get('id')];
    let currentFetchPromise = null;

    function _search() {
        // Already running a search
        if (currentFetchPromise) {
            return currentFetchPromise;
        }

        // Searched the whole tree
        if (searchStack.length === 0) {
            return Promise.reject("No child found");
        }

        const nodeId = searchStack.pop();
        const node = tree.getNodeById(nodeId);

        // Need to fetch children
        if (node.get('children').size === 0 && node.get('has_children')) {
            currentFetchPromise =
                tree.fetchNodeChildren(node)
                    .then(() => {
                        const node = tree.getNodeById(nodeId);
                        node.get('children').reverse().forEach(child => {
                            searchStack.push(child.get('id'));
                        });

                        currentFetchPromise = null; // Concurrency?!
                        const matchResult = isMatch(node, searchTerm);
                        if (matchResult) {
                            return {
                                node: node,
                                match: matchResult
                            };
                        } else { // Search recursively for matching node
                            return _search();
                        }
                    });
            return currentFetchPromise;
        }

        // Children already loaded
        else {
            node.get('children').reverse().forEach(child => {
                searchStack.push(child.get('id'));
            });

            const matchResult = isMatch(node, searchTerm);
            if (matchResult) {
                return Promise.resolve({
                    node: node,
                    match: matchResult
                });
            } else {
                return _search();
            }
        }
    }

    return _search;
}

/**
 * Implements a search adapter that uses a backend based search.
 * On querying for the next result, the algorithm starts to load
 * deferred child nodes top down depth first, until it encounters
 * the next match.
 */
export class BackendSearchAdapter extends SearchAdapter {
    /*
     * TODO(cla): Improve search algorithm. Idea/Algorithm:
     * 1. search all already loaded paths from root.
     * 2. on encountering a node whose children need
     *    to be loaded, add it to a list of deferred roots.
     * 3. if all already loaded paths have been search, restart
     *    algorithm for each node in deferred_list.
     */
    constructor(tree, matcher, hideRoot) {
        super(tree, matcher, hideRoot);

        // Backend Search State
        this.activeSearchAlgorithm = null;
        this.activeSearchFinished = false;
    }

    getNavigationState() {
        const navigationState = super.getNavigationState();
        navigationState.nextResult = !this.activeSearchFinished || navigationState.nextResult;
        navigationState.resultCount = this.activeSearchFinished ?
                                      this.tree.getSearchResultCount() :
                                      undefined;
        return navigationState;
    }

    onSendQuery(query) {
        if (this.activeSearchAlgorithm) {
            return undefined;
        }

        this.activeSearchAlgorithm = backendSearch(this.tree, this.isMatch, query);

        return this.onNextResult();
    }

    /* onPreviousResult() {
     *     if (this.activeSearchAlgorithm )
     *         return Promise.resolve();
     * }*/

    onNextResult() {
        const selectedSearchResult = this.tree.getSelectedSearchResultIndex();
        const isLastItem = selectedSearchResult === this.tree.getSearchResultCount() - 1;

        if (isLastItem && !this.activeSearchFinished) {
            return this.activeSearchAlgorithm().then(
                result => this.tree.setSearchResult(
                    this.tree.getSearchResult().set(result.node.get('id'),
                                                    result.match),
                    selectedSearchResult + 1
                ),
                () => {this.activeSearchFinished = true}
            );
        } else {
            return super.onNextResult();
        }
    }

    onClearResults() {
        this.activeSearchAlgorithm = null;
        this.activeSearchFinished = false;

        return super.onClearResults();
    }
}

export default {
    SearchAdapter: SearchAdapter,
    BackendSearchAdapter: BackendSearchAdapter,
    SimpleSearchAdapter: SimpleSearchAdapter
};
