/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: SplitterLayout.jsx 178930 2018-06-14 05:52:08Z cso $"
 */

import React from 'react';
import {prefixNS} from '../helpers';
import {classNames, PropTypes} from 'cs-web-components-externals';

class PrimaryPane extends React.Component {
    render() {
        const {fixSizing, children} = this.props;
        const classes = classNames(
            prefixNS('splitter-layout__pane--primary'),
            prefixNS('splitter-layout__pane')
        );
        return (
            <div className={classes}>
                {fixSizing ?
                    <div className={prefixNS('splitter-layout__pane--fix-size')}>
                        {children}
                    </div> : children
                }
            </div>
        );
    }
}

PrimaryPane.propTypes = {
    fixSizing: PropTypes.bool
};

PrimaryPane.defaultProps = {
    fixSizing: true
};

function ResizerSymbol() {
    return (
        <svg viewBox="0 0 6 6">
            <polygon points="2,3 4,0 4,6" />
        </svg>
    );
}

class Resizer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            resizing: false
        };
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this._clicking = false;
        this._resizing = false;
        this._resizer = null;
        this.startX = undefined;
        this.startY = undefined;
    }

    onMouseDown(event) {
        event.stopPropagation();
        event.preventDefault();

        this._clicking = false;
        if (this.props.resizable || this.props.collapsible) {
            this._clicking = true;
            document.addEventListener('mouseup', this.onMouseUp);
            document.addEventListener('mousemove', this.onMouseMove);
            this.startX = event.clientX;
            this.startY = event.clientY;
        }
    }

    onMouseMove(event) {
        event.stopPropagation();
        event.preventDefault();
        let offsetX = event.clientX - this.startX;  // >0 means rightwards
        let offsetY = event.clientY - this.startY;  // >0 means downwards
        if (offsetX !== 0 || offsetY !== 0) {
            // Clicking and dragging: not to fire a simple click event
            this._resizing = true;
        }
        if (this.props.resizable && this._clicking) {
            this.setState({
                resizing: true
            });
            const style = window.getComputedStyle(this._resizer, null);
            if (parseInt(style.top) < 0) {
                // Resizer is on top border:
                // layout is vertically split
                // and moving upwards is to increase the size
                offsetY = -offsetY;
                offsetX = 0;
            }
            else if (parseInt(style.bottom) < 0) {
                // Resizer is bottom:
                // layout is vertically split
                // and moving downwards is to increase the size
                offsetX = 0;
            }
            else if (parseInt(style.left) < 0) {
                // Resizer is on left border:
                // layout is hotizontally split
                // and moving leftwards is to increase the size
                offsetX = -offsetX;
                offsetY = 0;
            }
            else if (parseInt(style.right) < 0) {
                // Resizer is on right border:
                // layout is hotizontally split
                // and moving rightwards is to increase the size
                offsetY = 0;
            }
            this.startX = event.clientX;
            this.startY = event.clientY;
            if (this.props.onPositionChange) {
                this.props.onPositionChange(offsetX, offsetY);
            }
        }
    }

    onMouseUp(event) {
        event.stopPropagation();
        event.preventDefault();
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
        if (!this._resizing && this.props.collapsible && this.props.onToggle) {
            this.props.onToggle();
        }
        else if (this._resizing && this.props.resizable &&
                 this.props.onPositionChangeEnd) {
            this.props.onPositionChangeEnd();
        }
        this._clicking = false;
        this._resizing = false;
        this.setState({
            resizing: false
        });
        this.startX = undefined;
        this.startY = undefined;
    }

    render() {
        const {resizable, collapsible} = this.props;
        const classes = classNames(
            prefixNS('splitter-layout-splitter'),
            {
                [prefixNS('splitter-layout-splitter--resizable')]: resizable,
                [prefixNS('splitter-layout-splitter--collapsible')]: collapsible,
                [prefixNS('splitter-layout-splitter--resizing')]: this.state.resizing
            }
        );
        return (
            <div className={classes}
                 onMouseDown={this.onMouseDown}
                 ref={c => this._resizer = c}>
                {collapsible ?
                    <ResizerSymbol/> : null
                }
                {resizable ?
                    <div className={prefixNS('splitter-layout-splitter__resizer')}/> : null
                }
                {collapsible && resizable ?
                    <ResizerSymbol /> : null
                }
            </div>
        );
    }
}

Resizer.propTypes = {
    onPositionChange: PropTypes.func,
    onToggle: PropTypes.func,
    onPositionChangeEnd: PropTypes.func,
    resizable: PropTypes.bool,
    collapsible: PropTypes.bool
};

Resizer.defaultProps = {
    resizable: true,
    collapsible: true
};

class SecondaryPane extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            size: props.defaultSize,
            collapsed: props.initCollapsed,
            autoHiding: undefined
        };
        this.resize = this.resize.bind(this);
        this.resizeEnd = this.resizeEnd.bind(this);
        this.toggleCollapsed = this.toggleCollapsed.bind(this);
        this.onChange = this.onChange.bind(this);
        this._pane = null;
        this._autoHiding = undefined;
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.initCollapsed !== this.props.initCollapsed) {
            const collapsed = this.state.collapsed;
            this.setState({
                collapsed: nextProps.initCollapsed
            });
            if (collapsed !== nextProps.initCollapsed) {
                this.onChange(nextProps.initCollapsed, this.state.size);
            }
        }
        if (nextProps.defaultSize !== this.props.defaultSize) {
            this.setState({
                size: nextProps.defaultSize
            });
        }
    }

    resize(offsetX, offsetY) {
        let newSize;
        let expanding = false;
        if (offsetX !== 0) {
            // layout is hotizontally split
            newSize = this._pane.clientWidth + offsetX;
            expanding = offsetX > 0;
        } else if (offsetY !== 0) {
            newSize = this._pane.clientHeight + offsetY;
            expanding = offsetY > 0;
        }
        if (newSize !== undefined) {
            const {hidingBreakPoint} = this.props;
            if (hidingBreakPoint && newSize < hidingBreakPoint) {
                this._autoHiding = expanding ? 'expanding' : 'hiding';
            } else {
                this._autoHiding = undefined;
            }
            this.setState({
                size: `${newSize}px`,
                collapsed: false,
                autoHiding: this._autoHiding
            });
        }
    }

    resizeEnd() {
        let {collapsed, size} = this.state;
        if (this._autoHiding) {
            this._autoHiding = undefined;
            collapsed = true;
            size = `${this.props.hidingBreakPoint}px`;
            this.setState({
                collapsed,
                size,
                autoHiding: this._autoHiding
            });
        }
        this.onChange(collapsed, size);
    }

    toggleCollapsed() {
        const collapsed = !this.state.collapsed;
        this.setState({collapsed});
        this.onChange(collapsed, this.state.size);
    }

    onChange(collapsed, size) {
        const {onChange} = this.props;
        if (onChange) {
            onChange({collapsed, size});
        }
    }

    render() {
        const {resizable, collapsible, fixSizing, children} = this.props;
        const {size, collapsed, autoHiding} = this.state;
        const classes = classNames(
            this.props.className,
            prefixNS('splitter-layout__pane--secondary'),
            prefixNS('splitter-layout__pane'),
            {
                [prefixNS('splitter-layout__pane--collapsed')]: collapsed,
                [prefixNS('splitter-layout__pane--hiding')]: Boolean(autoHiding),
                [prefixNS('splitter-layout__pane--collapsing')]: autoHiding === 'hiding'
            }
        );
        const styles = size === undefined || collapsed ?
            undefined : {flexBasis: size};
        let content = null;
        if (!autoHiding) {
            if (fixSizing) {
                content = (
                    <div className={prefixNS('splitter-layout__pane--fix-size')}>
                        {children}
                    </div>
                );
            } else {
                content = children;
            }
        }
        return (
            <div className={classes}
                 style={styles}
                 ref={c => this._pane = c}>
                {content}
                {resizable || collapsible ?
                    <Resizer onPositionChange={this.resize}
                             onToggle={this.toggleCollapsed}
                             onPositionChangeEnd={this.resizeEnd}
                             resizable={resizable}
                             collapsible={collapsible}/> : null
                }
            </div>
        );
    }
}

SecondaryPane.propTypes = {
    className: PropTypes.string,
    resizable: PropTypes.bool,
    collapsible: PropTypes.bool,
    defaultSize: PropTypes.string,
    // fixSizing: whether to ensure that content fills out the pane area
    fixSizing: PropTypes.bool,
    // the minimal size to trigger hiding automatically
    hidingBreakPoint: PropTypes.number,
    initCollapsed: PropTypes.bool,
    onChange: PropTypes.func
};

SecondaryPane.defaultProps = {
    resizable: true,
    collapsible: true,
    defaultSize: '10rem',
    fixSizing: true,
    initCollapsed: false
};

/**
 * This component serves as a container for horizontally or vertically split panes.
 *
 * There are 2 types of panes: primary and secondary panes.
 * Primary panes are automatically resized if the container size gets changed, while
 * secondary panes keep their sizes. Secondary panes can have a splitter bar to
 * allow resizing(by dragging) and collapsing(by clicking) manually.
 *
 * Examples
 * --------
 *
 * .. code-block:: none
 *
 *    <SplitterLayout>
 *        <SplitterLayout.SecondaryPane>
 *          <div>left pane, resizable, collapsible</div>
 *       </<SplitterLayout.SecondaryPane>>
 *       <SplitterLayout.PrimaryPane>
 *         <div>main area, resized automatically</div>
 *       </SplitterLayout.PrimaryPane>
 *        <SplitterLayout.SecondaryPane>
 *          <div>right pane, resizable, collapsible</div>
 *       </<SplitterLayout.SecondaryPane>>
 *    </SplitterLayout>
 *
 * React Properties
 * ================
 *
 * SplitterLayout
 * --------------
 *
 * +-------------+--------+---------+------------------------------------------------------+
 * | Name        | Type   | Default | Description                                          |
 * +=============+========+=========+======================================================+
 * | vertical    | bool   | false   | Whether the panes are layed out vertically           |
 * +-------------+--------+---------+------------------------------------------------------+
 *
 * SplitterLayout.PrimaryPane
 * --------------------------
 *
 * +-------------+--------+---------+------------------------------------------------------+
 * | Name        | Type   | Default | Description                                          |
 * +=============+========+=========+======================================================+
 * | fixSizing   | bool   | true    | Whether to force the content taking exact size of    |
 * |             |        |         | the pane area (and being cut off by overflow)        |
 * +-------------+--------+---------+------------------------------------------------------+
 *
 * SplitterLayout.SecondaryPane
 * ----------------------------
 *
 * +------------------+--------+---------+------------------------------------------------------+
 * | Name             | Type   | Default | Description                                          |
 * +==================+========+=========+======================================================+
 * | fixSizing        | bool   | true    | Whether to force the content taking exact size of    |
 * |                  |        |         | the pane area (and being cut off by overflow)        |
 * +------------------+--------+---------+------------------------------------------------------+
 * | resizable        | bool   | true    | Whether to allow resizing the pane manually          |
 * +------------------+--------+---------+------------------------------------------------------+
 * | collapsible      | bool   | true    | Whether to allow collapsing the pane manually        |
 * +------------------+--------+---------+------------------------------------------------------+
 * | defaultSize      | string | 10rem   | Default size for the pane                            |
 * +------------------+--------+---------+------------------------------------------------------+
 * | hidingBreakPoint | number | \-      | Size in px, if specified, the pane will be collapsed |
 * |                  |        |         | automatically if its size is less than this value    |
 * +------------------+--------+---------+------------------------------------------------------+
 * | initCollapsed    | bool   | false   | Whether to collapse the pane initially               |
 * +------------------+--------+---------+------------------------------------------------------+
 * | onChange         | func   | \-      | Callback function, which will be called after        |
 * |                  |        |         | resizing or collapsing the pane, with an object      |
 * |                  |        |         | {collapsed, size} as argument                        |
 * +------------------+--------+---------+------------------------------------------------------+
 *
 */
export default class SplitterLayout extends React.Component {
    render() {
        const {vertical} = this.props;
        const classes = classNames(
            prefixNS('splitter-layout'),
            vertical ?
                prefixNS('splitter-layout--vertical') :
                prefixNS('splitter-layout--horizontal')
        );
        return (
            <div className={classes}>
                {this.props.children}
            </div>
        );
    }
}

SplitterLayout.propTypes = {
    vertical: PropTypes.bool
};

SplitterLayout.defaultProps = {
    vertical: false
};

SplitterLayout.PrimaryPane = PrimaryPane;
SplitterLayout.SecondaryPane = SecondaryPane;
