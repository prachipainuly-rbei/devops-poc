///*
// * Copyright (C) 2017 CONTACT Software GmbH
// * All rights reserved.
// * http://www.contact-software.com
// *
// * Revision "$Id: CalendarConverter.js 174476 2018-03-14 16:00:48Z yzh $"
// */

// Converter methods for calendar with expression
// constructor: (backendFormat, frontendFormat, frontendDateOnlyFormat)
// Methods to be implemented:
// convertToValue(display_string): Convert display string to backend string
// convertToDisplay(backend_string): Convert backend string to display string
// checkDisplayValue(display_string): Return true if display string is valid
// convertRangeToValue(dateRange): Return backend string from a DateRange object
// getRangeFromValue(backend_value): Return a DateRange object from backend string
// formatDisplayDate(moment_or_date): Return display string from moment or date object

import moment from 'moment';
import DateRange from './DateRange';

export default class CalendarConverter {
    constructor(backendFormat, frontendFormat, frontendDateOnlyFormat) {
        this.backendFormat = backendFormat;
        this.frontendFormat = frontendFormat;
        this.frontendDateOnlyFormat = frontendDateOnlyFormat;
        this.errors = [];
    }

    checkDisplayValue(displayValue) {
        this.errors = [];
        this.convertToValue(displayValue);
        if (this.errors.length > 0) {
            return false;
        }
        return true;
    }

    convertRangeToValue(dateRange) {
        return '>=' + dateRange.getStart().format(this.backendFormat) +
               ' AND <=' + dateRange.getEnd().format(this.backendFormat);
    }

    convertToValue(inValue) {
        return this._convert(inValue, this.frontendFormat, this.backendFormat);
    }

    convertToDisplay(inValue) {
        return this._convert(inValue, this.backendFormat, this.frontendFormat);
    }

    _convert(value, valueFormat, targetFormat) {
        // like CE-Core BuildStateExpressionParser::convert
        let result = '';
        if (value) {
            let literal = '';
            for (const c of value) {
                if (c === '<' || c === '>' ||
                    c === '=' || c === '!' ||
                    c === '(' || c === ')') {
                    result = result.concat(this._handle_literal(literal,
                                                                valueFormat,
                                                                targetFormat));
                    literal = '';
                    result = result.concat(c);
                } else if (c === ' ' && !literal.length) {
                    // Literale starten nicht mit einem Leerzeichen
                    result = result.concat(c);
                } else {
                    literal = literal.concat(c);
                }
            }
            result = result.concat(this._handle_literal(literal, valueFormat, targetFormat));
        }
        return result;
    }

    _handle_literal(literal, valueFormat, targetFormat) {
        if (literal.trim().length === 0) {
            // Nur Spaces
            return literal;
        }
        const [opIndex, op] = this._find_operator(literal);
        if (opIndex > -1) {
            return this._handle_literal(literal.substr(0, opIndex), valueFormat, targetFormat) +
                op +
                this._handle_literal(literal.substr(opIndex + op.length),
                                     valueFormat, targetFormat);
        }
        const literal_start = this._find_first_not_space(literal);
        if (literal_start === -1) {
            // Nur Spaces
            return literal;
        }
        const literal_end = this._find_last_not_space(literal);
        return literal.substr(0, literal_start) +  // leading spaces
               this._convert_literal(literal.substr(literal_start,
                                    (literal_end - literal_start) + 1), valueFormat, targetFormat) +
                                    literal.substr(literal_end + 1);  // Trailing spaces
    }

    _find_operator(value) {
        const operators = ['and', 'AND', 'or', 'OR'];
        for (const op of operators) {
            const result = value.indexOf(op);
            if (result > -1) {
                return [result, op];
            }
        }
        return [-1, ''];
    }

    _contains_time(moment_value) {
        return !(moment_value.hour() === 0
                && moment_value.minute() === 0
                && moment_value.second() === 0);
    }

    _convert_literal(value, valueFormat, targetFormat) {
        let result = value;
        const valueMoment = moment.parseZone(value, valueFormat);
        if (valueMoment.isValid()) {
            if (this._contains_time(valueMoment)) {
                result = valueMoment.format(targetFormat);
            } else {
                result = valueMoment.format(this._getOnlyDateFromFormat(targetFormat));
            }
        } else {
            this.errors.push("Error format value:" + value + " format:" +
                              (targetFormat ? targetFormat : "ISO_8601"));
        }
        return result;
    }

    _find_first_not_space(value) {
        const temp = value.replace(new RegExp('[^\\s]', 'g'), 'x');
        return temp.indexOf('x');
    }

    _find_last_not_space(value) {
        const temp = value.replace(new RegExp('[^\\s]', 'g'), 'x');
        return temp.lastIndexOf('x');
    }

    _getDateObjectStrict(value, format) {
        const strictFormat = format ? this._getOnlyDateFromFormat(format) : undefined;
        // use parseZone to keep zone information(exists or not) to avoid
        // problem with different zones when converting to Date object
        return moment.parseZone(value, strictFormat, true);
    }

    _getOnlyDateFromFormat(format) {
        if (format) {
            return format.split(' ')[0];
        }
        return 'YYYY-MM-DD'; // ISO_8601
    }

    _normalizeDateOP(dateOP, format) {
        if (dateOP) {
            let mom = this._getDateObjectStrict(dateOP[1], format);
            if (!mom.isValid()) {
                return null;
            }
            let op = dateOP[0];
            if (op === '>' || op === '<') {
                mom = mom.add(op === '>' ? 1 : -1, 'day');
                op += '=';
            }
            return {op, date: mom};
        }
        return null;
    }

    _getDateStrAndOperator(dateString) {
        if (dateString) {
            const dateStart = dateString.search(/\d/);
            if (dateStart !== -1) {
                return [
                    dateString.substring(0, dateStart).trim(),
                    dateString.substring(dateStart).trim()
                ];
            }
        }
        return null;
    }

    getRangeFromValue(value) {
        if (!value) {
            return null;
        }
        const inputDate = this._getDateObjectStrict(value, this.backendFormat);
        if (inputDate.isValid()) {
            return new DateRange(inputDate, inputDate);
        }
        const re = new RegExp('AND', 'gi');
        const matched = value.match(re);
        if (matched && matched.length > 1) {
            // Only ">= start [AND <= end]" formatted value
            // can be convert to DateRange.
            return null;
        }
        const values = value.split(re);
        const beginParsed = this._normalizeDateOP(
            this._getDateStrAndOperator(values[0]), this.backendFormat);
        if (!beginParsed) {
            // value not parsable
            return null;
        }
        if (values.length === 1) {
            if (beginParsed.op === '>=') {
                // >= someDate
                return new DateRange(beginParsed.date, null);
            } else if (beginParsed.op === '<=') {
                return new DateRange(null, beginParsed.date);
            }
            // no parsable
            return null;
        }
        const endParsed = this._normalizeDateOP(
            this._getDateStrAndOperator(values[1]), this.backendFormat);
        if (!endParsed) {
            // value not parsable
            return null;
        }
        if (beginParsed.op === '>=' && endParsed.op === '<=' &&
            beginParsed.date.isSameOrBefore(endParsed.date)) {
            return new DateRange(beginParsed.date, endParsed.date);
        } else if (beginParsed.op === '<=' && endParsed.op === '>=' &&
            beginParsed.date.isSameOrAfter(endParsed.date)) {
            return new DateRange(endParsed.date, beginParsed.date);
        }
        // no regular parsed value
        return null;
    }

    formatDisplayDate(date) {
        const dateMoment = moment(date);
        // specific date only mode
        if (!this._contains_time(dateMoment) && this.frontendDateOnlyFormat !== undefined) {
            return dateMoment.format(this.frontendDateOnlyFormat);
        }
        return dateMoment.format(this.frontendFormat);
    }
}
