/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: ObjectSearch.jsx 184338 2018-09-24 14:22:54Z cla $"
 */

import React from 'react';
import Immutable from 'immutable';
import {PropTypes, ImmutablePropTypes, connect} from 'cs-web-components-externals';
import TextInput from '../../formcontrols/TextInput';
import {getJSON} from '../../fetch';
import {notifyError} from '../../actions/notification.js';
import ObjectSearchTypeAhead from './ObjectSearchTypeAhead';
import Tags from '../Tags';
import Tag from '../Tag';
import {prefixNS, isCEDesktop} from '../../helpers';
import {formatStr} from '../../i18n';
import {initHistoryItems} from '../../actions/history-actions';
import {FavoriteActions} from '../../favorites';
import Tab from '../../layouts/Tab.jsx';
import Overlays from '../../overlays';

const {DropdownTextButton, MenuItem} = Overlays;

/**
 * A component that allows an interactive search in the EnterpriseSearch, history and favorites.
 *
 * React Properties
 * ----------------
 *
 * +-------------------+--------------+---------------------+-----------------------------------------------------+
 * | Property          | Type         | Default             | Use                                                 |
 * +===================+==============+=====================+=====================================================+
 * | value             | string       | ''                  | search value                                        |
 * +-------------------+--------------+---------------------+-----------------------------------------------------+
 * | searchPlaceholder | string       | undefined           | Placeholder text if the search value is empty       |
 * +-------------------+--------------+---------------------+-----------------------------------------------------+
 * | searchClasses     | string-array | undefined           | Predefined search classes                           |
 * +-------------------+--------------+---------------------+-----------------------------------------------------+
 * | excludeClasses    | string-array | undefined           | Classes that should be excluded from search         |
 * +-------------------+--------------+---------------------+-----------------------------------------------------+
 * | hideDefaultTags   | boolean      | false               | Hide predefined search classes tags in search field |
 * +-------------------+--------------+---------------------+-----------------------------------------------------+
 * | onSelectItem      | func         | undefined           | A callback fired when an object from the drop down  |
 * |                   |              |                     | is selected. An object with the rest url, title,    |
 * |                   |              |                     | icon url and search type is passed in               |
 * +-------------------+--------------+---------------------+-----------------------------------------------------+
 *
 * @module
 */

function nameComparator(a, b) {
    // sort favourites by name
    const nameA = a['name'];
    const nameB = b['name'];
    return (nameA < nameB) ? -1 : ((nameA > nameB) ? 1 : 0);
}

function filterItem(item, term, excludeClasses = []) {
    return item.get('title').toLowerCase().indexOf(term) > -1 &&
            excludeClasses.indexOf(item.get('classname')) === -1;
}

const TAB_KEY_ENTERPRISESEARCH = 'es';
const TAB_KEY_HISTORY = 'hi';
const TAB_KEY_FAVORITE = 'fav';

class ObjectSearch extends React.Component {

    constructor(props) {
        super(props);

        this.typeAheadObjectSearch = ObjectSearchTypeAhead(TextInput);
        this.state = {
            searchTerm: props.value ? props.value : "",
            searchResults: [],
            hasMore: false,
            limitedClasses: Immutable.OrderedSet(this.props.searchClasses),
            allowedClasses: null,
            resultClasses: null,
            searchExecuted: false,
            tabkey: TAB_KEY_ENTERPRISESEARCH,
            searchHistoryResults: this.props.historyItems,
            searchHFExecuted: false,
            focused: false,
        };

        this.timeoutID = null;
        this.timeoutIDSelectClasses = null;

        this.onDeleteTag = this.onDeleteTag.bind(this);
        this.onSelectTag = this.onSelectTag.bind(this);
        this.getTitle = this.getTitle.bind(this);
        this.handleSelect = this.handleSelect.bind(this);
        this.onSelectItem = this.onSelectItem.bind(this);
        this.getPlaceholder = this.getPlaceholder.bind(this);

        this.getAllowedClasses();

        props.initHistoryItems();
        props.initFavorites();
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.value !== this.props.value) {
            this.setState({searchTerm: nextProps.value});
        }
    }

    onSelectItem(item) {
        if (this.props.onSelectItem) {
            this.props.onSelectItem(item);
        }
    }

    isHideDefaultTagsActive() {
        return (this.props.hideDefaultTags &&
                Immutable.is(Immutable.OrderedSet(this.props.searchClasses),
                             Immutable.OrderedSet(this.state.limitedClasses)));
    }
    getPlaceholder() {
        if (this.props.searchPlaceholder) {
            return this.props.searchPlaceholder;
        }
        if (this.isHideDefaultTagsActive()
            && this.props.searchClasses
            && this.props.searchClasses.length > 0) {
            const entities = this.props.searchClasses.map(c => this.getTitle(c)).join(', ');
            return formatStr('object_search_placeholder_entity', {entity: entities});
        }
        return formatStr('object_search_placeholder');
    }

    getLimitedClassesWSubClasses() {

        // Add sub classes
        let limitedClassesSet = this.state.limitedClasses
                            .flatMap(l => {return this.state.allowedClasses
                              .filter(ac => ac['classname'] === l)
                                .flatMap(f => f['subClasses']);});
        // Filter predifined, but removed classes
        if (this.props.searchClasses) {
            const removedClasses = Immutable.Set(this.props.searchClasses
                                    .filter(c => !this.state.limitedClasses.has(c)));
            limitedClassesSet = limitedClassesSet.filter(c => !removedClasses.has(c));
        }

        // Only subclasses
        const onlySubClasses = this.state.limitedClasses
                               ? limitedClassesSet.subtract(this.state.limitedClasses)
                               : Immutable.Set();

        // Add parent classes
        limitedClassesSet = limitedClassesSet.union(
                              this.state.limitedClasses
                              ? this.state.limitedClasses
                              : []);
        return [limitedClassesSet, onlySubClasses];
    }

    getAllowedClasses() {
        if (this.timeoutID) {
            clearTimeout(this.timeoutID);
        }
        const {excludeClasses} = this.props;
        const params = excludeClasses ? {exclude_classes: excludeClasses.join()} : null;
        this.timeoutID = setTimeout(() => {
            getJSON("/internal/uisupport/object_search_allowed_classes", params).then((data) => {
                if (data.error) {
                    this.props.notifyError(data.error.statusText, "", data.error.message);
                    this.setState({
                        allowedClasses: null
                    });
                } else {
                    this.setState({
                        allowedClasses: Immutable.Set(data.classes)
                    });
                }
            }).catch((err) => {
                this.props.notifyError(err.response.statusText, "");
            });
        }, 250);
    }

    searchObjectTerm() {
        if (this.timeoutID) {
            clearTimeout(this.timeoutID);
        }
        const {excludeClasses} = this.props;
        const [limitedClassesAndSubclasses] = this.getLimitedClassesWSubClasses();

        const params = {
            fulltextsearch: this.state.searchTerm + '*'
        };
        if (limitedClassesAndSubclasses.size) {
            params.classes = limitedClassesAndSubclasses.join();
        }
        if (excludeClasses) {
            params.exclude_classes = excludeClasses.join();
        }

        this.timeoutID = setTimeout(() => {
            getJSON("/internal/uisupport/object_search", params).then((data) => {
                if (data.error) {
                    this.props.notifyError(data.error.statusText, "", data.error.message);
                    this.setState({
                        searchResults: [],
                        hasMore: false
                    });
                } else if (data.result.no_index_for_class) {
                    this.setState({
                        searchResults: [],
                        hasMore: false,
                        resultClasses: null,
                    });
                } else {
                    const hasMore = !(Object.keys(data.result.paging).length === 0 &&
                    data.result.paging.constructor === Object);
                    const classFromFacets = data.result.facetInfo.filter(f => f['count'] > 0)
                        .map(f => {
                            return {
                                name: f['name'],
                                count: f['count']
                            };
                        })
                        .filter(f => f);
                    const resultClasses = data.result.result.length > 0
                        ? Immutable.OrderedSet(classFromFacets)
                        : null;
                    this.setState({
                        searchResults: data.result.result,
                        hasMore: hasMore,
                        resultClasses,
                        searchExecuted: true,
                    });
                }
            }).catch((err) => {
                this.props.notifyError(err.response.statusText, "");
            });
        }, 250);
    }

    updateSearchTerm(e) {
        const term = e.target.value.trimLeft();
        this.setState({searchTerm: term}, () => {
            if (term !== "") {
                this.searchObjectTerm();
                this.searchHistFavObjectTerm();
            } else {
                this.setState({
                    searchResults: [],
                    hasMore: false,
                    searchExecuted: true,
                    searchHFExecuted: true,
                    searchHistoryResults: this.props.historyItems,
                });
            }
        });
    }

    searchObjectTermAfterClassChanges() {
        if (this.state.tabkey === TAB_KEY_ENTERPRISESEARCH) {
            this.timeoutIDSelectClasses = setTimeout(() => {this.searchObjectTerm()}, 2000);
        }
        else {
            this.timeoutIDSelectClasses = setTimeout(() => {this.searchHistFavObjectTerm()}, 2000);
        }
    }

    onSelectTag(name) {
        this.setInputFocus();
        if (this.timeoutIDSelectClasses) {
            clearTimeout(this.timeoutIDSelectClasses);
        }
        const limitedClasses = this.isHideDefaultTagsActive()
            ? Immutable.OrderedSet([name])
            : this.state.limitedClasses.add(name);
        this.setState({
            limitedClasses: limitedClasses,
            searchExecuted: false,
            searchHFExecuted: false,
        }, () => this.searchObjectTermAfterClassChanges());
    }

    onDeleteTag(name) {
        this.setInputFocus();
        if (this.timeoutIDSelectClasses) {
            clearTimeout(this.timeoutIDSelectClasses);
        }
        let limitedClasses = this.state.limitedClasses.filter(n => n !== name);
        if (this.props.hideDefaultTags &&
            this.props.searchClasses &&
            this.props.searchClasses.length > 0 &&
            limitedClasses.size === 0) {
            limitedClasses = Immutable.OrderedSet(this.props.searchClasses);
        }
        this.setState({
            limitedClasses: limitedClasses,
            searchExecuted: false,
            searchHFExecuted: false,
        }, () => this.searchObjectTermAfterClassChanges());
    }

    getTitle(classname) {
        const ac = this.state.allowedClasses ?
                  this.state.allowedClasses.find(c => c['classname'] === classname) : classname;
        return ac ? ac["name"] ? ac["name"] : classname : classname + '*';
    }

    getParentTitle(classname) {
        const parentClass = this.state.allowedClasses
                              ? this.state.allowedClasses
                                .filter(ac => ac['subClasses'].indexOf(classname) > -1)
                              : null;
        return parentClass.size > 0 ? parentClass.first()["name"] : '*';
    }

    renderAllowedClasses() {
        const all = Immutable.Set(this.state.allowedClasses ?
                        this.state.allowedClasses.filter(c => c['isIndexed'])
                                                 .map(c => c['classname'])
                        : []);
        const allClasses = this.props.searchClasses ?
                              this.props.searchClasses
                              : Immutable.OrderedSet(all.keys()).filter(c => c);
        const tags = Immutable.Set(allClasses
                                   .filter(c => !this.state.limitedClasses.has(c))
                                   .map(c => {return {id: c, name: this.getTitle(c)}}))
                               .sort(nameComparator);
        return (
            <div className={prefixNS('object-search-tags')}>
              {formatStr('object_search_search_for')}
              <Tags tags={tags}
                  onClickTag={this.onSelectTag}/>
              <hr/>
            </div>
        );
    }

    searchHistFavObjectTerm() {
        const [limitedClassesAndSubclasses] = this.getLimitedClassesWSubClasses();
        const {excludeClasses, historyItems, favoriteItems} = this.props;
        const term = this.state.searchTerm.toLowerCase();
        let filterHI = historyItems.filter(
            hi => filterItem(hi, term, excludeClasses));
        let filterFav = favoriteItems.toList().filter(
            fa => filterItem(fa, term, excludeClasses));
        if (limitedClassesAndSubclasses.size > 0) {
            filterHI = filterHI.filter(
                hi => limitedClassesAndSubclasses.has(hi.get('classname')));
            filterFav =
              filterFav.filter(
                  fa => limitedClassesAndSubclasses.has(fa.get('classname')));
        }

        this.setState({
            searchHistoryResults: filterHI,
            searchFavoriteResults: filterFav,
            searchHFExecuted: true
        });
    }

    getSearchExecutedString() {
        if (this.isHideDefaultTagsActive()) {
            const entities = this.props.searchClasses.map(c => this.getTitle(c)).join(', ');
            return formatStr('object_search_narrow_entity', {entity: entities});
        }
        return formatStr('object_search_results_in');
    }

    calcClassesforRender(searchExecuted) {
        const allowAdd = !(this.state.limitedClasses && this.state.limitedClasses.size > 0)
                         || this.isHideDefaultTagsActive()
                         || !searchExecuted;
        const all = Immutable.Set(this.state.allowedClasses ?
                      this.state.allowedClasses.map(c => c['classname'])
                      : []);
        const [limitedClassesAndSubclasses, onlySubClasses] = this.getLimitedClassesWSubClasses();
        const allClasses = this.props.searchClasses ?
                            Immutable.OrderedSet(this.isHideDefaultTagsActive()
                                                 && this.props.searchClasses.size === 1
                                                 ? onlySubClasses
                                                 : limitedClassesAndSubclasses)
                            : Immutable.OrderedSet(all.keys()).filter(c => c);
        return [allClasses, onlySubClasses, allowAdd];
    }

    renderResultClasses() {
        const [allClasses, onlySubClasses, allowAdd]
               = this.calcClassesforRender(this.state.searchExecuted);
        const resultClasses = Immutable.Set(this.state.resultClasses);
        const tags = Immutable.Set(
            resultClasses.filter(c => allClasses.has(c['name']))
                .map(c => {
                    const parentTitle =
                        onlySubClasses.has(c['name']) ? this.getParentTitle(c['name']) + ': ' : '';
                    return {
                        id: c['name'],
                        name: parentTitle + this.getTitle(c['name']) + ' (' + c['count'] + ')'
                    };
                }))
               .sort(nameComparator);
        return (
            <div className={prefixNS('object-search-tags')}>
              {!this.state.searchExecuted ? formatStr('object_search_categories')
                                          : this.getSearchExecutedString()}
              <Tags tags={tags} onClickTag={allowAdd ? this.onSelectTag : null}/>
              <hr/>
            </div>
        );
    }

    renderHiFavClasses(items) {
        const resultClasses = items
              .map(item => {return item.get('classname')}).toSet();
        const [allClasses, onlySubClasses, allowAdd]
                = this.calcClassesforRender(this.state.searchHFExecuted);
        const tags = Immutable.Set(
            resultClasses.filter(c => allClasses.has(c))
                .map(c => {
                    const parentTitle = onlySubClasses.has(c) ? this.getParentTitle(c) + ': ' : '';
                    const itemCount = items.count(item => item.get('classname') === c);
                    return {
                        id: c,
                        name: parentTitle + this.getTitle(c) + ' (' + itemCount + ')'
                    };
                }))
                .sort(nameComparator);
        return (
            <div className={prefixNS('object-search-tags')}>
              {this.getSearchExecutedString()}
              <Tags tags={tags} onClickTag={allowAdd ? this.onSelectTag : null}/>
              <hr/>
            </div>
        );
    }


    // Tags before input field
    renderLimitedClassesTags() {
        if (this.isHideDefaultTagsActive()) {
            return null;
        }
        let allowDelete = true;
        if (this.props.searchClasses &&
            this.props.searchClasses.length > 0 &&
            this.state.limitedClasses.size === 1 &&
            !this.props.hideDefaultTags) {
            allowDelete = false;
        }
        const tags = Immutable.Set(
            this.state.limitedClasses.map(c => (
                <Tag onClickIcon={allowDelete ? this.onDeleteTag : null}
                     id={c} key={c}
                     name={this.getTitle(c)} />
            )));
        if (this.state.limitedClasses.size > 3) {
            return this.createTagsDropDown(tags);
        } else {
            if (tags.size > 0) {
                return tags.toArray();
            } else {
                return null;
            }
        }
    }

    createTagsDropDown(tags) {
        const label = formatStr('object_search_in_categories',
                    {count: String(tags.size)});
        return (<div className={prefixNS('object-search-tag-dropdown-result')}>
            <DropdownTextButton title={label} buttonStyle='Default'
                            className={prefixNS('object-search-tag-dropdown')}>
            {tags.map(c => (
                <MenuItem key={c} header>{c}</MenuItem>))}
            </DropdownTextButton>
        </div>);
    }

    setInputFocus() {
        const searchInput =
            document.querySelector('.' + prefixNS('object-search-input'));
        if (searchInput) {
            searchInput.focus();
        }
        const withtypeahead =
            document.querySelector('.' + prefixNS('object-search-withtypeahead'));
        if (withtypeahead) {
            withtypeahead.classList.add('focus');
        }
    }

    focus(hasFocus) {
        if (hasFocus) {
            this.setInputFocus();
        } else {
            const withtypeahead =
                document.querySelector('.' + prefixNS('object-search-withtypeahead'));
            if (withtypeahead) {
                withtypeahead.classList.remove('focus');
            }
        }
        this.setState({focused: hasFocus});
    }

    handleSelect(selectedKey) {
        this.setInputFocus();
        this.setState({tabkey: selectedKey});
        if (selectedKey === TAB_KEY_ENTERPRISESEARCH) {
            this.searchObjectTerm();
        } else {
            this.searchHistFavObjectTerm();
        }
    }

    getEmptyResult() {
        const a = {};
        a['icon'] = '';
        a['rest_url'] = '';
        a['title'] = formatStr('object_search_no_results');
        return Immutable.List([Immutable.Map(a)]);
    }

    createSearchResults(items, type) {
        if (!items || items.size === 0) {
            return this.getEmptyResult();
        }
        return Immutable.List(items.map(item => {
            const a = {};
            a['searchtype'] = type;
            a['cdb_object_id'] = item.get('ref_object_id');
            a['icon'] = item.get('icon_url');
            a['title'] = item.get('title');
            a['ui_link'] = item.get('frontend_url');
            a['rest_url'] = item.get('rest_url');
            return Immutable.Map(a);}));
    }

    render() {
        const {maxResultItemsCount} = this.props;
        const {searchHistoryResults, searchFavoriteResults, searchResults, tabkey} = this.state;
        const TypeAheadObjectSearch = this.typeAheadObjectSearch;
        const esComponent = this.state.searchTerm
                                    ? this.renderResultClasses()
                                    : this.renderAllowedClasses();

        const historyTab = isCEDesktop() ? null : (
            <Tab.Title
                key={TAB_KEY_HISTORY}
                eventKey={TAB_KEY_HISTORY}
                title={formatStr('object_search_results_history')}
            />
        );
        const favoritesTab = isCEDesktop() ? null : (
            <Tab.Title
                key={TAB_KEY_FAVORITE}
                eventKey={TAB_KEY_FAVORITE}
                title={formatStr('object_search_results_favorites')}
            />
        );
        const leadingComponent = (
            <Tab.Container
                activeKey={tabkey}
                onSelect={this.handleSelect}
                id={prefixNS('object-search-tabs')}
            >
                <Tab.Bar
                    activeKey={tabkey}
                    onSelectFromMenu={this.handleSelect}
                >
                    <Tab.Title
                        key={TAB_KEY_ENTERPRISESEARCH}
                        eventKey={TAB_KEY_ENTERPRISESEARCH}
                        title={formatStr('object_search_results')}
                    />
                    {historyTab}
                    {favoritesTab}
                </Tab.Bar>
                <Tab.Content>
                    {tabkey === TAB_KEY_ENTERPRISESEARCH ? esComponent : null}
                    {tabkey === TAB_KEY_HISTORY ?
                        this.renderHiFavClasses(searchHistoryResults) : null}
                    {tabkey === TAB_KEY_FAVORITE ?
                        this.renderHiFavClasses(searchFavoriteResults) : null}
                </Tab.Content>
            </Tab.Container>
        );
        let searchResultsItems = null;
        let hasMore = false;
        switch (this.state.tabkey) {
            case TAB_KEY_ENTERPRISESEARCH:
                searchResultsItems = Immutable.fromJS(searchResults);
                if (!searchResultsItems || searchResultsItems.size === 0) {
                    searchResultsItems = this.getEmptyResult();
                }
                else {
                    searchResultsItems = searchResultsItems.map(s => {
                        const a = {};
                        a['searchtype'] = 'enterprisesearch';
                        a['cdb_object_id'] = s.get('cdb_object_id');
                        a['icon'] = s.get('icon');
                        a['title'] = s.get('system:description');
                        a['rest_url'] = s.get('rest_url');
                        a['ui_link'] = s.get('ui_link');
                        return Immutable.Map(a);});
                }
                hasMore = this.state.hasMore;
                break;
            case TAB_KEY_HISTORY:
                searchResultsItems = this.createSearchResults(searchHistoryResults, 'history');
                break;
            default:
                searchResultsItems = this.createSearchResults(searchFavoriteResults, 'favorite');
        }
        if (searchResultsItems.size > maxResultItemsCount) {
            searchResultsItems = searchResultsItems.take(maxResultItemsCount);
            hasMore = true;
        }
        const tags = this.renderLimitedClassesTags();
        const typeAhead = (<TypeAheadObjectSearch value={this.state.searchTerm}
                            matched={searchResultsItems}
                            hasMoreMatches={hasMore}
                            id={this.props.id}
                            name={this.props.id}
                            type="text"
                            autoComplete="off"
                            placeholder={this.getPlaceholder()}
                            onChange={(e) => {this.updateSearchTerm(e)}}
                            onSelectItem={this.onSelectItem}
                            leadingComponent={leadingComponent}
                            beforeControl={tags}
                            onFocus={() => {this.focus(true)}}
                            onBlur={() => {this.focus(false)}}
                            className={prefixNS('object-search-input')}/>);
        return (
            <div className={this.props.className}>
                {typeAhead}
            </div>
        );
    }
}

ObjectSearch.defaultProps = {
    searchPlaceholder: "",
    className: prefixNS('object-search'),
    maxResultItemsCount: 10,
    hideDefaultTags: false,
};

ObjectSearch.propTypes = {
    id: PropTypes.string.isRequired,
    searchPlaceholder: PropTypes.string.isRequired,
    className: PropTypes.string.isRequired,
    notifyError: PropTypes.func,
    searchClasses: PropTypes.arrayOf(PropTypes.string),
    excludeClasses: PropTypes.arrayOf(PropTypes.string),
    initHistoryItems: PropTypes.func.isRequired,
    historyItems: ImmutablePropTypes.list.isRequired,
    initFavorites: PropTypes.func,
    favoriteItems: ImmutablePropTypes.map,
    onSelectItem: PropTypes.func,
    value: PropTypes.string,
    maxResultItemsCount: PropTypes.number,
    hideDefaultTags: PropTypes.bool,
};

function mapStateToProps(state) {
    return {
        historyItems: state.historyItems,
        favoriteItems: state.favorites
    };
}

const actions = {
    notifyError, initHistoryItems,
    initFavorites: FavoriteActions.initFavorites
};

export default connect(mapStateToProps, actions)(ObjectSearch);
