/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Table.jsx 184132 2018-09-19 09:18:57Z vov $"
 */

import React from 'react';
import {Table as _Table} from 'react-bootstrap';
import {prefixNS} from '../helpers';
import {getVisibleColumns, getSelectAllRowsEvent, getSelectRangeEvent} from './common/reducers.js';
import {PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import connect from './connect';
import Immutable from 'immutable';
import {setTableUserSettings, setFocusedRow, setFocusedColumn,
        navigate, setSelectedRows, setSelectableRowsAggregationState,
        setRenderDirectives, resetFocusTable} from './common/actions';
import {addLocalShortcuts, removeAllLocalShortcuts} from '../key-handlers.js';
import THead from './THead.jsx';
import TBody from './TBody.jsx';
import TableRow from './TableRow.jsx';

/**
 * Default table component implementation.
 *
 * @memberof module:Table
 * @module
 */

class Table extends React.Component {
    constructor(props) {
        super(props);
        this.rowRefs = {};  // Cache for row visibility, uses DOM
        this.state = {
            columns: props.columns,
            visibleColumns: this.getVisibleColumns(props),
            rowClassName: props.rowClassName
        };
        this.onSelectRow = this.onSelectRow.bind(this);
        this.onFocusPreviousColumn = this.onFocusPreviousColumn.bind(this);
        this.onFocusNextColumn = this.onFocusNextColumn.bind(this);
        this.onFocusPreviousRow = this.onFocusPreviousRow.bind(this);
        this.onFocusNextRow = this.onFocusNextRow.bind(this);
        this.onResetColumnFocus = this.onResetColumnFocus.bind(this);
        this.onExtendSelectionDown = this.onExtendSelectionDown.bind(this);
        this.onExtendSelectionUp = this.onExtendSelectionUp.bind(this);
        this.onMoveSelectionDown = this.onMoveSelectionDown.bind(this);
        this.onMoveSelectionUp = this.onMoveSelectionUp.bind(this);
        this.onToggleSelected = this.onToggleSelected.bind(this);
        this.onAction = this.onAction.bind(this);
    }

    onSelectRow(rowID, colID, event) {
        // We use Shift+Click for range selection, so reset windows text selection.
        // It is not possible to use preventDefault here effectively, as selection
        // may be handled before synthetic event dispatching.
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed && event.shiftKey) {
            selection.removeAllRanges();
        }

        const {onSelectRow} = this.props;
        if (onSelectRow && event.target.tagName !== 'A') {
            onSelectRow(rowID, colID, event);
        }
    }

    componentWillMount() {
        this.props.setTableUserSettings('columnWidths');
        if (this.props.selectableRowIDs) {
            this.setSelectableRowsAggregationState(
              this.props.selectableRowIDs, this.props.selectedRows);
        } else {
            this.setSelectableRowsAggregationState(
              this.props.rows.map(r => r.get('id')), this.props.selectedRows);
        }
        this.props.setRenderDirectives(this.props.renderDirectives);
    }

    componentDidMount() {
        addLocalShortcuts(
            this.tableRef,
            [
                ['Control+ArrowUp', this.onFocusPreviousRow],
                ['Control+ArrowDown', this.onFocusNextRow],
                ['Control+ArrowLeft', this.onFocusPreviousColumn],
                ['Control+ArrowRight', this.onFocusNextColumn],
                ['Shift+ArrowUp', this.onExtendSelectionUp],
                ['Shift+ArrowDown', this.onExtendSelectionDown],
                ['ArrowUp', this.onMoveSelectionUp],
                ['ArrowDown', this.onMoveSelectionDown],
                ['Spacebar', this.onToggleSelected],
                ['Escape', this.onResetColumnFocus],
                ['Enter', this.onAction],
            ]
        );
    }

    componentWillUnmount() {
        removeAllLocalShortcuts(this.tableRef);
    }

    componentWillReceiveProps(nextProps) {
        const newState = {};
        if (nextProps.columns !== this.props.columns) {
            newState.columns = nextProps.columns;
        }
        if (nextProps.visibleColumns !== this.props.visibleColumns ||
            nextProps.onlyShowColumns !== this.props.onlyShowColumns) {
            newState.visibleColumns = this.getVisibleColumns(nextProps);
        }
        if (nextProps.hiddenRows !== this.props.hiddenRows ||
            nextProps.rowClassName !== this.props.rowClassName) {
            newState.rowClassName = nextProps.rowClassName.has('hide') ?
                nextProps.rowClassName.mergeIn(['hide'], nextProps.hiddenRows) :
                nextProps.rowClassName.set('hide', nextProps.hiddenRows);
        }
        // TODO: maybe only setState if anything changes to avoid rerenderings
        if (newState) {
            this.setState(newState);
        }

        // If rows are rendered set initial focus on first row
        if (nextProps.focusedRow === null && nextProps.rows.size > 0) {
            this.props.setFocusedRow(nextProps.rows.getIn([0, 'id']));
        }

        if (nextProps.isFocusOnTable === true &&
            this.props.isFocusOnTable !== nextProps.isFocusOnTable) {
            this.props.setFocusedRow(nextProps.rows.getIn([0, 'id']));
            const firstRow = nextProps.rows.getIn([0, 'id']);
            this.props.setFocusedRow(firstRow);
            this.props.setSelectedRows(Immutable.OrderedSet([firstRow]));
            this.tableRef.focus();
            this.props.resetFocusTable();
        }

        if (nextProps.selectAllRowsEvent !== this.props.selectAllRowsEvent) {
            const rowIds = nextProps.selectableRowIDs ?
             nextProps.selectableRowIDs : nextProps.rows.map(r => r.get('id'));
            if (nextProps.selectAllRowsEvent.get("selectAll")) {
                nextProps.setSelectedRows(
                  nextProps.selectedRows.union(Immutable.OrderedSet(rowIds)));
            } else {
                nextProps.setSelectedRows(nextProps.selectedRows.subtract(rowIds));
            }
        }

        if (nextProps.selectRangeEvent !== this.props.selectRangeEvent) {
            this.selectRange(nextProps.selectRangeEvent, nextProps);
        }

        if (nextProps.selectableRowIDs) {
            if (nextProps.selectableRowIDs !== this.props.selectableRowIDs ||
              nextProps.selectedRows !== this.props.selectedRows) {
                this.setSelectableRowsAggregationState(
                  nextProps.selectableRowIDs, nextProps.selectedRows);
            }
        } else {
            if (nextProps.rows !== this.props.rows ||
              nextProps.selectedRows !== this.props.selectedRows) {
                this.setSelectableRowsAggregationState(
                  nextProps.rows.map(r => r.get('id')), nextProps.selectedRows);
            }
        }

        if (nextProps.renderDirectives !== this.props.renderDirectives) {
            nextProps.setRenderDirectives(nextProps.renderDirectives);
        }
    }

    selectRange(range, props) {
        const rowIds = props.selectableRowIDs ?
          props.selectableRowIDs : props.rows.map(r => r.get('id'));
        const from = rowIds.indexOf(range['from']);
        const to = rowIds.indexOf(range['to']);
        const include = range['include'];
        if (from > -1 && to > -1) {
            props.setSelectedRows(include
                  ? props.selectedRows.union(
                    rowIds.slice(Math.min(from, to), Math.max(from, to) + 1))
                  : Immutable.OrderedSet(
                    rowIds.slice(Math.min(from, to), Math.max(from, to) + 1)),
                  range['to']);
        }
    }

    setSelectableRowsAggregationState(rowIDs, selectedRows) {
        let result = 0;
        if (rowIDs.size) {
            const checked = Immutable.Set(rowIDs).subtract(selectedRows);
            if (checked.size === 0) {result = 1}
            else if (checked.size < rowIDs.size) {result = 2}
        } else {
            result = 3;
        }
        this.props.setSelectableRowsAggregationState(result);
    }

    setRowRef(rowId, element) {
        if (element) {
            this.rowRefs[rowId] = {
                'element': element,
                'visible': undefined,
            };
        } else {
            delete this.rowRefs[rowId];
        }
    }

    _isRowVisible(rowId) {
        if (!this.rowRefs[rowId]) {
            return false;
        }

        if (this.rowRefs[rowId]['visible'] === undefined) {
            const element = this.rowRefs[rowId]['element'];
            this.rowRefs[rowId]['visible'] = element.offsetParent !== null;
        }

        return this.rowRefs[rowId]['visible'];
    }

    _getVisibleRowsByInspection() {
        return this.props.rows.filter(r => this._isRowVisible(r.get('id')));
    }

    _getNextRow(offset) {
        const visibleRows = this._getVisibleRowsByInspection();
        const uncappedIndex =
            visibleRows.findIndex(r => r.get('id') === this.props.focusedRow) + offset;
        const index = Math.min(Math.max(0, uncappedIndex), visibleRows.size - 1);
        return visibleRows.getIn([index, 'id']);
    }

    _getNextColumn(offset) {
        const columns = this.state.visibleColumns.toList();
        const index =
            (((columns.findIndex(c => c === this.props.focusedColumn) + 1) +
             (columns.size + 1) +
             offset)
                % (columns.size + 1));
        return index === 0 ? null : columns.get(index - 1);
    }

    onAction() {
        if (this.props.focusedRow !== null) {
            const focusedRow = this.props.rows.find(r => r.get('id') === this.props.focusedRow);

            if (!focusedRow) {
                return;
            }

            if (this.props.focusedColumn !== null) {
                // Column Action
                const focusedColumnIndex = this.state.columns.findIndex(
                    c => c.get('id') === this.props.focusedColumn);

                if (focusedColumnIndex === -1) {
                    return;
                }

                const focusedColumn = this.state.columns.get(focusedColumnIndex);
                const action = focusedColumn.get('action');
                const getLink = focusedColumn.get('getLink');
                if (action) {
                    // Custom action has been set for column
                    action(focusedRow.getIn(['columns', focusedColumnIndex]),
                           focusedRow,
                           focusedColumn);
                } else if (getLink) {
                    // Follow provided link as default action
                    const link = getLink(focusedRow.getIn(['columns', focusedColumnIndex]),
                                         focusedRow,
                                         focusedColumn);
                    if (link) {
                        window.location = link;
                    }
                }
            } else if (this.props.rowAction) {
                // Row Action
                this.props.rowAction(focusedRow);
            }
        }
    }

    onFocusPreviousRow() {
        this.props.setFocusedRow(this._getNextRow(-1));
    }

    onFocusNextRow() {
        this.props.setFocusedRow(this._getNextRow(+1));
    }

    onFocusPreviousColumn() {
        this.props.setFocusedColumn(this._getNextColumn(-1));
    }

    onFocusNextColumn() {
        this.props.setFocusedColumn(this._getNextColumn(+1));
    }

    onResetColumnFocus() {
        this.props.setFocusedColumn(null);
    }

    _getSelectionInterval(from, to) {
        const {rows} = this.props;
        const idx1 = rows.findIndex(row => row.get('id') === from);
        const idx2 = rows.findIndex(row => row.get('id') === to);
        return (idx1 < idx2 ?
                rows.slice(idx1, idx2 + 1) :
                rows.slice(idx2, idx1 + 1).reverse()).map(r => r.get('id'))
                                                     .filter(r => this._isRowVisible(r));
    }

    onExtendSelectionUp() {
        const nextRow = this._getNextRow(-1);
        let selectionAnchor = this.props.selectionAnchor;
        if (!selectionAnchor || !this._isRowVisible(selectionAnchor)) {
            selectionAnchor = this.props.focusedRow || nextRow;
        }
        const rows = this._getSelectionInterval(selectionAnchor, nextRow);
        this.props.navigate(Immutable.Map({
            rowIds: rows,
            focusedRow: nextRow,
            extend: false,
            selectionAnchor
        }));
    }

    onExtendSelectionDown() {
        const nextRow = this._getNextRow(+1);
        let selectionAnchor = this.props.selectionAnchor;
        if (!selectionAnchor || !this._isRowVisible(selectionAnchor)) {
            selectionAnchor = this.props.focusedRow || nextRow;
        }
        const rows = this._getSelectionInterval(selectionAnchor, nextRow);
        this.props.navigate(Immutable.Map({
            rowIds: rows,
            focusedRow: nextRow,
            extend: false,
            selectionAnchor
        }));
    }

    onMoveSelectionUp() {
        const nextRow = this._getNextRow(-1);
        this.props.navigate(Immutable.fromJS({
            rowIds: [nextRow],
            focusedRow: nextRow,
            extend: false,
            selectionAnchor: nextRow,
        }));
    }

    onMoveSelectionDown() {
        const nextRow = this._getNextRow(+1);
        this.props.navigate(Immutable.fromJS({
            rowIds: [nextRow],
            focusedRow: nextRow,
            extend: false,
            selectionAnchor: nextRow,
        }));
    }

    onToggleSelected() {
        this.props.navigate(Immutable.fromJS({
            rowIds: [this.props.focusedRow],
            focusedRow: this.props.focusedRow,
            extend: true,
            selectionAnchor: this.props.focusedRow,
        }));
    }

    getVisibleColumns(props) {
        const {visibleColumns, onlyShowColumns} = props;
        return onlyShowColumns > 0 ? visibleColumns.take(onlyShowColumns) : visibleColumns;
    }

    render() {
        const {
            rows, height, columnActions, TableHeadComponent,
            TableBodyComponent, id, columnWidths, condensed,
            focusedRow, focusedColumn,
            columnRenderers, hover, ...others
        } = this.props;
        [
            'columns', 'visibleColumns', 'orderedColumns', 'hiddenColumns', 'unhidableColumns',
            'setTableUserSettings', 'onSelectRow', 'setFocusedRow', 'setFocusedColumn',
            'selectionAnchor', 'store', 'rowAction', 'rowClassName', 'hiddenRows',
            'columnAggregator', 'onlyShowColumns', 'dispatch', 'navigate', 'navigation',
            'selectAllRowsEvent', 'setSelectedRows', 'selectableRowIDs',
            'setSelectableRowsAggregationState', 'selectedRows', 'onSelectRows',
            'initFilter', 'initSelected', 'selectRangeEvent', 'setRenderDirectives',
            'renderDirectives', 'isFocusOnTable', 'resetFocusTable'
        ].forEach(propname => {
            delete others[propname];
        });
        const {columns, visibleColumns, rowClassName} = this.state;
        return (
            <div ref={c => {this.tableRef = c}}
                 tabIndex={0}
                 className={prefixNS('table')}
                 style={{height: height}}
                 id={id}>
                <_Table bordered striped condensed={condensed} {...others}>
                    <TableHeadComponent
                        {...{columns, visibleColumns, columnActions, columnWidths}}
                        className={prefixNS('tabel-header')}/>
                    <TableBodyComponent className={prefixNS('tabel-body')}>
                        {rows.map((row, idx) =>
                            <TableRow
                                key={String(idx)}
                                contentRef={elem => this.setRowRef(row.get('id'), elem)}
                                {...{
                                    focusedRow,
                                    focusedColumn,
                                    row,
                                    columns,
                                    visibleColumns,
                                    rowClassName,
                                    columnRenderers
                                }}
                                onClick={this.onSelectRow}
                                hover={hover}/>
                        )}
                    </TableBodyComponent>
                </_Table>
            </div>
        );
    }
}

Table.propTypes = {
    id: PropTypes.string,
    height: PropTypes.number,
    condensed: PropTypes.bool,
    onSelectRow: PropTypes.func,
    rows: ImmutablePropTypes.list,
    hiddenRows: ImmutablePropTypes.set,
    columns: ImmutablePropTypes.list,
    orderedColumns: ImmutablePropTypes.orderedSet,
    hiddenColumns: ImmutablePropTypes.set,
    unhidableColumns: ImmutablePropTypes.set,
    columnActions: ImmutablePropTypes.list,
    columnWidths: ImmutablePropTypes.map,
    setFocusedRow: PropTypes.func,
    setFocusedColumn: PropTypes.func,
    selectionAnchor: PropTypes.string,
    focusedRow: PropTypes.string,
    focusedColumn: PropTypes.string,
    visibleColumns: ImmutablePropTypes.orderedSet,
    rowAction: PropTypes.func,
    navigate: PropTypes.func,
    rowClassName: ImmutablePropTypes.map,
    TableHeadComponent: PropTypes.oneOfType([
        PropTypes.element, PropTypes.func]),
    TableBodyComponent: PropTypes.oneOfType([
        PropTypes.element, PropTypes.func]),
    setTableUserSettings: PropTypes.func,
    columnRenderers: ImmutablePropTypes.map,
    // Internal usage only(e.g. fixed columns):
    // just show the given numbers of columns from left hand side.
    onlyShowColumns: PropTypes.number,
    hover: PropTypes.bool,
    selectableRowIDs: ImmutablePropTypes.list,
    setSelectedRows: PropTypes.func,
    selectAllRowsEvent: ImmutablePropTypes.map,
    selectRangeEvent: PropTypes.object,
    setSelectableRowsAggregationState: PropTypes.func,
    selectedRows: ImmutablePropTypes.orderedSet,
    renderDirectives: PropTypes.object,
    setRenderDirectives: PropTypes.func,
    isFocusOnTable: PropTypes.bool,
    resetFocusTable: PropTypes.func
};

Table.defaultProps = {
    columns: Immutable.List(),
    orderedColumns: Immutable.OrderedSet(),
    hiddenRows: Immutable.Set(),
    unhidableColumns: Immutable.Set(),
    TableHeadComponent: THead,
    TableBodyComponent: TBody,
    condensed: true,
    onlyShowColumns: 0,
    hover: true,
    renderDirectives: Immutable.Map(),
};

function mapStateToProps(state) {
    const {
        columns, orderedColumns, hiddenColumns,
        columnActions, columnWidths, rowClassName,
        columnRenderers, unhidableColumns,
        focusedRow, focusedColumn, selectionAnchor,
        selectedRows, isFocusOnTable
    } = state;
    return {
        columns, orderedColumns, hiddenColumns,
        columnActions, columnWidths, rowClassName,
        columnRenderers, unhidableColumns,
        focusedRow, focusedColumn, selectionAnchor,
        selectedRows, isFocusOnTable,
        visibleColumns: getVisibleColumns(state),
        selectAllRowsEvent: getSelectAllRowsEvent(state),
        selectRangeEvent: getSelectRangeEvent(state),
    };
}
export default connect(
    mapStateToProps,
    {
        setTableUserSettings, setFocusedRow, setFocusedColumn,
        navigate, setSelectedRows, setSelectableRowsAggregationState,
        setRenderDirectives, resetFocusTable}
)(Table);
