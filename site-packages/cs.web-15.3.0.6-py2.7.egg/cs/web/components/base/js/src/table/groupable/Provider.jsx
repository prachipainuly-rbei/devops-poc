/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Provider.jsx 171949 2018-01-19 11:09:05Z mbr $"
 */

import React from 'react';
import connect from '../connect';
import Immutable from 'immutable';
import {PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import {setGroupColumns, setInitGroupColumns, expandAll} from './actions';
import {setTableUserSettings} from '../common/actions';
import {getGroupColumns, getCollapsedGroups} from './reducers';
import RowRenderer from './RowRenderer';
import {prefixNS} from '../../helpers';

// TODO: check column.groupable to disable groupping on columns like selection, icon etc.

const GROUPIDPREFIX = `${prefixNS('#table-groupBy#')}`;

const createGroupRow = (value, parentID, level, columnID, groupIndex) => Immutable.Map({
    id: `${parentID}#${groupIndex}`,
    parentID: parentID,
    Renderer: RowRenderer,
    value: value,
    level: level,
    columnID: columnID,
    groupMember: undefined
});

const defaultGroupBy = (value) => value;

// get custom groupByFunction either from colDef or contentRenderer or default one
const getGroupByFunction = (colDef) => {
    if (colDef.get("groupByFunction")) {
        return colDef.get("groupByFunction");
    }
    const renderer = colDef.get('contentRenderer');
    return renderer && renderer.groupByFunction ? renderer.groupByFunction : defaultGroupBy;
};

// group rows by calling either custom or default groupByFunction(value, row, colDef)
const applyGroupByFunction = (rows, columns, columnID) => {
    const columnIndex = columns.findIndex(col => col.get('id') === columnID);
    const colDef = columns.get(columnIndex);
    const groupByFunction = getGroupByFunction(colDef);
    return rows.groupBy(row => groupByFunction(row.get('columns').get(columnIndex), row, colDef));
};

const groupByCols = (rows, cols, columns, parentID, level = 0) => {
    if (!cols || cols.count() < 1) {
        return rows;
    }
    const columnID = cols.first();
    const grouped = applyGroupByFunction(rows, columns, columnID);
    let groupIndex = 0;
    const titled = grouped.mapEntries(([k, v]) => {
        const groupRow = createGroupRow(k, parentID, level, columnID, ++groupIndex);
        const groupID = groupRow.get('id');
        const subGroups = groupByCols(v, cols.rest(), columns, groupID, level + 1);
        if (subGroups === v) {
            // no sub groups: currently at lowest level
            const titleRow = groupRow
                .set('groupMember', subGroups.map(crow => crow.get('id')))
                .set('groupSize', subGroups.size);
            return [
                groupID,
                subGroups.unshift(titleRow)
            ];
        } else {
            // intermediate levels don't include groupSize
            const titleRow = groupRow
                .set('groupMember', subGroups.keySeq().toList());
            return [
                groupID,
                subGroups.toList().flatten(true).unshift(titleRow)
            ];
        }
    });
    return level === 0 ? titled.toList().flatten(true) : titled;
};

function takeSnapshot(grouped) {
    return grouped.map(grp => grp.get('id', {})).toOrderedSet();
}

export default function Provider(WrappedTable) {
    class Group extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                grouped: props.rows,
                hiddenByGroups: Immutable.Set(),
                hiddenRows: props.hiddenRows
            };
        }

        componentWillMount() {
            this.props.setInitGroupColumns(this.props.initGroupColumns);
            this.props.setTableUserSettings('groupColumns');
            this.props.expandAll();
        }

        componentWillReceiveProps(nextProps) {
            if (nextProps.initGroupColumns !== this.props.initGroupColumns) {
                nextProps.setInitGroupColumns(nextProps.initGroupColumns);
            }
            const newState = {...this.state};
            if (nextProps.groupColumns !== this.props.groupColumns ||
                nextProps.columns !== this.props.columns ||
                nextProps.rows !== this.props.rows) {
                const colIDs = nextProps.columns.map(col => col.get('id')).toOrderedSet();
                const validCols = nextProps.groupColumns.intersect(colIDs);
                newState.grouped = groupByCols(
                    nextProps.rows,
                    validCols,
                    nextProps.columns,
                    GROUPIDPREFIX);
                if (!takeSnapshot(this.state.grouped).equals(takeSnapshot(newState.grouped))) {
                    newState.hiddenByGroups = newState.hiddenByGroups.clear();
                    nextProps.expandAll();
                }
            } else if (nextProps.collapsedGroups !== this.props.collapsedGroups) {
                const hidden = this.hideGroups(nextProps, newState);
                if (!newState.hiddenByGroups.equals(hidden.hiddenByGroups)) {
                    newState.hiddenByGroups = hidden.hiddenByGroups;
                }
            }
            if (nextProps.hiddenRows !== this.props.hiddenRows ||
                newState.hiddenByGroups !== this.state.hiddenByGroups) {
                const hiddenRows = nextProps.hiddenRows.union(
                    newState.hiddenByGroups);
                if (!newState.hiddenRows.equals(hiddenRows)) {
                    newState.hiddenRows = hiddenRows;
                }
            }
            if (this.state.grouped !== newState.grouped ||
                this.state.hiddenByGroups !== newState.hiddenByGroups ||
                this.state.hiddenRows !== newState.hiddenRows) {
                this.setState(newState);
            }
        }

        hideGroups(props, state) {
            const {grouped, hiddenByGroups} = state;
            const hiddenRows = props.collapsedGroups.reduce(
                (hidden, groupID) => hidden.union(
                    this.hideGroup(groupID, grouped)),
                Immutable.Set()
            );
            return {
                hiddenByGroups: hiddenByGroups.equals(hiddenRows) ?
                    hiddenByGroups : hiddenRows
            };

        }

        hideGroup(groupID, groups) {
            const group = groups.find(grp => grp.get('id') === groupID);
            if (group === undefined) {
                return Immutable.Set();
            }
            const childRows = group.get('groupMember', Immutable.List()).toSet();
            // hide also all rows from sub groups.
            return childRows.filter(rowID => this.isGroupRow(rowID))
                .reduce(
                    (hidden, grpID) => hidden.union(
                        this.hideGroup(grpID, groups)),
                    childRows
                );
        }

        isGroupRow(rowID) {
            return typeof rowID === 'string' && rowID.indexOf(GROUPIDPREFIX) > -1;
        }

        render() {
            const {...others} = this.props;
            const selectableRowIDs = this.props.selectableRowIDs ?
              this.props.selectableRowIDs : others.rows.map(r => r.get('id'));
            delete others.rows;
            delete others.setInitGroupColumns;
            delete others.initGroupColumns;
            delete others.setGroupColumns;
            delete others.setTableUserSettings;
            delete others.groupColumns;
            delete others.columns;
            delete others.collapsedGroups;
            delete others.expandAll;
            delete others.hiddenRows;
            return (
                <WrappedTable
                    {...others}
                    rows={this.state.grouped}
                    hiddenRows={this.state.hiddenRows}
                    selectableRowIDs={selectableRowIDs}/>
            );
        }
    }

    Group.propTypes = {
        initGroupColumns: ImmutablePropTypes.orderedSet,
        rows: ImmutablePropTypes.list,
        selectableRowIDs: ImmutablePropTypes.list,
        hiddenRows: ImmutablePropTypes.set,
        setInitGroupColumns: PropTypes.func,
        setGroupColumns: PropTypes.func,
        setTableUserSettings: PropTypes.func,
        groupColumns: ImmutablePropTypes.orderedSet,
        columns: ImmutablePropTypes.list,
        collapsedGroups: ImmutablePropTypes.set,
        expandAll: PropTypes.func
    };

    Group.defaultProps = {
        hiddenRows: Immutable.Set()
    };

    function mapStateToProps(state) {
        const groupColumns = getGroupColumns(state);
        const collapsedGroups = getCollapsedGroups(state);
        const {columns} = state;
        return {
            groupColumns, collapsedGroups, columns
        };
    }

    return connect(
        mapStateToProps,
        {setInitGroupColumns, setGroupColumns, setTableUserSettings, expandAll}
    )(Group);
}
