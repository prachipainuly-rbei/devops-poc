/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: OperationHandler.jsx 179967 2018-07-04 13:36:46Z cla $"
 */

import React from 'react';
import Immutable from 'immutable';
import {PropTypes, connect, ImmutablePropTypes} from 'cs-web-components-externals';
import {Registry} from '../../registry.js';
import {getDisplayName} from '../../helpers.js';
import {
    initOperationInstance, clearOperationInstance, setSubmitHandler
} from '../actions/form_with_operations.js';
import {
    runOperation, cancelOperation, changeOperationValues,
    submitOperation,
    queryResultBack, queryResultCall, queryResultCancel, queryResultSubmit,
    queryCancelForce, queryCancelBack,
    addFiles, removeFiles,
} from '../../operations/actions/operations.js';
import {
    executeSuccessHandlerFns, executeFailureHandlerFns
} from '../../operations/actions/handlers.js';
import {Console} from '../../helpers.js';
import {OperationMode, NOT_ACTIVE_SET, NOT_RUNNING_SET} from '../constants.js';

/**
 * Operation Handlers are container components who can be used to allow the
 * user to control the execution of an operation. Usually they will present
 * a configured form to the user, and -- on user interaction -- send actions
 * to the saga running the operation.
 *
 * In order to do that, the HOC
 * :ref:`cs-web-components-base-form.containers.OperationHandler.WithOperationHandler`
 * provides several functions and fields to the wrapped component to interact
 * with the saga.
 *
 * Handler Names
 * -------------
 *
 * The operation handler is identified by its handler name. This can either
 * be set for a whole class of operation handlers when creating the operation
 * handler component with
 * :ref:`cs-web-components-base-form.containers.OperationHandler.WithOperationHandler`
 * or specifically for one instance of a component, by passing the property
 * handlerName to the component. Note that this property must not change during
 * the handlers React component lifecycle, as the handler will be registered in
 * componentWillMount and unregistered again on componentDidUnmount.
 *
 * Operation State
 * ---------------
 *
 * The current state of the operation will be passed in as property ``operationState``.
 * This ``Immutable.Map`` contains the following fields describing the current state of
 * the operation:
 *
 * - **mode**: The mode the operation's execution is currently in. See
 *   :ref:`cs-web-components-base-form.constants.__module__`.
 * - **info**: The operation info object, describing the operation that is executed.
 * - **params**: Parameters with which the operation was initialized.
 * - **values**: The current values of the operation state.
 * - **registers**: The registers/fields of the operation.
 * - **unchecked**: A list of unchecked fields.
 * - **query**: Presubmit Dialog Hooks allow a dialog to be displayed to the user. If
 *   a dialog hook calls the set_dialog function, the dialog configuration will be
 *   passed to the operation handler in this field.
 * - **queryCancel**: Boolean that is set, if the user wants to cancel the operation,
 *   but values have changed preventing cancellation.
 * - **displayForm**: Boolean that is set if the form should be displayed.
 * - **submitDisabled**: Boolean that is set if the OperationHandler should disable
 *   submitting the operation.
 * - **pendingChecks**: an ``Immutable.Map`` containing the fields for which asynchonuous
 *   value checks are currently pending.
 *
 * The following fields are provided to determine the current mode of the operation
 * handler:
 *
 * - **isInstanceActive**: An operation has been started, though the operation state may
 *   not yet be initialized.
 * - **isInstanceRunning**: An operation has been started, and its operation state has
 *   been initialized.
 *
 *
 * Function Properties passed to the wrapped component
 * ---------------------------------------------------
 *
 * Basic interaction is achieved via the following functions:
 *
 * **runOperation**: start the execution of an operation. For parametrization, see
 * :ref:`cs-web-components-base-operations.actions.operations.runOperation_parameters`.
 *
 * .. code-block:: none
 *
 *    runOperation(
 *      operation: Immutable.map,
 *      operationParameters: object,
 *      operationHandler = undefined: string,
 *    )
 *
 * **onChangeValues**: If the user changes one or more values, call this function to update
 * the operation state. ``operationState.get('values')`` will yield the updated values.
 * See also: :ref:`cs-web-components-base-operations.actions.operations.changeOperationValues`
 *
 * .. code-block:: none
 *
 *    onChangeValues(
 *      values: Immutable.map,
 *      unchecked: boolean,
 *    )
 *
 * **onSubmit**: This will enter presubmit state. Validity Checks and Dialog Hooks will be run,
 * and the operation will be submitted, or the operation state will be updated accordingly.
 *
 * .. code-block:: none
 *
 *    onSubmit()
 *
 * For ways to cancel a running operation, the following functions are provided:
 *
 * **onCancel**: Cancel the operation. If values have been changed, this will
 * result in ``operationState.get('queryCancel')`` to be set. The operation handler may
 * now either continue the operation or cancel it, by invoking ``queryCancelBack`` or
 * ``queryCancelForce``.
 * To bypass checking for changed values, set parameter ``force`` to ``false``
 * See also :ref:`cs-web-components-base-operations.actions.operations.cancelOperation`
 *
 * .. code-block:: none
 *
 *    onCancel(force = false)
 *
 * **queryCancelForce**: If ``queryCancel`` is set, this will cancel the operation.
 *
 * .. code-block:: none
 *
 *    queryCancelForce()
 *
 * **queryCancelBack**: If ``queryCancel`` is set, this will continue the operation.
 *
 * .. code-block:: none
 *
 *    queryCancelBack()
 *
 * **forceCancel**: Force cancellation of the operation, regardless of changed values.
 * This is a conveniance function for calling cancelOperation with parameter ``force``
 * set.
 *
 * .. code-block:: none
 *
 *    forceCancel()
 *
 * If a presubmit hook displays a dialog to the user, the following functions should be
 * mapped to the buttons of the dialog if available:
 *
 * **preSubmitDialogBackToDialog**: Update the operation's values according to
 * ``attribute``, and return to the configured form.
 *
 * .. code-block:: none
 *
 *    preSubmitDialogBackToDialog(
 *      attribute: {
 *        name: string,
 *        value
 *      }
 *    )
 *
 * **preSubmitDialogCallServer**: Update the operation's values according to
 * ``attribute``, and invoke the dialog hooks again.
 *
 * .. code-block:: none
 *
 *    preSubmitDialogCallServer(
 *      attribute: {
 *        name: string,
 *        value
 *      }
 *    )
 *
 * **preSubmitDialogSubmit**: Update the operation's values according to
 * ``attribute``, and submit the operation. Note that you should not call
 * ``onSubmit`` in the context of a dialog hook.
 *
 * .. code-block:: none
 *
 *    preSubmitDialogSubmit(
 *      attribute: {
 *        name: string,
 *        value
 *      }
 *    )
 *
 * **preSubmitDialogCancel**: Cancel the operation. This will query the user for
 * loss of changed data. There is no way to override this. Note that calling
 * ``onCancel`` or ``forceCancel`` will not work in the context of a dialog.
 *
 * .. code-block:: none
 *
 *    preSubmitDialogCancel()
 *
 * The ``attribute`` value that three of these functions may provide is used
 * to update the values in the operation state. These are usually provided in the
 * dialog configuration and should be retrieved from the operation state by the
 * component managing the user interation.
 *
 * @name OperationHandler
 * @module
 */

class OperationHandler extends React.Component {
    constructor(props) {
        super(props);
        this.submitOperation = this.submitOperation.bind(this);
        this.runOperation = this.runOperation.bind(this);
        this.onCancel = this.onCancel.bind(this);
        this.forceCancel = this.forceCancel.bind(this);
        this.changeOperationValues = this.changeOperationValues.bind(this);

        this.queryCancelForce = this.queryCancelForce.bind(this);
        this.queryCancelBack = this.queryCancelBack.bind(this);

        this.preSubmitDialogBackToDialog = this.preSubmitDialogBackToDialog.bind(this);
        this.preSubmitDialogCallServer = this.preSubmitDialogCallServer.bind(this);
        this.preSubmitDialogCancel = this.preSubmitDialogCancel.bind(this);
        this.preSubmitDialogSubmit = this.preSubmitDialogSubmit.bind(this);

        this.addFiles = this.addFiles.bind(this);
        this.removeFiles = this.removeFiles.bind(this);

        // TODO cla: deprecated. Legacy result handling
        this.setSubmitHandler = this.setSubmitHandler.bind(this);
        this.startOperation = this.startOperation.bind(this);
        this.onSuccess = null;
        this.onFailure = null;

        this.state = {
            isInstanceFinished: false,
            isInstanceSucceeded: false,
            isInstanceCancelled: false,
            isInstanceFailed: false,
        };
    }

    getOperationHandler(handlerName = undefined) {
        const instanceName = this.getInstanceName(handlerName);
        if (instanceName === undefined) {
            const theHandlerName = handlerName || this.props.handlerName;
            Console.warn(
                `OperationHandler ${theHandlerName} not found in current OperationScope`
            );
        }
        return instanceName;
    }

    getInstanceName(handlerName = undefined, props = undefined) {
        return this.context.getOperationHandler(handlerName || (props || this.props).handlerName);
    }

    getOperationState(props = undefined) {
        const {allOperationStates} = (props || this.props);
        return allOperationStates.get(this.getInstanceName(undefined, props), Immutable.Map());
    }

    componentWillMount() {
        // Scope and Form initialization is done in ctor, so OperationHandlers
        // may do setup work in componentDidMount.

        if (!this.context.registerOperationHandler) {
            Console.warn('OperationHandler needs to be used inside OperationScope');
            return;
        }

        const instanceName = this.context.registerOperationHandler(this.props.handlerName);
        this.props.initOperationInstance(instanceName);
    }

    componentWillReceiveProps(nextProps) {
        this.updateState(
            this.getOperationState(this.props),
            this.getOperationState(nextProps),
        );
    }

    updateState(thisOperationState, nextOperationState) {
        function testResult(res) {
            return (
                !thisOperationState.get('result') &&
                nextOperationState.get('result') === res
            );
        }

        const newState = {
            isInstanceSucceeded: testResult(OperationMode.SUCCEEDED),
            isInstanceCancelled: testResult(OperationMode.CANCELLED),
            isInstanceFailed: testResult(OperationMode.FAILED),
        };

        newState.isInstanceFinished =
            newState.isInstanceSucceeded ||
            newState.isInstanceCancelled ||
            newState.isInstanceFailed;

        const hasChanged =
            ['isInstanceSucceeded', 'isInstanceCancelled', 'isInstanceFailed']
                .some(k => this.state[k] !== newState[k]);

        if (hasChanged) {
            this.setState(newState);
        }
    }

    componentWillUnmount() {
        const instanceName = this.context.unregisterOperationHandler(this.props.handlerName);
        this.props.clearOperationInstance(instanceName);
    }

    setSubmitHandler(onSuccess = undefined, onFailure = undefined) {
        Console.warn(
            'OperationHandler.setSubmitHandler is deprecated in cs.web 15.3.',
            'You should reimplement your result handlers using Redux Saga.'
        );

        this.onSuccess = onSuccess;
        this.onFailure = onFailure;
    }

    startOperation(operation, operationParameters = {}, operationHandler = undefined) {
        Console.warn(
            'OperationTrigger.startOperation is deprecated in cs.web 15.3.',
            'Use OperationTrigger.runOperation instead.'
        );

        // Write submit handlers to store
        const operationProvider = this.getOperationHandler(operationHandler);
        const {setSubmitHandler} = this.props;
        setSubmitHandler(operationProvider, this.onSuccess, this.onFailure);

        // Setup parameters and run operation
        const {object, objects, ...others} = operationParameters;
        others.contextObjects = Immutable.List(objects || (object ? [object] : []));
        if (this.onSuccess) {
            others.successActions = [executeSuccessHandlerFns()];
        }
        if (this.onFailure) {
            others.failureActions = [executeFailureHandlerFns()];
        }
        return this.runOperation(operation, others, operationHandler);
    }

    runOperation(operation, operationParameters = {}, operationHandler = undefined) {
        this.props.runOperation(
            this.getOperationHandler(operationHandler), Object.assign(
                {operationInfo: operation},
                operationParameters
            )
        );
    }

    addFiles(file) {
        this.props.addFiles(this.getOperationHandler(), file);
    }

    removeFiles(file) {
        this.props.removeFiles(this.getOperationHandler(), file);
    }

    changeOperationValues(values, unchecked = false) {
        this.props.changeOperationValues(
            this.getOperationHandler(),
            values,
            unchecked,
        );
    }

    queryCancelForce() {
        this.props.queryCancelForce(this.getOperationHandler());
    }

    queryCancelBack() {
        this.props.queryCancelBack(this.getOperationHandler());
    }

    submitOperation() {
        this.props.submitOperation(this.getOperationHandler());
    }

    preSubmitDialogSubmit(attribute) {
        this.props.queryResultSubmit(this.getInstanceName(), attribute);
    }

    preSubmitDialogCancel() {
        this.props.queryResultCancel(this.getInstanceName());
    }

    preSubmitDialogCallServer(attribute) {
        this.props.queryResultCall(this.getInstanceName(), attribute);
    }

    preSubmitDialogBackToDialog(attribute) {
        this.props.queryResultBack(this.getInstanceName(), attribute);
    }

    cancelOperation(force = false) {
        this.props.cancelOperation(this.getOperationHandler(), force);
    }

    onCancel() {
        this.cancelOperation(false);
    }

    forceCancel() {
        this.cancelOperation(true);
    }

    render() {
        const {Component, ...others} = this.props;

        delete others.initOperationInstance;
        delete others.clearOperationInstance;

        const TheComponent = (
            (typeof Component === "string") ?
            Registry.findComponent(Component) :
            Component
        );

        const operationInstance = this.getInstanceName();
        const operationState = this.getOperationState();
        const operationMode = operationState.get('mode');

        // An operation may only be invoked on this instance if this flag is not set
        const isInstanceActive = !NOT_ACTIVE_SET.has(operationMode);
        // This flag will be set in all states where the operation state is available.
        const isInstanceRunning = !NOT_RUNNING_SET.has(operationMode);

        return (
            <TheComponent
                {...others}
                operationInstance={operationInstance}
                operationState={operationState}

                isInstanceActive={isInstanceActive}
                isInstanceRunning={isInstanceRunning}

                {...this.state}

                runOperation={this.runOperation}
                onCancel={this.onCancel}
                forceCancel={this.forceCancel}
                onChangeValues={this.changeOperationValues}
                onSubmit={this.submitOperation}

                queryCancelBack={this.queryCancelBack}
                queryCancelForce={this.queryCancelForce}

                preSubmitDialogBackToDialog={this.preSubmitDialogBackToDialog}
                preSubmitDialogCallServer={this.preSubmitDialogCallServer}
                preSubmitDialogSubmit={this.preSubmitDialogSubmit}
                preSubmitDialogCancel={this.preSubmitDialogCancel}

                addFiles={this.addFiles}
                removeFiles={this.removeFiles}
            />
        );
    }
}

OperationHandler.propTypes = {
    Component: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.object
    ]),
    handlerName: PropTypes.string.isRequired,
    initOperationInstance: PropTypes.func.isRequired,
    clearOperationInstance: PropTypes.func.isRequired,
    changeOperationValues: PropTypes.func.isRequired,
    runOperation: PropTypes.func.isRequired,
    submitOperation: PropTypes.func.isRequired,
    cancelOperation: PropTypes.func.isRequired,

    queryCancelBack: PropTypes.func.isRequired,
    queryCancelForce: PropTypes.func.isRequired,

    queryResultSubmit: PropTypes.func.isRequired,
    queryResultBack: PropTypes.func.isRequired,
    queryResultCancel: PropTypes.func.isRequired,
    queryResultCall: PropTypes.func.isRequired,

    addFiles: PropTypes.func.isRequired,
    removeFiles: PropTypes.func.isRequired,

    setSubmitHandler: PropTypes.func.isRequired,

    allOperationStates: ImmutablePropTypes.map.isRequired
};

OperationHandler.contextTypes = {
    registerOperationHandler: PropTypes.func,
    unregisterOperationHandler: PropTypes.func,
    getOperationHandler: PropTypes.func
};

function mapStateToProps(state) {
    const allOperationStates = state.formWithOperations;
    const isOperationRunning =
        allOperationStates.some(
            state =>
                state.get('mode') !== OperationMode.INITIAL &&
                   !state.get('nonBlocking')
        );
    return {
        allOperationStates, isOperationRunning
    };
}

const ConnectedOperationHandler = connect(
    mapStateToProps,
    {
        initOperationInstance,
        clearOperationInstance,
        changeOperationValues,
        runOperation,
        submitOperation,
        cancelOperation,

        // Result callbacks when user is queried for cancel
        queryCancelBack,
        queryCancelForce,

        // handling interation with queries from dialog hooks
        queryResultBack,
        queryResultCall,
        queryResultCancel,
        queryResultSubmit,

        // File Interation for Creating Documents with files
        addFiles,
        removeFiles,

        // Legacy action creator for result handler functions
        setSubmitHandler
    }
)(OperationHandler);

export default ConnectedOperationHandler;

/**
 * HOC for creating
 * :ref:`cs-web-components-base-form.containers.OperationHandler.__module__`
 * components. Wrapping a component with this HOC has two effects:
 *
 * - The component is connected to the form_with_operations actions and reducers
 *   allowing the component to execute operations, display the operation state
 *   and interact with the saga executing the operation.
 * - it is registered as a provider using the provider-name provided as a property.
 *   OperationTrigger components may trigger an operation to be executed using this
 *   component.
 *
 * Parameters:
 *
 * - Component: The component to be wrapped
 * - defaultHandlerName: The default handler name, with
 *   which the component will be registered. Component Instances may override this,
 *   by passing in the property ``handlerName``.
 */
export function WithOperationHandler(Component, defaultHandlerName = undefined) {
    class WrappedComponent extends React.Component {
        render() {
            const {handlerName, ...others} = this.props;
            return (
                <ConnectedOperationHandler
                    handlerName={handlerName || defaultHandlerName}
                    {...others}
                    Component={Component} />
            );
        }
    }
    WrappedComponent.propTypes = {
        handlerName: PropTypes.string
    };
    WrappedComponent.displayName =
        `WithOperationHandler(${getDisplayName(Component)})`;
    return WrappedComponent;
}

/**
 * Apply an OperationHandler Extension to a raw OperationHandler.
 * @private
 */
export function applyExtension(Component, Extension) {
    const Composition = props => (
        <Extension {...props}>
            {
                uiExtensions =>
                    <Component
                        {...props}
                        uiExtensions={[props.uiExtensions, uiExtensions]} />
            }
        </Extension>
    );

    Composition.propTypes = {
        uiExtensions: PropTypes.array
    };

    return Composition;
}

/**
 * Apply a list of OperationHandler Extensions to a raw OperationHandler.
 * @private
 */
export const composeExtensions = (Component, ...Extensions) =>
    Extensions.reduce(applyExtension, Component);
