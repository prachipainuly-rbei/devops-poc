/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: config_wrapper.js 181707 2018-08-06 13:50:17Z mbr $"
 */

import Immutable from 'immutable';
import {DATA_TYPES, DISPLAY_TYPES, DEFAULT_COLUMN_WIDTH} from './constants.js';
import {timeToDisplayFormat, floatToDisplayFormat, intToDisplayFormat,
        getPhysQuantText} from './helpers.js';
import {formatStr} from './i18n.js';
const defaultColumns = Immutable.List();
const defaultOrderedColumns = Immutable.OrderedSet();
const defaultRows = Immutable.List();

export const getLink = (value, row, column) => {
    if (column.get('isLink')) {
        const linkParam = column.get('linkParam');
        // If we are running embedded in a windows client
        // uiLink contains a cdbcmsg-URL and webuiLink
        // contains the webui link
        const webuiLink = row.get('webuiLink');
        const uiLink = row.get('uiLink');
        if (webuiLink !== undefined && linkParam) {
            return `${webuiLink}${linkParam}`;
        } else {
            if (uiLink !== undefined) {
                return `${uiLink}${linkParam}`;
            }
        }
    } else if (value) {
        if (column.get('isURL')) {
            return `${value}`;
        } else if (column.get('isEmail')) {
            return `mailto:${value}`;
        }
    }
    return null;
};

export function rowLinkAction(row) {
    const uiLink = row.get('uiLink');
    if (uiLink !== undefined) {
        window.location = uiLink;
    }
}

export function cmpPhysQuant(a, b) {
    if (a && b && a[0] && b[0]) {
        const v_a = a[0].getIn(['normalized', 0]);
        const v_b = b[0].getIn(['normalized', 0]);
        if (v_a === v_b) {
            return 0;
        } else if (v_a < v_b) {
            return -1;
        } else {
            return 1;
        }
    } else if (a && a[0]) {
        return 1;
    } else if (b && b[0]) {
        return -1;
    }
    return 0;
}

export function getCheckBoxText(value) {
    let result = '';
    // We check for string '0' as legacy apps may use this value
    // to represent the bool value false. See E045366
    if (value && value !== '0') {
        result = '\u2714';
    }
    return result;
}

export function translateSelection(oriRows, selection) {
    // Translate persistent-id based selection-sets back to what the user expects
    const indexSeq = selection.toIndexedSeq();
    return oriRows.filter(row => selection.includes(row.get('persistent_id')))
        .sort((a, b) => {
            return indexSeq.indexOf(a.get('persistent_id')) -
                   indexSeq.indexOf(b.get('persistent_id'));})
        .map(row => row.get('id'));
}

export const wrapTableConfig = (oriRows, tableDef) => {
    const viewableColumns = [];

    const columns = tableDef === undefined ?
        defaultColumns :
        tableDef.get('columns').map((column) => {
            const width = column.getIn(['width', 'value']);
            const unit = column.getIn(['width', 'unit']);
            const widthString = width ? `${width}${unit}` : DEFAULT_COLUMN_WIDTH;
            if (column.get('kind') >= 0) {
                viewableColumns.push(column.get('id'));
            }
            let result = column.set('width', widthString);
            if (column.get('isLink') || column.get('isURL') || column.get('isEmail')) {
                result = result.set('getLink', getLink);
            }
            if (column.get('content_type') === DATA_TYPES.PQ) {
                result = result.set('getFormattedValue', getPhysQuantText).set(
                  'sortFunction', cmpPhysQuant);
            } else if (column.get('displayType') === DISPLAY_TYPES.CHECKBOX) {
                result = result.set('getFormattedValue', getCheckBoxText);
            }
            if (column.get('content_type') === DATA_TYPES.DATE) {
                result = result.set('getFormattedValue', timeToDisplayFormat);
            } else if (column.get('content_type') === DATA_TYPES.FLOAT) {
                result = result.set('getFormattedValue', floatToDisplayFormat);
            } else if (column.get('content_type') === DATA_TYPES.INTEGER) {
                result = result.set('getFormattedValue', intToDisplayFormat);
            }
            if (column.get('label') === '') {
                result = result.set('label',
                                    column.get('tooltip') ||
                                    formatStr('tabdef_no_description',
                                              {'attribute': column.get('attribute')}));
                result = result.set('hide_label', true);
            }
            return result;
        });

    const orderedColumns = viewableColumns ?
        Immutable.OrderedSet(viewableColumns) : defaultOrderedColumns;
    // TableWrapper-based tables should use persistent_id as table data,
    // so selections can be retained after updates.
    // We check for persistent_id so we are compatible with cdb < 15.2.14
    // TODO row.has('persistent_id') be removed in a release that allows for
    // compatibility-breaking changes (major release)
    const rows = (oriRows === undefined ? defaultRows : oriRows)
        .map(row => (row.has('persistent_id') ?
                     row.set('id', row.get('persistent_id'))
                        .delete('persistent_id') :
                     row));
    return {columns, orderedColumns, rows};
};
