/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: reducers.js 180052 2018-07-05 11:33:53Z vov $"
 */

import {SET_TREE_NODES, TOGGLE_TREE_NODE,
    EXPAND_TREE_NODES, COLLAPSE_TREE_NODES,
    TOGGLE_TREE_VIEW, FILTER_OUT_NODES,
    EXPAND_TREE_LEVEL
} from './actions';
import {SET_TABLE_SETTINGS_FETCHED} from '../common/actions';
import Immutable from 'immutable';

function traverseTree(nodes, parents = Immutable.OrderedSet()) {
    let result = Immutable.Map();
    if (!nodes) {
        return result;
    }
    nodes.forEach(node => {
        const nodeID = node.get('id');
        const children = node.get('children');
        const parentID = parents.count() > 0 ? parents.last() : undefined;
        const level = parents.count();
        result = result.set(
            nodeID,
            node.set('parents', parents)
                .set('parent', parentID)
                .set('level', level)
                .set(
                    'children',
                    children ?
                        children.map(child => child.get('id')) :
                        undefined)
        ).merge(traverseTree(node.get('children'), parents.add(nodeID)));
    });
    return result;
}

export function treeViewState(state = Immutable.Map(), action) {
    switch (action.type) {
        case SET_TREE_NODES:
            return action.payload === undefined ?
                Immutable.Map() : traverseTree(action.payload);
        case TOGGLE_TREE_NODE: {
            const treeNode = state.get(action.payload);
            return treeNode === undefined ?
                state :
                state.set(
                    action.payload,
                    treeNode.set('expanded', !treeNode.get('expanded', false)));
        }
        case EXPAND_TREE_NODES: {
            if (!action.payload) {
                return state;
            }
            return state.withMutations(
                mapping => {
                    action.payload.forEach(
                        nodeID => {
                            const treeNode = mapping.get(nodeID);
                            if (treeNode) {
                                mapping.set(nodeID, treeNode.set('expanded', true));
                            }
                        }
                    );
                }
            );
        }
        case COLLAPSE_TREE_NODES: {
            if (!action.payload) {
                return state;
            }
            return state.withMutations(
                mapping => {
                    action.payload.forEach(
                        nodeID => {
                            const treeNode = mapping.get(nodeID);
                            if (treeNode) {
                                mapping.set(nodeID, treeNode.set('expanded', false));
                            }
                        }
                    );
                }
            );
        }
        case FILTER_OUT_NODES: {
            if (!action.payload) {
                return state;
            }
            return state.map(treeNode =>
                action.payload.contains(treeNode.get('id')) ?
                    treeNode.set('filteredOut', true) : treeNode.delete('filteredOut')
            );
        }
        case EXPAND_TREE_LEVEL: {
            if (action.payload === undefined) {
                return state;
            }
            // filter: tree node has always "children" key,
            // but it can be assigned to "undefined"
            return state.merge(
                state.filter(treeNode =>
                    treeNode.get('children') !== undefined &&
                    treeNode.get('children').count() > 0
                ).map(treeNode =>
                    treeNode.set(
                        'expanded',
                        treeNode.get('level') < action.payload)
                )
            );
        }
        default:
            return state;
    }
}

export function treeViewOff(state = false, action) {
    switch (action.type) {
        case TOGGLE_TREE_VIEW:
            return !state;
        case SET_TABLE_SETTINGS_FETCHED:
            return action.payload.get('treeViewOff') !== undefined ?
                action.payload.get('treeViewOff') : state;
        default:
            return state;
    }
}

export function treeViewExpandLevel(state = 0, action) {
    switch (action.type) {
        case EXPAND_TREE_LEVEL:
            return action.payload;
        default:
            return state;
    }
}

export default {
    treeViewState, treeViewOff, treeViewExpandLevel
};
