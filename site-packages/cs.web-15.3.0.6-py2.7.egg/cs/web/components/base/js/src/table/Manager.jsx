/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Manager.jsx 175876 2018-04-13 09:03:40Z yzh $"
 */

import React from 'react';
import ReactDOM from 'react-dom';
import Immutable from 'immutable';
import {PropTypes, ImmutablePropTypes, createStore, combineReducers,
        applyMiddleware, thunk, connect} from 'cs-web-components-externals';
import commonReducers from './common/reducers';
import {setColumns, setOrderedColumns, setHiddenColumns,
    setColumnActions, setToolbarButtons, setToolbarMenu,
    setSettingPanels, setHeaderPanels, setFooterPanels,
    setTableSettingsFetched, setTableUserSettings,
    setTableUserSettingConfigurations, setTableCurrentConfiguration,
    SET_TABLE_CHANGE_CONFIGURATION,
    SET_TABLE_NEW_CONFIGURATION,
    SET_TABLE_REMOVE_CONFIGURATION,
    SET_TABLE_RESET_CONFIGURATION} from './common/actions';
import {STORE_SETTINGS} from './setting_panels/actions';
import {storeShape} from './constants';
import Table from './Table';
import DefaultLayout from './DefaultLayout';
import {
    storeUserSetting, resetUserSetting, fetchUserSetting
} from '../actions/user-settings-actions';
import {DEFAULT_TABLE_CONFIGURATION_NAME} from './constants';
import {Console, debugMode} from '../helpers';
import {addLocalShortcut, removeAllLocalShortcuts} from '../key-handlers.js';

/**
 * The Manager function is responsible for creating a table component based
 * on a set of options, that control the different features and controls of
 * this component.
 *
 * The components used in specifying options are usually feature modules, that
 * pack all options relevant to this feature into one module, so that it can be
 * easily used in the definition of a table component. For details on how these
 * feature components are implemented, see section
 * :ref:`cs-web-components-base.table.Manager.sec_custom_ext`.
 *
 * options are provided as an Object that contains an entry for each type of
 * feature that may be activated. The different types for which feature components
 * may be specified are:
 *
 * - **Table:** The **Table** option allows to specify a React component that
 *   overrides the default  table renderer component. The default component used
 *   here is :ref:`cs-web-components-base-table.Table.__module__`. Usually you do not
 *   want to provide your own component here.
 * - **providers:** A list of **Providers**. These omponents alter the way in
 *   which table data is rendered. Providers are HOCs which are instantiated in
 *   reverse order in which they occur in the provided list, with **Table** as
 *   the base component. As a result of this,. properties flow from the first
 *   listed provider to the last, which finally passes it to the **Table**
 *   component.
 * - **columnActions:**
 * - **toolbarButtons:**
 *
 * .. _`cs-web-components-base.table.Manager.sec_custom_ext`:
 *
 * Writing custom extensions
 * -------------------------
 *
 * A table feature such as
 * :ref:`cs-web-components-base-table.sortable.index.__module__` is usually provided
 * as a module which exports the different options provided to realize the
 * feature, such as column actions or a provider.
 *
 * @module
 */

const logger =
    () => next => action => {
        Console.log('dispatching table actions', action);
        return next(action);
    };

const createStoreWithMiddleware = (middleWares, options) => {
    const basicEnhancer = applyMiddleware(
        thunk,
        logger,
        ...middleWares);
    const enhancer =
        (debugMode && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ !== undefined) ?
        window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(options)(basicEnhancer)
        : basicEnhancer;
    return enhancer(createStore);
};

let tableID = 0;
const createTableStore = (featureReducers, middleWares) =>
    createStoreWithMiddleware(middleWares, {name: `Table${++tableID}`})(
        combineReducers(Object.assign({}, commonReducers, featureReducers)),
        {tableID});

const DEFAULT_USER_SETTING = Immutable.Map();

export default function(
    options = {}
) {
    const WrappedTable = options.Table || Table;
    const providers = options.providers || [];
    const {featureReducers, CombinedComponent} =
        providers.slice(0).reverse().reduce(
            (result, feature) => ({
                featureReducers: Object.assign(result.featureReducers, feature.reducers),
                CombinedComponent: feature.Provider === undefined ?
                    result.CombinedComponent :
                    feature.Provider(result.CombinedComponent)

            }),
            {
                featureReducers: {},
                CombinedComponent: WrappedTable
            });

    const TableLayout = options.Layout || DefaultLayout;
    const LayoutedComponent = TableLayout(CombinedComponent);

    const columnActions = options.columnActions || [];
    const allColumnActions = columnActions.reduce(
        (allColumnActions, feature) =>
            feature.columnActions === undefined ?
                allColumnActions :
                allColumnActions.concat(feature.columnActions),
        Immutable.List());

    const toolbarButtons = options.toolbarButtons || [];
    const allToolbarButtons = toolbarButtons.reduce(
        (allToolbarButtons, feature) =>
            feature.toolbarButtons === undefined ?
                allToolbarButtons :
                allToolbarButtons.concat(feature.toolbarButtons),
        Immutable.List());

    const toolbarMenu = options.toolbarMenu || [];
    const allToolbarMenu = toolbarMenu.reduce(
        (allToolbarMenu, feature) =>
            feature.toolbarMenu === undefined ?
                allToolbarMenu :
                allToolbarMenu.concat(feature.toolbarMenu),
        Immutable.List());

    const settingPanels = options.settingPanels || [];
    const allSettingPanels = settingPanels.reduce(
        (allSettingPanels, feature) =>
            feature.settingPanels === undefined ?
                allSettingPanels :
                allSettingPanels.concat(feature.settingPanels),
        Immutable.List());

    const headerPanels = options.headerPanels || [];
    const allHeaderPanels = headerPanels.reduce(
        (allHeaderPanels, feature) =>
            feature.Panels === undefined ?
                allHeaderPanels :
                allHeaderPanels.concat(feature.Panels),
        Immutable.List());

    const footerPanels = options.footerPanels || [];
    const allFooterPanels = footerPanels.reduce(
        (allFooterPanels, feature) =>
            feature.Panels === undefined ?
                allFooterPanels :
                allFooterPanels.concat(feature.Panels),
        Immutable.List());

    const shortcuts = options.shortcuts || [];
    const allShortcuts = shortcuts.reduce(
        (allShortcuts, feature) =>
            feature.shortcuts === undefined ?
                allShortcuts :
                allShortcuts.concat(feature.shortcuts),
        Immutable.List());

    const optionListeners = options.listeners || [];

    class Manager extends React.Component {
        constructor(props) {
            super(props);
            this.settingsListener = this.settingsListener.bind(this);
            this.tableStore = createTableStore(featureReducers,
                                  optionListeners.concat([this.settingsListener]));
            if (this.props.settingID) {
                props.fetchUserSetting("table", this.props.settingID);
            }
            this.persistSettings = this.persistSettings.bind(this);
            this.state = {settingsFetched: false};
            this.currentConfiguration = DEFAULT_TABLE_CONFIGURATION_NAME;
            this.setLayoutRef = this.setLayoutRef.bind(this);
        }

        settingsListener() {
            return next => action => {
                switch (action.type) {
                    case STORE_SETTINGS:
                        this.persistSettings(action.payload);
                        break;
                    case SET_TABLE_CHANGE_CONFIGURATION:
                        this.changeConfiguration(action.payload);
                        break;
                    case SET_TABLE_NEW_CONFIGURATION:
                        this.newConfiguration(action.payload);
                        break;
                    case SET_TABLE_REMOVE_CONFIGURATION:
                        this.removeConfiguration(action.payload);
                        break;
                    case SET_TABLE_RESET_CONFIGURATION:
                        this.resetConfiguration();
                        break;
                    default:
                        break;
                }
                return next(action);
            };
        }

        setLayoutRef(c) {
            this.layoutRef = ReactDOM.findDOMNode(c);  // eslint-disable-line react/no-find-dom-node
        }

        getChildContext() {
            return {
                tableStore: this.tableStore,
                tableStoreSubscription: null
            };
        }

        componentWillMount() {
            const {columns, orderedColumns, hiddenColumns} = this.props;
            const {dispatch} = this.tableStore;
            dispatch(setColumns(columns));
            dispatch(setOrderedColumns(orderedColumns));
            dispatch(setHiddenColumns(hiddenColumns));
            dispatch(setColumnActions(allColumnActions));
            dispatch(setToolbarButtons(allToolbarButtons));
            dispatch(setToolbarMenu(allToolbarMenu));
            dispatch(setSettingPanels(allSettingPanels));
            dispatch(setHeaderPanels(allHeaderPanels));
            dispatch(setFooterPanels(allFooterPanels));
            dispatch(setTableUserSettings('orderedColumns'));
            dispatch(setTableUserSettings('hiddenColumns'));
            dispatch(setTableCurrentConfiguration(DEFAULT_TABLE_CONFIGURATION_NAME));
        }

        componentDidMount() {
            const {dispatch} = this.tableStore;
            allShortcuts.forEach(
                shortcut => addLocalShortcut(this.layoutRef,
                                             shortcut.keys,
                                             event => shortcut.handler(event, dispatch))
            );
        }

        componentWillUnmount() {
            removeAllLocalShortcuts(this.layoutRef);
        }

        componentWillReceiveProps(nextProps) {
            const {dispatch} = this.tableStore;
            if (nextProps.columns !== this.props.columns) {
                dispatch(setColumns(nextProps.columns));
            }
            if (nextProps.orderedColumns !== this.props.orderedColumns) {
                dispatch(setOrderedColumns(nextProps.orderedColumns));
            }
            if (nextProps.hiddenColumns !== this.props.hiddenColumns) {
                dispatch(setHiddenColumns(nextProps.hiddenColumns));
            }

            if (nextProps.userSettings !== this.props.userSettings) {
                this.setState({settingsFetched: true});
                if (nextProps.userSettings) {
                    // If settings are undefined we reset to default
                    let settings = nextProps.userSettings.getIn(
                        ['configurations', nextProps.userSettings.get('lastUsed')],
                        DEFAULT_USER_SETTING
                    );
                    settings = Immutable.Map(settings);
                    if (settings.get('hiddenColumns') === undefined) {
                        settings = settings.set('hiddenColumns', nextProps.hiddenColumns);
                    }
                    if (settings.get('orderedColumns') === undefined) {
                        settings = settings.set('orderedColumns', nextProps.orderedColumns);
                    }
                    dispatch(setTableSettingsFetched(settings.
                       set("columnIDs", nextProps.columns.map(c => c.get('id')))));

                    if (nextProps.userSettings.get('configurations')) {
                        const configurations =
                            Object.keys(nextProps.userSettings.get('configurations').toJS());
                        dispatch(setTableUserSettingConfigurations(Immutable.List(configurations)));
                        this.currentConfiguration = nextProps.userSettings.get('lastUsed');
                    } else {
                        this.currentConfiguration = DEFAULT_TABLE_CONFIGURATION_NAME;
                    }
                    dispatch(setTableCurrentConfiguration(this.currentConfiguration));

                }
            }
            if (nextProps.settingID && nextProps.settingID !== this.props.settingID) {
                nextProps.fetchUserSetting("table", nextProps.settingID);
                this.setState({settingsFetched: false});
            }
        }

        persistSettings(settings)
        {
            if (settings) {
                let configurations = DEFAULT_USER_SETTING;
                if (this.props.userSettings && this.props.userSettings.get('configurations')) {
                    configurations = this.props.userSettings.get('configurations');
                }
                configurations = configurations.set(this.currentConfiguration, settings);
                this.props.storeUserSetting(
                    "table", this.props.settingID,
                    Immutable.fromJS({
                        lastUsed: this.currentConfiguration,
                        configurations
                    })
                );
            }
        }

        changeConfiguration(configuration) {
            if (configuration !== this.currentConfiguration) {
                if (this.props.userSettings) {
                    this.currentConfiguration = configuration;
                    let settings =
                        this.props.userSettings.getIn(
                            ['configurations', configuration],
                            DEFAULT_USER_SETTING
                        );
                    settings = Immutable.Map(settings);
                    if (settings.get('hiddenColumns') === undefined) {
                        settings = settings.set('hiddenColumns', this.props.hiddenColumns);
                    }
                    if (settings.get('orderedColumns') === undefined) {
                        settings = settings.set('orderedColumns', this.props.orderedColumns);
                    }

                    const {dispatch} = this.tableStore;
                    dispatch(setTableSettingsFetched(Immutable.fromJS(settings).
                      set("columnIDs", this.props.columns.map(c => c.get('id')))));
                    dispatch(setTableCurrentConfiguration(this.currentConfiguration));
                    if (this.props.userSettings && this.props.userSettings.get('configurations')) {
                        const configurations = this.props.userSettings.get('configurations');
                        this.props.storeUserSetting(
                            "table", this.props.settingID,
                            Immutable.fromJS({
                                lastUsed: this.currentConfiguration,
                                configurations
                            })
                        );
                    }
                }
            }
        }

        newConfiguration(configuration) {
            if (configuration !== DEFAULT_TABLE_CONFIGURATION_NAME && this.props.userSettings) {
                const configurations = this.props.userSettings.get('configurations') ?
                    Object.keys(this.props.userSettings.get('configurations').toJS()) : [];
                this.currentConfiguration = configuration;
                const {dispatch} = this.tableStore;
                configurations.push(configuration);
                dispatch(setTableUserSettingConfigurations(Immutable.List(configurations)));
                dispatch(setTableCurrentConfiguration(this.currentConfiguration));
            }
        }

        removeConfiguration(configuration) {
            const configurationNames =
                Object.keys(this.props.userSettings.get('configurations').toJS());
            if (configurationNames.indexOf(configuration) !== -1) {
                if (this.props.userSettings) {
                    let configurations = this.props.userSettings.get('configurations');
                    if (configuration === this.currentConfiguration) {
                        this.currentConfiguration = DEFAULT_TABLE_CONFIGURATION_NAME;
                    }
                    const {dispatch} = this.tableStore;
                    if (configurations.size === 1) {
                        this.props.resetUserSetting("table", this.props.settingID);
                        dispatch(setTableUserSettingConfigurations(Immutable.List()));
                    } else {
                        configurations = configurations.delete(configuration);
                        this.props.storeUserSetting(
                            "table", this.props.settingID,
                            Immutable.fromJS({
                                lastUsed: this.currentConfiguration,
                                configurations
                            })
                        );
                        delete configurationNames[configuration];
                        dispatch(setTableUserSettingConfigurations(
                            Immutable.List(configurationNames)));
                    }
                    dispatch(setTableCurrentConfiguration(this.currentConfiguration));
                }
            }
        }

        resetConfiguration() {
            let settings = DEFAULT_USER_SETTING;
            if (settings.get('hiddenColumns') === undefined) {
                settings = settings.set('hiddenColumns', this.props.hiddenColumns);
            }
            if (settings.get('orderedColumns') === undefined) {
                settings = settings.set('orderedColumns', this.props.orderedColumns);
            }
            const {dispatch} = this.tableStore;
            dispatch(setTableSettingsFetched(Immutable.fromJS(settings).
              set("columnIDs", this.props.columns.map(c => c.get('id')))));
        }

        render() {
            const {...props} = this.props;
            delete props.columns;
            delete props.orderedColumns;
            delete props.hiddenColumns;
            delete props.userSettings;
            delete props.settingID;
            delete props.fetchUserSetting;
            delete props.storeUserSetting;
            delete props.resetUserSetting;
            return (
                <LayoutedComponent ref={this.setLayoutRef}
                                   {...props}/>
            );
        }
    }

    Manager.propTypes = {
        columns: ImmutablePropTypes.list,
        orderedColumns: ImmutablePropTypes.orderedSet,
        hiddenColumns: ImmutablePropTypes.set,
        settingID: PropTypes.string,
        fetchUserSetting: PropTypes.func,
        storeUserSetting: PropTypes.func,
        resetUserSetting: PropTypes.func,
        userSettings: PropTypes.object
    };

    Manager.childContextTypes = {
        tableStore: storeShape,
        tableStoreSubscription: PropTypes.object
    };

    function mapStateToProps(state, ownProps) {
        const {userSettings} = state;
        const settings = userSettings.getIn(
            ["table", ownProps.settingID], DEFAULT_USER_SETTING
        );
        return {
            userSettings: settings === "" ? DEFAULT_USER_SETTING : settings
        };
    }

    return connect(
        mapStateToProps,
        {storeUserSetting, fetchUserSetting, resetUserSetting}
    )(Manager);
}
