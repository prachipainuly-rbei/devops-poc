/*
 * Copyright (C) 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: instances.js 183705 2018-09-11 14:11:10Z gwe $"
 */

import Immutable from 'immutable';
import {ReduxSaga} from 'cs-web-components-externals';
import {getJSON, putJSON, postJSON} from '../../fetch.js';
import {getAppSetup} from '../../helpers.js';
import {ACTIONS, FTS_ATTRNAME} from '../constants.js';
import {
    getClassname, getFavouriteId, getSubmitUrl, getSearchRequestData, isSearchRunning,
    hasSpecialFavourite, getSpecialResultLink, isCatalogSearch, getOriginalCatalogSearchFormData,
    getVisibleAttributes, getSearchValues, getAttributeOrder, getOperationState, isRelshipSearch,
    relshipHasSearch, getFormUrl, getSearchOnNavigate
} from '../selectors/instances.js';
import {initClassSearch} from './classes.js';
import {ResultType} from '../../form/constants.js';
import {repeatSearch as repeatSearchAction, setSearchOnNavigate} from '../actions/instances.js';
import Operations from '../../operations';
import {fetchRelshipOperationInfo} from '../../actions/operations.js';
import {formatStr} from '../../i18n.js';

const {call, put, select, takeEvery} = ReduxSaga.effects;

/**
 * Try to get a detailed description from the error
 **/
function* createSearchFailed(err, instanceName) {
    let errMessage = err;
    if (err.response) {
        try {
            const r = yield call(response => response.json(), err.response);
            if (r && (r.message || r.detail)) {
                errMessage = `${r.message ? r.message : ""} ${r.detail ? r.detail : ""}`;
            }
        } catch (x) {/* empty */ }
    }
    yield put({
        type: ACTIONS.SEARCH_FAILED,
        payload: {instanceName, "err": new Error(errMessage)}
    });
}


/**
 * A "special" search is one where the results are not obtained by calling a search
 * operation. They have a specific URL instead, and can't take further search
 * attributes.
 */
function* doSpecialSearch(instanceName) {
    yield put({
        type: ACTIONS.SEARCH_STARTED,
        payload: {instanceName}
    });
    try {
        const state = yield select();
        const resultLink = getSpecialResultLink(state, instanceName);
        const result = yield call(getJSON, resultLink);
        yield put({
            type: ACTIONS.SEARCH_DONE,
            payload: {instanceName, result}
        });
    }
    catch (err) {
        yield call(createSearchFailed, err, instanceName);
    }
}

/**
 * A "standard" search calls the search operation for the class, giving the search
 * values.
 */
function* doStandardSearch(instanceName) {
    // TODO: copy actually used search values for later "repeat search" (see
    // comment farther down).
    yield put({
        type: ACTIONS.SEARCH_STARTED,
        payload: {instanceName}
    });
    try {
        const state = yield select();
        const searchUrl = getSubmitUrl(state, instanceName);
        const request_data = getSearchRequestData(state, instanceName);
        const result = yield call(postJSON, searchUrl, request_data);
        yield put({
            type: ACTIONS.SEARCH_DONE,
            payload: {instanceName, result}
        });
    }
    catch (err) {
        yield call(createSearchFailed, err, instanceName);
    }
}

/**
 * Initializing a search instance means to set up the search params, and to start
 * the search if meaningful search values have been provided.
 */
function* initializeSearch({payload}) {
    const {instanceName} = payload;
    const state = yield select();
    if (isSearchRunning(state, instanceName)) {
        return;
    }
    const classname = getClassname(state, instanceName);

    if (isCatalogSearch(state, instanceName)) {
        // TODO
    }
    else if (hasSpecialFavourite(state, instanceName)) {
        // For "special" favourites there are no further settings, we can just
        // fire off the request.
        yield call(doSpecialSearch, instanceName);
    }
    else if (state.search.operationByClass.get(classname).get('error')) {
        const error =
          formatStr(state.search.operationByClass.get(classname).get('error'));
        yield call(createSearchFailed, error, instanceName);
    }
    else if (shouldSearchOnInitialize(state, instanceName)) {
        // If the search should be started automatically after navigating to the
        // page, this must not trigger more than once!
        yield put(setSearchOnNavigate(instanceName, false));
        yield call(doStandardSearch, instanceName);
    }
}

function shouldSearchOnInitialize(state, instanceName) {
    return (
        getSearchOnNavigate(state, instanceName)
        || hasSearchAttributes(state, instanceName));
}

function hasSearchAttributes(state, instanceName) {
    const classname = getClassname(state, instanceName);
    const favouriteId = getFavouriteId(state, instanceName);
    if (favouriteId !== undefined) {
        return true;
    }
    const opState = state.search.operationByClass.get(classname);
    return !Immutable.is(
        getSearchValues(state, instanceName),
        opState.get('defaultValues')
    );
}

/**
 * Assemble the search parameters from the search operation and, if given, the
 * search favourite.
 */
function* doInitializeSearchParams({payload}) {
    const {instanceName} = payload;
    const state = yield select();
    if (isCatalogSearch(state, instanceName) || hasSpecialFavourite(state, instanceName)) {
        return;
    }
    const classname = getClassname(state, instanceName);
    const favouriteId = getFavouriteId(state, instanceName);
    const opState = state.search.operationByClass.get(classname);
    if (opState.get('error')) {
        const error = formatStr(opState.get('error'));
        yield call(createSearchFailed, error, instanceName);
    }
    else {
        const favourite = state.search.favouritesByClass.getIn([
            classname, 'favourites', favouriteId]);
        yield put({
            type: ACTIONS.INITIALIZE_SEARCH_PARAMS,
            payload: {instanceName, opState, favourite}
        });
    }
}

/**
 * This function will be called for each tabular catalog instance, regardless of
 * whether it actually provides a separate search facility. In any case, we fetch
 * the initial catalog rows here.
 */
function* createCatalogSearchInstance({payload}) {
    // Note: the reducer function has already been called at this point, so that
    // the instance data is in the store.
    const {instanceName, queryFormURL, callingFormData} = payload;

    try {
        // If we have a query form (ie. search for this catalog is enabled), load
        // the form configuration to determine possible search fields.
        if (queryFormURL) {
            const searchFormData = yield call(postJSON, queryFormURL, callingFormData);
            yield put({
                type: ACTIONS.CATALOG_SEARCH_FORM_LOADED,
                payload: {instanceName, searchFormData}
            });
        }
    }
    catch (err) {
        yield call(createSearchFailed, err, instanceName);
    }

    // Trigger the initial search
    yield call(doCatalogSearch, instanceName);
}

function* doCatalogSearch(instanceName) {
    yield put({
        type: ACTIONS.SEARCH_STARTED,
        payload: {instanceName}
    });
    const state = yield select();
    try {
        const searchUrl = getSubmitUrl(state, instanceName);
        const request_data = getSearchRequestData(state, instanceName);
        const result = yield call(postJSON, searchUrl, request_data);
        yield put({
            type: ACTIONS.CATALOG_SEARCH_DONE,
            payload: {instanceName, result}
        });
    }
    catch (err) {
        yield call(createSearchFailed, err, instanceName);
    }
}

function collectSearchParamsForFavourite(state, instanceName) {
    const instance = state.search.instances.get(instanceName);
    const searchValues = instance.get('searchValues');
    const attributeOrder = instance.get('attributeOrder');

    // Collect the relevant attribute & values from the instance
    const searchParams = attributeOrder.map(
        attr => ({attribute: attr, value: searchValues.get(attr, '')}));
    const ftsParam = searchValues.get(FTS_ATTRNAME, '');
    if (ftsParam !== '' && !attributeOrder.includes(FTS_ATTRNAME)) {
        return searchParams.unshift({attribute: FTS_ATTRNAME, value: ftsParam});
    }
    return searchParams;
}

/**
 * Store the current search settings as a new favourite.
 */
function* storeAsSearchFavourite({payload}) {
    const {instanceName, favouriteName} = payload;
    const state = yield select();
    const classname = state.search.instances.getIn([instanceName, 'classname']);

    // prepare & send the request to create a new favourite
    const data = {
        name: favouriteName,
        params: collectSearchParamsForFavourite(state, instanceName).toArray()
    };
    const favouritesLink = getAppSetup().getIn(['class_view', 'searchFavourites']);
    const newFavourite = yield call(postJSON, favouritesLink, data);

    // Put the new favourite into the store. Use put.resolve so that the new
    // favourite's data is already in the store before we select it below.
    yield put.resolve({
        type: ACTIONS.STORE_FAVOURITE_FOR_CLASS,
        payload: {classname, newFavourite}
    });
    yield put({
        type: ACTIONS.SET_FAVOURITE_ID,
        payload: {instanceName, classname, favouriteId: newFavourite['cdb_object_id']}
    });
}

/**
 * Overwrite the current search favourites parameters with the current search
 * settings.
 */
function* storeSearchFavourite({payload}) {
    const {instanceName} = payload;
    const state = yield select();
    const classname = state.search.instances.getIn([instanceName, 'classname']);
    const favouriteId = state.search.instances.getIn([instanceName, 'favouriteId']);
    // Make an updated favourite by overwriting the search parameters, and send
    // it to the backend.
    const favourite = state.search.favouritesByClass
        .getIn([classname, 'favourites', favouriteId])
        .set('params', collectSearchParamsForFavourite(state, instanceName));
    const newFavourite = yield call(putJSON, favourite.get('@id'), favourite.toJS());
    // Put the return value from the backend into the store.
    yield put({
        type: ACTIONS.STORE_FAVOURITE_FOR_CLASS,
        payload: {classname, newFavourite}
    });

}

function* selectFavourite(action) {
    const {instanceName, classname, favouriteId} = action.payload;
    yield put.resolve({
        type: ACTIONS.SET_FAVOURITE_ID,
        payload: {instanceName, classname, favouriteId}
    });
    yield call(initClassSearch, action);
    yield call(doInitializeSearchParams, action);
    yield call(initializeSearch, action);
}

function* repeatSearch(action) {
    // TODO: we might want to store the parameters used for the last search
    // separately, so that "repeat search" will not use the possibly changed
    // current values.
    yield call(runSearch, action);
}

/**
 * Reset the search parameters to an initial state
 */
function* resetSearch(action) {
    const {instanceName} = action.payload;
    const state = yield select();
    if (isSearchRunning(state, instanceName)) {
        return;
    }

    if (isCatalogSearch(state, instanceName)) {
        const searchFormData = getOriginalCatalogSearchFormData(state, instanceName);
        yield put({
            type: ACTIONS.CATALOG_SEARCH_FORM_LOADED,
            payload: {instanceName, searchFormData}
        });
    }
    else if (isRelshipSearch(state, instanceName)) {
        yield call(resetRelshipSearch, action);
    }
    else {
        yield call(doInitializeSearchParams, action);
        yield call(initializeSearch, action);
    }
}

export function* runSearch({payload}) {
    const {instanceName} = payload;
    const state = yield select();
    if (isSearchRunning(state, instanceName)) {
        return;
    }

    if (isCatalogSearch(state, instanceName)) {
        yield call(doCatalogSearch, instanceName);
    }
    else if (hasSpecialFavourite(state, instanceName)) {
        yield call(doSpecialSearch, instanceName);
    }
    else if (isRelshipSearch(state, instanceName)) {
        yield call(doRelshipSearch, instanceName);
    }
    else {
        yield call(doStandardSearch, instanceName);
    }
}

/**
 * Set the search fields and their values from a search dialog. This means we set
 * the new value for all previously visible attributes, and add new ones at the
 * end. Fields that had a value, but no longer have one, are removed. Fields that
 * had no value before opening the form will be retained.
**/
export function* changeFieldsFromDialog({payload}) {
    const {instanceName, fields} = payload;
    const state = yield select();
    const visibleAttributes = getVisibleAttributes(state, instanceName);
    const oldValues = getSearchValues(state, instanceName);
    const keysToRemove = oldValues
        .filter(val => val !== "").keySeq().toSet()
        .intersect(fields.filter(val => val === "").keySeq());
    const newValues = oldValues
        .merge(fields.filter(val => val !== ""))
        .filter((val, key) => visibleAttributes.includes(key))
        .filter((val, key) => !keysToRemove.includes(key));
    // Keep the existing order, append new values
    const oldAttributeOrder = getAttributeOrder(state, instanceName).toOrderedSet();
    const visibleAttributesInOrder = oldAttributeOrder
      .union(visibleAttributes.filter(attr => attr !== FTS_ATTRNAME));
    yield put.resolve({
        type: ACTIONS.SET_SEARCH_FIELDS,
        payload: {
            instanceName,
            searchValues: newValues,
            attributeOrder: visibleAttributesInOrder.filter(attr => newValues.has(attr)).toList()
        }
    });
    yield call(runSearch, {payload});
}

/**
 * Set the search fields and their values from a search bar. This means we set
 * the new value for all previously search attributes, and add new ones at the
 * end. Fields that had a value, but no longer have one,
 * are removed except the field specified by "attr".
 */
export function* changeFieldsFromSearchBar({payload}) {
    const {instanceName, fields, attr} = payload;
    const state = yield select();
    const visibleAttributes = getVisibleAttributes(state, instanceName);
    const oldValues = getSearchValues(state, instanceName);
    const keysToRemove = oldValues
        .filter(val => val !== "").keySeq().toSet()
        .intersect(fields.filter(val => val === "").keySeq());
    const newValues = oldValues
        .merge(fields.filter((val, key) => (val !== "") || key === attr))
        .filter((val, key) => visibleAttributes.includes(key))
        .filter((val, key) => !keysToRemove.includes(key) || key === attr);
    // Keep the existing order, append new values
    const oldAttributeOrder = getAttributeOrder(state, instanceName).toOrderedSet();
    const visibleAttributesInOrder = oldAttributeOrder
      .union(visibleAttributes.filter(attr => attr !== FTS_ATTRNAME));
    yield put.resolve({
        type: ACTIONS.SET_SEARCH_FIELDS,
        payload: {
            instanceName,
            searchValues: newValues,
            attributeOrder: visibleAttributesInOrder.filter(attr => newValues.has(attr)).toList()
        }
    });
}

/**
 * Remove a search field.
 * In addition, for catalog fields, a catalog call is used to remove any dependent fields.
**/
export function* removeSearchFieldIncludingDependencies({payload}) {
    const {instanceName, field} = payload;
    const attr = field.get('attribute');
    const state = yield select();
    const selectURL = field.getIn(['config', 'selectURL']);
    if (selectURL) {
        const formData = getSearchValues(state, instanceName);
        const operationState = getOperationState(state, instanceName);
        formData['cdb::argument.catalogcall_cldef'] = field.getIn(['config', 'contextClass']);
        formData['cdb::argument.catalogfieldactivelang'] = field.getIn(['config', 'iso_lang']);
        formData[attr] = "";

        const jsonData = {
            'form_data': formData,
            'catalog_field': attr,
            'operation_state': operationState
        };
        jsonData['selected_ids'] = [];
        const result = yield call(postJSON, selectURL, jsonData);
        const attrToDelete = Immutable.Map(result.selected_values)
          .filter((v, k) => k !== attr && !v).keySeq().toList();
        yield put.resolve({
            type: ACTIONS.REMOVE_SEARCH_FIELDS,
            payload: {
                instanceName,
                fieldnames: attrToDelete
            }
        });
    }
    yield put.resolve({
        type: ACTIONS.REMOVE_SEARCH_FIELD,
        payload: {
            instanceName,
            fieldname: attr
        }
    });
}

/**
 * Executed when Operation is successfully executed in ResultArea. We usually want to
 * refresh the Result List, except when an HTML_VIEW result is received.
 */
function* handleOperationSuccess(action) {
    const {Handlers, dispatchResultHandler} = Operations;
    if (action.payload.operation.result.result_type === ResultType.HTML_VIEW) {
        yield call(dispatchResultHandler, Handlers.handleOperationSuccess, action);
    } else {
        yield put(repeatSearchAction(action.payload.instanceName));
    }
}

function* createRelshipSearchInstance({payload}) {
    const {parentObject, relshipName} = payload;
    yield put(fetchRelshipOperationInfo(parentObject, relshipName));
    /*
    activate -> fetch relship URL (no search)
    set result as search result
    get relship operations
    if SearchAgain: enable search
    repeatSearch: not yet searched -> fetch relship, searched -> search again
    */
}

function* loadRelshipSearchForm({payload}) {
    const {instanceName, formURL} = payload;
    const searchFormData = yield call(getJSON, formURL);
    yield put({
        type: ACTIONS.RELSHIP_SEARCH_FORM_LOADED,
        payload: {instanceName, searchFormData}
    });
}

function* resetRelshipSearch({payload}) {
    const {instanceName} = payload;
    const state = yield select();
    const formURL = getFormUrl(state, instanceName);
    yield call(loadRelshipSearchForm, {payload: {instanceName, formURL}});
}

function* doRelshipSearch(instanceName) {
    yield put({
        type: ACTIONS.SEARCH_STARTED,
        payload: {instanceName}
    });
    try {
        const state = yield select();
        const searchUrl = getSubmitUrl(state, instanceName);
        let result;
        if (relshipHasSearch(state, instanceName)) {
            // We have an actual operation "Search Again" to call, so collect the
            // search params and POST to the operation
            const request_data = getSearchRequestData(state, instanceName);
            result = yield call(postJSON, searchUrl, request_data);
        }
        else {
            // Just GET the data from the relationship URL
            result = yield call(getJSON, searchUrl);
        }
        if (result.error_message) {
            yield call(createSearchFailed, result.error_message, instanceName);
        }
        else {
            yield put({
                type: ACTIONS.RELSHIP_SEARCH_DONE,
                payload: {instanceName, result}
            });
        }
    }
    catch (err) {
        yield call(createSearchFailed, err, instanceName);
    }
}

export default function* watcher() {
    // Use takeEvery here, because we have to check for each instance whether a
    // search is already running. In addition, we don't want to start a new search,
    // but use the result from the one already underway.
    yield takeEvery(ACTIONS.INITIALIZE_SEARCH, initializeSearch);
    yield takeEvery(ACTIONS.DO_INITIALIZE_SEARCH_PARAMS, doInitializeSearchParams);
    yield takeEvery(ACTIONS.REPEAT_SEARCH, repeatSearch);
    yield takeEvery(ACTIONS.RUN_SEARCH, runSearch);
    yield takeEvery(ACTIONS.RESET_SEARCH, resetSearch);
    yield takeEvery(ACTIONS.SELECT_FAVOURITE, selectFavourite);
    yield takeEvery(ACTIONS.STORE_SEARCH_FAVOURITE, storeSearchFavourite);
    yield takeEvery(ACTIONS.STORE_AS_SEARCH_FAVOURITE, storeAsSearchFavourite);
    yield takeEvery(ACTIONS.CREATE_CATALOG_SEARCH_INSTANCE, createCatalogSearchInstance);
    yield takeEvery(ACTIONS.CHANGE_FIELDS_FROM_DIALOG, changeFieldsFromDialog);
    yield takeEvery(ACTIONS.CHANGE_FIELDS_FROM_SEARCHBAR, changeFieldsFromSearchBar);
    yield takeEvery(ACTIONS.HANDLE_OPERATION_SUCCESS, handleOperationSuccess);
    yield takeEvery(ACTIONS.REMOVE_SEARCH_FIELD_INCLUDING_DEPENDENCIES,
                    removeSearchFieldIncludingDependencies);
    yield takeEvery(ACTIONS.CREATE_RELSHIP_SEARCH_INSTANCE, createRelshipSearchInstance);
    yield takeEvery(ACTIONS.LOAD_RELSHIP_SEARCH_FORM, loadRelshipSearchForm);
}
