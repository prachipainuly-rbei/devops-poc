/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: SearchField.jsx 184312 2018-09-24 10:02:30Z cla $"
 */

import React from 'react';
import {PropTypes, classNames} from 'cs-web-components-externals';
import {formatStr} from '../i18n.js';
import {getJSON} from '../fetch.js';
import {prefixNS} from '../helpers.js';
import TextInput from '../formcontrols/TextInput';
import WithTypeAhead from '../formcontrols/WithTypeAhead';
import Immutable from 'immutable';

const term_search_api = '/internal/search/term';

const TypeAheadText = WithTypeAhead(TextInput);

/**
 * +---------------------------+--------+---------+---------------------------------------------------+
 * | Name                      | Type   | Default | Description                                       |
 * +===========================+========+=========+===================================================+
 * | productName               | string | \-      | The brandable product name.                       |
 * +---------------------------+--------+---------+---------------------------------------------------+
 * | searchCallback            | func   | \-      | Callback invoked when enter is pushed.            |
 * +---------------------------+--------+---------+---------------------------------------------------+
 * | searchTextChangedCallback | func   | \-      | Callback invoked when content changes.            |
 * +---------------------------+--------+---------+---------------------------------------------------+
 * | searchText                | string | \-      | Initial content of the search field.              |
 * +---------------------------+--------+---------+---------------------------------------------------+
 * | searchButtonSize          | string | \-      | Size of the search button.                        |
 * +---------------------------+--------+---------+---------------------------------------------------+
 *
 * This component is an extended TextInput component with type ahead feature that accesses the Enterprise Search.
 * It will open a drop down list to show possible options during typing.
 * ``productName`` is inserted into the placeholder of the field.
 *
 * @class SearchField
 * @extends React.Component
 */

function SearchFieldTypeAheadItemRenderer(props) {
    const {inputString, item} = props;
    const lower = inputString.split(' ').pop().toLowerCase();
    let showing = '';
    if (typeof item === 'string') {
        showing = item;
    }
    else {
        showing = item.toString();
    }
    const matchIdx = showing.toLowerCase().indexOf(lower);
    const lengthIdx = matchIdx + lower.length;
    return (
        <span>
            {showing.substring(0, matchIdx)}
            <b>{showing.substring(matchIdx, lengthIdx)}</b>
            {showing.substr(lengthIdx)}
        </span>
    );
}

SearchFieldTypeAheadItemRenderer.propTypes = {
    inputString: PropTypes.string,
    item: PropTypes.oneOfType([PropTypes.string, PropTypes.object])
};

export default class SearchField extends React.Component {

    constructor(props) {
        super(props);
        this.state = {
            currentSearchText: props.searchText,
            currInput: '',
            terms: Immutable.List(),
            focused: false
        };
        this.onSearchTextChanged = this.onSearchTextChanged.bind(this);
        this.searchFieldKeyDown = this.searchFieldKeyDown.bind(this);
        this.searchFieldFocusOut = this.searchFieldFocusOut.bind(this);
        this.searchFieldFocusIn = this.searchFieldFocusIn.bind(this);

        this.stepTerm = this.stepTerm.bind(this);
        this.selectTermAt = this.selectTermAt.bind(this);
        this.cancelTermSelection = this.cancelTermSelection.bind(this);
        this._request = null;
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.searchText !== this.props.searchText) {
            this.setState({currentSearchText: nextProps.searchText});
            this.signalNewSearchText(nextProps.searchText);
        }
    }

    componentWillUnmount() {
        this.cleanRequest();
    }

    cleanRequest() {
        if (this._request) {
            clearTimeout(this._request);
        }
    }

    replaceLastWord(txt, word) {
        if (!txt) {
            return word;
        }

        const words = txt.split(' ');

        if (words.length === 1) {
            return word;
        }
        else {
            words.pop();
            words.push(word);
            return words.join(' ');
        }
    }

    cancelTermSelection() {
        this.setState({currentSearchText: this.state.currInput});
        this.signalNewSearchText(this.state.currInput);
    }

    stepTerm(idx) {
        if (idx >= 0) {
            const term = this.state.terms.get(idx);
            if (term) {
                const txt =
                    this.replaceLastWord(this.state.currentSearchText, term);
                this.setState({currentSearchText: txt});
                this.signalNewSearchText(txt);
            }
        } else {
            this.cancelTermSelection();
        }
    }

    selectTermAt(idx) {
        if (idx >= 0) {
            const term = this.state.terms.get(idx);
            if (term) {
                this.selectTermAndStart(term);
            }
        }
    }

    selectTermAndStart(searchTerm) {
        const searchText = this.replaceLastWord(this.state.currentSearchText, searchTerm);

        this.setState({currentSearchText: searchText});
        this.signalNewSearchText(searchText);
        this.startTermSearch('');

        this.search(searchText);
    }

    lastWord(txt) {
        return txt ? txt.split(' ').pop() : '';
    }

    startTermSearch(searchText) {
        if (this.lastWord(searchText) !== '') {
            const lastWord = this.lastWord(searchText).toLowerCase();
            getJSON(term_search_api, {searchtext: lastWord}).then(
                data => this.setState({
                    terms: Immutable.List(data.result)
                }),
                () => this.setState({
                    terms: this.state.terms.clear()
                })
            );
        } else {
            this.setState({
                terms: this.state.terms.clear()
            });
        }
    }

    searchFieldFocusOut(event) {
        this.startTermSearch('');
        if (this.props.onBlur) {
            this.props.onBlur(event);
        }
        this.setState({focused: false});
    }

    searchFieldFocusIn() {
        this.startTermSearch(this.state.currentSearchText);
        if (this.props.onFocus) {
            this.props.onFocus();
        }
        this.setState({focused: true});
    }

    searchFieldKeyDown(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            this.search();
        }
    }

    onSearchTextChanged(searchText) {
        const {termSearchDelay} = this.props;
        this.cleanRequest();
        this.setState({
            currentSearchText: searchText,
            currInput: searchText
        });
        this.signalNewSearchText(searchText);
        this._request = setTimeout(() =>
            this.startTermSearch(this.state.currentSearchText), termSearchDelay);
    }

    search(searchText = undefined) {
        const searchFor = searchText ? searchText : this.state.currentSearchText;
        this.props.searchCallback(searchFor);
    }

    onSearchRequested(event) {
        event.preventDefault();
        this.search();
    }

    /**
     * If the parent component needs access to the current search text, changes
     * will be signalle through the supplied callback.
     */
    signalNewSearchText(txt) {
        const {searchTextChangedCallback} = this.props;
        if (searchTextChangedCallback) {
            searchTextChangedCallback(txt);
        }
    }

    render() {
        const {className, productName, beforeControl, afterControl} = this.props;
        const clsnames = classNames(prefixNS('search-field'), className);
        const placeholder = !this.state.focused ?
            formatStr('search_for', {product: productName}) : "";
        return (
            <span className={clsnames}>
                <TypeAheadText name="searchText"
                               placeholder={placeholder}
                               value={this.state.currentSearchText}
                               onValueChange={this.onSearchTextChanged}
                               matched={this.state.terms}
                               onTAStepAt={this.stepTerm}
                               onTACancel={this.cancelTermSelection}
                               onSelectAt={this.selectTermAt}
                               onBlur={(event) => {this.searchFieldFocusOut(event)}}
                               onFocus={this.searchFieldFocusIn}
                               onKeyDown={this.searchFieldKeyDown}
                               afterControl={afterControl}
                               beforeControl={beforeControl}
                               TypeAheadItemRenderer={SearchFieldTypeAheadItemRenderer}
                />
            </span>
        );
    }
}

SearchField.propTypes = {
    productName: PropTypes.string.isRequired,
    searchCallback: PropTypes.func.isRequired,
    searchTextChangedCallback: PropTypes.func,
    searchButtonSize: PropTypes.string,
    className: PropTypes.string,
    searchText: PropTypes.string,
    termSearchDelay: PropTypes.number,
    afterControl: PropTypes.node,
    beforeControl: PropTypes.node,
    onFocus: PropTypes.func,
    onBlur: PropTypes.func
};

SearchField.defaultProps = {
    searchButtonSize: null,
    searchText: '',
    termSearchDelay: 300,
    afterControl: null,
    beforeControl: null
};
