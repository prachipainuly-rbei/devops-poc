/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: operations.js 181856 2018-08-08 13:26:19Z gwe $"
 */

import {ReduxSaga} from 'cs-web-components-externals';
import Immutable from 'immutable';
import {getJSON, postJSON} from '../../fetch.js';
import {openTabAsync, navigateTabAsync, closeTabAsync} from '../actions/navigate.js';
import {Console} from '../../helpers.js';
import {
    queryCancel, queryUser, queryDismiss,
    submitValueError, submitGeneralError,
    clearErrors,
    addFiles,
} from '../actions/operations.js';
import {
    operationIsStarting,
    initOperationState, clearOperationState,
    openForm, closeForm, changeFormValues,
    operationSucceeded, operationFailed, operationCancelled,
} from '../../form/actions/form_with_operations.js';
import {ACTIONS, PRESENTATION_ID, TABS} from '../constants.js';
import {callPreSubmitHooks} from '../../form/dialog_hooks.js';
import {
    hasModifiedValues, getMandatoryFields, processNetworkException, selectState
} from '../helpers.js';
import {uploadFiles} from './files.js';
import {OperationMode} from '../../form/constants.js';
import {substitute_link_variables} from '../../helpers.js';
import {setWindowLocation} from '../helpers.js';
import Handlers from '../actions/handlers.js';
import {formatStr} from '../../i18n.js';

/**
 * This module implements the operation execution logic in the front end.
 *
 * It's main entry point is runOperationSaga. The main steps are implemented as
 * sagas themselves:
 *
 * 1. ``startOperation``: Get Operation State and Form data from backend and
 *    initialize frontend state
 * 2. ``execOperation``: Handle form interaction, exec presubmit and submit stage
 * 3. Handle result data by dispatching actions for success, cancellation, and error.
 *
 * @module
 */

const {takeEvery, put, take, call, race} = ReduxSaga.effects;

function logInfo(...rest) {
    Console.log('operations.js:', ...rest);
}

function logError(...rest) {
    Console.error('operations.js:', ...rest);
}

/**
 * Higher Order Selector for Actions on Operation Instances.
 *
 * This Higher Order Function takes an instanceName and creates a
 * selector that will select an action based on the provided
 * instanceName and actionType.
 */
function selectOperationAction(instanceName, actionType) {
    return action => (
        action.type === actionType &&
        action.payload.instanceName === instanceName
    );
}

/**
 * Retrieve the initial operation_state and mask configuration from backend,
 * if available, and initializes the Redux operation-state.
 *
 * @param runOperation payload.
 */
function* startOperationSaga({payload}) {
    const {
        instanceName, parameters, operationInfo, contextObjects, initialFiles, dialog
    } = payload;

    yield put(operationIsStarting(instanceName));

    if (payload.resultInNewTab === TABS.OPEN_ON_RUN) {
        yield put(openTabAsync(instanceName));
    }

    const queryParams = {};

    if (contextObjects) {
        queryParams['object_navigation_id'] =
            contextObjects.map(co => co.get('system:navigation_id')).toJS();
    }
    if (dialog) {
        queryParams['dialog_name'] = dialog;
    }
    if (parameters) {
        queryParams['additional_params'] = JSON.stringify(parameters.toJS());
    }

    try {
        const beState = Immutable.fromJS(yield call(
            getJSON, operationInfo.get('form_url'), queryParams
        ));
        yield put(initOperationState(
            instanceName,
            operationInfo,
            beState,
            {
                contextObjects: payload.contextObjects,
            },
            payload.nonBlocking,
            payload.hasFiles,
        ));

        const feState = yield selectState(instanceName);
        if (feState.get('hasFiles') && initialFiles) {
            // This is mainly used when creating a document/file-based
            // object by dropping files. Needs to be done after operation
            // state is initialized
            yield put(addFiles(instanceName, initialFiles));
        }

        yield put({type: ACTIONS._EXEC_OPERATION, payload});

    } catch (error) {
        yield put({
            type: ACTIONS._FINISH_OPERATION,
            payload: {payload, result: {error: yield call(processNetworkException, error)}},
        });
    }
}

/**
 * Display a FrontendDialog to the user, and wait for one of the possible result.
 *
 * When running submitOperation, the Operations presubmit DialogHooks will be run.
 * If a dialog is configured, it will be displayed to the user by this saga by
 * invoking the queryUser action.
 *
 * The dialog may update an arbitrary attribute value in the operation state,
 * and continue the operation.
 *
 * The dialog component must dispatch one of the following actions to continue
 * operation execution:
 *
 * - queryResultBack: Update attribute, go back to form
 * - queryResultCall: Update attribute, invoke dialog hooks again
 * - queryResultCancel: Cancel operation
 * - queryResultSubmit: Update attribute, submit operation
 *
 */
function* queryUserSaga({payload: {payload, hookResult}}) {
    const {instanceName} = payload;

    yield put(queryUser(instanceName, hookResult.dialog));

    const result = yield race({
        cancel: take(selectOperationAction(instanceName, ACTIONS.QUERY_RESULT_CANCEL)),
        submit: take(selectOperationAction(instanceName, ACTIONS.QUERY_RESULT_SUBMIT)),
        call: take(selectOperationAction(instanceName, ACTIONS.QUERY_RESULT_CALL)),
        back: take(selectOperationAction(instanceName, ACTIONS.QUERY_RESULT_BACK)),
    });

    // TODO move to ConfiguredForm?
    yield put(queryDismiss(instanceName));

    if (result.submit) {
        result.attribute = result.submit.payload.attribute;
    } else if (result.call) {
        result.attribute = result.call.payload.attribute;
    } else if (result.back) {
        result.attribute = result.back.payload.attribute;
    }

    // Update attribute from dialog
    if (result.attribute) {
        const state = yield selectState(payload.instanceName);
        yield put(changeFormValues(
            instanceName,
            {
                values: state.get('values').set(
                    result.attribute.name,
                    result.attribute.value
                )
            }
        ));
    }

    if (result.call) {
        return yield put({type: ACTIONS._PRESUBMIT_OPERATION, payload});
    } else if (result.cancel) {
        return yield put({type: ACTIONS._QUERY_CANCEL_FORM, payload});
    } else if (result.back) {
        return yield put({type: ACTIONS._EXEC_OPERATION, payload});
    }

    return yield put({type: ACTIONS._SUBMIT_OPERATION, payload});
}

function getNextStep(wizardProgress) {
    if (!wizardProgress || wizardProgress.size === 0) {
        return null;
    }

    const nextPosition = wizardProgress.get('position', 0) + 1;
    const nextSteps = wizardProgress.get('steps', Immutable.List()).skip(nextPosition);
    const nextEntry = nextSteps
        .findEntry(step => step.get('dialog_link') && step.get('kind', -1) > -1);
    if (!nextEntry) {
        return null;
    }
    return [nextEntry[0] + nextPosition, nextEntry[1]];
}

function* loadNextPage(instanceName, state, wizardProgress) {
    const nextPage = getNextStep(wizardProgress);
    if (!nextPage) {
        return false;
    }

    const [nextPosition, nextStep] = nextPage;
    const nextDialog = Immutable.fromJS(yield call(
        postJSON,
        nextStep.get('dialog_link'),
        {
            wizard_progress: wizardProgress.toJS(),
            obj_values: state.get('values').toJS(),
            operation_state: state.get('operationState').toJS(),
        },
    ));

    const nextOperationState = nextDialog.get('operation_state');
    const nextValues = state.get('values')
                            .merge(nextDialog.get('values'))
                            .mergeWith(old => old,
                                       nextOperationState
                                           .get('json_field_types')
                                           .mapEntries(e => [e[0], '']));
    yield put(changeFormValues(
        instanceName,
        {
            registers: nextDialog.get('registers'),
            operationState: nextOperationState,
            wizardProgress: wizardProgress.set('position', nextPosition)
                                          .set('button_label', nextStep.get('button_label')),
            dialogHooks: nextDialog.get('dialog_hooks'),
            values: nextValues
        }
    ));

    return true;
}

function* queryCancelFormSaga({payload}) {
    const {instanceName} = payload;

    let result = {cancel: {}};
    if (hasModifiedValues(yield selectState(instanceName))) {
        yield put(queryCancel(instanceName));

        result = yield race({
            cancel: take(selectOperationAction(instanceName, ACTIONS.QUERY_CANCEL_FORCE)),
            back: take(selectOperationAction(instanceName, ACTIONS.QUERY_CANCEL_BACK)),
        });
    }

    if (result.cancel) {
        yield put({type: ACTIONS._FINISH_OPERATION, payload: {payload, result}});
    } else {
        yield put({type: ACTIONS._EXEC_OPERATION, payload});
    }
}

/**
 * Executes Presubmit Stage. Returns an object that is analyzed for
 * control flow. This may either return to form execution stage,
 * yield an error, cancel the operation, or cause execOperation to
 * continue with submit stage.
 *
 * 1. Check form for missing values for mandatory fields. If this fails
 *    the user is notified, and form execution continues.
 * 2. Call presubmit hooks and evaluate results:
 *
 *    - Dialog Hooks yield errors
 *    - Dialog Hooks query the user
 *    - Wizard Logic: Replace form data in state with return values
 *      from dialog hook.
 *
 * 3. Wizard Logic: Retrieve a new form from backend and replace
 *    form data in state.
 */
function* execPresubmitSaga({payload}) {
    // Run in a loop as dialog hooks may cause operation to re-enter presubmit.
    const state = yield selectState(payload.instanceName);

    // remove outdated errors
    yield put(clearErrors(payload.instanceName));

    // 1. Check missing fields
    const missingFields = getMandatoryFields(state);
    if (missingFields.size !== 0) {
        yield put(submitValueError(
            payload.instanceName,
            missingFields.map(field => Immutable.Map({field, type: 'mandatory'}))
        ));

        return yield put({type: ACTIONS._EXEC_OPERATION, payload});
    }

    try {
        // 2. Call presubmit hooks
        const hookResult = yield call(
            callPreSubmitHooks,
            state.get('dialogHooks'),
            {
                currValues: state.get('values'),
                registers: state.get('registers'),
                operationState: state.get('operationState'),
                wizardProgress: state.get('wizardProgress'),
            }
        );

        if (hookResult.errors.length > 0) {
            // 2.1 Display Errors & Continue Operation
            yield put(submitGeneralError(
                payload.instanceName,
                Immutable.fromJS(hookResult.errors),
            ));
            return yield put({type: ACTIONS._EXEC_OPERATION, payload});
        }

        if (hookResult.dialog) {
            return yield put({
                type: ACTIONS._QUERY_USER,
                payload: {payload, hookResult}
            });
        }

        if (hookResult.next_dialog) {
            // 2.3 Execute Wizard Logic
            const wizardProgress = hookResult.wizard_progress;
            yield put(changeFormValues(
                payload.instanceName,
                {
                    registers: Immutable.fromJS(hookResult.next_dialog.registers),
                    operationState: Immutable.fromJS(hookResult.next_dialog.operation_state),
                    values: state.get('values').merge(hookResult.next_dialog.values),
                    dialogHooks: Immutable.fromJS(hookResult.next_dialog.dialog_hooks),
                    wizardProgress: wizardProgress.set(
                        'position',
                        wizardProgress.get('position', 0) + 1
                    ),
                },
            ));
            return yield put({type: ACTIONS._EXEC_OPERATION, payload});
        }


        // 3. Execute Wizard Logic
        const wizardProgress = hookResult.wizard_progress || state.get('wizardProgress');
        if (yield call(loadNextPage, payload.instanceName, state, wizardProgress)) {
            return yield put({type: ACTIONS._EXEC_OPERATION, payload});
        }
    } catch (error) {
        const mError = yield call(processNetworkException, error);

        const errorMessage = (
            mError.json ?
            {
                title: formatStr(  //mError.json.explanation is not i18ned
                    'op_start_failed',
                    {opname: "Presubmit Hook"}
                ),
                message: mError.json.detail || mError.json.message
            } : {
                title: formatStr(  //mError.json.explanation is not i18ned
                    'op_start_failed',
                    {opname: "Presubmit Hook"}
                ),
                message: formatStr('dialog_unspecified_hook_error'),
            }
        );
        yield put(submitGeneralError(payload.instanceName, Immutable.fromJS([errorMessage])));

        return yield put({type: ACTIONS._EXEC_OPERATION, payload});
    }

    return yield put({type: ACTIONS._SUBMIT_OPERATION, payload});
}

/**
 * Submit a running operation.
 *
 * @param payload - the payload provided to runOperation.
 * @param newState - the current operation state.
 */
function* submitOperationSaga({payload}) {
    const state = yield selectState(payload.instanceName);

    if (!state.get('pendingChecks').isEmpty()) {
        return yield put({type: ACTIONS._EXEC_OPERATION, payload});
    }

    try {
        const result = {
            submit: yield call(
                postJSON,
                payload.operationInfo.get('submit_url'),
                {
                    object_navigation_id:
                                         payload.contextObjects
                                                .map(co => co.get('system:navigation_id')).toJS(),
                    operation_state: state.get('operationState').toJS(),
                    values: state.get('values').toJS(),
                }
            )
        };

        if (state.get('hasFiles')) {
            return yield put({type: ACTIONS._UPLOAD_FILES, payload: {payload, result}});
        }

        return yield put({type: ACTIONS._FINISH_OPERATION, payload: {payload, result}});

    } catch (error) {
        logError('Error on submit.', error);

        const {operationInfo} = payload;
        const mError = yield call(processNetworkException, error);
        // If back_to_dialog is set, the form should handle the error.
        if (mError.json && mError.json.back_to_dialog) {
            yield put(submitGeneralError(
                payload.instanceName,
                Immutable.fromJS([{
                    title: formatStr(  // mError.json.explanation is not i18ned
                        'op_start_failed',
                        {opname: `${operationInfo.get('label')}`}
                    ),
                    message: mError.json.detail || error.json.message,
                }]),
            ));

            return yield put({type: ACTIONS._EXEC_OPERATION, payload});
        }

        return yield put({
            type: ACTIONS._FINISH_OPERATION,
            payload: {payload, result: {error: mError}}
        });
    }
}

function* uploadFilesSaga({payload: {payload, result}}) {
    const state = yield selectState(payload.instanceName);
    if (state.get('hasFiles')) {
        result.submit.files = yield call(
            uploadFiles,
            result.submit.object,
            state.get('files'),
        );
    }
    yield put({type: ACTIONS._FINISH_OPERATION, payload: {payload, result}});
}

/**
 * Display a form and wait for either submit or cancel. CHANGE_OPERATION_VALUES
 * events are handled in ``form.js:changeFormSaga``.
 */
function* execFormSaga({payload}) {
    const {instanceName} = payload;

    yield put(openForm(instanceName));

    // ... wait for submit or cancel
    const result = yield race({
        submit: take(selectOperationAction(instanceName, ACTIONS.SUBMIT_OPERATION)),
        cancel: take(selectOperationAction(instanceName, ACTIONS.CANCEL_OPERATION)),
    });

    // If cancel is not forced and values have changed we query the user.
    if (result.cancel) {
        if (result.cancel.payload.force) {
            return yield put({type: ACTIONS._FINISH_OPERATION, payload: {payload, result}});
        }

        return yield put({type: ACTIONS._QUERY_CANCEL_FORM, payload});
    }

    if (payload.resultInNewTab === TABS.OPEN_ON_SUBMIT) {
        yield put(openTabAsync(payload.instanceName));
    }

    return yield put({type: ACTIONS._PRESUBMIT_OPERATION, payload});
}

/**
 * Runs in a loop executing the frontend logic for the operation.
 * Each iteration, the saga
 *
 * 1. waits till the user submits or cancels the form. This may
 *    either cancel or continue the operation or reinitiate form interation
 *    (See ``getOperationValues`` saga).
 * 2. executes the presubmit stage (containing form validation, dialog hooks and
 *    wizard logic) This may either cancel or continue the operation or reinitiate
 *    form interation (See ``execPresubmit`` saga).
 * 3. finally submit the operation state to the backend for operation execution.
 *    This may either return to the form (when asynchronuous form checks are still
 *    pending), signal an error or return a result. (See ``execSubmit`` saga).
 */
function* execOperationSaga({payload}) {
    const {instanceName} = payload;
    const state = yield selectState(instanceName);

    // If we have registers to display, display form and ...
    if ((state.get('registers').size || payload.forceHandler) && !payload.suppressHandler) {
        return yield put({type: ACTIONS._EXEC_FORM, payload});
    }

    return yield put({type: ACTIONS._PRESUBMIT_OPERATION, payload});
}

function* isOperationRunning(payload) {
    // Check if instance is already running an operation
    const state = yield selectState(payload.instanceName);
    return state.get('mode') !== OperationMode.INITIAL;
}

/**
 * If targetUrl is set the operation will be run in
 * legacy mode, by navigating to the provided CDB-URL.
 */
function* runHybridOperation(payload) {
    const {operationInfo} = payload;
    const targetUrl = operationInfo.get('target_url');
    if (!targetUrl) {
        return false;
    }

    const hybridOpLink = yield call(
        substitute_link_variables,
        targetUrl,
        payload.contextObjects.get(0));
    yield call(setWindowLocation, window, hybridOpLink);
    return true;
}

function checkOperationParams(payload) {
    // Check if parametrization is valid, and issue an error if not.
    if (payload.operationInfo === undefined) {
        Console.error('You must provide an operationInfo object to runOperation');
        return false;
    }

    return true;
}

/**
 * Top-level entry point for running operations.
 *
 * This initializes and executes an operation, and
 * dispatches the provided result handlers.
 *
 * See operations/actions/operations.js for a description
 * of the structure of payload.
 */
function* runOperationSaga({payload}) {
    const config = yield call(applySpecialCases, payload);

    // Check If Parameters are valid
    if (!checkOperationParams(config)) {
        return;
    }

    // Try to run hybrid operation, must be configured
    // in Operation Configuration
    if (yield call(runHybridOperation, config)) {
        return;
    }

    // Check if this instance is already running an operation
    if (yield call(isOperationRunning, config)) {
        return;
    }

    yield put({type: ACTIONS._START_OPERATION, payload: config});
}

function* dispatchResultToStore(payload, result) {
    if (result.submit) {
        yield put(operationSucceeded(payload.instanceName));
    } else if (result.error) {
        yield put(operationFailed(payload.instanceName));
    } else if (result.cancel) {
        yield put(operationCancelled(payload.instanceName));
    }
}

function* dispatchResultHandlers(payload, actions, additionalValues = {}) {
    for (const action of actions) {
        const _action = {...action};
        _action.payload.operation = Object.assign(
            {
                instanceName: payload.instanceName,
                info: payload.operationInfo,
            },
            additionalValues,
        );
        yield put(_action);
    }
}

function* dispatchAllResultHandlers(payload, result) {
    if (result.submit) {
        logInfo('Operation submitted.', result);

        if (payload.resultInNewTab) {
            yield put(navigateTabAsync(payload.instanceName, result.submit.ui_link));
        }

        yield call(
            dispatchResultHandlers,
            payload,
            payload.successActions,
            {result: result.submit}
        );
    } else if (result.error) {
        logInfo('Operation failed.', result);

        if (payload.resultInNewTab) {
            yield put(closeTabAsync(payload.instanceName));
        }

        yield call(
            dispatchResultHandlers,
            payload,
            payload.failedActions,
            {error: result.error}
        );
    } else if (result.cancel) {
        logInfo('Operation cancelled.', result);

        if (payload.resultInNewTab) {
            yield put(closeTabAsync(payload.instanceName));
        }

        yield call(
            dispatchResultHandlers,
            payload,
            payload.cancelActions
        );
    }

    yield call(
        dispatchResultHandlers,
        payload,
        payload.generalActions,
        {result}
    );
}

function* closeFormSaga({instanceName}) {
    const operationState = yield selectState(instanceName);
    if (operationState.get('displayForm')) {
        yield put(closeForm(instanceName));
    }
}

function* finishOperationSaga({payload: {payload, result}}) {
    yield call(closeFormSaga, payload);
    yield call(dispatchResultToStore, payload, result);
    yield call(dispatchAllResultHandlers, payload, result);
    yield put(clearOperationState(payload.instanceName));
}

function applySpecialCases(conf) {
    return Object.assign(conf, {
        // display id ``navigate-new-tab`` indicates operation has no form and should display
        // result in new tab
        resultInNewTab: conf.operationInfo.get('presentation_id') === PRESENTATION_ID.NEW_TAB ?
                        TABS.OPEN_ON_RUN :
                        conf.resultInNewTab,
        // display id ``delete`` - indicating CDB_Delete - uses a special OperationHandler, but
        // has no form. Force displayForm call.
        forceHandler: conf.operationInfo.get('presentation_id') === PRESENTATION_ID.DELETE ?
                      true :
                      conf.forceHandler,
        // display id ``no-form`` suppresses call to displayForm, even if a form is configured.
        suppressHandler: conf.operationInfo.get('presentation_id') === PRESENTATION_ID.NO_FORM ?
                         true :
                         conf.suppressHandler,
        // display id ``delete`` removes the object.
        // Install special success action for CDB_Delete if we are on the objects detail page.
        successActions: conf.operationInfo.get('presentation_id') === PRESENTATION_ID.DELETE &&
                        conf.contextObjects
                            .map(co => co.get('system:ui_link'))
                            .contains(window.location.href) ?
                        [Handlers.navigate('/')] :
                        conf.operationInfo.get('presentation_id') === PRESENTATION_ID.NEW_TAB ?
                        [] :
                        conf.successActions,

        // Hack for enabling classes with attached files only for document and model
        // This is a workaround until File-Upload in Operations is fully supported,
        // see E046186
        hasFiles: ['document', 'model'].includes(conf.operationInfo.get('classname')) &&
                  conf.operationInfo.get('opname') === 'CDB_Create',
    });
}

export default function* setupSagas() {
    yield takeEvery(ACTIONS.RUN_OPERATION, runOperationSaga);
    yield takeEvery(ACTIONS._START_OPERATION, startOperationSaga);
    yield takeEvery(ACTIONS._EXEC_OPERATION, execOperationSaga);
    yield takeEvery(ACTIONS._EXEC_FORM, execFormSaga);
    yield takeEvery(ACTIONS._QUERY_CANCEL_FORM, queryCancelFormSaga);
    yield takeEvery(ACTIONS._PRESUBMIT_OPERATION, execPresubmitSaga);
    yield takeEvery(ACTIONS._QUERY_USER, queryUserSaga);
    yield takeEvery(ACTIONS._SUBMIT_OPERATION, submitOperationSaga);
    yield takeEvery(ACTIONS._UPLOAD_FILES, uploadFilesSaga);
    yield takeEvery(ACTIONS._FINISH_OPERATION, finishOperationSaga);
}
