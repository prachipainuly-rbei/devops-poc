/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Calendar.jsx 182712 2018-08-23 12:56:06Z vov $"
 */

import React from 'react';
import {storiesOf} from 'cs-web-components-storybook';
import {FormControl} from 'cs-web-components-base';
import Immutable from 'immutable';
import moment from 'moment';
import {PropTypes} from 'cs-web-components-externals';
import CalendarSimpleConverter from '../../types/CalendarSimpleConverter';

class Calendar extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            value: ''
        };
        this.onDateChange = this.onDateChange.bind(this);
    }

    onDateChange(value) {
        this.setState({value: value});
        this.props.onDateChange && this.props.onDateChange(value);
    }

    render() {
        return (
            <FormControl.Calendar
                {...this.props}
                value={this.state.value}
                onDateChange={this.onDateChange}/>
        );
    }
}

Calendar.propTypes = {
    onDateChange: PropTypes.func
};

class CalendarAllowExpression extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            value: ''
        };
        this.onDateChange = this.onDateChange.bind(this);
    }

    onDateChange(value) {
        this.setState({value: value});
        this.props.onDateChange && this.props.onDateChange(value);
    }

    render() {
        return (
            <FormControl.Calendar
                {...this.props}
                allowExpression={true}
                value={this.state.value}
                onDateChange={this.onDateChange}/>
        );
    }
}

CalendarAllowExpression.propTypes = {
    onDateChange: PropTypes.func
};

class CalendarHandleInvalidInput extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            value: ''
        };
        this.onDateChange = this.onDateChange.bind(this);
        this.onInvalidInput = this.onInvalidInput.bind(this);
    }

    onDateChange(value) {
        this.setState({value: value});
        this.props.onDateChange && this.props.onDateChange(value);
    }

    onInvalidInput(value) {
        this.setState({value: value});
        // This component should handle the invalid input, e.g. show notification etc.
        this.props.onInvalidInput && this.props.onInvalidInput(value);
    }

    render() {
        return (
            <FormControl.Calendar
                {...this.props}
                valueFormat={"DD.MM.YYYY"}
                displayFormat={"YYYY-MM-DD"}
                value={this.state.value}
                onDateChange={this.onDateChange}
                onInvalidInput={this.onInvalidInput}/>
        );
    }
}

CalendarHandleInvalidInput.propTypes = {
    onDateChange: PropTypes.func,
    onInvalidInput: PropTypes.func
};

const CalendarWithTypeAhead = FormControl.WithTypeAhead(FormControl.Calendar);
const DATEONLYFORMAT = "DD.MM.YYYY";
const DISPLAYFORMAT = "DD.MM.YYYY HH:mm:ss";
const DISPLAYFORMAT2 = "YYYY-MM-DD";
const itemList = Immutable.List(['11.11.2011', '23.04.1978', '25.06.1987']);
const valueList = itemList.map(d => moment(d, DATEONLYFORMAT).format());
class CalendarTypeAhead extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            value: '',
            matches: Immutable.List()
        };
        this.onChange = this.onChange.bind(this);
        this.onDateChange = this.onDateChange.bind(this);
        this.onSelectAt = this.onSelectAt.bind(this);
    }

    onChange(event) {
        const value = event.target.value;
        this.setState({
            value: value,
            matches: this.matchValues(value)
        });
        if (this.props.onChange) {
            event.persist();
            this.props.onChange(event);
        }
    }

    onDateChange(value) {
        this.setState({
            value: value,
        });
        this.props.onDateChange && this.props.onDateChange(value);
    }

    onSelectAt(idx) {
        const hit = this.state.matches.get(idx);
        const oriIdx = itemList.indexOf(hit);
        this.setState({
            value: valueList.get(oriIdx),
            matches: this.matchValues(hit)
        });
    }

    matchValues(value) {
        return itemList.filter(
            item => value !== '' && item.indexOf(value) > -1);
    }

    render() {
        return (
            <CalendarWithTypeAhead
                {...this.props}
                value={this.state.value}
                matched={this.state.matches}
                onChange={this.onChange}
                onDateChange={this.onDateChange}
                onSelectAt={this.onSelectAt}/>
        );
    }
}

CalendarTypeAhead.propTypes = {
    onDateChange: PropTypes.func,
    onChange: PropTypes.func
};

storiesOf('Form Control', {})
    .addWithInfo(
        'Calendar',
        `
            This is subtitle
        `,
        () => (
            <Calendar name="CalendarDemo"
                      displayFormat={DISPLAYFORMAT}
                      dateOnlyFormat={DATEONLYFORMAT}
                      onDateChange={() => {}}
                      onChange={() => {}}
                      onInvalidInput={() => {}}
            />
        ),
        {inline: true, propTables: [FormControl.Calendar]}
    );

storiesOf('Form Control', {}).addWithInfo(
    'Calendar allows expression',
    `
        This is subtitle
    `,
    () => (
        <CalendarAllowExpression
            name="CalendarAllowExpressionDemo"
            displayFormat={DISPLAYFORMAT}
            dateOnlyFormat={DATEONLYFORMAT}
            onDateChange={() => {}}
            onChange={() => {}}
            onInvalidInput={() => {}}
        />
    ),
    {inline: true, propTables: [FormControl.Calendar]}
);

storiesOf('Form Control', {}).addWithInfo(
    'Calendar allows expression 2',
    `
        This is subtitle
    `,
    () => (
        <CalendarAllowExpression
            name="CalendarAllowExpression2Demo"
            displayFormat={DISPLAYFORMAT2}
            dateOnlyFormat={DISPLAYFORMAT2}
            valueFormat={DATEONLYFORMAT}
            onDateChange={() => {}}
            onChange={() => {}}
            onInvalidInput={() => {}}
        />
    ),
    {inline: true, propTables: [FormControl.Calendar]}
);

storiesOf('Form Control', {}).addWithInfo(
    'Calendar allows expression Simple',
    `
        This is subtitle
    `,
    () => (
        <CalendarAllowExpression
            name="CalendarAllowExpressionSimple"
            displayFormat={DISPLAYFORMAT2}
            dateOnlyFormat={DISPLAYFORMAT2}
            valueFormat={DATEONLYFORMAT}
            onDateChange={() => {}}
            onChange={() => {}}
            onInvalidInput={() => {}}
            dateConverter={CalendarSimpleConverter}
        />
    ),
    {inline: true, propTables: [FormControl.Calendar]}
);

storiesOf('Form Control', {}).addWithInfo(
    'Calendar handles invalid inputs',
    `
        This is subtitle
    `,
    () => (
        <CalendarHandleInvalidInput
                  name="CalendarInvalidInputDemo"
                  displayFormat={DISPLAYFORMAT}
                  dateOnlyFormat={DATEONLYFORMAT}
                  onDateChange={() => {}}
                  onChange={() => {}}
                  onInvalidInput={() => {}}
        />
    ),
    {inline: true, propTables: [FormControl.Calendar]}
);

storiesOf('Form Control', {}).addWithInfo(
    'Calendar with TypeAhead',
    `
        The <Calendar> can be used with a HOC \`WithTypeAhead\`. Then
           it gains the type ahead feature.

        ~~~js
        const CalendarWithTypeAhead = FormControl.WithTypeAhead(FormControl.Calendar);
        const DATEONLYFORMAT = "DD.MM.YYYY";
        const DISPLAYFORMAT = "DD.MM.YYYY HH:mm:ss";
        const itemList = Immutable.List(['11.11.2011', '23.04.1978', '25.06.1987']);
        const valueList = itemList.map(d => moment(d, DATEONLYFORMAT).format());
        class CalendarTypeAhead extends React.Component {
            constructor(props) {
                super(props);
                this.state = {
                    value: undefined,
                    matches: Immutable.List()
                };
                this.onChange = this.onChange.bind(this);
                this.onDateChange = this.onDateChange.bind(this);
                this.onSelectAt = this.onSelectAt.bind(this);
            }

            onChange(event) {
                const value = event.target.value;
                this.setState({
                    value: value,
                    matches: this.matchValues(value)
                });
                if (this.props.onChange) {
                    event.persist();
                    this.props.onChange(event);
                }
            }

            onDateChange(value) {
                this.setState({
                    value: value,
                });
                this.props.onDateChange && this.props.onDateChange(value);
            }

            onSelectAt(idx) {
                const hit = this.state.matches.get(idx);
                const oriIdx = itemList.indexOf(hit);
                this.setState({
                    value: valueList.get(oriIdx),
                    matches: this.matchValues(hit)
                });
            }

            matchValues(value) {
                return itemList.filter(
                    item => value !== '' && item.indexOf(value) > -1);
            }

            render() {
                return (
                    <CalendarWithTypeAhead
                        {...this.props}
                        value={this.state.value}
                        matched={this.state.matches}
                        onChange={this.onChange}
                        onDateChange={this.onDateChange}
                        onSelectAt={this.onSelectAt}/>
                );
            }
        }
        ~~~
    `,
    () => {
        return (
            <CalendarTypeAhead name="CalendarTypeAheadDemo"
                               displayFormat={DISPLAYFORMAT}
                               dateOnlyFormat={DATEONLYFORMAT}
                               onDateChange={() => {}}
                               onChange={() => {}}
                               onInvalidInput={() => {}}
            />
        );

    },
    {inline: true, propTables: [FormControl.Calendar, CalendarWithTypeAhead]}
);
