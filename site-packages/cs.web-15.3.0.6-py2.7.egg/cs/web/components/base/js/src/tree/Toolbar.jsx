/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Toolbar.jsx 174898 2018-03-22 14:54:34Z sla $"
 */

import React from 'react';
import {formatStr} from '../i18n';
import {InputGroup, FormControl} from 'react-bootstrap';
import Button from '../components/Button';
import ButtonToolbar from '../components/ButtonToolbar.jsx';
import {MenuItem} from 'react-bootstrap';
import {PropTypes} from 'cs-web-components-externals';
import Icon from '../components/Icon.jsx';
import {prefixNS} from '../helpers';

import csweb_search_icon_svg from '../../../resources/cis_search_primary.svg';
import csweb_remove from '../../../resources/cis_remove_danger.svg';
import csweb_menu_up from '../../../resources/cis_chevron-up.svg';
import csweb_menu_down from '../../../resources/cis_chevron-down.svg';

export const SEARCH_MODE_TYPE_AHEAD = "search_mode_type_ahead";
export const SEARCH_MODE_CONFIRM = "search_mode_confirm";

const SEARCH_STATE_INACTIVE = 0;
const SEARCH_STATE_SEARCH = 1;
const SEARCH_STATE_RESULTS = 2;

// TODO move css classes out of 'src/tree/tree.css'

export class ToolbarSearch extends React.Component {
    constructor(props) {
        super(props);

        this.onSearchTermChanged = this.onSearchTermChanged.bind(this);
        this.onPreviousResult = this.onPreviousResult.bind(this);
        this.onNextResult = this.onNextResult.bind(this);
        this.onSubmitSearch = this.onSubmitSearch.bind(this);
        this.onSearchKeyPress = this.onSearchKeyPress.bind(this);
        this.setSearchStateActive = this.setSearchStateActive.bind(this);
        this.setSearchStateResults = this.setSearchStateResults.bind(this);
        this.setSearchStateInactive = this.setSearchStateInactive.bind(this);
        this.setSearchTerm = this.setSearchTerm.bind(this);
        this.clearSearchResult = this.clearSearchResult.bind(this);
        this.state = {
            searchState: SEARCH_STATE_INACTIVE,
            searchTerm: '',
            previousResult: false,
            nextResult: false,
            selectedResult: undefined,
            resultCount: undefined,
            searchIsRunning: false
        };
    }

    componentWillReceiveProps() {
        this.setState(this.props.getNavigationState());
    }

    setSearchState(newState) {
        const oldState = this.state.searchState;
        this.setState({
            searchState: newState
        }, () => {
            if (this.inputField) {
                this.inputField.focus();
            }
        });

        if (newState === SEARCH_STATE_INACTIVE) {
            // Entering inactive
            this.setState({
                searchTerm: ''
            });
        }

        if (oldState === SEARCH_STATE_RESULTS && newState !== SEARCH_STATE_RESULTS) {
            // Leaving results
            this.props.onClearResults();
        } else if (newState === SEARCH_STATE_RESULTS) {
            // Entering results
            if (this.props.searchMode === SEARCH_MODE_CONFIRM) {
                this.props.onSendQuery(this.state.searchTerm)
                    .then(() => this.setState(this.props.getNavigationState()));
            }
        }
    }

    setSearchStateActive() {
        this.setSearchState(
            this.props.searchMode === SEARCH_MODE_TYPE_AHEAD ?
            SEARCH_STATE_RESULTS :
            SEARCH_STATE_SEARCH
        );
    }

    setSearchStateResults() {
        this.setSearchState(SEARCH_STATE_RESULTS);
    }

    setSearchStateInactive() {
        this.setSearchState(SEARCH_STATE_INACTIVE);
    }

    clearSearchResult() {
        this.setSearchTerm('');
    }

    onSubmitSearch(event) {
        event.preventDefault();
        switch (this.state.searchState) {
            case SEARCH_STATE_SEARCH:
                this.setSearchState(SEARCH_STATE_RESULTS);
                break;
            case SEARCH_STATE_RESULTS:
                this.onNextResult();
                break;
        }
    }

    onSearchTermChanged(event) {
        return this.setSearchTerm(event.target.value);
    }

    setSearchTerm(searchTerm) {
        this.setState({
            searchTerm: searchTerm
        });

        if (this.props.searchMode === SEARCH_MODE_TYPE_AHEAD) {
            this.props.onSendQuery(searchTerm)
                .then(() => this.setState(this.props.getNavigationState()));
        } else {
            if (this.state.searchState === SEARCH_STATE_RESULTS) {
                this.setSearchState(SEARCH_STATE_SEARCH);
            }
        }

    }

    onPreviousResult() {
        this.props.onPreviousResult()
            .then(() => this.setState(this.props.getNavigationState()));
    }

    onNextResult() {
        this.props.onNextResult()
            .then(() => this.setState(this.props.getNavigationState()));
    }

    onSearchKeyPress(event) {
        switch (event.keyCode) {
            case 13:
                this.setSearchState(SEARCH_STATE_RESULTS);
                break;
        }
    }

    onResultKeyPress(event) {
        switch (event.keyCode) {
            case 27:
                this.setSearchTerm('');
                break;
            case 38:
                this.onPreviousResult();
                break;
            case 13:
            case 40:
                this.onNextResult();
                break;
        }
    }

    render() {
        // TODO formatStr needs i18n'ed parameter
        this.inputField = null;
        return this.state.searchState === SEARCH_STATE_INACTIVE ?
               (
                   <Button.IconButton iconSrc={csweb_search_icon_svg}
                                      buttonStyle="primary"
                                      title={formatStr('tree_search_tooltip')}
                                      onClick={this.setSearchStateActive} />
               ) :
               this.state.searchState === SEARCH_STATE_SEARCH ?
               (
                   <div className={prefixNS("ToolbarSearchWrapper")}>
                       <InputGroup className={prefixNS("toolbar-search")}>
                           <FormControl inputRef={c => {this.inputField = c}}
                                        onKeyDown={this.onSearchKeyPress}
                                        type="text"
                                        label={"Foofoo"}
                                        placeholder={formatStr("search_for", {product: ""})}
                                        value={this.state.searchTerm}
                                        tabIndex={this.props.tabIndex}
                                        onChange={this.onSearchTermChanged} />
                           <InputGroup.Button>
                               <Button.IconButton onClick={this.state.searchTerm ?
                                                           this.setSearchStateResults :
                                                           undefined}
                                                  disabled={this.state.searchTerm === ''}
                                                  buttonStyle="primary"
                                                  title={formatStr('tree_search_tooltip')}
                                                  iconSrc={csweb_search_icon_svg}
                                                  size="sm"/>
                               <Button.IconButton onClick={this.setSearchStateInactive}
                                                  buttonStyle="danger"
                                                  title={formatStr('tree_search_close_tooltip')}
                                                  iconSrc={csweb_remove}
                                                  size="sm" />
                           </InputGroup.Button>
                       </InputGroup>
                   </div>
               ) :
               this.state.searchState === SEARCH_STATE_RESULTS ?
               (
                   <div className={prefixNS("ToolbarSearchWrapper")}>
                       <InputGroup className={this.state.resultCount === 0 ?
                                              prefixNS("toolbar-search") + ' bg-danger' :
                                              prefixNS("toolbar-search")}>
                           <FormControl inputRef={c => {this.inputField = c}}
                                        onKeyDown={this.onResultKeyPress.bind(this)}
                                        type="text"
                                        label={"Foofoo"}
                                        placeholder={"Enter search"}
                                        value={this.state.searchTerm}
                                        tabIndex={this.props.tabIndex}
                                        onChange={this.onSearchTermChanged} />
                           <InputGroup.Button>
                               <Button.IconButton disabled={this.state.previousResult ?
                                                            false : true}
                                                  buttonStyle="primary"
                                                  title={formatStr('tree_search_previous_tooltip')}
                                                  onClick={this.state.previousResult ?
                                                           this.onPreviousResult :
                                                           undefined}
                                                  iconSrc={csweb_menu_up} />
                               <Button.IconButton disabled={this.state.nextResult ?
                                                            false : true}
                                                  buttonStyle="primary"
                                                  title={formatStr('tree_search_next_tooltip')}
                                                  onClick={this.state.nextResult ?
                                                           this.onNextResult :
                                                           undefined}
                                                  iconSrc={csweb_menu_down} />
                               <Button.IconButton onClick={this.clearSearchResult}
                                                  buttonStyle="danger"
                                                  title={formatStr('tree_search_close_tooltip')}
                                                  iconSrc={csweb_remove} />
                           </InputGroup.Button>
                       </InputGroup>
                   </div>
               ) : null;
    }
}

/*
   Indicator:

   <span className={prefixNS("ToolbarSearchWrapper__indicator")}>
   {(this.state.selectedResult === undefined ?
   '?' :
   String(this.state.selectedResult)) +
   '/' +
   (this.state.resultCount === undefined ?
   '?' :
   String(this.state.resultCount))}
   </span>

 */

ToolbarSearch.propTypes = {
    searchMode: PropTypes.oneOf([SEARCH_MODE_TYPE_AHEAD, SEARCH_MODE_CONFIRM]),
    tabIndex: PropTypes.number,
    getNavigationState: PropTypes.func.isRequired,
    onSendQuery: PropTypes.func.isRequired,
    onClearResults: PropTypes.func.isRequired,
    onNextResult: PropTypes.func.isRequired,
    onPreviousResult: PropTypes.func.isRequired
};

/**
 * The SearchAdapter provides an interface for use with the
 * ToolbarSearch Widget.
 * Pass an object confirming to this proptype as a property
 * to ToolbarSearchWithAdapter.
 *
 * @private
 */
const SearchAdapter = PropTypes.shape(
    {
        getNavigationState: PropTypes.func.isRequired,
        onSendQuery: PropTypes.func.isRequired,
        onClearResults: PropTypes.func.isRequired,
        onNextResult: PropTypes.func.isRequired,
        onPreviousResult: PropTypes.func.isRequired
    }
);

export class ToolbarSearchWithAdapter extends React.Component {
    render() {
        return (
            <ToolbarSearch searchMode={this.props.searchMode}
                           getNavigationState={this.props.searchAdapter.getNavigationState}
                           onSendQuery={this.props.searchAdapter.onSendQuery}
                           onPreviousResult={this.props.searchAdapter.onPreviousResult}
                           onNextResult={this.props.searchAdapter.onNextResult}
                           onClearResults={this.props.searchAdapter.onClearResults} />
        );
    }
}

ToolbarSearchWithAdapter.propTypes = {
    searchMode: PropTypes.oneOf([SEARCH_MODE_TYPE_AHEAD, SEARCH_MODE_CONFIRM]),
    searchAdapter: SearchAdapter.isRequired
};

const toolbarWidgetRegistry = {
    search: function search(index, config) {
        return (
            <ToolbarSearchWithAdapter
                key={index}
                searchMode={config["mode"]}
                searchAdapter={config["adapter"]} />
        );
    },
    button: function button(index, config) {
        if (config.iconSrc) {
            return (
                <Button.IconButton key={index}
                                   title={config.title}
                                   buttonStyle={config.style}
                                   iconSrc={config.iconSrc}
                                   onClick={config.func} />
            );
        }
        return (
            <Button.IconButton key={index}
                               title={config.title}
                               buttonStyle={config.style}
                               iconName={config.icon}
                               onClick={config.func} />
        );
    },
    menu: function menu(index, config) {
        return (
            <Button.DropdownIconButton key={index} id="file_actions"
                                       buttonStyle={config.style}
                                       iconName={config.icon}
                                       noCaret pullRight>
                {config.conf.map(
                     (itemConfig, index) =>
                         toolbarWidgetRegistry[itemConfig.type](index, itemConfig))
                }
            </Button.DropdownIconButton>
        );
    },
    item: function item(index, config) {
        return (
            <MenuItem key={index} onClick={config.func}>
                <Icon name={config.icon} size="sm" />
                {" " + config.title}
            </MenuItem>
        );
    }
};

/**
 * Types
 * -----
 *
 * Search Widget:
 *
 * .. code-block:: javascript
 *
 *   {
 *     type: "search"
 *     adapter: SearchAdapter instance
 *     mode: SEARCH_MODE_TYPE_AHEAD || SEARCH_MODE_CONFIRM
 *   }
 *
 *
 * Buttons:
 *
 * .. code-block:: javascript
 *
 *   {
 *     type: "button"
 *     icon: string
 *     func: function
 *   }
 *
 *   {
 *     type: "button",
 *     icon: "euro",
 *     func: () => console.log("Hello World")
 *   }
 *
 * Menu:
 *
 * .. code-block:: javascript
 *
 *   {
 *     type: "menu"
 *     icon: string
 *     conf: [
 *        {
 *          type: "item"
 *          icon: string
 *          title: string
 *          func: function
 *        }
 *        ...
 *     ]
 *   }
 */
export class Toolbar extends React.Component {
    render() {
        return (
            <ButtonToolbar>
                {this.props.config.slice(0).reverse().map(
                     (config, index) => toolbarWidgetRegistry[config["type"]](index, config))}
            </ButtonToolbar>
        );
    }
}

Toolbar.propTypes = {
    config: PropTypes.array.isRequired
};
