/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: object-store.js 177052 2018-05-09 11:33:42Z mbr $"
 */

/**
 * This module provides access to the global object store.
 * The actions used to modify this store are defined in
 * :ref:`cs-web-components-base-actions.object-actions.__module__`.
 *
 * Firstly, this module contains reducers that store certain entities
 * of the REST API, such as objects, types or relation.
 *
 * Interaction of Object Stores And Meta Stores
 * --------------------------------------------
 *
 * Failure and pending operations on the object store are also handled
 * using Redux. E.g., if an object is retrieved via
 * :ref:`cs-web-components-base-actions.object-actions.fetchObject`
 * given an url ``url``, the Promise returned by the action will be
 * stored in
 * :ref:`cs-web-components-base-reducers.fetching.fetchingById`.
 * The presence of this entry represents a pending request for the
 * given ``url``.

 * When the object retrieval either fails or completes successfully,
 * the Promise is removed from
 * :ref:`cs-web-components-base-reducers.fetching.fetchingById`,
 * and depending on the result of the operation an error message is
 * put into
 * :ref:`cs-web-components-base-reducers.fetching.errorsById`,
 * or the received object is put into
 * :ref:`cs-web-components-base-reducers.object-store.objectsById`.
 * Finally the Promise associated with the request is resolved.
 *
 * An example on how to connect to a store is given in
 * :ref:`cs-web-components-base-reducers.object-store.objectsById`
 *
 * @module
 */

import Immutable from 'immutable';
import {
    RECEIVED_OBJECT, RECEIVED_COLLECTION, RECEIVED_RELSHIP_N, RECEIVED_RELSHIP_1,
    EDITING_OBJECT, RECEIVED_TYPE, DELETED_OBJECT, RECEIVED_CLASS_RELSHIPS
} from '../actions/object-actions.js';

/**
 * This store is an Immutable map that stores all objects fetched via REST API
 * by their id.
 *
 * Example
 * ~~~~~~~
 *
 * .. code-block:: none
 *
 *    function ExampleComponent(props) {
 *      return <div>{props.myObject ? props.myObject.get('titel') : 'undefined'}</div>;
 *    }
 *
 *    function mapStateToProps(state, ownProps) => {
 *      return {myObject: state.objectsById.get(ownProps.myObjectId)};
 *    };
 *
 *    connect(mapStateStateToProps)(ExampleComponent);
 */
export function objectsById(state = Immutable.Map(), action) {
    switch (action.type) {
        case RECEIVED_OBJECT:
            return state.withMutations(map => {
                // The URL we requested may not be the canonical URL of the object
                // (eg. for documents only z_nummer was specified). The views may
                // reference one, and the backend return another value in the '@id'
                // field, so we store the object under both URLs.
                const obj = Immutable.fromJS(action.payload);
                if (action.payload['@id'] !== action.meta.url) {
                    map.set(action.payload['@id'], obj).set(action.meta.url, obj);
                } else {
                    map.set(action.payload['@id'], obj);
                }
            });
        case RECEIVED_COLLECTION:
        case RECEIVED_RELSHIP_N: {
            const tmp =
                action.payload
                    .filter(x => typeof x === "object")
                    .map(o => [o['@id'], Immutable.fromJS(o)]);
            // Don't use state.set() here, because an already existing entry may
            // have more attribute values than the new one - we want to keep them!
            return (tmp.length > 0) ? state.mergeDeep(Immutable.Map(tmp)) : state;
        }
        case RECEIVED_RELSHIP_1:
            if ((action.payload === null) || (typeof action.payload === "string")) {
                return state;
            }
            else {
                // Don't use state.set() here, because an already existing entry may
                // have more attribute values than the new one - we want to keep them!
                return state.mergeDeepIn([action.payload['@id']], Immutable.fromJS(action.payload));
            }
        case EDITING_OBJECT: {
            const {object, values} = action.payload;
            return state.mergeIn([object.get('@id')], values);
        }
        case DELETED_OBJECT:
            // XXX This ignores the non-canonical form, which remains in the
            // object store; c.f. RECEIVED_OBJECT
            return state.delete(action.payload.get('@id'));
        default:
            return state;
    }
}

/**
 * This reducer stores type information retrieved for the object-type
 * that can be retrieved under the url ``object.get('@type')``.
 */
export function typesById(state = Immutable.Map(), action) {
    switch (action.type) {
        case RECEIVED_TYPE:
            return state.set(action.payload['@id'], Immutable.fromJS(action.payload));
        default:
            return state;
    }
}

/**
 * Stores objects related to an entity by a relation specified by
 * an url.
 */
export function relshipsById(state = Immutable.Map(), action) {
    switch (action.type) {
        case DELETED_OBJECT: { // Delete object's relationships
            const relations = action.payload.getIn(['system:relships', 'relships']);
            if (relations) {
                let newState = state;
                relations.toList().forEach(
                    // TODO relation `value` may be resolved in store,
                    // see objectsById:RECEIVED_OBJECT
                    value => {
                        newState = newState.delete(value);
                    }
                );
                return newState;
            }
            return state;
        }
        case RECEIVED_RELSHIP_N: {
            const orig = state.get(action.meta.url);
            const oids = action.payload.map(o => (typeof o === "string") ? o : o['@id']);
            if (orig === undefined) {
                return state.set(action.meta.url, Immutable.OrderedSet(oids));
            }
            else {
                const updated = orig.intersect(oids).union(oids);
                return state.set(action.meta.url, updated);
            }
        }
        case RECEIVED_RELSHIP_1:
            return state.set(
                action.meta.url,
                ((action.payload === null) ?
                    null
                    : ((typeof action.payload === "string") ?
                        action.payload
                        : action.payload['@id']))
            );
        default:
            return state;
    }
}

/**
 * Relationship meta data by classname
 */
export function relshipsByClass(state = Immutable.Map(), action) {
    switch (action.type) {
        case RECEIVED_CLASS_RELSHIPS: {
            const {classname, relships} = action.payload;
            return state.set(classname, Immutable.fromJS(relships));
        }
        default:
            return state;
    }
}
