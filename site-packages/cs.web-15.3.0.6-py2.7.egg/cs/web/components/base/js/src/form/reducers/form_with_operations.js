/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: form_with_operations.js 177299 2018-05-17 11:50:22Z cla $"
 */
import Immutable from 'immutable';
import {
    INIT_OP_INSTANCE, CLEAR_OP_INSTANCE,
    OPERATION_IS_STARTING, INIT_OP_STATE, CLEAR_OP_STATE,
    OPEN_FORM, CLOSE_FORM, CHANGE_FORM_VALUES,
    ADD_FILES, REMOVE_FILES,
    FORM_CHECK_PENDING, FORM_CHECK_DONE,
    OPERATION_SUCCEEDED, OPERATION_FAILED,
    OPERATION_CANCELLED,

    SET_SUBMIT_HANDLER,
} from '../actions/form_with_operations.js';
import {OperationMode} from '../constants.js';
import {ACTIONS} from '../../operations/constants.js';

/**
 * currentOperation: opInfo - Current operation
 * defaultOperation: opInfo - Default name of the operation
 * currentOpParams: {       - Parameters for current op
 *    object: object        - The object on which the operation is executed
 * }
 * mode: OperationMode Enum - Current state of the operation execution fsm, see
                              OperationMode constants for details
 * lastError,               - lastError if error was received
 * lastErrorResult,         - json payload of last error
 * result                   - result of operation
 *
 * @private
 * @module
 */

function newState() {
    return {
        mode: OperationMode.INITIAL,
        info: null,
        state: null,  // <-- This is the initial state, when calling startOperation
                      //     It will not be overwritten, by subsequent calls to
                      //     CHANGE_FORM_VALUES.
        params: null,
        values: null,
        registers: null,
        wizardProgress: null,
        dialogHooks: null,
        operationState: null,
        unchecked: null,
        preventSubmitReasons: null,
        valueErrors: null,
        generalErrors: null,
        query: null,
        queryCancel: false,
        displayForm: false,
        submitDisabled: false,
        pendingChecks: Immutable.Map(),
        nonBlocking: null,

        hasFiles: false,
        files: null,
    };
}

// TODO check that state change is valid (appropriate previous state)
// e.g., started only reachable from initialized
export default function(state = Immutable.Map(), action) {
    if (!action.payload) {
        return state;
    }
    const {instanceName} = action.payload;
    switch (action.type) {
        case INIT_OP_INSTANCE:
            return state.mergeIn([instanceName], newState())
                        // These fields persist runOperation call.
                        .setIn([instanceName, 'result'], null)
                        // TODO cla: deprecated.
                        .setIn([instanceName, 'successHandler'], null)
                        .setIn([instanceName, 'failureHandler'], null);
        case CLEAR_OP_STATE:
            return state.mergeIn([instanceName], newState());

        case CLEAR_OP_INSTANCE:
            return state.delete(instanceName);

        case OPERATION_IS_STARTING:
            return state.setIn([instanceName, 'mode'], OperationMode.STARTING);

        case INIT_OP_STATE: {
            const {opInfo, opState, opParams, nonBlocking} = action.payload;

            return state.mergeIn(
                [instanceName],
                {
                    mode: OperationMode.STARTED,
                    info: opInfo,
                    state: opState,
                    params: opParams,
                    values: opState.get('values'),
                    registers: opState.get('registers'),
                    wizardProgress: opState.get('wizard_progress'),
                    dialogHooks: opState.get('dialog_hooks'),
                    operationState: opState.get('operation_state'),
                    unchecked: Immutable.Set(),
                    preventSubmitReasons: Immutable.Set(),
                    submitDisabled: false,
                    pendingChecks: Immutable.Map(),
                    nonBlocking,
                    result: null,

                    hasFiles: action.payload.hasFiles,
                    files: action.payload.hasFiles ? [] : null,
                }
            );
        }

        case ADD_FILES:
            return state.updateIn([instanceName, 'files'],
                                  v => v.concat(action.payload.files));

        case REMOVE_FILES:
            return state.updateIn([instanceName, 'files'],
                                  files => files.filter(f => !action.payload.files.contains(f)));

        case OPEN_FORM:
            return state.setIn([instanceName, 'displayForm'], true)
                        .setIn([instanceName, 'submitDisabled'], false);
        case CLOSE_FORM:
            return state.setIn([instanceName, 'displayForm'], false)
                        .setIn([instanceName, 'submitDisabled'], false);

        case CHANGE_FORM_VALUES:
            // registers and wizardProgress may be optional, when
            // these are undefined, we keep the values.
            // TODO prevent state updates if not initialized
            return state
                .updateIn([instanceName, 'values'],
                          v => action.payload.fields.values || v)
                .updateIn([instanceName, 'unchecked'],
                          v => action.payload.fields.unchecked || v)
                .updateIn([instanceName, 'preventSubmitReasons'],
                          v => action.payload.fields.preventSubmitReasons || v)
                .updateIn([instanceName, 'registers'],
                          v => action.payload.fields.registers || v)
                .updateIn([instanceName, 'wizardProgress'],
                          v => action.payload.fields.wizardProgress || v)
                .updateIn([instanceName, 'dialogHooks'],
                          v => action.payload.fields.dialogHooks || v)
                .updateIn([instanceName, 'operationState'],
                          v => action.payload.fields.operationState || v);


        case ACTIONS.SUBMIT_OPERATION:
            return state.setIn([instanceName, 'submitDisabled'], true);


        case ACTIONS.QUERY_CANCEL:
            return state.setIn([instanceName, 'queryCancel'], true);

        case ACTIONS.QUERY_CANCEL_FORCE:
        case ACTIONS.QUERY_CANCEL_BACK:
            return state.setIn([instanceName, 'queryCancel'], false);

        case ACTIONS.QUERY_USER:
            return state.setIn([instanceName, 'query'], action.payload.dialog);
        case ACTIONS.QUERY_DISMISS:
            return state.setIn([instanceName, 'query'], null);

        case ACTIONS.SUBMIT_VALUE_ERROR:
            return state.setIn([instanceName, 'valueErrors'], action.payload.fields);
        case ACTIONS.SUBMIT_GENERAL_ERROR:
            return state.setIn([instanceName, 'generalErrors'], action.payload.errors);
        case ACTIONS.CLEAR_ERRORS:
            return state.setIn([instanceName, 'valueErrors'], null)
                        .setIn([instanceName, 'generalErrors'], null);

        case FORM_CHECK_PENDING:
            return state.setIn([instanceName, 'pendingChecks', action.payload.field], true);
        case FORM_CHECK_DONE:
            return state.deleteIn([instanceName, 'pendingChecks', action.payload.field]);

        /* Handling operation result via operationState */
        case OPERATION_SUCCEEDED:
            return state.setIn([instanceName, 'result'], OperationMode.SUCCEEDED);
        case OPERATION_FAILED:
            return state.setIn([instanceName, 'result'], OperationMode.FAILED);
        case OPERATION_CANCELLED:
            return state.setIn([instanceName, 'result'], OperationMode.CANCELLED);

        case SET_SUBMIT_HANDLER:
            return state
                .setIn([instanceName, 'successHandler'], action.payload.onSuccess)
                .setIn([instanceName, 'failureHandler'], action.payload.onFailure);

        default:
            return state;
    }
}
