/*
 * Copyright (C) 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: AlignedOverlay.jsx 185125 2018-10-16 09:13:25Z cla $"
 */

import React from 'react';
import ReactDOM from 'react-dom';
import {PropTypes} from 'cs-web-components-externals';
import {
    HorizontalAlignment, HorizontalAlignmentType,
    VerticalAlignment, VerticalAlignmentType
} from './constants.js';
import Overlay from './Overlay.jsx';
import Controlled from './Controlled.jsx';

// Interval in ms between updates to overlay position for AlignedOverlay
const POSITION_TIMEOUT = 30;

function domRectToJSON(domRect) {
    return {
        width: domRect.width,
        height: domRect.height,
        left: domRect.left,
        right: domRect.right,
        top: domRect.top,
        bottom: domRect.bottom,
    };
}

class PositionWatcher extends React.Component {
    constructor(props) {
        super(props);

        this.containerElement = null;
        this.containerPosition = {};  // dimensions of browser window/overlay container
        this.parentElement = null;   // element that displays the overlay
        this.parentPosition = {};
        this.contentRef = null;      // ref to the content of the overlay
        this.contentElement = null;  // element thats the content of the overlay
        this.contentPosition = {};
        this.timeout = null;

        this.onPositionChanged = this.onPositionChanged.bind(this);
        this.setContentRef = this.setContentRef.bind(this);
    }

    setContentRef(c) {
        const {setContentRef} = this.props;
        this.contentRef = c;
        if (setContentRef) {
            setContentRef(c);
        }
    }

    componentDidMount() {
        // Update Parent Element
        if (this.props.parentRef) {
            this.parentElement =
                ReactDOM.findDOMNode(this.props.parentRef);  // eslint-disable-line  react/no-find-dom-node
        }

        if (this.props.containerRef) {
            this.containerElement =
                ReactDOM.findDOMNode(this.props.containerRef);  // eslint-disable-line react/no-find-dom-node
        }

        // Get Overlay Content Root
        this.contentElement =
            ReactDOM.findDOMNode(this.contentRef);  // eslint-disable-line  react/no-find-dom-node

        // Manage Timer flag
        this.onPositionChanged();
        if (this.props.useTimer) {
            this.timeout = setInterval(this.onPositionChanged, POSITION_TIMEOUT);
        }
    }

    componentWillReceiveProps(nextProps) {
        // Update Parent Element
        if (this.props.parentRef !== nextProps.parentRef) {
            if (nextProps.parentRef) {
                this.parentElement =
                    ReactDOM.findDOMNode(nextProps.parentRef);  // eslint-disable-line  react/no-find-dom-node
            } else {
                this.parentElement = null;
            }
        }

        if (this.props.containerRef !== nextProps.containerRef) {
            if (nextProps.containerRef) {
                this.containerElement =
                    ReactDOM.findDOMNode(nextProps.containerRef);  // eslint-disable-line  react/no-find-dom-node
            } else {
                this.containerElement = null;
            }
        }

        // Manage Timer/Update Position in manual mode
        if (!nextProps.useTimer) {
            if (this.timeout) {
                clearInterval(this.timeout);
                this.timeout = null;
            }

            if ((this.props.parentRef !== nextProps.parentRef
              || this.props.containerRef !== nextProps.parentRef)
                && this.containerElement && this.parentElement) {
                this.onPositionChanged();
            }
        }
    }

    componentWillUnmount() {
        if (this.timeout) {
            clearInterval(this.timeout);
        }
    }

    onPositionChanged() {
        const {onPositionChanged} = this.props;
        let needsUpdate = false;

        let containerRect = null;
        if (this.containerElement) {
            containerRect = domRectToJSON(this.containerElement.getBoundingClientRect());

            // Adjust for scrollbars as getBoundingClientRect includes these.
            const horScrollMargin = containerRect['width'] - this.containerElement.clientWidth;
            containerRect.width -= horScrollMargin;
            containerRect.right -= horScrollMargin;

            const verScrollMargin = containerRect['height'] - this.containerElement.clientHeight;
            containerRect.height -= verScrollMargin;
            containerRect.bottom -= verScrollMargin;

        } else {
            containerRect = {
                left: 0,
                top: 0,
                right: window.innerWidth,
                bottom: window.innerHeight,
                width: window.innerWidth,
                height: window.innerHeight,
            };
        }

        if (this.hasPositionChanged(this.containerPosition, containerRect)) {
            this.containerPosition = containerRect;
            needsUpdate = true;
        }

        const parentRect = this.parentElement.getBoundingClientRect();
        if (this.hasPositionChanged(this.parentPosition, parentRect)) {
            // DOMRect.toJSON is not supported by IE11
            this.parentPosition = domRectToJSON(parentRect);
            needsUpdate = true;
        }

        const contentRect = {
            width: this.contentElement.scrollWidth,
            height: this.contentElement.scrollHeight,
        };
        if (this.hasPositionChanged(this.contentPosition, contentRect)) {
            this.contentPosition = contentRect;
            needsUpdate = true;
        }

        if (needsUpdate) {
            onPositionChanged(parentRect, contentRect, containerRect);
        }
    }

    hasPositionChanged(r1, r2) {
        return (
            r1.width !== r2.width ||
            r1.height !== r2.height ||
            r1.left !== r2.left ||
            r1.right !== r2.right ||
            r1.top !== r2.top ||
            r1.bottom !== r2.bottom
        );
    }

    render() {
        // Inject our own this.setContentRef into Overlay
        return React.cloneElement(
            React.Children.only(this.props.children),
            {setContentRef: this.setContentRef}
        );
    }
}

PositionWatcher.propTypes = {
    containerRef: PropTypes.object,
    parentRef: PropTypes.object,
    onPositionChanged: PropTypes.func,
    useTimer: PropTypes.bool,
    setContentRef: PropTypes.func,
};

PositionWatcher.defaultProps = {
    useTimer: true,
};

/**
 * Extended Overlay that handles layouting. A layouting function needs to be provided to
 * calculate the styling/positioning of the overlay. The overlay will then be positioned
 * in relation to the property ``parentRef``. Exact positioning is determined by
 * ``layoutFunc``.
 *
 * Layout Function
 * ===============
 *
 * .. code-block::
 *
 *    layoutFunc(
 *      layoutConfig: object,
 *      horizontalAlign: HorizontalAlignment,
 *      verticalAlign: VerticalAlignment,
 *      parentRect: object,
 *      overlayRect: object,
 *    ) => object
 *
 * Functions provided as a layouting function to this component must accept the following
 * parameters:
 *
 * - **layoutConfig**: Parameters that depend on the layout function used
 * - **horizontalAlign**: The horizontal alignment of the overlay
 * - **verticalAlign**: The vertical alignment of the overlay
 * - **parentRect**: An object with the absolute position and the dimensions of the parent component.
 * - **overlayRect**: An object with the dimensions of the content of the overlay.
 *
 * The return value should be an object, containing at least properties ``top`` and ``left``,
 * which specify the absolute position of the overlay in ``document.body``. Since the return value
 * is passed as the element-style of the overlay diff, it is also possible to use CSS for advanced
 * options, like enabling scrolling.
 *
 * Children
 * ========
 *
 * As children a single element should be passed. This element will be rendered as the content
 * of the overlay.
 *
 * React Properties
 * ================
 *
 * ================= ========================= ================================================
 *    Name              Type                       Description
 * ================= ========================= ================================================
 *  parentRef         element                   The element to which the overlay will be
 *                                              aligned.
 *  onBlur            function                  Sets an ``onBlur`` handler on the overlay div
 *                                              This is useful if you want to close the div
 *                                              when it loses focus. Note that for this to
 *                                              work, you need to initially request the focus
 *                                              on the component.
 *  setOverlayRef     function                  Callback to receive a reference to the overlay
 *                                              DOM element, e.g., to request the focus, when
 *                                              it is rendered.
 *  setContentRef     function                  Callback to receive a reference to the content
 *                                              of the overlay.
 *  visible           boolean                   The overlay is only rendered if this flag is
 *                                              ``true``
 *  className         string                    Append additional classes to the overlay's
 *                                              class attribute.
 *  useTimer          boolean                   If set, a timer will check for responsive
 *                                              changes and trigger relayouting if necessary
 *  layoutFunc        function                  A function that calculates the position/layout
 *                                              of the overlay, based on its content, the
 *                                              window dimensions and an optional container
 *  horizontalAlign   HorizontalAlignmentType   The horizontal alignment of the component.
 *                                              Will be passed as a parameter to the layout
 *                                              function.
 *  verticalAlign     VerticalAlignmentType     The vertical alignment of the component.
 *                                              Will be passed as a parameter to the layout
 *                                              function.
 * ================= ========================= ================================================
 *
 */
export default class AlignedOverlay extends React.Component {
    constructor(props) {
        super(props);
        this.state = {style: undefined};
        this.onPositionChanged = this.onPositionChanged.bind(this);
    }

    isParentHidden(containerRect, parentRect) {
        return (
            parentRect.left < containerRect.left ||
            parentRect.right > containerRect.right ||
            parentRect.top < containerRect.top ||
            parentRect.bottom > containerRect.bottom
        );
    }

    componentWillReceiveProps(nextProps) {
        if (this.props.visible && !nextProps.visible) {
            // Reset state if we won't be rendered
            this.setState({style: undefined});
        }
    }

    onPositionChanged(parentRect, overlayRect, containerRect) {
        const {horizontalAlign, verticalAlign, layoutConfig, layoutFunc} = this.props;

        if (this.isParentHidden(containerRect, parentRect)) {
            this.setState({style: undefined});
        } else {
            const style = layoutFunc(
                layoutConfig, horizontalAlign, verticalAlign,
                parentRect, overlayRect, containerRect
            );

            if (this.state.style === undefined) {
                // Next update will activate visibility of overlay. After render we may request
                // initial focus in the next animation frame.
                const {onOverlayVisible} = this.props;
                if (onOverlayVisible) {
                    window.requestAnimationFrame(onOverlayVisible);
                }
            }

            this.setState({style});
        }
    }

    render() {
        const {
            setContentRef,
            setOverlayRef,
            onFocus,
            onBlur,
            onFocusOut,
            visible,
            useTimer,
            parentRef,
            containerRef,
            className,
            children
        } = this.props;

        if (!parentRef || !visible || containerRef === null) {
            return null;
        }

        // If the position is not initialized we render it hidden in the top left.
        // - to avoid confusing the layout (position:absolute with no position properties may cause that)
        // - to avoid showing the uninitialized dropdown
        // - to still get size information about our overlay
        // This on the other hand renders the initial focus() call in Controlled.setContentRef defunct
        // (the overlay is not yet visible). Therefore we trigger this also after the first render by queuing
        // props.onOverlayVisible in onPositionChanged.
        // If we do not set the position it will be rendered in the bottom left corner,
        // possible introducing a vertical scrollbar to the body, which again confuses the layout
        const overlayStyle =
            this.state.style === undefined ?
            Overlay.HIDDEN :
            this.state.style;

        // To accomodate for layout algorithms passing styles to children, we
        // may receive a facc in props.children
        const {_children, ...style} = overlayStyle;
        const renderedChildren =
            (typeof children === 'function') ?
            children(_children || {}) :
            children;

        return (
            <PositionWatcher containerRef={containerRef}
                             parentRef={parentRef}
                             useTimer={useTimer}
                             setContentRef={setContentRef}
                             onPositionChanged={this.onPositionChanged}>
                <Overlay onFocus={onFocus}
                         onBlur={onBlur}
                         onFocusOut={onFocusOut}
                         className={className}
                         visible={visible}
                         setOverlayRef={setOverlayRef}
                         positionStyle={style}>
                    {renderedChildren}
                </Overlay>
            </PositionWatcher>
        );
    }
}

AlignedOverlay.propTypes = {
    containerRef: PropTypes.object, // null means containerRef is passed but not available
    // undefined means use window dimensions
    parentRef: PropTypes.object,
    useTimer: PropTypes.bool,
    layoutFunc: PropTypes.func.isRequired,
    layoutConfig: PropTypes.object,
    horizontalAlign: HorizontalAlignmentType,
    verticalAlign: VerticalAlignmentType,
    ...Overlay.propTypes
};

AlignedOverlay.defaultProps = {
    useTimer: true,
    horizontalAlign: HorizontalAlignment.LEFT,
    verticalAlign: VerticalAlignment.BOTTOM,
    layoutConfig: {},
    ...Overlay.defaultProps
};

/**
 * AlignedOverlay, extended for closing the overlay by user interaction.
 *
 * React Properties
 * ================
 *
 * In addition to those defined for
 * :ref:`cs-web-components-base-overlays.AlignedOverlay.__default__` this component
 * receives the following properties
 *
 * ================= ========================= ================================================
 *    Name              Type                       Description
 * ================= ========================= ================================================
 *  onHide            function                  This handler is called when the user presses
 *                                              ``Escape`` on the overlay or it loses focus.
 *                                              Use to modify visibility state of component.
 * ================= ========================= ================================================
 *
 * See :ref:`cs-web-components-base-overlays.index.__module__--custom` for
 * details.
 *
 * @class Controlled
 */
AlignedOverlay.Controlled = Controlled(AlignedOverlay);
