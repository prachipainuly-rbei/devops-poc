/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: OperationTrigger.jsx 184133 2018-09-19 09:19:59Z cla $"
 */

import React from 'react';
import Immutable from 'immutable';
import {PropTypes, connect} from 'cs-web-components-externals';
import {Console} from '../../helpers.js';
import {OperationMode, NOT_ACTIVE_SET, NOT_RUNNING_SET, FINISHED_SET} from '../constants.js';
import {ImmutablePropTypes} from 'cs-web-components-externals';
import Operations from '../../operations';
import {setSubmitHandler} from '../actions/form_with_operations.js';

/**
 * This module provides the HOC
 * :ref:`cs-web-components-base-form.containers.OperationTrigger.WithOperationTrigger`
 * to implement operation Wrapping a component with an OperationTrigger provides a
 * ``runOperation`` callback.
 *
 * Handler Names
 * -------------
 *
 * While operations may specify a default handler they should be invoked with by
 * setting an appropriate value for field ``presentation_id`` of the operation
 * configuration (see `operations_presentation_ids`) specialized applications
 * want to customize the way in which operations are handled. When creating an
 * operation trigger component with the ``WithOperationTrigger`` HOC, a handler
 * name may be passed as the second parameter to have instances of this component
 * use the operation handler identified by this name.
 *
 * Note that this parameter may in turn be overriden by passing a handlerName
 * property to a specific instance of the operation trigger component.
 *
 * So the way a handler name is determined is as follows:
 *
 * 1. ``<MyOperationTrigger handlerName={'foo1'} />``
 * 2. ``const MyOperationTrigger = WithOperationTrigger(MyComponent, 'foo2')``
 * 3. ``operationInfo.get('presentation_id')``
 *
 * Running Operations
 * ------------------
 *
 * The wrapped component may invoke an operation fetched with WithOperations by
 * calling runOperation, passed as property.
 *
 * .. code-block:: none
 *
 *    runOperation(operation, operationParameters)
 *
 * This callback will trigger an operation in the surrounding operation scope.
 * ``runOperation`` receives an operation information object as
 * provided to frontend components by the
 * :ref:`cs-web-components-base-components.WithOperations.__module__` HOC, as well
 * as an object that specifies the parameters to the operation.
 *
 * Given an operation ``opInfo``, the operation may be called like
 *
 * .. code-block:: none
 *
 *    class MyComponent extends React.Component {
 *       doRunOp() {
 *           const {runOperation, opInfo, contextObject} = this.props
 *           runOperation(opInfo, {objects: Immutable.List([contextObject, ...])});
 *       }
 *
 *       render() {
 *           // Render the component
 *       }
 *    }
 *
 *    export default WithOperationTrigger(MyComponent);
 *
 * For a comprehensive list of possible parameters, see
 * :ref:`cs-web-components-base-operations.actions.operations.runOperation_parameters`.
 *
 * Properties passed to the wrapping Component (this component) are:
 *
 * +----------------------------+----------------+---------+---------------------------------------------------+
 * | Name                       | Type           | Default | Description                                       |
 * +============================+================+=========+===================================================+
 * | handlerName                | string         | \-      | Override the handlerName provided by the          |
 * |                            |                |         | operation. Optional.                              |
 * +----------------------------+----------------+---------+---------------------------------------------------+
 * | defaultOperationParameters | object         | \-      | defaultOperationParameters are merged into the    |
 * |                            |                |         | parameters provided to startOperation. Optional.  |
 * +----------------------------+----------------+---------+---------------------------------------------------+
 *
 * Properties passed to the wrapped component are:
 *
 * +----------------------------+----------------+---------------------------------------------------+
 * | Name                       | Type           | Description                                       |
 * +============================+================+===================================================+
 * | runOperation               | func           | Start the provided operation in the               |
 * |                            |                | surrounding scope.                                |
 * +----------------------------+----------------+---------------------------------------------------+
 *
 * @module OperationTrigger
 */

class OperationTrigger extends React.Component {
    constructor(props) {
        super(props);
        this.runOperation = this.runOperation.bind(this);

        // TODO cla: deprecated. Legacy result handling
        this.startOperation = this.startOperation.bind(this);
        this.setSubmitHandler = this.setSubmitHandler.bind(this);
        this.onSuccess = undefined;
        this.onFailure = undefined;
    }

    _getOperationProvider(operation) {
        // The configured handler name will be overridden by the property if available,
        // except for entries in handlerWhitelist.
        // This allows the ui configuration to override the general operation configuration
        // provided by the backend.
        const handlerName = this.props.handlerName || operation.get('presentation_id');
        if (handlerName === undefined) {
            Console.warn(
                `Neither operation '${operation.get('classname')}/${operation.get('opname')}'` +
                ` nor OperationTrigger specifies an OperationHandler`
            );
        }

        if (this.context.getOperationHandler === undefined) {
            Console.warn(
                `OperationTrigger has no surrounding OperationScope.`
            );
            return undefined;
        }

        const operationProvider = this.context.getOperationHandler(handlerName);
        if (operationProvider === undefined) {
            Console.warn(
                `No OperationHandler ${handlerName} in current OperationScope.`
            );
            return undefined;
        }

        return operationProvider;
    }

    setSubmitHandler(onSuccess = undefined, onFailure = undefined) {
        Console.warn(
            'OperationTrigger.setSubmitHandler is deprecated in cs.web 15.3.',
            'You should reimplement your result handlers using Redux Saga.'
        );

        this.onSuccess = onSuccess;
        this.onFailure = onFailure;
    }

    mergedOperationParameters(operationParameters) {
        const {defaultOperationParameters} = this.props;

        return {
            ...(defaultOperationParameters || {}),
            ...(operationParameters || {}),
        };
    }

    startOperation(operation, operationParameters) {
        Console.warn(
            'OperationTrigger.startOperation is deprecated in cs.web 15.3.',
            'Use OperationTrigger.runOperation instead.'
        );

        // Write submit handlers to store
        const operationProvider = this._getOperationProvider(operation);
        const {setSubmitHandler} = this.props;
        setSubmitHandler(operationProvider, this.onSuccess, this.onFailure);

        // Setup parameters and run operation
        const {object, objects, ...others} = this.mergedOperationParameters(operationParameters);
        const rOpParams = {'parameters': Immutable.Map(others)};
        rOpParams.contextObjects = Immutable.List(objects || (object ? [object] : []));
        if (this.onSuccess) {
            rOpParams.successActions = [Operations.Handlers.executeSuccessHandlerFns()];
        }
        if (this.onFailure) {
            rOpParams.failureActions = [Operations.Handlers.executeFailureHandlerFns()];
        }
        return this.runOperation(operation, rOpParams, true);
    }

    runOperation(operation, operationParameters, noDefault = false) {
        const operationProvider = this._getOperationProvider(operation);
        if (operationProvider) {
            this.props.runOperation(
                operationProvider, Object.assign(
                    {operationInfo: operation},
                    noDefault ?
                    operationParameters :
                    this.mergedOperationParameters(operationParameters),
                )
            );
        }
        return operationProvider;
    }

    render() {
        const {children, ...otherProps} = this.props;
        const {handlerName, allOperationStates} = otherProps;
        const handler =
            handlerName &&
            this.context.getOperationHandler(handlerName);

        // If we have a fixed handler, we can determine its state
        let stateProps = {};
        if (handler) {
            const operationState = allOperationStates.get(handler);
            stateProps = {
                isInstanceActive: !NOT_ACTIVE_SET.has(operationState.get('mode')),
                isInstanceRunning: !NOT_RUNNING_SET.has(operationState.get('mode')),
                isInstanceFinished: FINISHED_SET.has(operationState.get('result')),
                isInstanceSucceeded: operationState.get('result') === OperationMode.SUCCEEDED,
                isInstanceFailed: operationState.get('result') === OperationMode.FAILED,
                isInstanceCancelled: operationState.get('result') === OperationMode.CANCELLED,
            };
        }

        const props = {
            ...otherProps,
            ...stateProps,
            runOperation: this.runOperation,
            startOperation: this.startOperation,
            setSubmitHandler: this.setSubmitHandler,
        };
        return React.cloneElement(React.Children.only(children), props);
    }
}

OperationTrigger.propTypes = {
    handlerName: PropTypes.string,
    defaultOperationParameters: PropTypes.object,
    runOperation: PropTypes.func.isRequired,
    addFiles: PropTypes.func.isRequired,
    allOperationStates: ImmutablePropTypes.map.isRequired,
    setSubmitHandler: PropTypes.func,
};

OperationTrigger.contextTypes = {
    getOperationHandler: PropTypes.func
};

function mapStateToProps(state) {
    const {formWithOperations} = state;
    const isOperationRunning =
        formWithOperations.some(
            state =>
                state.get('mode') !== OperationMode.INITIAL &&
                   !state.get('nonBlocking')
        );
    return {isOperationRunning, allOperationStates: formWithOperations};
}

const triggerActions = {
    runOperation: Operations.runOperation,
    addFiles: Operations.addFiles,
    setSubmitHandler,
};

const ConnectedOperationTrigger = connect(mapStateToProps, triggerActions)(OperationTrigger);

export default ConnectedOperationTrigger;

/**
 * The Higher-Order Component WithOperationTrigger should be used to
 * connect your component to the frontend-based operation state, which
 * stores data relevant to the operation execution and determines the way
 * user interaction (retrieving data required for the operation) is run.
 *
 * The WithOperationTrigger HOC wraps a component and passes a wrapped
 * ``runOperation`` function to it, which has the following interface:
 *
 * .. code-block:: javascript
 *
 *  runOperation(
 *      operation: Immutable.Map,
 *      {
 *          contextObjects: Immutable.List,
 *          parameters: Immutable.Map,
 *          resultInNewTab: Boolean,
 *          successActions: [ReduxActions...],
 *          failedActions: [ReduxActions...],
 *          cancelActions: [ReduxActions...],
 *          generalActions: [ReduxActions...],
 *          suppressHandler: Boolean,
 *          forceHandler: Boolean,
 *          nonBlocking: Boolean,
 *          dialog: String
 *      }
 *  )
 *
 * For a detailed description of all parameters see the action runOperation
 */
export function WithOperationTrigger(WrappedComponent, defaultHandlerName) {
    class WrapperComponent extends React.Component {
        render() {
            const {
                handlerName, defaultOperationParameters, ...otherProps
            } = this.props;
            return (
                <ConnectedOperationTrigger
                        handlerName={handlerName || defaultHandlerName}
                        defaultOperationParameters={defaultOperationParameters}>
                    <WrappedComponent {...otherProps} />
                </ConnectedOperationTrigger>
            );
        }
    }
    WrapperComponent.propTypes = {
        handlerName: PropTypes.string,
        defaultOperationParameters: PropTypes.object
    };
    WrapperComponent.displayName = 'WithOperationTrigger';
    return WrapperComponent;
}
