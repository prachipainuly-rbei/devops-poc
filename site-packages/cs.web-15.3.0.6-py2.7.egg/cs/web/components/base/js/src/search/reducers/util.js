/*
 * Copyright (C) 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: util.js 174759 2018-03-20 14:31:14Z gwe $"
 */

import Immutable from 'immutable';

function compareFields(field1, field2) {
    if (field1.get('row') < field2.get('row')) {return -1}
    else if (field1.get('row') > field2.get('row')) {return 1}
    else if (field1.get('column') < field2.get('column')) {return -1}
    else if (field1.get('column') > field2.get('column')) {return 1}
    else if (field1.get('label') < field2.get('label')) {return -1}
    else if (field1.get('label') > field2.get('label')) {return 1}
    else {return 0}
}

function flattenRegisters(registers) {
    return registers.map(reg => reg.get('fields')).flatten(1);
}

function flattenMultilangFields(fields) {
    /*
     * When the backend returns an operation dialog, for the multi language fields
     * only the current session language is given directly as a field. The other
     * languages are put into an array 'multilang'.
     */
    const multilangFields = fields
        .filter(f => f.has('multilang'))
        .map(f => f.get('multilang'))
        .flatten(1);
    const fieldsWithRemoveML = fields.map(f => f.delete('multilang'));
    return multilangFields.concat(fieldsWithRemoveML);
}

function getRelevantFieldsFromSearchForm(registers) {
    return flattenMultilangFields(flattenRegisters(registers)).filter(
        field => field.get('fieldtype') !== 'image');
}

/**
 * From the registers and values of a search form, extract the attributes that
 * can be used in a search.
 */
export function extractAttributesFromSearchOperation(registers, values) {
    const allFields = getRelevantFieldsFromSearchForm(registers);
    const allAttributes = allFields.map(f => f.get('attribute')).toSet();

    // Split fields by visibility. Note: an attribute may be contained in more
    // than one register. If it is visible in one place, it is counted as visible
    // for the search operation.
    // The visibleFields are sorted according to the form layout, this ordering
    // is used to initialize the order of the search parameters elsewhere.
    const visibleAttributes = allFields
        .filter(f => !f.get('hidden'))
        .sort(compareFields)
        .map(f => f.get('attribute'))
        .toOrderedSet();
    const hiddenAttributes = allFields
        .filter(f => f.get('hidden'))
        .map(f => f.get('attribute'))
        .toSet()
        .subtract(visibleAttributes);

    // Only fields that are marked read only at every visible occurence are
    // considered to really be read only. Note: readonly = 2 does not actually
    // mean read only, but "only from catalog"!
    const writeableAttributes = allFields
        .filter(f => f.get('readonly') !== 1)
        .map(f => f.get('attribute'))
        .toSet()
        .intersect(visibleAttributes);
    const readOnlyAttributes = visibleAttributes.subtract(writeableAttributes);

    // Determine which values are to be used in search operations.
    const searchValues = values.filter(v => v !== '');

    // These are passed as default values to the search mask, but may be changed
    // or removed by the user
    const defaultValues = searchValues.filter((v, k) => writeableAttributes.includes(k));

    // These are shown to the user, but can't be changed
    const fixedValues = searchValues.filter((v, k) => readOnlyAttributes.includes(k));

    // These are either hidden, or have no field at all. They will be passed to
    // the search implicitly.
    const implicitValues =
        searchValues.filter((v, k) => hiddenAttributes.includes(k))
        .merge(searchValues.filter((v, k) => !allAttributes.includes(k)));

    return Immutable.Map({
        fields: Immutable.Map(allFields.map(f => [f.get('attribute'), f])),
        visibleAttributes,
        hiddenAttributes,
        writeableAttributes,
        readOnlyAttributes,
        defaultValues,
        fixedValues,
        implicitValues
    });
}
