/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: RelatedObjects.jsx 175826 2018-04-12 09:45:19Z cla $"
 */

import React from 'react';
import Immutable from 'immutable';
import {PropTypes, connect, ImmutablePropTypes} from 'cs-web-components-externals';
import {formatStr} from '../../i18n';
import {getPlugin, referencedObjects, prefixNS} from '../../helpers.js';
import ContentBlock from '../ContentBlock.jsx';
import FallbackTile from '../../tiles/FallbackTile.jsx';
import {fetchRelatedObjectTiles} from './actions/related-objects.js';

/**
 * A plugin container component to show objects related in some way to the
 * contextObject. Which objects should be displayed is configured in the backend
 * in the 'Assigned objects' configuration.
 *
 * The objects are displayed as small 'tiles', where the tiles are dynamically
 * determined React components, based on the class of the objects (ie. the
 * ``discriminator`` in the plugin configuration must be a class name, see
 * :ref:`web_ui_plugins` for details). The tile components receive the object
 * they must render in their ``contextObject`` property.
 *
 * React Properties
 * ----------------
 *
 * =================  =============  ==================  =============================
 * Property           Type           Default             Use
 * =================  =============  ==================  =============================
 * contextObject      Immutable.Map  \-                  The object that is the origin
 *                                                       of the relations shown
 * pluginContextName  string         'class-tile-small'  The plugin ID that configures
 *                                                       the tiles
 * =================  =============  ==================  =============================
*/
class RelatedObjects extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            tilesByClass: Immutable.Map()
        };
    }

    componentDidMount() {
        this.fetchRelatedObjectTiles(this.props);
        this.cacheConfiguredTiles(this.props);
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.contextObject &&
            this.props.contextObject !== nextProps.contextObject) {
            this.fetchRelatedObjectTiles(nextProps);
        }
        this.cacheConfiguredTiles(nextProps);
    }

    cacheConfiguredTiles(props) {
        const {tilesByClass} = this.state;
        let newTiles = tilesByClass;
        const {relshipConfigs} = props;
        relshipConfigs.forEach(cfg => {
            const objs = referencedObjects(props, props.contextObject, cfg.get('name'));
            if (objs === null || objs === undefined) {
                return;
            }
            if (objs.has('system:classname')) {
                newTiles = this.cacheTile(newTiles, objs);
            }
            else {
                objs.forEach(obj => {
                    newTiles = this.cacheTile(newTiles, obj);
                });
            }
        });
        if (newTiles !== tilesByClass) {
            this.setState({tilesByClass: newTiles});
        }
    }

    cacheTile(tiles, obj) {
        const classname = obj.get('system:classname');
        if (tiles.has(classname)) {
            return tiles;
        }
        else {
            const Tile = getPlugin(
                this.props.pluginContextName,
                cn => cn === classname,
                FallbackTile);
            return tiles.set(classname, Tile);
        }
    }

    fetchRelatedObjectTiles(props) {
        const {contextObject, fetchRelatedObjectTiles} = props;
        fetchRelatedObjectTiles(
            contextObject.get('system:classname'),
            contextObject.get('system:navigation_id')
        );
    }

    renderTile(obj, key) {
        const {tilesByClass} = this.state;
        const Tile = tilesByClass.get(obj.get('system:classname'));
        return Tile ?
            (<Tile key={key} contextObject={obj}/>)
            : null;
    }

    tilesToRender() {
        const {relshipConfigs} = this.props;
        const tilesWrapper = [];
        relshipConfigs.forEach(cfg => {
            const rsname = cfg.get('name');
            const objs = referencedObjects(this.props, this.props.contextObject, rsname);
            if (objs === null || objs === undefined) {
                return;
            }
            const label = cfg.get('label');
            if (objs.has('system:classname')) {
                const key = `${rsname}-${objs.get('@id')}`;
                const tile = this.renderTile(objs, key);
                if (tile) {
                    tilesWrapper.push(
                        <RelatedObjectsWrapper text={label} key={key}>
                            {tile}
                        </RelatedObjectsWrapper>);
                }
            }
            else if (objs.size > 0) {
                const key = `${rsname}-${cfg.get('id')}`;
                tilesWrapper.push(
                    <RelatedObjectsWrapper text={label} key={key}>
                        {objs.map(obj => this.renderTile(obj, `${rsname}-${obj.get('@id')}`))}
                    </RelatedObjectsWrapper>);
            }
        });
        return tilesWrapper;
    }

    render() {
        const tiles = this.tilesToRender();
        return (
            <ContentBlock collapsible={true}
                          expanded={true}
                          title={formatStr('related_objects')}>
                <ContentBlock.Body>
                    {tiles.length > 0 ? tiles :
                        <div className={`${componentNameSpace}-related-objects__default`}>
                            {formatStr('related_objects_default')}
                        </div>
                    }
                </ContentBlock.Body>
            </ContentBlock>
        );
    }
}
RelatedObjects.propTypes = {
    contextObject: ImmutablePropTypes.map.isRequired,
    pluginContextName: PropTypes.string,
    relshipConfigs: ImmutablePropTypes.list.isRequired,
};
RelatedObjects.defaultProps = {
    pluginContextName: 'class-tile-small'
};

/**
 * RelatedObjectsWrapper
 */
function RelatedObjectsWrapper(props) {
    return (
        <div className={prefixNS('related-objects-wrapper')}>
            {props.text ?
                <span className={prefixNS('related-objects__label')}>
                    {props.text}
                </span> :
                <span className={prefixNS('related-objects__label--empty')}/>
            }
            <div className={prefixNS('related-objects')}>
                {props.children}
            </div>
        </div>
    );
}

RelatedObjectsWrapper.propTypes = {
    text: PropTypes.string
};

function mapStateToProps(state, ownProps) {
    const {contextObject} = ownProps;
    const {relatedObjectTiles} = state;
    const relshipConfigs = relatedObjectTiles.get(
        contextObject.get('system:classname'),
        Immutable.List()
    );
    return {
        relshipConfigs,
        objectsById: state.objectsById,
        relshipsById: state.relshipsById,
    };
}

const actions = {fetchRelatedObjectTiles};

export default connect(mapStateToProps, actions)(RelatedObjects);
