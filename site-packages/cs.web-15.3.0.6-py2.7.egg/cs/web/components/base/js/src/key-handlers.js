/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: key-handlers.js 184373 2018-09-25 13:26:52Z cla $"
 */

import {Console} from './helpers.js';
import Immutable from 'immutable';

/**
 * This module allows shortcuts to be registered on a page.
 * These shortcuts may either be local to an element or global, i.e.
 * they can be triggered from the whole page (except for blacklisted
 * elements).
 *
 * Keyboard shortcuts are made up of a sequence of a sequence of 1
 * to 5 keychords, where each keychord is a combination of several
 * modifiers (supported modifiers are ``Control``, ``Alt`` and
 * ``Shift``) and a keyname, that is either a printable character,
 * or one of the supported special keys. They may be described using
 * descriptive strings like ``"Alt+escape k"``.
 *
 * Shortcut Syntax
 * ---------------
 *
 * The syntax for defining shortcuts is:
 *
 * .. code-block:: none
 *
 *    shortcut = (<keychord> ' ')* <keychord>
 *    keychord = (<modifier> '+')* <keyname>
 *    modifier = ('Control' | 'Alt' | 'Shift')
 *
 * Handlers
 * --------
 *
 * Shortcut Handler functions may accept one parameter, which is the
 * DOM Event that triggered the shortcut.
 *
 * Example
 * -------
 *
 * The following Example shows a component that handles a list of
 * shortcuts:
 *
 * .. code-block:: none
 *
 *    import React from 'react';
 *    import ReactDOM from 'react-dom';
 *    import {
 *      addGlobalShortcut,
 *      addLocalShortcuts,
 *      removeAllLocalShortcuts,
 *    } from 'cs-web-components-base';
 *
 *    class ShortcutExample extends React.Component {
 *      constructor(props) {
 *        super(props);
 *        this.focus = this.focus.bind(this);
 *      }
 *
 *      componentDidMount() {
 *        this._element = ReactDOM.findDOMNode(this);
 *        addGlobalShortcut('Ctrl+x Ctrl+e', this.focus);
 *        addLocalShortcuts(
 *          this._element,
 *          [
 *            ['Escape', this.cancel],
 *            ['Enter', this.submit],
 *          ]
 *        );
 *      }
 *
 *      componentWillUnmount() {
 *        removeAllLocalShortcuts(this._element);
 *        removeGlobalShortcut('Ctrl+x Ctrl+e');
 *        this._element = null;
 *      }
 *
 *      focus() { this._element.focus(); }
 *      submit() { ... }
 *      cancel() { ... }
 *    }
 *
 * @module
 */

const keyFixTable = {
    Add: '+',
    Decimal: '.',
    Divide: '/',
    Subtract: '-',
    Multiply: '*',
    Spacebar: ' ',
    Esc: 'Escape',
    Nonconvert: 'NonConvert',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown',
    Del: 'Delete',
    Menu: 'ContextMenu',
    MediaNextTrack: 'MediaTrackNext',
    MediaPreviousTrack: 'MediaTrackPrevious',
    SelectMedia: 'MediaSelect',
    HalfWidth: 'Hankaku',
    FullWidth: 'Zenkaku',
    RomanCharacters: 'Romaji',
    Crsel: 'CrSel',
    Exsel: 'ExSel',
    Zoom: 'ZoomToggle',
    [' ']: 'Spacebar',
};

const MAX_SHORTCUT_LENGTH = 5;

const SHORTCUT_TIMEOUT = 1000;

const ALL_MODIFIERS = ['Control', 'Alt', 'Shift'];
const INPUT_MODIFIERS = ['Control', 'Alt'];

/* List of tagnames whose elements are not handled by ``dispatchKeyDown`` */
const DISPATCH_BLACKLIST = new Set(['INPUT', 'TEXTAREA']);

function get_keyname(event, escaped) {
    const key = keyFixTable[event.key] || event.key;
    return [
        (key.length === 1 ? INPUT_MODIFIERS : ALL_MODIFIERS)
            .filter(mod => event.getModifierState(mod) && (mod !== 'Alt' || !escaped))
            .join('+'),
        key
    ].filter(Boolean).join('+');
}

export function stopSyntheticEvent(event) {
    event.nativeEvent.stopImmediatePropagation();
}

function splitKeyChord(keychord) {
    const tokens = keychord.split('+');
    return {
        modifiers: tokens.slice(0, tokens.length - 1),
        key: tokens[tokens.length - 1]
    };
}

function normalizeKey(key) {
    if (key === undefined || key.length === 0) {
        return undefined;
    }

    return key;
}

function normalizeModifiers(modifiers) {
    // Check that all modifiers are consistent
    if (modifiers.some(m => ALL_MODIFIERS.indexOf(m) === -1)) {
        return undefined;
    }

    // normalize modifier order
    return ALL_MODIFIERS.filter(m => modifiers.indexOf(m) > -1);
}

function joinKeychord(modifiers, key) {
    return key === undefined ?
           undefined :
           [...modifiers, key].join('+');
}

function normalizeKeyChord(keychord) {
    const {modifiers, key} = splitKeyChord(keychord);
    return joinKeychord(normalizeModifiers(modifiers),
                        normalizeKey(key));
}

function parseShortcut(keychords) {
    return keychords.split(' ')
                    .filter(Boolean)
                    .map(normalizeKeyChord);
}

/*
 * A tree containing all registered shortcuts. Inner Nodes map a
 * keychord string to the respective subkeymap, while leaf nodes
 * contain an array of handler functions.
 */
let keymap = Immutable.Map();

/*
 * The list of currently active keychords.
 * This map collects entered keychords until:
 *
 * - a list of event-handlers is found, and a handler
 *   may be executed
 * - the keychord times out after ``SHORTCUT_TIMEOUT``
 * - the active keychords are no existing path in ``keymap``
 */
const currentKeyPrefix = [];

function clearPrefix() {
    clearTimeout(clearPrefix);
    currentKeyPrefix.length = 0;
}

function getFlattenedHandlers(handlers) {
    if (handlers instanceof Immutable.List) {
        return handlers;
    }

    return handlers.map(v => getFlattenedHandlers(v)).toList().flatten();
}

function findHandler(handlers, event) {
    return handlers.find(h => (h.get('target') === undefined ||
                               h.get('target').contains(event.target)));
}

function dispatchKeyDown(event) {
    let escaped = false;
    if (DISPATCH_BLACKLIST.has(event.target.tagName) ||
       event.target.isContentEditable) {
        if (!event.altKey) {
            return true;
        }

        escaped = true;
    }

    const keychord = get_keyname(event, escaped);
    currentKeyPrefix.push(keychord);
    if (currentKeyPrefix.length === MAX_SHORTCUT_LENGTH) {
        clearPrefix();
        return false;
    }

    const handlers = keymap.getIn(currentKeyPrefix);
    // No handlers for this prefix
    if (handlers === undefined) {
        clearPrefix();
        return true;
    }
    // Shortcut is complete, search for handler that contains event.target
    else if (handlers instanceof Immutable.List) {
        clearPrefix();

        const handler = findHandler(handlers, event);
        if (handler) {
            // Handle event
            event.preventDefault();
            handler.get('handler')(event);
            return false;
        }
        // Pass event on
        return true;
    }
    // This is prefix to another shortcut
    else /*if (handlers is Immutable.Map)*/ {
        const handler = findHandler(getFlattenedHandlers(handlers), event);
        // Prefix might be handled by at least one handler in scope of event.target
        if (handler) {
            setTimeout(clearPrefix, SHORTCUT_TIMEOUT);
            event.preventDefault();
            return false;
        }
        // Pass event on
        clearPrefix();
        return true;
    }
}

export function initializeKeyHandler() {
    document.addEventListener('keydown', dispatchKeyDown);
}

function updateHandlerList(handlers, handler, target) {
    // Register handler: This sorts the handlers in the array, so that handlers that
    // are higher in the tree get larger indices, i.e. for each tuple of nodes
    // (o1, o2) => if o1.contains(o2) index(o1) > index(o2).
    // This way, when invoking handlers we simply search the first node that contains
    // event.target. Global handlers come last.
    const entry = Immutable.Map({handler: handler, target: target});
    const idx = target === undefined ? -1 :
                handlers.findIndex(h => (h.get('target') === undefined ||
                                         target.contains(h.get('target'))));
    if (idx === -1) {
        return handlers.push(entry);
    }

    return handlers.splice(idx, 0, entry);
}

function addShortcut(shortcut, handler, target = undefined) {
    const keychords = parseShortcut(shortcut);
    if (keychords.length === 0 || keychords.length > MAX_SHORTCUT_LENGTH) {
        return;
    }

    const handlers = keymap.getIn(keychords, Immutable.List());
    if (!(handlers instanceof Immutable.List)) {
        Console.error(`Shortcut "${keychords.join(' ')}" is already prefix of another shortcut.`);
        return;
    }

    const updatedKeyMap = keymap.setIn(keychords, updateHandlerList(handlers, handler, target));
    if (updatedKeyMap === keymap) {
        Console.error(`A prefix of "${keychords.join(' ')}" is already registered as a shortcut.`);
    }
    keymap = updatedKeyMap;
}

/**
 * Add a list of global shortcuts to the page's keymap.
 *
 * @param shortcutList - A List of pairs ``[shortcut, handler]`` to be added.
 */
export function addGlobalShortcuts(shortcutList) {
    for (const [shortcut, fn] of shortcutList) {
        addGlobalShortcut(shortcut, fn);
    }
}

/**
 * Add a global shortcut to the page's keymap.
 *
 * @param shortcut - The serialized form of the shortcut.
 * @param handler - The handler function to be triggered.
 */
export function addGlobalShortcut(shortcut, handler) {
    addShortcut(shortcut, handler);
}

/**
 * Remove a list of global shortcuts to the page's keymap.
 *
 * @param shortcutList - An array consisting of pairs ``[shortcut, handler]``.
 */
export function removeGlobalShortcuts(shortcutList) {
    for (const shortcut of shortcutList) {
        removeGlobalShortcut(shortcut);
    }
}

/**
 * Remove a globally defined shortcut by its serialized form
 * from the page's keymap.
 *
 * @param shortcut - The serialized form of the shortcut.
 */
export function removeGlobalShortcut(shortcut) {
    removeLocalShortcut(undefined, shortcut);
}

/**
 * Add a list of local shortcuts to HTMLElement component.
 *
 * @param component - The HTMLElement on which the shortcuts should be defined.
 * @param shortcutList - An array consisting of pairs ``[shortcut, handler]``.
 */
export function addLocalShortcuts(component, shortcutList) {
    for (const [shortcut, fn] of shortcutList) {
        addLocalShortcut(component, shortcut, fn);
    }
}

/**
 * Add a local shortcut to HTMLElement component.
 *
 * @param component - The HTMLElement on which the shortcut should be defined.
 * @param shortcut - A serialized representation of the shortcut.
 * @param handler - A function to be invoked, when the shortcut is triggered.
 */
export function addLocalShortcut(component, shortcut, handler) {
    if (!(component instanceof HTMLElement)) {
        Console.error(
            'addLocalShortcut [',
            shortcut,
            ']: First argument must be HTMLElement. Got',
            component
        );
        return;
    }

    addShortcut(shortcut, handler, component);
}

function _removeAllLocalShortcuts(keymap, component) {
    return keymap instanceof Immutable.List ?
           keymap.filterNot(handler => handler.get('target') === component) :
           keymap.map(keymap => _removeAllLocalShortcuts(keymap, component));
}

/**
 * Remove all shortcuts defined locally for HTMLElement component.
 *
 * @param component - The HTMLElement from which to remove the shortcut.
 * @param shortcuts - An array of shortcuts serialized as strings.
 */
export function removeAllLocalShortcuts(component) {
    if (!(component instanceof HTMLElement)) {
        Console.error(
            'removeAllLocalShortcuts: First argument must be HTMLElement. Got',
            component
        );
        return;
    }

    keymap = _removeAllLocalShortcuts(keymap, component);
}

/**
 * Remove an array of shortcuts defined locally on an HTMLElement component.
 *
 * @param component - The HTMLElement from which to remove the shortcut.
 * @param shortcuts - An array of shortcuts serialized as strings.
 */
export function removeLocalShortcuts(component, shortcutList) {
    for (const shortcut of shortcutList) {
        removeLocalShortcut(component, shortcut);
    }
}

/**
 * Remove a shortcut defined locally on an HTMLElement.
 *
 * @param component - The HTMLElement from which to remove the shortcut.
 * @param shortcut - The serialized shortcut representation
 */
export function removeLocalShortcut(component, shortcut) {
    if (!(component instanceof HTMLElement)) {
        Console.error(
            'removeLocalShortcut [',
            shortcut,
            ']: First argument must be HTMLElement. Got',
            component
        );
        return;
    }

    const keychords = parseShortcut(shortcut);
    if (!(keymap.getIn(keychords) instanceof Immutable.List)) {
        Console.error(`No handlers defined for shortcut ${shortcut}`);
        return;
    }

    keymap = keymap.updateIn(
        keychords,
        handlers => handlers.filterNot(h => h.get('target') === component)
    );
}
