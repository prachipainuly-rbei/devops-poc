/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: initialize.jsx 182684 2018-08-23 08:05:29Z cla $"
 */

import React from 'react';
import {createStore, combineReducers, applyMiddleware,
         thunk, Provider, ReactIntl, ReactDnD, ReduxSaga} from 'cs-web-components-externals';
import {getAppSetup, prefixNS, isCEDesktop} from './helpers.js';
import {makeConfiguredComponentClass} from './ConfiguredComponent';
import {Registry} from './registry';
import Messages from './messages';
import {ModificationListener} from './modifications';
import {getScrollBarWidth, Console, debugMode} from './helpers.js';
import Channel from './channel';
import OperationScope from './form/containers/OperationScope.jsx';
import OperationModal from './components/OperationModal.jsx';
import OperationDeleteDialog from './components/OperationDeleteDialog.jsx';
import {getContainerId, setContainer} from './portals.js';

const logger = (/* store */) => next => action => {
    Console.log('dispatching', action);
    const result = next(action);
    // console.log('next state', store.getState());
    return result;
};

/**
 * Original code from http://redux.js.org/docs/advanced/Middleware.html
 * Schedules actions with { meta: { delay: N } } to be delayed by N milliseconds.
 * Makes `dispatch` return a function to cancel the timeout in this case.
 */
const timeoutScheduler = (/* store */) => next => action => {
    if (!action.meta || !action.meta.delay) {
        return next(action);
    }

    const timeoutId = setTimeout(
        () => next(action),
        action.meta.delay
    );

    return function cancel() {
        clearTimeout(timeoutId);
    };
};

const sagaMiddleware = ReduxSaga.createSagaMiddleware();

const middlewares = [thunk, timeoutScheduler, sagaMiddleware];
if (debugMode) {
    middlewares.unshift(logger);
}
const basicEnhancer = applyMiddleware(...middlewares);

/**
 * If debug mode is on from the backend, and the redux devtools browser extension
 * is active, wrap the redux store to use the devtools.
 */
const storeEnhancer =
    (debugMode && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ !== undefined) ?
        window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({name: 'global'})(basicEnhancer)
        : basicEnhancer;

// composed saga run
function* allSagas() {
    yield ReduxSaga.effects.all(Registry.getSagas().map(ReduxSaga.effects.call));
}

/**
 * Return the React component for the application root, according to the
 * configuration from the backend. The configuration can be either a simple
 * component name that will be looked up in the registry, or a more complex
 * configuration object.
 * In the latter case, all keys of the configuration object can in turn be
 * component names or configurations. The configuration object must contain a
 * key ``pageRenderer``, that represents the top level application component.
 * All other keys are given as props to this component.
 */
export function getAppComponent() {
    const appComponentName = getAppSetup().getIn(['appSettings', 'appComponent']);
    if (appComponentName === null) {
        // No component name given, so use a configuration.
        const appConf = getAppSetup()
            .get('applicationConfiguration')
            .map(
                conf =>
                    typeof conf === 'string'
                        ? Registry.findComponent(conf)
                        : makeConfiguredComponentClass(conf)
            );
        const App = function(props) {
            const PageRenderer = appConf.get('pageRenderer');
            const childProps = appConf.delete('pageRenderer').toObject();
            return <PageRenderer {...props} {...childProps} />;
        };
        App.displayName = 'ConfiguredApp';
        return App;
    }
    else {
        // The BE gave a registered component name, so we simply use that.
        return Registry.findComponent(appComponentName);
    }
}

class DnD_Wrapper extends React.Component {
    render() {
        return (
            <div className={prefixNS('dnd-wrapper')}>
                {this.props.children}
            </div>
        );
    }
}

function setupScrollbarSizes() {
    window.CE_SCROLLBAR_WIDTH = getScrollBarWidth();
}

export function getAppContainer() {
    const appSetup = getAppSetup();
    // disable body scrolling if backend-app permits it.
    if (appSetup.getIn(['appSettings', 'renderFixedBody'])) {
        document.body.classList.add(prefixNS("fixed-body"));
    }
    // Get registered reducer functions here, so that all JS files are already
    // loaded and the component registrations are done.
    const store = createStore(combineReducers(Registry.getReducers()), storeEnhancer);
    sagaMiddleware.run(allSagas);
    const Wrapper = ReactDnD.DragDropContext(ReactDnD.HTML5Backend)(DnD_Wrapper);
    const locale = appSetup.getIn(['appSettings', 'language']);
    const portalContainerId = getContainerId();
    setupScrollbarSizes();
    return function AppRoot(props) {
        return (
            <Provider store={store}>
                <ReactIntl.IntlProvider locale={locale}>
                    <Channel.Provider channelName="">
                        <Wrapper>
                            <OperationScope>
                                <OperationModal handlerName="*"/>
                                <OperationDeleteDialog />
                                {isCEDesktop() ? <ModificationListener /> : null}
                                {React.Children.only(props.children)}
                            </OperationScope>
                            <div id={portalContainerId}
                                 className={portalContainerId}
                                 ref={setContainer} />
                            <Messages.NotificationContainer />
                        </Wrapper>
                    </Channel.Provider>
                </ReactIntl.IntlProvider>
            </Provider>
        );
    };
}
