/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: WithTypeAhead.jsx 185125 2018-10-16 09:13:25Z cla $"
 */

import React from 'react';
import ReactDOM from 'react-dom';
import {PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import {prefixNS} from '../helpers';
import {formatStr} from '../i18n.js';
import Overlays from '../overlays';

const {TypeAhead, Menu, MenuItem} = Overlays;

function DefaultItem(props) {
    const {inputString, item} = props;
    const lower = inputString.toLowerCase();
    let showing = '';
    if (typeof item === 'string') {
        showing = item;
    }
    else {
        showing = item.toString();
    }
    const matchIdx = showing.toLowerCase().indexOf(lower);
    const lengthIdx = matchIdx + lower.length;
    return (
        <span>
            {showing.substring(0, matchIdx)}
            <b>{showing.substring(matchIdx, lengthIdx)}</b>
            {showing.substr(lengthIdx)}
        </span>
    );
}

DefaultItem.propTypes = {
    inputString: PropTypes.string,
    item: PropTypes.oneOfType([PropTypes.string, PropTypes.object])
};

class TypeDropDownMenu extends React.Component {
    render() {
        const {
            inputString, matched, activated,
            ItemRenderer, ...others
        } = this.props;
        delete others.hasMoreMatches;
        return (
            <Menu
                className={prefixNS('formcontrols-withtypeahead-menu')}
                {...others}>
                {matched.map((item, idx) => (
                    <MenuItem eventKey={idx}
                              key={idx}
                              active={idx === activated}>
                        <ItemRenderer inputString={inputString} item={item} />
                    </MenuItem>
                ))}
                {
                    this.props.hasMoreMatches ?
                    <div className={prefixNS("formcontrols-withtypeahead-has-more")}>
                        {formatStr("has_more")}
                    </div>
                    : null
                }
            </Menu>
        );
    }
}

TypeDropDownMenu.propTypes = {
    inputString: PropTypes.string,
    activated: PropTypes.number,
    matched: ImmutablePropTypes.list,
    hasMoreMatches: PropTypes.bool,
    ItemRenderer: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.object
    ])
};

TypeDropDownMenu.defaultProps = {
    ItemRenderer: DefaultItem
};

let typeAheadCounter = 0;

/**
 *
 * This component enhances another
 * <:ref:`cs-web-components-base-formcontrols.TextInput.__default__`>-based
 * form control with ``type ahead`` feature. It will open a drop down list to show possible options
 * during typing. The extended component has following additional properties:
 *
 * +-------------------------+--------------------+-------------+----------------------------------------------------+
 * | Property                | Type               | Default     | Use                                                |
 * +=========================+====================+=============+====================================================+
 * | onSelectAt              | func               | -           | A callback fired when an option from the drop down |
 * |                         |                    |             | is selected, the index of the option is passed in  |
 * +-------------------------+--------------------+-------------+----------------------------------------------------+
 * | onTAStepAt              | func               | -           | A callback fired when an option from the drop down |
 * |                         |                    |             | is navigated by pressing arrow keys, the index of  |
 * |                         |                    |             | the option is passed in                            |
 * +-------------------------+--------------------+-------------+----------------------------------------------------+
 * | onTACancel              | func               | -           | A callback fired when the user close the drop down |
 * |                         |                    |             | by pressing "Escape" key                           |
 * +-------------------------+--------------------+-------------+----------------------------------------------------+
 * | value                   | any                | -           | Data to be displayed                               |
 * +-------------------------+--------------------+-------------+----------------------------------------------------+
 * | matched                 | Immutable.List     | -           | A list of options, which match the typed data      |
 * +-------------------------+--------------------+-------------+----------------------------------------------------+
 * | hasMoreMatches          | bool               | -           | Indicates if list of matches was truncated         |
 * +-------------------------+--------------------+-------------+----------------------------------------------------+
 * | TypeAheadItemRenderer   | component          | -           | Renderer for the options in the drop down list     |
 * +-------------------------+--------------------+-------------+----------------------------------------------------+
 * | forceOpenMatchesOnFocus | bool               | -           | Dropdown opens when input receives focus.          |
 * +-------------------------+--------------------+-------------+----------------------------------------------------+
 *
 * Example:
 *
 * .. code-block:: none
 *
 *     import React from 'react';
 *     import {FormControl} from 'cs-web-components-base';
 *     import Immutable from 'immutable';
 *
 *     const testData = Immutable.List([
 *         'Bayern',
 *         'Berlin',
 *         'Brandenburg',
 *         'Bremen',
 *         'Sachsen',
 *         'Sachsen-Anhalt'
 *     ]);
 *
 *     function filterTestData(value) {
 *         const lowered = value.toLowerCase();
 *         return testData.filter(item => lowered !== '' && item.toLowerCase().indexOf(lowered) == 0);
 *     }
 *
 *     const TypeAheadText = FormControl.WithTypeAhead(FormControl.TextInput);
 *
 *     // can be used in render() of some other component as: <StaticTypeAhead />
 *     class StaticTypeAhead extends React.Component {
 *         constructor(props) {
 *             super(props);
 *             this.state = {
 *                 text: '',
 *                 matches: Immutable.List()
 *             };
 *             this.onTextChange = this.onTextChange.bind(this);
 *             this.onSelectAt = this.onSelectAt.bind(this);
 *         }
 *
 *         onTextChange(event) {
 *             const value = event.target.value;
 *             this.setState({
 *                 text: value,
 *                 matches: filterTestData(value)
 *             });
 *         }
 *
 *         onSelectAt(idx) {
 *             const hit = this.state.matches.get(idx);
 *             this.setState({
 *                 text: hit,
 *                 matches: filterTestData(hit)
 *             });
 *         }
 *
 *         render() {
 *             return (
 *                 <div>
 *                     <label className="text-muted">type 'b' or 's'</label>
 *                     <TypeAheadText
 *                         value={this.state.text}
 *                         matched={this.state.matches}
 *                         onChange={this.onTextChange}
 *                         onSelectAt={this.onSelectAt}/>
 *                 </div>
 *             );
 *         }
 *     };
 *
 *
 * @module
 */
export default function(WrappedComponent) {
    class WithTypeAhead extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                matchActive: -1,
                hide: false,
            };
            this.dropdownID = ++typeAheadCounter;
            // use local var to keep selecting state
            // to tell ignore input blur
            // setState does not work because of run loop
            this.selecting = false;
            this.onKeyDown = this.onKeyDown.bind(this);
            this.onChange = this.onChange.bind(this);
            this.onToggle = () => {};
            this.onSelect = this.onSelect.bind(this);
            this.onFocus = this.onFocus.bind(this);
            this.onBlur = this.onBlur.bind(this);
            this.onSelecting = this.onSelecting.bind(this);
            this._overlay = null;
            this.setOverlayElement = this.setOverlayElement.bind(this);
            this._wrappedElement = null;
            this._wrappedComponent = null;
            this.setWrappedComponentRef = this.setWrappedComponentRef.bind(this);
        }

        isOpen() {
            return this.props.matched.count() > 0 && !this.state.hide;
        }

        stepMatch(step) {
            const count = this.props.matched.count();
            let nextMatch = this.state.matchActive + step;
            if (nextMatch >= count) {
                nextMatch = -1;
            }
            else if (nextMatch < -1) {
                nextMatch = count - 1;
            }
            this.setState({
                matchActive: nextMatch
            });
            if (this.props.onTAStepAt) {
                this.props.onTAStepAt(nextMatch);
            }
        }

        onKeyDown(event) {
            const {onKeyDown} = this.props;
            if (this.isOpen()) {
                switch (event.key) {
                    case 'ArrowDown':
                        this.stepMatch(1);
                        event.preventDefault();
                        return undefined;
                    case 'ArrowUp':
                        this.stepMatch(-1);
                        event.preventDefault();
                        return undefined;
                    // case 'ArrowRight':
                    //     return;
                    case 'Enter':
                        this.setState({hide: true});
                        if (this.state.matchActive > -1) {
                            event.preventDefault();
                            return this.onSelectAt(this.state.matchActive);
                        }
                        break;
                    case 'Escape':
                        this.setState({hide: true});
                        event.preventDefault();
                        if (this.props.onTACancel) {
                            this.props.onTACancel();
                        }
                        return undefined;
                    default:
                        break;
                }
            } else {
                switch (event.key) {
                    case 'ArrowDown':
                        this.setState({
                            hide: false
                        });
                        event.preventDefault();
                        return undefined;
                    default:
                        break;
                }
            }
            if (onKeyDown) {
                event.persist();
                return onKeyDown(event);
            }
            return undefined;
        }

        onChange(event) {
            const {onChange} = this.props;
            this.setState({
                matchActive: -1
            });
            if (onChange) {
                event.persist();
                return onChange(event);
            }
            return undefined;
        }

        onSelect(eventKey) {
            return this.onSelectAt(eventKey);
        }

        onSelectAt(idx) {
            const {matched, onSelectAt} = this.props;
            if (idx < 0 || idx >= matched.count()) {
                return undefined;
            }
            this.setState({
                matchActive: -1
            }, () => {
                if (this._wrappedComponent && this._wrappedComponent.quitEditing) {
                    this._wrappedComponent.quitEditing();
                }
                if (this._wrappedElement) {
                    if (this._wrappedElement.querySelector('input')) {
                        this._wrappedElement.querySelector('input').focus();
                    }
                    else if (this._wrappedElement.querySelector('textarea')) {
                        this._wrappedElement.querySelector('textarea').focus();
                    }
                }
            });
            this.selecting = false;
            if (onSelectAt) {
                return onSelectAt(idx);
            }
            return undefined;
        }

        onFocus(event) {
            const {onFocus, forceOpenMatchesOnFocus} = this.props;

            if (this.state.hide && forceOpenMatchesOnFocus) {
                this.setState({hide: false});
            }

            if (onFocus) {
                return onFocus(event);
            }

            return undefined;
        }

        onBlur(event) {
            const {onBlur} = this.props;

            // Keep focus on TextInput if Overlay is focused.
            if (event.relatedTarget && this._overlay &&
                (event.relatedTarget === this._overlay ||
                 this._overlay.contains(event.relatedTarget))) {

                if (this._wrappedElement) {
                    const input = this._wrappedElement.querySelector('input') ||
                                  this._wrappedElement.querySelector('textarea');
                    if (input) {
                        input.focus();
                    }
                }

                event.stopPropagation();
                return undefined;
            }

            if (!this.selecting) {
                this.setState({
                    hide: true,
                    matchActive: -1,
                });
                if (onBlur) {
                    return onBlur(event);
                }
            }
            return undefined;
        }

        onSelecting() {
            this.selecting = true;
            if (this._wrappedComponent && this._wrappedComponent.ignoreBlurring) {
                this._wrappedComponent.ignoreBlurring();
            }
        }

        componentWillReceiveProps(nextProps) {
            if (nextProps.matched !== this.props.matched) {
                const autoSelect = nextProps.matched.count() > 0 && nextProps.autoSelectFirstMatch;
                this.setState({
                    hide: false,
                    matchActive: (autoSelect) ? 0 : -1
                });
            }
        }

        setOverlayElement(c) {
            this._overlay = c ? ReactDOM.findDOMNode(c) : null;  // eslint-disable-line react/no-find-dom-node
        }

        setWrappedComponentRef(c) {
            if (c) {
                this._wrappedElement = ReactDOM.findDOMNode(c);  // eslint-disable-line react/no-find-dom-node
                this._wrappedElement.addEventListener('focusout', this.onBlur);
            } else {
                this._wrappedElement.removeEventListener('focusout', this.onBlur);
                this._wrappedElement = null;
            }

            this._wrappedComponent = c;
        }

        render() {
            const {
                value,
                TypeAheadItemRenderer,
                matched,
                onBlur,
                onFocus,
                forceOpenMatchesOnFocus,
                ...others
            } = this.props;

            delete others.onSelectAt;
            delete others.hasMoreMatches;
            delete others.onTAStepAt;
            delete others.onTACancel;
            delete others.autoSelectFirstMatch;
            delete others.forceOpenMatchesOnFocus;

            const {matchActive} = this.state;
            const isOpen = this.isOpen();

            const onFocusCb = forceOpenMatchesOnFocus ? this.onFocus : onFocus;

            return (
                <TypeAhead.Static setOverlayRef={this.setOverlayElement}
                                  onHide={onBlur}
                                  visible={isOpen}>
                    <WrappedComponent
                        groupClassName={prefixNS('formcontrols-withtypeahead')}
                        value={value}
                        {...others}
                        onKeyDown={this.onKeyDown}
                        onChange={this.onChange}
                        onFocus={onFocusCb}
                        autoComplete="off"
                        ref={this.setWrappedComponentRef} />
                    <TypeDropDownMenu
                        inputString={value}
                        ItemRenderer={TypeAheadItemRenderer}
                        bsRole="menu"
                        matched={matched}
                        activated={matchActive}
                        onSelect={this.onSelect}
                        onMouseDown={this.onSelecting}
                        hasMoreMatches={this.props.hasMoreMatches} />
                </TypeAhead.Static>
            );
        }
    }

    WithTypeAhead.propTypes = {
        onFocus: PropTypes.func,
        onBlur: PropTypes.func,
        onKeyDown: PropTypes.func,
        onChange: PropTypes.func,
        onSelectAt: PropTypes.func,
        onTAStepAt: PropTypes.func,
        onTACancel: PropTypes.func,
        value: PropTypes.any,
        matched: ImmutablePropTypes.list,
        hasMoreMatches: PropTypes.bool,
        autoSelectFirstMatch: PropTypes.bool,
        forceOpenMatchesOnFocus: PropTypes.bool,
        TypeAheadItemRenderer: PropTypes.oneOfType([
            PropTypes.func,
            PropTypes.instanceOf(React.Component)
        ])
    };

    WithTypeAhead.defaultProps = {
        hasMoreMatches: false,
        autoSelectFirstMatch: false,
        forceOpenMatchesOnFocus: false
    };

    return WithTypeAhead;
}
