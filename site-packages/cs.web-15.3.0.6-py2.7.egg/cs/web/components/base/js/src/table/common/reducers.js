/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: reducers.js 184132 2018-09-19 09:18:57Z vov $"
 */

import Immutable from 'immutable';
import {
    SET_COLUMNS, SET_ORDERED_COLUMNS, SET_HIDDEN_COLUMNS,
    SET_SELECTED_ROWS, SET_FOCUSED_ROW, SET_FOCUSED_COLUMN,
    SET_COLUMN_ACTIONS, SET_HEADER_PANELS,
    SET_FOOTER_PANELS, SET_TOOLBAR_BUTTONS, SET_TOOLBAR_MENU,
    SET_SETTING_PANELS, SET_COLUMN_HEADER_CLICKED, SET_COLUMN_WIDTH,
    SET_TABLE_SETTINGS_FETCHED, SET_TABLE_USER_SETTING,
    SET_ROW_CLASS_NAME, ADD_COLUMN_RENDERER,
    ADD_UNHIDABLE_COLUMNS, REMOVE_UNHIDABLE_COLUMNS,
    SET_FIXED_COLUMNS,
    NAVIGATE,
    SELECT_ALL_ROWS_EVENT, SET_SELECTABLE_ROWS_AGGREGATION_STATE,
    SELECT_RANGE_EVENT, SET_RENDER_DIRECTIVES, SET_FOCUS_TABLE, RESET_FOCUS_TABLE
} from './actions';
import {reselect} from 'cs-web-components-externals';

export function settingsToStore(state = Immutable.Set(), action) {
    switch (action.type) {
        case SET_TABLE_USER_SETTING:
            return state.add(action.payload);
        default:
            return state;
    }
}

export function columns(state = Immutable.List(), action) {
    switch (action.type) {
        case SET_COLUMNS:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function orderedColumns(state = Immutable.OrderedSet(), action) {
    switch (action.type) {
        case SET_ORDERED_COLUMNS:
            return action.payload === undefined ? state : action.payload;
        case SET_TABLE_SETTINGS_FETCHED:
            return action.payload.get('orderedColumns') ?
                action.payload.get('orderedColumns').toOrderedSet()
                    .intersect(action.payload.get('columnIDs'))
                    .union(action.payload.get('columnIDs')) :
                Immutable.OrderedSet();  // Reset if undefined
        default:
            return state;
    }
}

export function hiddenColumns(state = Immutable.Set(), action) {
    switch (action.type) {
        case SET_HIDDEN_COLUMNS:
            return action.payload === undefined ? state : action.payload;
        case SET_TABLE_SETTINGS_FETCHED:
            return action.payload.get('hiddenColumns') ?
                action.payload.get('hiddenColumns').toOrderedSet()
                    .intersect(action.payload.get('columnIDs')) :
                Immutable.Set();  // Reset if undefined
        default:
            return state;
    }
}

export function columnActions(state = Immutable.List(), action) {
    switch (action.type) {
        case SET_COLUMN_ACTIONS:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function toolbarButtons(state = Immutable.List(), action) {
    switch (action.type) {
        case SET_TOOLBAR_BUTTONS:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function toolbarMenu(state = Immutable.List(), action) {
    switch (action.type) {
        case SET_TOOLBAR_MENU:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function settingPanels(state = Immutable.List(), action) {
    switch (action.type) {
        case SET_SETTING_PANELS:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function headerPanels(state = Immutable.List(), action) {
    switch (action.type) {
        case SET_HEADER_PANELS:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function footerPanels(state = Immutable.List(), action) {
    switch (action.type) {
        case SET_FOOTER_PANELS:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function selectedRows(state = Immutable.OrderedSet(), action) {
    switch (action.type) {
        case SET_SELECTED_ROWS:
            return action.payload.rows === undefined ? state : action.payload.rows;
        default:
            return state;
    }
}

export function isFocusOnTable(state = null, action) {
    switch (action.type) {
        case SET_FOCUS_TABLE:
            return true;
        case RESET_FOCUS_TABLE:
            return false;
        default:
            return state;
    }
}

export function selectionAnchor(state = null, action) {
    switch (action.type) {
        case SET_SELECTED_ROWS:
            return action.payload.selectionAnchor === undefined ?
                   null :
                   action.payload.selectionAnchor;
        default:
            return state;
    }
}

export function focusedRow(state = null, action) {
    switch (action.type) {
        case SET_FOCUSED_ROW:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function focusedColumn(state = null, action) {
    switch (action.type) {
        case SET_FOCUSED_COLUMN:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function columnHeaderClicked(
    state = Immutable.Map({columnID: null}), action) {
    switch (action.type) {
        case SET_COLUMN_HEADER_CLICKED:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function columnWidths(state = Immutable.Map(), action) {
    switch (action.type) {
        case SET_COLUMN_WIDTH:
            return action.payload === undefined ?
                state :
                state.set(action.payload.columnID, action.payload.width);
        case SET_TABLE_SETTINGS_FETCHED:
            return action.payload.get('columnWidths') ?
                   action.payload.get('columnWidths').
                       filter((v, k) => action.payload.get('columnIDs').includes(k)) :
                   state;
        default:
            return state;
    }
}

export function rowClassName(state = Immutable.Map(), action) {
    switch (action.type) {
        case SET_ROW_CLASS_NAME:
            return action.payload === undefined ?
                state :
                state.merge(action.payload);
        default:
            return state;
    }
}

export function tableID(state = 1) {
    return state;
}

export function columnRenderers(state = Immutable.Map(), action) {
    switch (action.type) {
        case ADD_COLUMN_RENDERER: {
            if (action.payload === undefined) {
                return state;
            }
            const renderers = state.get(
                action.payload.columnID,
                Immutable.OrderedSet());
            return state.set(
                action.payload.columnID,
                renderers.add(action.payload.renderer));
        }
        default:
            return state;
    }
}

export function unhidableColumns(state = Immutable.Set(), action) {
    switch (action.type) {
        case ADD_UNHIDABLE_COLUMNS:
            return action.payload === undefined ?
                state : state.concat(action.payload);
        case REMOVE_UNHIDABLE_COLUMNS:
            return action.payload === undefined ?
                state : state.subtract(action.payload);
        default:
            return state;
    }
}

export function fixedColumns(state = 0, action) {
    switch (action.type) {
        case SET_FIXED_COLUMNS:
            return action.payload === undefined ? state : action.payload;
        case SET_TABLE_SETTINGS_FETCHED:
            return action.payload.get('fixedColumns') === undefined ?
                0 : action.payload.get('fixedColumns');
        default:
            return state;
    }
}

export function navigation(state = null, action) {
    switch (action.type) {
        case NAVIGATE:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export const getVisibleColumns = reselect.createSelector(
    [
        state => state.orderedColumns,
        state => state.hiddenColumns,
        state => state.unhidableColumns,
    ],
    (orderedColumns, hiddenColumns, unhidableColumns) =>
        orderedColumns.subtract(hiddenColumns.subtract(unhidableColumns))
);

export function selectAllRowsEvent(state = Immutable.Map(), action) {
    switch (action.type) {
        case SELECT_ALL_ROWS_EVENT:
            return Immutable.Map({selectAll: action.payload});
        default:
            return state;
    }
}

export function getSelectAllRowsEvent(state) {
    return state.selectAllRowsEvent;
}

export function selectableRowsAggregationState(state = 0, action) {
    switch (action.type) {
        case SET_SELECTABLE_ROWS_AGGREGATION_STATE:
            return action.payload === undefined ? state : action.payload;
        default:
            return state;
    }
}

export function getSelectableRowsAggregationState(state) {
    return state.selectableRowsAggregationState;
}

export function selectRangeEvent(state = {}, action) {
    switch (action.type) {
        case SELECT_RANGE_EVENT:
            return action.payload;
        default:
            return state;
    }
}

export function getSelectRangeEvent(state) {
    return state.selectRangeEvent;
}

export function renderDirectives(state = Immutable.Map(), action) {
    switch (action.type) {
        case SET_RENDER_DIRECTIVES:
            return action.payload === undefined ?
                state :
                state.merge(action.payload);
        default:
            return state;
    }
}

export default {
    columns, orderedColumns, hiddenColumns,
    columnActions, toolbarButtons, toolbarMenu,
    headerPanels, footerPanels,
    settingPanels, selectedRows, focusedRow, focusedColumn,
    columnHeaderClicked, columnWidths, settingsToStore,
    rowClassName, tableID, columnRenderers,
    unhidableColumns, fixedColumns,
    navigation, selectionAnchor,
    selectAllRowsEvent, selectRangeEvent,
    selectableRowsAggregationState, renderDirectives, isFocusOnTable
};
