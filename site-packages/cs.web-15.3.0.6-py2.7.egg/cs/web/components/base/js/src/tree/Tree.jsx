/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Tree.jsx 174864 2018-03-22 11:24:56Z gwe $"
 */

import React from 'react';
import Immutable from 'immutable';
import {PropTypes, ImmutablePropTypes, classNames} from 'cs-web-components-externals';
import {prefixNS} from '../helpers.js';
import {walkTopDownDepthFirst, walkTopDownDepthFirstCustom, visit} from './tree-tools.js';
import {SimpleSearchAdapter} from './SearchAdapter.jsx';
import DefaultNodeRenderer, {NodeRendererType} from './NodeRenderer.jsx';
import TreeContainer from './TreeContainer';
import Registry from './Registry.js';
import SimpleTextMatcher from './SimpleTextMatcher';

/**
 * The Tree class is a highly customizable component to display tree structures.
 * It provides an interface to search for nodes in the tree, and to navigate
 * through the search result. Furthermore, keyboard navigation is provided
 * to navigate through the trees nodes.
 *
 * Specifying the tree's structure
 * -------------------------------
 *
 * Subclasses of Tree must at least set the :samp:`rootNode` attribute in the
 * component's state. The root node must be an :samp:`Immutable.Map` instance,
 * with the following entries:
 *
 * - id: a unique ID for the node
 * - content: the actual content belonging to the node, the node renderer
 *   component must be able to render this
 * - expanded: bool, describes the current state of the node
 * - children: an :samp:`Immutable.List` instance with child nodes
 * - has_children: bool, describes whether the node has children. If this is set
 *   to :samp:`true`, but :samp:`children` is empty, :samp:`fetchNodeChildren`
 *   is called to retrieve the child nodes.
 *
 * Deferred loading of children
 * ----------------------------
 *
 * If your tree implementation can be expanded dynamically, your subclass must
 * also implement the method :samp:`fetchNodeChildren`. This method will be
 * invoked, if a node indicates it has children that are not yet fetched (the nodes
 * has_children property is set to true, but the property children is an empty list)
 * (from the server). fetchNodeChildren must be a thenable that:
 *
 * - fetches the children by application-specific means
 * - updates the tree node whose children have been fetched, by invoking
 *   ``super.updateTreeNode(...)`` which is a thenable that resolves after
 *   the tree has been updated.
 * - resolves after the tree has been updated.
 *
 * .. code-block:: javascript
 *
 *    attachChildren(node, children) {
 *      return node.set('children', Immutable.List(children));
 *    }
 *
 *    fetchNodeChildren(node) {
 *      return runRestGet(node.get('child_url')).then(children => {
 *         const nodeWithChildren = this.attachChildren(node, children);
 *         return super.updateTreeNode(nodeWithChildren);
 *      });
 *    }
 *
 * If your tree implementation does not know in advance, wether there are child
 * nodes to be fetched, you may initialize all nodes with has_children set to
 * true, and when you discover that no child nodes are available
 * for a given node fetchNodeChildren may set the has_children property to false,
 * instead of updating children.
 *
 * Searching for nodes
 * -------------------
 *
 * Two properties control, how the tree may be searched:
 *
 * - **SearchAdapter** is a property that allows to enhance the
 *   mechanism by which the tree's structure is navigated during search.
 * - **matcher** controls how the search algorithm determines a match.
 *
 * A matcher must be a function that contains the following signature:
 *
 * .. code-block:: javascript
 *
 *    (node, search) => Boolean
 *
 * ``node`` is the node for whom a match should be determined, while
 * ``search`` is the string that is input into the searchwidget.
 *
 * SearchAdapters are provided by module tree.SearchAdapter. Available are
 * SimpleSearchAdapter, which implements a basic top-down depth-first search
 * on all already loaded nodes and BackendSearchAdapter, which fetches children
 * using fetchNodeChildren.
 *
 * Rendering the title
 * -------------------
 *
 * The title is rendered as follows: If a TitleRenderer React.Component is
 * specified, this component will be rendered. It will be provided the tree's props
 * and state as props. If no TitleRenderer is specified the prop title will be used
 * as the title. The prop title can be overwritten by specifying a state-variable
 * title when subclassing the tree.
 *
 * Customizing tree rendering
 * --------------------------
 *
 * The property ``TreeRenderer`` allows to customize the way the tree component is
 * rendered. Rendering occurs through a series of HOCs terminated by a tree renderer
 * component. The renderer itself is responsible to render the tree structure provided
 * as ``rootNode`` property, while the nested HOCs may modify the tree's properties,
 * and enhance the tree's UI representation.
 *
 * The default configuration is as follows:
 *
 * .. code-block:: javascript
 *
 *    TreeContainer.DefaultRenderer = compose(
 *      Tree.TreeRenderer,
 *      Tree.TreeFilter.ShowSearchResults,
 *      Tree.TreeContainer,
 *    );
 *
 * In addition, the component ModalTreeContainer provides a simplified default renderer
 * for use in modal dialogs, which avoids the use of modal components.
 *
 * Customizing node rendering
 * --------------------------
 *
 * The tree component provides a module NodeRenderer, which provides a set of HOCs to
 * customize the trees ability to render nodes. Examples of using this API may be found
 * in StructureTree and RestTree, which use configurable default components provided by
 * NodeRenderer to extract labels and icons from the tree-nodes provided by a
 * domain-specific API to render their nodes.
 *
 * React Properties
 * ================
 *
 * +-----------------------+-----------+---------+---------------------------------+
 * | Property              | Type      | Default | Use                             |
 * +=======================+===========+=========+=================================+
 * | className             | string    | \-      | Attach a custom classname to    |
 * |                       |           |         | the tree component.             |
 * +-----------------------+-----------+---------+---------------------------------+
 * | NodeRenderer          | string    | \-      | React component that will be    |
 * |                       |           |         | used to render the node content |
 * +-----------------------+-----------+---------+---------------------------------+
 * | hasFocus              | bool      | true    | If true, the tree should handle |
 * |                       |           |         | keybpard events for navigation  |
 * +-----------------------+-----------+---------+---------------------------------+
 * | TitleRenderer         | component | \-      |                                 |
 * +-----------------------+-----------+---------+---------------------------------+
 * | TreeRenderer          | component | \-      | Custom tree rendering           |
 * +-----------------------+-----------+---------+---------------------------------+
 * | onSelect              | func      | \-      | Callback on node selection      |
 * +-----------------------+-----------+---------+---------------------------------+
 * | title                 | string    | \-      |                                 |
 * +-----------------------+-----------+---------+---------------------------------+
 * | hideRoot              | bool      | false   | If true, root node is not       |
 * |                       |           |         | rendered                        |
 * +-----------------------+-----------+---------+---------------------------------+
 *
 * @module
 */

/*
 * Helper function for recursive expansion of children.
 *
 * @private
 */
function removeExpandChildren(node) {
    if (node.has('expandChildren')) {
        const noFetchingNeeded = !(node.get('children').size === 0 && node.get('has_children'));
        if (noFetchingNeeded) {
            return node.delete('expandChildren');
        }
    }

    return node;
}

export default class Tree extends React.Component {
    /*
     * TODO factory/clone methods for node objects
     * @private
     */
    constructor(props) {
        super(props);

        this.publicInterface = {};

        // In the multiselect case, selectedId is the id of the last selected
        // node, while selectedIds is the complete set of the selected nodes
        this.state = {
            title: props.title,
            rootNode: this.props.rootNode || null,
            selectedId: undefined,
            selectedIds: Immutable.Set(),
            searchResult: Immutable.Map(),
            searchResultOrder: Immutable.List(),
            selectedSearchResult: -1
        };

        this._bindInterface({
            getRoot: this.getRoot.bind(this),
            getPath: this.getPath.bind(this),
            getNodeById: this.getNodeById.bind(this),
            activateKey: this.activateKey.bind(this),
            selectTreeNode: this.selectTreeNode.bind(this),
            selectTreeNodeById: this.selectTreeNodeById.bind(this),
            setSearchResult: this.setSearchResult.bind(this),
            getSearchResult: () => this.state.searchResult,
            getSelectedSearchResult: () => this.state.selectedSearchResult === -1 ?
                                         undefined :
                                         this.getNodeById(this.state.searchResultOrder.get(
                                             this.state.selectedSearchResult)),
            setSelectedSearchResultIndex: this.setSelectedSearchResultIndex.bind(this),
            getSelectedSearchResultIndex: () => this.state.selectedSearchResult,
            getSearchResultCount: () => this.state.searchResultOrder.size,
            toggleTreeNode: this.toggleTreeNode.bind(this),
            fetchNodeChildren: this.fetchNodeChildren.bind(this),
            expandLevels: this.expandLevels.bind(this),
            collapseLevels: this.collapseLevels.bind(this)
        });
    }

    /**
     * Add provided members to this.publicInterface and this.state.
     * If a key is already defined it will be overwritten in both objects.
     *
     * @private
     */
    _bindInterface(members) {
        Object.assign(
            this.state,
            Object.assign(this.publicInterface, members)
        );
    }

    _initSearchAdapter() {
        this.searchAdapter = new this.props.SearchAdapter(
            this.publicInterface,
            this.props.matcher,
            this.props.hideRoot
        );
    }

    componentWillMount() {
        this._initSearchAdapter();
    }

    componentWillReceiveProps(nextProps) {
        if (this.props.matcher !== nextProps.matcher ||
            this.props.hideRoot !== nextProps.hideRoot) {
            this._initSearchAdapter();
        }

        // Rendering component has changed root node
        if (this.props.rootNode !== nextProps.rootNode) {
            let newRoot = nextProps.rootNode;

            if (this.state.rootNode && nextProps.rootNode) {
                // Transfer expansion state of nodes
                newRoot = visit(nextProps.rootNode, {
                    ascending: node => {
                        const oldNode = this.getNodeById(node.get('id'));
                        return (
                            oldNode && oldNode !== node ?
                            node.set('expanded', oldNode.get('expanded')) :
                            node
                        );
                    }
                });
            }

            this.setState({rootNode: newRoot});
        }
    }

    /**
     * Callback invoked if child nodes need to be fetched. You need to implement this if nodes in your tree
     * implementation have an empty list of children as nodes, but has_children set to true.
     * This method should clone the node, with children attached, or has_children set to false.
     * @private
     */
    fetchNodeChildren() {
        return null;
    }

    findNode(matcher) {
        const gen = walkTopDownDepthFirst(this.state.rootNode);
        let node;
        while (!(node = gen.next()).done) {
            if (matcher(node.value)) {
                return node.value;
            }
        }

        return undefined;
    }

    getRoot() {
        return this.state.rootNode;
    }

    // Exchange node and currentNode
    getPath(node, currentNode = undefined) {
        if (currentNode === undefined) {
            return this.getPath(node, this.getRoot());
        } else if (node.get('id') === currentNode.get('id')) {
            return [currentNode];
        } else {
            let foundSubPath = null;
            currentNode.get('children').forEach(child => {
                if (foundSubPath == null) {
                    const subPath = this.getPath(node, child);
                    if (subPath) {
                        subPath.unshift(currentNode);
                        foundSubPath = subPath;
                    }
                }
            });

            return foundSubPath;
        }
    }

    getNodeById(nodeId) {
        return this.findNode(node => node.get('id') === nodeId);
    }

    visitAndUpdate(callbacks, root = undefined) {
        if (!root) {
            return this.visitAndUpdate(callbacks, this.getRoot());
        } else if (root !== this.getRoot()) {
            return this.visitAndUpdate(
                {
                    descending: node => (root.get('id') === node.get('id') ?
                                         visit(root, callbacks) :
                                         node)
                }
            );
        } else {
            return new Promise(resolve => {
                const treeRoot = this.state.rootNode;
                const newTreeRoot = visit(treeRoot, callbacks);
                if (newTreeRoot !== treeRoot) {
                    this.setState({rootNode: newTreeRoot}, () => {
                        resolve(newTreeRoot);
                    });
                }
                return newTreeRoot;
            });
        }
    }

    /*
     * A node has been updated: propagate expandChildren flag if required.
     * See also expandChildren.
     */
    updateTreeNode(newNode) {
        return this.visitAndUpdate(
            {
                // Descending: Propagate expandChildren to children
                descending: (node, depth, parent) => {
                    if (parent && parent.get('expandChildren') > 1) {
                        return node.merge({
                            expanded: true,
                            expandChildren: parent.get('expandChildren') - 1
                        });
                    }
                    return node;
                },
                // Ascending: remove expandChildren if no children will be fetched
                ascending: removeExpandChildren
            },
            newNode
        );
    }

    /*
     * Recursively expand the tree's nodes under a root ``node`` for a number
     * of ``levels``.
     *
     * As fetchNodeChildren, will be called in TreeNode, we simply tag the
     * nodes for expansion. When expandLevels is called, the provided node
     * and each node for ``levels`` levels under it will receive a field
     * ``expandChildren`` that specifies the amount of levels that are to
     * be expanded on this particular node - only if fetchNodeChildren will
     * be invoked when tree is expanded.
     *
     * If a new subtree is then loaded, further expandChildren tags will be
     * added in updateTreeNode.
     */
    expandLevels(levels, node = undefined) {
        const selectedNode = node || this.getNodeById(this.state.selectedId) || this.getRoot();

        return this.visitAndUpdate(
            {
                // Descending: expand all nodes, set expandChildren and propagate to all children
                descending: (node, depth, parent) => {
                    if (node.get('id') === selectedNode.get('id')) {
                        // root of the subtree to be expanded
                        return node.merge({
                            expanded: true,
                            expandChildren: levels
                        });
                    } else if (parent.get('expandChildren') > 1) {
                        // propagate to nodes under subtrees root
                        return node.merge({
                            expanded: true,
                            expandChildren: parent.get('expandChildren') - 1
                        });
                    }
                    return node;
                },
                // Ascending: remove expandChildren if no children will be fetched
                ascending: removeExpandChildren
            },
            selectedNode
        );
    }

    /**
     * Recursively collapse all nodes under ``node``.
     * @private
     */
    collapseLevels(node = undefined) {
        const selectedNode = node || this.getNodeById(this.state.selectedId) || this.getRoot();
        const root = this.getRoot();

        return this.visitAndUpdate(
            {
                ascending: node => {
                    // Do not collapse root, if it is hidden.
                    if (node.get('id') === root.get('id') && this.props.hideRoot) {
                        return node;
                    }
                    return node.set('expanded', false);
                }
            },
            selectedNode
        );
    }

    toggleTreeNode(id) {
        return this.visitAndUpdate(
            {
                descending: node => {
                    if (node.get('id') === id) {
                        const expanded = node.get('expanded');
                        return node.set('expanded', !expanded);
                    }
                    else {
                        return node;
                    }
                }
            }
        );
    }

    selectTreeNodeById(id, searchResultIndex, add = false, toggle = true) {
        let selectedIds;
        if (add === true && this.state.selectedIds.has(id)) {
            // If the node is already selected, remove it from the selection
            selectedIds = this.state.selectedIds.delete(id);
        } else if (add === true) {
            selectedIds = this.state.selectedIds.add(id);
        } else {
            selectedIds = Immutable.Set().add(id);
        }

        let selectedNode = undefined;
        let unselectedNode = undefined;
        return this.visitAndUpdate(
            {
                descending: node => {
                    // Toggle flag if selected
                    if (selectedIds.has(node.get('id'))) {
                        const newNode = node.set('is_selected',
                            toggle === true ? !node.get('is_selected') : true);
                        if (newNode.get('is_selected')) {
                            selectedNode = newNode;
                        } else {
                            unselectedNode = newNode;
                        }
                        return newNode;
                    }
                    // Reset other nodes
                    else if (node.get('is_selected', false)) {
                        unselectedNode = node.set('is_selected', false);
                        return unselectedNode;
                    }
                    // Leave other nodes as is
                    return node;
                }
            }
        ).then(() => {
            return new Promise(resolve => {
                this.setState(
                    {
                        selectedId: id,
                        selectedIds,
                        searchResultIndex: searchResultIndex
                    },
                    () => {
                        if (this.props.onSelect) {
                            this.props.onSelect({
                                selectedNode: selectedNode ?
                                              selectedNode.get('content') :
                                              undefined,
                                unselectedNode: unselectedNode ?
                                                unselectedNode.get('content') :
                                                undefined
                            });
                        }
                        return resolve(selectedNode);
                    }
                );
            });
        });
    }

    selectTreeNode(node, add = false, toggle = true) {
        return this.selectTreeNodeById(
            node.get('id'), /*searchResultIndex=*/ undefined, add, toggle);
    }

    expandTreeNode(id) {
        const visit = match => node => {
            const visitChildren = node.get('children').map(visit(match));
            let newNode = node.set(
                'children', visitChildren.map(child => child.node)
            );

            const expand = match(newNode) ||
                visitChildren.some(child => child.expand);
            if (expand) {
                newNode = newNode.set('expanded', true);
            }

            return {expand, newNode};
        };

        const {node} = visit(node => (node.get('id') === id))(this.state.rootNode);
        if (node !== this.state.rootNode) {
            return new Promise(resolve => {
                this.setState({rootNode: node}, () => resolve(node));
            });
        }
        else {
            return Promise.resolve(node);
        }
    }

    setSelectedSearchResultIndex(searchResultIndex) {
        return new Promise(
            resolve => {
                this.setState(
                    {
                        selectedSearchResult: searchResultIndex
                    },
                    () => {
                        this.selectTreeNodeById(this.state.searchResultOrder
                                                    .get(this.state.selectedSearchResult))
                            .then(node => resolve(node));
                    }
                );
            }
        );
    }

    setSearchResult(matches, selectedSearchResult = 0) {
        return new Promise(
            resolve => {
                this.setState(
                    {
                        searchResult: matches,
                        searchResultOrder: Immutable.fromJS([...matches.keys()]),
                        selectedSearchResult: matches.size > 0 ? selectedSearchResult : -1
                    },
                    () => {
                        if (this.state.selectedSearchResult > -1) {
                            this.selectTreeNodeById(this.state.searchResultOrder
                                                        .get(this.state.selectedSearchResult))
                                .then(node => resolve(node));
                        } else {
                            resolve();
                        }
                    }
                );
            }
        );
    }

    activateKey(key) {
        const {hideRoot} = this.props;
        const {rootNode, selectedId} = this.state;
        // get the selected node with its previous and next visible nodes
        const getSelected = () => {
            // If no selection is available, use First node
            if (selectedId === undefined) {
                const selectedNode = hideRoot ?
                                     rootNode.getIn(['children', 0]) :
                                     rootNode;
                return {
                    previous: selectedNode,
                    selected: selectedNode,
                    next: selectedNode
                };
            }

            // iterate only on visible nodes
            const iterate = node =>
                (node.get('expanded') ? node.get('children') : Immutable.List());
            const gen = walkTopDownDepthFirstCustom(iterate)(rootNode);

            let previous;
            let selected;
            let next;
            let child;
            if (hideRoot) {
                gen.next(); // Skip root
            }
            while (!(child = gen.next()).done) {
                if (child.value.get('id') === selectedId) {
                    selected = child.value;
                    next = gen.next().value;
                    break;
                }
                previous = child.value;
            }
            return {
                previous,
                selected,
                next
            };
        };

        const getParent = () => {
            const _getParent = (node) => {
                let resultNode = null;

                node.get('children').forEach(child => {
                    if (resultNode == null) {
                        if (child.get('id') === selectedId) {
                            resultNode = node;
                        }
                    }
                });

                if (resultNode != null) {
                    return resultNode;
                }

                let parent;
                node.get('children').forEach(child => {
                    if (resultNode == null) {
                        parent = _getParent(child);
                        if (parent !== undefined) {
                            resultNode = parent;
                        }
                    }
                });

                return resultNode;
            };
            return _getParent(rootNode);
        };

        const {previous, selected, next} = getSelected();
        switch (key) {
            // Up and down arrow keys move between visible nodes
            case 'ArrowDown':
                if (next) {
                    this.selectTreeNode(next);
                }
                break;
            case 'ArrowUp':
                if (previous) {
                    this.selectTreeNode(previous);
                }
                break;
            case 'ArrowLeft':
                if (selected) {
                    if (selected.get('expanded')) {
                        // Left arrow key on an expanded node closes the node
                        this.toggleTreeNode(selectedId);
                    }
                    else {
                        // Left arrow key on a closed or end node moves focus to the node's parent
                        const parent = getParent();
                        if (parent && !(parent.get('id') === this.state.rootNode.get('id') &&
                                        this.props.hideRoot)) {
                            this.selectTreeNode(parent);
                        }
                    }
                }
                break;
            case 'ArrowRight':
                if (selected) {
                    if (selected.get('expanded')) {
                        // Right arrow key moves to the first child of an open node
                        const children = selected.get('children');
                        if (children && children.size > 0) {
                            this.selectTreeNode(children.get(0));
                        }
                    }
                    else {
                        // expands a closed node
                        this.toggleTreeNode(selectedId);
                    }
                    // or does nothing on a leaf node
                }
                break;
        }
    }

    renderTree(rendererProps = {}) {
        const {TreeRenderer, treeRendererName, className, ...rest} = this.props;
        const TheTreeRenderer = Registry.getTreeRenderer(treeRendererName) || TreeRenderer;
        const classes = classNames([prefixNS('tree'), className]);
        return (
            <div className={classes}>
                <TheTreeRenderer searchAdapter={this.searchAdapter}
                                 {...rest}
                                 SearchAdapter={undefined}
                                 {...this.state}
                                 {...rendererProps} />
            </div>
        );
    }

    render() {
        return this.renderTree();
    }
}

Tree.propTypes = {
    className: PropTypes.string,
    TreeRenderer: PropTypes.func,
    treeRendererName: PropTypes.string,
    NodeRenderer: NodeRendererType,
    TitleRenderer: PropTypes.oneOf([PropTypes.func, PropTypes.object]),
    SearchAdapter: PropTypes.func,
    title: PropTypes.string,
    matcher: PropTypes.func,
    hasFocus: PropTypes.bool,
    rootNode: ImmutablePropTypes.map,
    hideRoot: PropTypes.bool,
    onSelect: PropTypes.func
};

Tree.defaultProps = {
    TreeRenderer: TreeContainer.DefaultRenderer,
    NodeRenderer: DefaultNodeRenderer,
    SearchAdapter: SimpleSearchAdapter,
    matcher: SimpleTextMatcher(node => node.getIn(['content'])),
    hasFocus: true,
    hideRoot: false
};
