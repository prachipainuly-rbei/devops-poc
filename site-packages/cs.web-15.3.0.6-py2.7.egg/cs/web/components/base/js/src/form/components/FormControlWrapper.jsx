/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: FormControlWrapper.jsx 184286 2018-09-21 13:59:56Z cla $"
 */

import Immutable from 'immutable';
import React from 'react';
import {PropTypes} from 'cs-web-components-externals';
import FormControl from '../../formcontrols';
import mappingTextWrapper from './mappingTextWrapper';
import enumWrapper from './enumWrapper';
import fieldTypes, {
    isValue, isTriStateCheckBox, getRelevantAttributes, anyAttributeIsRelevant
} from '../fieldTypes';
import dataTypes from '../dataTypes';
import {getIcon} from '../../helpers.js';
import {SimpleBuffer, TableCatalogBuffer} from './FormControlBuffers.jsx';
import wrapProps, {deleteProps} from './wrapProps.js';
import {CE_DATEFORMAT} from '../constants.js';
import {formatStr} from '../../i18n.js';

const HyperlinkInput = FormControl.WithHyperlink(SimpleBuffer(FormControl.TextInput));
const MappedHyperlinkInput = mappingTextWrapper(HyperlinkInput);
const BufferedNumericEdit = SimpleBuffer(FormControl.NumericEdit);
const HyperlinkCatalog = FormControl.WithHyperlink(TableCatalogBuffer);
const MappedHyperlinkCatalog = mappingTextWrapper(HyperlinkCatalog);
const EnumComboBox = enumWrapper(FormControl.ComboBox);
const ComboBox = FormControl.WithHyperlink(FormControl.ComboBoxCatalog);
const BufferedPassword = SimpleBuffer(FormControl.Password);
const BufferedEmail = SimpleBuffer(FormControl.Email);
const BufferedTextArea = SimpleBuffer(FormControl.TextArea);

export default class FormControlWrapper extends React.Component {
    constructor(props) {
        super(props);
        this.handleCatalogChange = this.handleCatalogChange.bind(this);
        this.handleCheckboxChange = this.handleCheckboxChange.bind(this);
        this.handleDateChange = this.handleDateChange.bind(this);
        this.handleTextChange = this.handleTextChange.bind(this);
        this.handleTriStateChange = this.handleTriStateChange.bind(this);
        this.handleValueChange = this.handleValueChange.bind(this);
        this.handleButtonClicked = this.handleButtonClicked.bind(this);
        const name = this.props.setting.get('attribute');
        this.initValue = this.props.values ? this.props.values.get(name) : "";
        this.initalOpname = this.props.operationState ?
            this.props.operationState.get('opname') : "";
    }

    componentWillReceiveProps(nextProps) {
        const name = this.props.setting.get('attribute');
        const opName = nextProps.operationState ? nextProps.operationState.get('opname') : "";
        if (this.initalOpname !== opName) {
            this.initValue = nextProps.values ? nextProps.values.get(name) : "";
            this.initalOpname = opName;
        }
    }

    hasDisplayMapping() {
        return this.props.setting.getIn(['config', 'display_mapping', 'id']);
    }

    handleTextChange(value) {
        const {setting, onFieldsChange} = this.props;
        let the_value = value;
        if (setting.get('textlimit') && setting.get('textlimit') > 0) {
            the_value = the_value.substring(0, setting.get('textlimit'));
        }
        const result = Immutable.Map().set(setting.get('attribute'), the_value);
        onFieldsChange(result);
    }

    handleValueChange(value, unchecked = false) {
        const {setting, onFieldsChange} = this.props;
        const result = Immutable.Map().set(setting.get('attribute'), value);
        onFieldsChange(result, unchecked);
    }

    handleCheckboxChange(event) {
        const {setting, onFieldsChange} = this.props;
        const value = event.target.checked ? 1 : 0;
        const result = Immutable.Map().set(setting.get('attribute'), value);
        onFieldsChange(result);
    }

    handleTriStateChange(value) {
        const {setting, onFieldsChange} = this.props;
        const dataType = setting.get('data_type');
        let wrapped = value;
        if (dataType !== dataTypes.TEXT) {
            wrapped = parseInt(value);
            if (Number.isNaN(wrapped)) {
                wrapped = null;
            }
        }
        const result = Immutable.Map().set(setting.get('attribute'), wrapped);
        onFieldsChange(result);
    }

    handleCatalogChange(values) {
        const {onFieldsChange} = this.props;
        const result = Immutable.Map(values);
        onFieldsChange(result);
    }

    handleDateChange(value) {
        const {setting, onFieldsChange} = this.props;
        const result = Immutable.Map().set(setting.get('attribute'), value);
        onFieldsChange(result);
    }

    handleButtonClicked() {
        const {setting, onFieldsChange} = this.props;
        const result = Immutable.fromJS({
            [setting.get('attribute')]: 'button_pressed'
        });
        onFieldsChange(result);
    }

    renderTextInput() {
        const {
            setting, onNavigateLink, operationState, displayMappingURL
        } = this.props;
        const props = {
            'data-ce-id': setting.get('attribute'),
            'data-ce-type': 'textinput',
            ...wrapProps(this.props, this.initValue),
            onValueChange: this.handleTextChange,
            targetLink: setting.getIn(['config', 'link_target_url']),
            displayMapping: setting.getIn(['config', 'display_mapping']),
            operationState,
            displayMappingURL,
            onNavigateLink
        };
        let LinkedTextInput = MappedHyperlinkInput;
        if (!this.hasDisplayMapping()) {
            LinkedTextInput = HyperlinkInput;
            deleteProps(props, 'displayMapping', 'operationState', 'displayMappingURL');
        }
        deleteProps(props, 'uncheckedValues', 'containerRef');
        return (
            <LinkedTextInput {...props}/>
        );
    }

    renderCheckBox() {
        const {
            value, readOnly, disabled, mandatory, ...others
        } = wrapProps(this.props, this.initValue);
        // show tri state checkbox if value is not set but is mandatory
        if (!readOnly && !isValue(value) && mandatory) {
            return this.renderTriStateCheckBox();
        }

        deleteProps(others, 'containerRef');

        const checked = value === 1 || value === '1';
        // Setting readonly on checkbox just keeps value unchangable, but
        // the user can still interact with that element(turn on/off).
        // So we must *disable* it to prevent the interactions.
        const forceDisabled = readOnly || disabled;
        return (
            <FormControl.CheckBox
                checked={checked}
                onChange={this.handleCheckboxChange}
                readOnly={readOnly}
                disabled={forceDisabled}
                data-ce-id={this.props.setting.get('attribute')}
                data-ce-type="checkbox"
                mandatory={mandatory}
                {...others} />
        );
    }

    renderTriStateCheckBox() {
        const {value, readOnly, disabled, ...others} = wrapProps(this.props, this.initValue);
        const forceDisabled = readOnly || disabled;
        const valueStr = value === null ? '' : value.toString();
        deleteProps(others, 'onEnter', 'containerRef');
        return (
            <FormControl.TriStateCheckBox
                value={valueStr}
                onStateChange={this.handleTriStateChange}
                readOnly={readOnly}
                disabled={forceDisabled}
                data-ce-id={this.props.setting.get('attribute')}
                data-ce-type="tristatecheckbox"
                {...others} />
        );
    }

    renderCatalog() {
        const {
            setting, values, uncheckedValues, onNavigateLink, operationState, displayMappingURL
        } = this.props;
        const textReadOnly = setting.get('readonly') > 0;
        const props = {
            'data-ce-id': setting.get('attribute'),
            'data-ce-type': "tablecatalog",
            contextClass: setting.getIn(['config', 'contextClass']),
            activeLanguage: setting.getIn(['config', 'iso_lang']),
            selectURL: setting.getIn(['config', 'selectURL']),
            catalogTableURL: setting.getIn(['config', 'catalogTableURL']),
            structureRootURL: setting.getIn(['config', 'structureRootURL']),
            typeAheadURL: setting.getIn(['config', 'typeAheadURL']),
            valueCheckURL: setting.getIn(['config', 'valueCheckURL']),
            proposalCatalogURL: setting.getIn(['config', 'proposalCatalogURL']),
            proposalLabel: setting.getIn(['config', 'proposalLabel']),
            formData: values,
            unchecked: uncheckedValues.has(setting.get('attribute')),
            targetLink: setting.getIn(['config', 'link_target_url']),
            onValueChange: this.handleValueChange,
            onCatalogChange: this.handleCatalogChange,
            textReadOnly: textReadOnly,
            displayMapping: setting.getIn(['config', 'display_mapping']),
            queryFormURL: setting.getIn(['config', 'queryFormURL']),
            ...wrapProps(this.props, this.initValue),
            operationState,
            displayMappingURL,
            onNavigateLink,
            lines: setting.getIn(['config', 'lines']),
            userSettings: setting.getIn(['config', 'userSettings'])
        };
        let CatalogField = MappedHyperlinkCatalog;
        if (!this.hasDisplayMapping()) {
            CatalogField = HyperlinkCatalog;
            deleteProps(props, 'displayMappingURL', 'displayMapping');
        }
        deleteProps(props, 'containerRef');
        return (
            <CatalogField {...props}/>
        );
    }

    renderComboBox() {
        const {setting, onNavigateLink, values, operationState} = this.props;
        const textReadOnly = setting.get('readonly') > 0;
        const items = setting.getIn(['config', 'catalog_values']);
        const props = wrapProps(this.props, this.initValue);
        return (
            <ComboBox
                contextClass={setting.getIn(['config', 'contextClass'])}
                activeLanguage={setting.getIn(['config', 'iso_lang'])}
                selectURL={setting.getIn(['config', 'selectURL'])}
                items={items}
                onValueChange={textReadOnly ? undefined : this.handleTextChange}
                itemsURL={setting.getIn(['config', 'itemsURL'])}
                formData={values}
                onCatalogChange={this.handleCatalogChange}
                textReadOnly={textReadOnly}
                onNavigateLink={onNavigateLink}
                targetLink={setting.getIn(['config', 'link_target_url'])}
                operationState={operationState}
                {...props} />
        );
    }

    renderEnumComboBox() {
        const {setting} = this.props;
        const textReadOnly = true;
        const props = wrapProps(this.props, this.initValue);
        deleteProps(props, 'containerRef');
        return (
            <EnumComboBox
                config={setting.get('config')}
                onCatalogChange={this.handleCatalogChange}
                textReadOnly={textReadOnly}
                {...props} />
        );
    }

    renderCalendar() {
        const {formats, operationState, calendarValueFormat} = this.props;
        let dateFormat = undefined;
        let dateTimeFormat = undefined;
        if (formats) {
            dateTimeFormat = formats.get('dateTimeFormat').replace('hh', 'HH');
            dateFormat = formats.get('dateFormat');
        }
        const isSearchOperation = Boolean(
            operationState && operationState.get('opname') === 'CDB_Search');
        const valueFormat = (calendarValueFormat !== undefined) ?
            calendarValueFormat
            : (isSearchOperation ? CE_DATEFORMAT : undefined);
        const props = wrapProps(this.props, this.initValue);
        return (
            <FormControl.Calendar
                onDateChange={this.handleDateChange}
                displayFormat={dateTimeFormat}
                dateOnlyFormat={dateFormat}
                valueFormat={valueFormat}
                allowExpression={isSearchOperation}
                {...props} />
        );
    }

    renderNumericEdit() {
        const {setting} = this.props;
        const decimal = setting.getIn(['display_hints', 'post_decimals']);
        const variableDecimal =
            setting.get('data_type') === dataTypes.FLOAT && decimal === undefined;
        const {value, ...others} = wrapProps(this.props, this.initValue);
        deleteProps(others, 'containerRef');
        return (
            <BufferedNumericEdit
                value={value}
                decimalPlaces={decimal}
                onValueChange={this.handleValueChange}
                variableDecimal={variableDecimal}
                {...others} />
        );
    }

    renderPassword() {
        const props = wrapProps(this.props, this.initValue);
        deleteProps(props, 'containerRef');
        return (
            <BufferedPassword
                onValueChange={this.handleTextChange}
                {...props}/>
        );
    }

    renderEmail() {
        const props = wrapProps(this.props, this.initValue);
        deleteProps(props, 'containerRef');
        return (
            <BufferedEmail
                onValueChange={this.handleTextChange}
                {...props}/>
        );
    }

    renderHyperLink() {
        const {value, ...others} = wrapProps(this.props, this.initValue);
        deleteProps(others, 'operationInstance', 'uncheckedValues', 'containerRef');
        return (
            <HyperlinkInput
                onValueChange={this.handleTextChange}
                value={value}
                targetLink={value}
                {...others}
            />
        );
    }

    renderTextArea() {
        const {setting} = this.props;
        const lines = setting.getIn(['config', 'lines']);
        const contentType = setting.getIn(['config', 'content_type'], '');
        const props = wrapProps(this.props, this.initValue);
        deleteProps(props, 'containerRef');
        if (contentType === 'RichText') {
            return (
                <FormControl.RichText
                    onValueChange={this.handleTextChange}
                    rows={lines}
                    {...props}/>
            );
        } else {
            return (
                <BufferedTextArea
                    onValueChange={this.handleTextChange}
                    rows={lines}
                    {...props}/>
            );
        }
    }

    renderBitmapIcon() {
        const {setting} = this.props;
        const {label, ...others} = wrapProps(this.props, this.initValue);
        const iconUrl = setting.getIn(['config', 'icon']);
        const iconTitle = setting.getIn(['config', 'title']);
        const height = setting.getIn(['config', 'height']);
        const width = setting.getIn(['config', 'width']);
        const keepAspectRatio = setting.getIn(['config', 'keep_aspect_ratio']);
        deleteProps(others, 'mandatory', 'mandatoryEmptyHint', 'validationState',
            'operationInstance', 'uncheckedValues', 'containerRef');
        return (
            <div>
                <FormControl.BitmapIcon src={iconUrl}
                                        label={label}
                                        title={iconTitle}
                                        alt={iconTitle}
                                        height={height}
                                        width={width}
                                        keepAspectRatio={keepAspectRatio}
                                        {...others} />
            </div>
        );
    }

    renderMultilangType() {
        const {setting, getPlaceholderCB, placeholder} = this.props;
        const placeholderMain = getPlaceholderCB ? getPlaceholderCB(setting) : placeholder;
        if (setting.get('multilang')) {
            const others =
                setting.get('multilang')
                    .map(ml => ({
                        id: ml.get('attribute'),
                        setting: ml,
                        placeholder: getPlaceholderCB ? getPlaceholderCB(ml) : placeholder
                    }))
                    .toArray();
            const sML = setting.set('ml_origin', setting.get('multilang')).delete('multilang');
            const props = {...this.props};
            deleteProps(props, 'containerRef');
            return (
                <FormControl.GroupControl
                    iconSrc={getIcon('csweb_globe')}
                    others={others}
                    titleExpanded={formatStr('formcontrols_hide_other_languages')}
                    titleCollapsed={formatStr('formcontrols_show_more_languages')}>
                    <FormControlWrapper {...props}
                                        placeholder={placeholderMain}
                                        setting={sML}/>
                </FormControl.GroupControl>
            );
        } else {
            const props = {...this.props};
            deleteProps(props, 'containerRef');
            return (
                <FormControlWrapper {...props} />
            );
        }
    }

    renderButton() {
        const {label, tooltip, ...others} = wrapProps(this.props, this.initValue);
        deleteProps(others, 'mandatory', 'mandatoryEmptyHint', 'validationState',
            'operationInstance', 'uncheckedValues', 'containerRef');
        return (
            <div>
                <FormControl.Button
                    label={label}
                    title={tooltip}
                    onClick={this.handleButtonClicked}
                    {...others} />
            </div>
        );
    }

    renderComponent() {
        const {contextObjects, operationState, setting} = this.props;
        const {readOnly, value, tooltip, label} = wrapProps(this.props, this.initValue);
        const props = {
            componentName: setting.getIn(['config', 'component_name'], ''),
            contentType: setting.getIn(['config', 'content_type'], ''),
            lines: setting.getIn(['config', 'lines'], ''),
            readOnly,
            value,
            tooltip,
            label,
            contextObjects,
            operationState
        };
        return (
            <FormControl.ReactComponentControl
                {...props}
                onValueChange={this.handleValueChange}
            />
        );
    }

    renderByControlType() {
        const {setting} = this.props;
        if (setting === undefined || setting.get('fieldtype') === undefined) {
            return null;
        }
        if (setting.get('multilang')) {
            return this.renderMultilangType();
        } else {
            switch (setting.get('fieldtype')) {
                case fieldTypes.TEXT: {
                    const dataType = setting.get('data_type');
                    if (dataType === dataTypes.INTEGER ||
                        dataType === dataTypes.FLOAT) {
                        return this.renderNumericEdit();
                    }
                    return this.renderTextInput();
                }
                case fieldTypes.CHECKBOX:
                    // show tri state checkbox if configured as
                    if (isTriStateCheckBox(setting)) {
                        return this.renderTriStateCheckBox();
                    }
                    return this.renderCheckBox();
                case fieldTypes.PASSWORD:
                    return this.renderPassword();
                case fieldTypes.EMAIL:
                    return this.renderEmail();
                case fieldTypes.HYPERLINK:
                    return this.renderHyperLink();
                case fieldTypes.LONGTEXT:
                    return this.renderTextArea();
                case fieldTypes.IMAGE:
                    return this.renderBitmapIcon();
                case fieldTypes.CALENDAR:
                    return this.renderCalendar();
                case fieldTypes.CATALOG:
                    return this.renderCatalog();
                case fieldTypes.COMBOBOX:
                    return this.renderComboBox();
                case fieldTypes.NUMERICEDIT:
                    return this.renderNumericEdit();
                case fieldTypes.ENUMCOMBOBOX:
                    return this.renderEnumComboBox();
                case fieldTypes.BUTTON:
                    return this.renderButton();
                case fieldTypes.COMPONENT:
                    return this.renderComponent();
                default:
                    return this.renderTextInput();
            }
        }
    }

    shouldComponentUpdate(nextProps) {
        if (nextProps.onFieldsChange !== this.props.onFieldsChange ||
            nextProps.readOnly !== this.props.readOnly ||
            nextProps.setting !== this.props.setting ||
            nextProps.formats !== this.props.formats ||
            nextProps.afterControl !== this.props.afterControl ||
            nextProps.onNavigateLink !== this.props.onNavigateLink ||
            nextProps.displayMappingURL !== this.props.displayMappingURL ||
            nextProps.operationState !== this.props.operationState ||
            nextProps.containerRef !== this.props.containerRef ||
            typeof nextProps.values !== typeof this.props.values) {
            return true;
        }
        if (typeof nextProps.values !== 'undefined') {
            if (anyAttributeIsRelevant(nextProps.setting)) {
                return true;
            }
            return getRelevantAttributes(nextProps.setting).filter(attr =>
                    nextProps.values.get(attr) !== this.props.values.get(attr)
                ).length > 0;
        }
        return false;
    }

    render() {
        return this.renderByControlType();
    }
}

FormControlWrapper.propTypes = {
    containerRef: PropTypes.object,
    onFieldsChange: PropTypes.func,
    uncheckedValues: PropTypes.instanceOf(Immutable.Set),
    readOnly: PropTypes.bool,
    onNavigateLink: PropTypes.func,
    setting: PropTypes.instanceOf(Immutable.Map).isRequired,
    formats: PropTypes.instanceOf(Immutable.Map),
    calendarValueFormat: PropTypes.string,
    values: PropTypes.instanceOf(Immutable.Map),
    displayMappingURL: PropTypes.string,
    operationState: PropTypes.instanceOf(Immutable.Map),
    afterControl: PropTypes.node,
    className: PropTypes.string,
    getPlaceholderCB: PropTypes.func,
    placeholder: PropTypes.string,
    contextObjects: PropTypes.instanceOf(Immutable.List)
};

FormControlWrapper.defaultProps = {
    uncheckedValues: Immutable.Set()
};
