/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: ResultWithDetails.jsx 185797 2018-10-29 13:14:52Z gwe $"
 */

import Immutable from 'immutable';
import React from 'react';
import {PropTypes, ImmutablePropTypes, connect} from 'cs-web-components-externals';
import {prefixNS} from '../helpers.js';
import {setContextObjectsBatchLoad} from '../actions/context-objects.js';
import {ContextObjectWrapper} from '../containers/context-wrapper.jsx';
import SplitterLayout from '../layouts/SplitterLayout';
import ResultArea from '../search/ResultArea.jsx';
import DetailView from './DetailView.jsx';

/**
 * Renders a search result, and possibly a detail view if one is configured. This
 * component also handles the propagation of the result table selection to the
 * detail view.
 */
class ResultWithDetails extends React.Component {
    constructor(props) {
        super(props);
        this.onSelectionChanged = this.onSelectionChanged.bind(this);
    }

    selectionPath() {
        return `search-result/${this.props.instanceName}`;
    }

    /**
     * Convert the selectionIds from the table to the object IDs for the actual
     * REST objects; that is what setContextObjects uses.
     */
    selectedObjectIDs(selectedIds) {
        const {searchResult} = this.props;
        // Build a mapping selection ID => object ID for the selected entries
        const idMap = Immutable.Map(
            searchResult.get('rows')
                .filter(row => selectedIds.includes(row.get('id')))
                .map(row => [row.get('id'), [
                    row.get('restLink'), row.get('restname'), row.get('keys')]])
        );
        // For the result, keep the selection order from the table.
        return selectedIds.map(id => idMap.get(id)).filter(oid => oid !== undefined);
    }

    /**
     * If a detail view is configured, propagate changes in the resault table
     * selection. We use setContextObjects and ContextObjectWrapper, so that the
     * REST objects for the selection will be loaded automatically.
     */
    onSelectionChanged(sel) {
        const {setContextObjectsBatchLoad} = this.props;
        const ids = this.selectedObjectIDs(sel);
        setContextObjectsBatchLoad(this.selectionPath(), ids);
    }

    render() {
        const {instanceName, rootClassname, detail, searchResult,
               repeatSearch, childConfiguration} = this.props;
        const selectionPath = this.selectionPath();
        const resultTableConf = childConfiguration
            ? childConfiguration.resultTable
            : null;
        const resultArea = (
            <ResultArea
                instanceName={instanceName}
                rootClassname={rootClassname}
                selectionPath={selectionPath}
                searchResult={searchResult}
                repeatSearch={repeatSearch}
                onSelectionChanged={this.onSelectionChanged}
                resultTableConf={resultTableConf} />
        );
        if (detail === undefined) {
            return (
                <div className={prefixNS('result-no-details')}>
                    {resultArea}
                </div>
            );
        }
        else {
            return (
                <SplitterLayout>
                    <SplitterLayout.PrimaryPane>
                        {resultArea}
                    </SplitterLayout.PrimaryPane>
                    <SplitterLayout.SecondaryPane initCollapsed={false} defaultSize="300px">
                        <div className={prefixNS('classview-detail')}>
                            <ContextObjectWrapper readPath={selectionPath}>
                                <DetailView
                                    detail={detail}
                                    selectionPath={this.selectionPath()} />
                            </ContextObjectWrapper>
                        </div>
                    </SplitterLayout.SecondaryPane>
                </SplitterLayout>
            );
        }
    }
}
ResultWithDetails.propTypes = {
    instanceName: PropTypes.string.isRequired,
    rootClassname: PropTypes.string.isRequired,
    searchResult: ImmutablePropTypes.map.isRequired,
    detail: PropTypes.element,
    repeatSearch: PropTypes.func.isRequired,
    childConfiguration: PropTypes.object,
    // actions
    setContextObjectsBatchLoad: PropTypes.func.isRequired
};

export default connect(null, {setContextObjectsBatchLoad})(ResultWithDetails);
