/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: detail-wrapper.jsx 175632 2018-04-09 10:49:03Z cla $"
 */

import React, {Component} from 'react';
import {PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import {Alert} from 'react-bootstrap';
import {connect} from 'cs-web-components-externals';
import {notifyError} from '../actions/notification.js';
import {fetchObject, fetchType} from '../actions/object-actions.js';
import {addHistoryItem} from '../actions/history-actions.js';
import {getDisplayName, getAppSetup} from '../helpers.js';
import {setContextObjects} from '../actions/context-objects.js';
import {formatStr} from '../i18n.js';

/**
 * Wraps a React component, so that it can be used as the detailComponent in a
 * generic frame.
 *
 * @module
 */
export default function(WrappedComponent) {
    /**
     * DetailWrapper determines the current objects URL from a base URL provided by
     * the backend, and the routing params provided in the props. When mounted, or
     * when the object URL changes, an action to fetch the current object from the
     * REST API is dispatched.
     *
     * The current object is provided as property ``contextObject`` to the single
     * child.
     *
     * This component is normally not used by itself, but is automatically
     * employed by the frontend routing.
     */
    class DetailWrapper extends Component {
        constructor(props) {
            super(props);
            this._onDeleteContextObject = this._onDeleteContextObject.bind(this);
            this.onDeleteContextObject = this.onDeleteContextObject.bind(this);
        }

        componentDidMount() {
            const {contextObject, fetchObject, fetchType} = this.props;
            // There are lots of objects as projects or persons with assigned files that
            // nobody wants to see
            fetchObject(this.props.objectUrl, null, "no");
            if (contextObject !== undefined) {
                fetchType(contextObject.get('@type'));
            }
        }

        componentWillReceiveProps(nextProps) {
            if (nextProps.objectUrl !== this.props.objectUrl) {
                this.props.fetchObject(nextProps.objectUrl);
            }

            const nextContextObject = nextProps.contextObject;
            if (nextContextObject !== this.props.contextObject) {
                this.props.setContextObjects('root', nextContextObject);
            }

            if (nextContextObject && (nextContextObject !== this.props.contextObject)) {
                const title = nextContextObject.get("system:description");
                document.title = title;
                this.props.addHistoryItem({
                    classname: nextContextObject.get("system:classname"),
                    rest_id: nextContextObject.get("system:navigation_id"),
                    ref_object_id: nextContextObject.get("cdb_object_id")
                });
            }
            if (nextProps.fetchError && nextProps.fetchError !== this.props.fetchError) {
                //TODO: i18n
                this.props.notifyError(nextProps.fetchError, null, 'Error while fetching object');
            }
        }

        _onDeleteContextObject() {
            window.location = '/';
        }

        onDeleteContextObject(operationState) {
            const {contextObject} = this.props;
            // If contextObject is contained in objects parameter we override default behaviour,
            // by navigating back to landing page
            const opParams = operationState.get('params');
            const deletesContextObject =
                contextObject &&
                (opParams.get('objects') === undefined ?
                 opParams.getIn(['object', '@id']) === contextObject.get('@id') :
                 opParams.get('objects')
                         .map(obj => obj.get('@id'))
                         .includes(contextObject.get('@id')));

            return deletesContextObject ?
                   this._onDeleteContextObject :
                   undefined;
        }

        render() {
            const {contextObject, fetchError} = this.props;
            if (fetchError) {
                return (
                    <Alert bsStyle="warning">
                        {formatStr('detail_wrapper_fetch_error')}
                        {`: ${fetchError.status} ${fetchError.statusText}`}
                    </Alert>
                );
            }
            else if (contextObject === undefined) {
                return (
                    <Alert bsStyle="info">
                        {formatStr('detail_wrapper_fetching')}
                    </Alert>
                );
            }
            else {
                // We override the global delete-handler as our page is pretty much
                // useless without its context object.
                return (
                    <WrappedComponent {...this.props} />
                );
            }
        }
    }

    DetailWrapper.propTypes = {
        // the current object; may not be available until retrieved
        contextObject: ImmutablePropTypes.map,
        // URL for the current object, as constructed from base URL and routing params
        objectUrl: PropTypes.string.isRequired,
        // if object retrieval failed, the corresponding Error
        fetchError: PropTypes.object,
        // action functions
        fetchObject: PropTypes.func.isRequired,
        fetchType: PropTypes.func.isRequired,
        addHistoryItem: PropTypes.func.isRequired,
        setContextObjects: PropTypes.func.isRequired,
        notifyError: PropTypes.func.isRequired
    };
    DetailWrapper.displayName = `DetailWrapper(${getDisplayName(WrappedComponent)})`;

    function mapStateToProps(state, ownProps) {
        const url_template = getAppSetup().getIn(['links', 'detail_view', 'object_url_template']);
        const objectUrl = url_template.replace("${keys}", ownProps.match.params.object_keys);
        const contextObject = state.objectsById.get(objectUrl);
        return {
            objectUrl,
            contextObject,
            fetchError: state.errorsById.get(objectUrl)
        };
    }

    const actions = {fetchObject, fetchType, addHistoryItem, setContextObjects, notifyError};
    return connect(mapStateToProps, actions)(DetailWrapper);
}
