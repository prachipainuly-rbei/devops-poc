#!/usr/bin/env powerscript
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2017 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

"""
Handling of Web UI outlets
"""

__revision__ = "$Id: outlet_config.py 168473 2017-11-14 18:10:55Z heiko $"

from collections import defaultdict

import cdbwrapc
from cdb import auth
from cdb import sig
from cdb import tools
from cdb import ue
from cdb import util
from cdb.objects import Object, Reference_1, Reference_N, Forward
from cdb.platform.gui import Label, Icon
from .configuration_helpers import WithComponentOrConfiguration, WithJsonProperties

OutletDescription = Forward(__name__ + ".OutletDescription")
OutletDefinition = Forward(__name__ + ".OutletDefinition")
OutletPosition = Forward(__name__ + ".OutletPosition")
OutletPositionOwner = Forward(__name__ + ".OutletPositionOwner")
OutletChild = Forward(__name__ + ".OutletChild")


class OutletPositionCallbackBase(object):
    """
    A class that gives you the opportunity to
    customize the configuration of outlets.
    You should derive from this class to implement your
    own behaviour if you have configured a fqpyname in
    the OutletPosition.
    """
    @classmethod
    def adapt_initial_config(cls, pos_config, cldef):
        """
        This callback allows you to manipulate the configuration of the
        position. You may change `pos_config` or return a list of dictionaries
        that should be used instead of this configuration.
        `cldef` is the class definition of the object that contains the
        data displayed by the outlet.
        """
        return pos_config

    @classmethod
    def adapt_final_config(cls, component_config, cldef):
        """
        This callback allows you to manipulate the configuration of the
        position after the configuration had been transferred to the form
        that will be transferred to the frontend. You have to change
        component_config in place.
        `cldef` is the class definition of the object that contains the
        data displayed by the outlet.
        """
        pass


def replace_outlets(model, app_setup):
    """ Walks through the `applicationConfiguration` subtree in `app_setup`, and
        searches for `outlet` properties defined for the components therein.
        For each occurence that is found, the `outlet` key is removed, and the
        configuration of that outlet is inserted.
        `model` is an subclass of ``ConfigurableUIModel``, that can be used to
        register libraries etc.

        THINKABOUT: for now, this will only work for DetailViews. Probably at
        least ClassViews should have this too.
    """
    # The top level keys may either be strings (ie. component names) or actual
    # configurations.
    new_conf = {k: v if isinstance(v, basestring) else _walk_tree(model, v)
                for k, v in app_setup["applicationConfiguration"].iteritems()}
    app_setup["applicationConfiguration"] = new_conf


def _walk_tree(model, configuration):
    """ Here, `configuration` is a dictionary in the form expected by the JS
        function ``confToComponent``. Process the configuration itself, and
        recursively call this function to process sub-components. Returns the
        new configuration, with outlets replaced.
    """
    new_conf = configuration.copy()

    # Handle outlet for this component, modifies new_conf in place. This is done
    # before the recursive calls, so that we automatically handle outlets in
    # components that were just inserted from an outlet.
    _replace_outlet(model, new_conf)

    # Recurse into children etc.
    children = new_conf.pop("children", None)
    if children is not None:
        new_conf["children"] = [_walk_tree(model, c) for c in children]

    for name in ("components", "componentClasses"):
        conf_dict = new_conf.pop(name, None)
        if conf_dict is not None:
            new_conf[name] = {k: _walk_tree(model, v)
                              for k, v in conf_dict.iteritems()}

    return new_conf


def _get_callback(cfg):
    """
    Returns the configured callable or ``None``
    """
    fqpyname = cfg.get("setup_fqpyname")
    if fqpyname:
        return tools.getObjectByName(fqpyname)


def _replace_outlet(model, new_conf):
    """ If `new_conf` has an outlet definition, replace that with the configured
        components that should be rendered.
    """
    outlet_name = new_conf.pop("outlet", None)
    if outlet_name is None:
        return

    outlet_cfgs = OutletDefinition.get_outlet_positions(outlet_name, model.classdef)
    children = new_conf.setdefault("children", [])
    properties = new_conf.setdefault("properties", {})
    properties["__outlets"] = []
    for cfg in outlet_cfgs:
        cb = _get_callback(cfg)
        if cb:
            cfgs = cb.adapt_initial_config(cfg, model.classdef)
        else:
            cfgs = [cfg]
        for c in cfgs:
            idx = len(children)
            key = "__outlet_%d" % idx
            icon = c.get("icon_url")
            if icon:
                iconattr = "icon_url"
            else:
                iconattr = "icon_id"
                icon = c.get("icon_id")
            properties["__outlets"].append({"key": key,
                                            "childIndex": idx,
                                            "title": c["title"],
                                            iconattr: icon})
            config = _make_component(model, c, key)
            if cb:
                cb.adapt_final_config(config, model.classdef)

            children.append(config)


def _make_component(model, outlet_cfg, key):
    result = {}
    config_file = outlet_cfg.get("configuration")
    if config_file is None:
        result["name"] = outlet_cfg.get("component")
    else:
        cfg = model.load_config_file(config_file)
        result.update(cfg["configuration"])
        model.add_configuration_to_context(cfg)
    # Collect the resulting properties for the component
    props = result.setdefault("properties", {})
    props.update(outlet_cfg.get("properties", {}))
    props["__outlet"] = {"key": key}
    return result


class OutletDescription(Object):
    __maps_to__ = 'csweb_outlet_description'
    __classname__ = 'csweb_outlet_description'

    Definitions = Reference_N(OutletDefinition,
                              OutletDefinition.outlet_name == OutletDescription.outlet_name)


class OutletDefinition(Object):
    __maps_to__ = 'csweb_outlet_definition'
    __classname__ = 'csweb_outlet_definition'

    Positions = Reference_N(OutletPosition,
                            OutletPosition.outlet_name == OutletDefinition.outlet_name,
                            OutletPosition.classname == OutletDefinition.classname)
    Description = Reference_1(OutletDescription, OutletDefinition.outlet_name)

    # Cache for configuration data
    # {(outlet_name, classname) -> {position -> [config, ...]}}
    _Cache = None

    @classmethod
    def _fill_cache(cls):
        def _get_child_dict(cfg):
            """
            Returns the configuration of an outlet child as dictionary
            or an error configuration if there is no child configuration.
            """
            child = all_children.get(cfg.child_name)
            if child:
                return cfg.to_dict(child)
            else:
                from cdb import misc
                from cdb.platform.gui import Message
                errmsg = Message.GetMessage("csweb_err_outlet_child_undefined",
                                            cfg.child_name)
                misc.log_error(errmsg)
                return {"component": "cs-web-components-base-ConfigurationError",
                        "properties": {"message": errmsg},
                        "title": cdbwrapc.get_label("web.base.config_error"),
                        "icon_id": "ConfigurationError"}

        if cls._Cache is not None:
            return
        cls._Cache = {}
        all_positions = OutletPosition.PositionsForCurrentUser()
        all_children = {c.outlet_child_name: c.to_dict()
                        for c in OutletChild.Query()}
        for definition in OutletDefinition.Query():
            key = (definition.outlet_name, definition.classname)
            positions = {pos: [_get_child_dict(cfg) for cfg in configs]
                         for pos, configs in all_positions.get(key, {}).iteritems()}
            cls._Cache[key] = positions

    @classmethod
    def _clear_cache(cls):
        cls._Cache = None

    @classmethod
    def get_outlet_definition(cls, outlet_name, classdef):
        """ Returns an outlet definition for the given outlet name and class.
            Searches upwards in the inheritance hierarchy, with `*`as fallback, for
            a matching outlet definition entry.
        """
        cls._fill_cache()
        clsnames = ([classdef.getClassname()] +
                    [name for name in classdef.getBaseClassNames()] +
                    ["*"])
        for cn in clsnames:
            match = cls._Cache.get((outlet_name, cn))
            if match is not None:
                return match
        return {}

    @classmethod
    def get_outlet_positions(cls, outlet_name, classdef):
        """ Returns a list of outlet positions for the given outlet name and
            class. For each distinct position, this selects the entry with the
            highest property (first in cached list, the lists are sorted
            accordingly).
            TODO: evaluate rules, and use the first match.
        """
        result = []
        positions = cls.get_outlet_definition(outlet_name, classdef)
        for pos in sorted(positions.keys()):
            configs = positions[pos]
            if configs:
                result.append(configs[0])
        return result


class OutletPosition(Object, WithJsonProperties):
    __maps_to__ = 'csweb_outlet_position'
    __classname__ = 'csweb_outlet_position'

    Owners = Reference_N(OutletPositionOwner,
                         OutletPositionOwner.outlet_name == OutletPosition.outlet_name,
                         OutletPositionOwner.classname == OutletPosition.classname,
                         OutletPositionOwner.pos == OutletPosition.pos,
                         OutletPositionOwner.priority == OutletPosition.priority)
    Definition = Reference_1(OutletDefinition,
                             OutletPosition.outlet_name,
                             OutletPosition.classname)
    Child = Reference_1(OutletChild, OutletPosition.child_name)
    Label = Reference_1(Label, OutletPosition.ausgabe_label)
    Icon = Reference_1(Icon, OutletPosition.cdb_icon_id)

    @classmethod
    def PositionsForCurrentUser(cls):
        """ Returns a dict
            {(outlet_name, classname) -> {position -> [OutletPosition ...]}}
            of outlet position, that are applicable to the current user via their
            role assignments.
            The lists of OutletPositions are sorted by descending priority.
        """
        roles = set(util.get_roles("GlobalContext", "", auth.persno))
        owners = set([(o.outlet_name, o.classname, o.pos, o.priority)
                      for o in OutletPositionOwner.KeywordQuery(role_id=roles,
                                                                order_by='priority DESC')])

        def cond(x):
            return (x.outlet_name, x.classname, x.pos, x.priority) in owners

        result = defaultdict(lambda: defaultdict(list))
        for p in filter(cond, cls.Query().Execute()):
            result[(p.outlet_name, p.classname)][p.pos].append(p)
        return result

    def to_dict(self, outlet_child_dict):
        """ Create a dictionary representation of self. The values from the
            outlet child form the basis, but can be overwritten here.
        """
        result = dict(outlet_child_dict)
        result.update(pos=self.pos,
                      priority=self.priority,
                      setup_fqpyname=self.setup_fqpyname)
        if self.ausgabe_label:
            result["title"] = cdbwrapc.get_label(self.ausgabe_label)
        if self.cdb_icon_id:
            result["icon_id"] = self.cdb_icon_id
        own_props = self.get_properties()
        if own_props:
            props = dict(outlet_child_dict["properties"])
            props.update(own_props)
            result["properties"] = props
        return result

    def get_callable(self):
        """
        Returns the object specified in `self.fqpyname` or
        ``None`` if no fqpyname is specified.
        Raises an `ue.Exception` if the configuration for
        the callable is wrong.
        """
        result = None
        if self.setup_fqpyname:
            try:
                result = tools.getObjectByName(self.setup_fqpyname)
            except Exception as e:
                raise ue.Exception("csweb_err_plugin_fqpyname", self.setup_fqpyname, repr(e))
            try:
                if not issubclass(result, OutletPositionCallbackBase):
                    raise ue.Exception("csweb_err_outlet_fqpyname_derived", self.setup_fqpyname)
            except TypeError:
                # issubclass raises an exception if cls is not a class
                raise ue.Exception("csweb_err_outlet_fqpyname_derived", self.setup_fqpyname)
        return result

    def _check_fqpyname(self, ctx):
        """
        Check if fqpyname is set and the class is derived from
        `OutletPositionCallbackBase`. `get_callable` will raise the
        exceptions for us.
        """
        self.get_callable()

    event_map = {
        (("modify", "create", "copy"), "post_mask"): "_check_fqpyname"
    }


class OutletPositionOwner(Object):
    __maps_to__ = 'csweb_outlet_position_owner'
    __classname__ = 'csweb_outlet_position_owner'

    Position = Reference_1(OutletPosition,
                           OutletPositionOwner.outlet_name,
                           OutletPositionOwner.classname,
                           OutletPositionOwner.pos,
                           OutletPositionOwner.priority)


class OutletChild(Object, WithComponentOrConfiguration, WithJsonProperties):
    __maps_to__ = 'csweb_outlet_child'
    __classname__ = 'csweb_outlet_child'

    Label = Reference_1(Label, OutletPosition.ausgabe_label)
    Icon = Reference_1(Icon, OutletPosition.cdb_icon_id)
    Usages = Reference_N(OutletPosition,
                         OutletPosition.child_name == OutletChild.outlet_child_name)

    def get_title(self):
        return cdbwrapc.get_label(self.ausgabe_label) if self.ausgabe_label else ''

    def to_dict(self):
        result = {"title": self.get_title(),
                  "icon_id": self.cdb_icon_id,
                  "properties": self.get_properties()}
        self._set_component_configuration(result)
        return result


# On any change concerning the outlet configuration, flush the cache
def _flush_cache(self, ctx):
    if not ctx.error:
        OutletDefinition._clear_cache()


for clazz in (OutletDefinition, OutletPosition, OutletPositionOwner, OutletChild):
    for action in ("create", "copy", "modify", "delete"):
        sig.connect(clazz, action, "post")(_flush_cache)
