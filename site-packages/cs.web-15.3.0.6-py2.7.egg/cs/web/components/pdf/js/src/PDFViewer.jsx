/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: PDFViewer.jsx 185837 2018-10-29 16:15:14Z bma $"
 */

import React from 'react';
import {Alert, Pagination} from 'react-bootstrap';
import {PropTypes, classNames} from 'cs-web-components-externals';
import {Console, ContentBlock, Button,
    Zoomer, ButtonToolbar} from 'cs-web-components-base';
import {formatStr, formatStrBase} from './i18n.js';

/**
 * A plugin component to render a PDF file. The user can select which page to
 * show, and can select a scale factor.
 *
 * React Properties
 * ----------------
 *
 * ==========  ========  =========  =================================
 * Property    Type      Default    Use
 * ==========  ========  =========  =================================
 * url         string    \-         The URL of the PDF file to render
 * filename    string    \-         The filename of the image file
 * scaleToFit  bool      true       Fit scale to available width
 * minified    bool      false      Show fewer controls
 * toolbar     node      null       Additional toolbar to show
 * ==========  ========  =========  =================================
 */
class PDFViewer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            pdfDocument: null,
            pdfPage: null,
            currentPageNum: 0,
            currentScale: 1.0,
            loadingError: false,
            shouldUpdateScaling: props.scaleToFit,
        };
        this._viewerWrapperWidth = null;
        this._rendering = false;
        this._waitingPageToRender = null;
        this.setScaleToFit = this.setScaleToFit.bind(this);
    }

    componentDidMount() {
        if (this.props.url) {
            this.loadDocument(this.props.url);
        }
        /* We can't depend on window resize events to detect changes to the area
         * available to the PDF viewer, because it might be rendered inside a
         * splitter. Therefore, we check periodically how much space there is.
         */
        this.checkWidthInterval = setInterval(() => this.checkWidth(), 100);
    }

    componentWillUnmount() {
        clearInterval(this.checkWidthInterval);
    }

    checkWidth() {
        if (this.state.shouldUpdateScaling && this._viewerWrapper) {
            const viewerWrapperWidthCurrent = this._viewerWrapper.clientWidth;
            if (viewerWrapperWidthCurrent !== this._viewerWrapperWidth) {
                this._viewerWrapperWidth = viewerWrapperWidthCurrent;
                this.adjustScaleToFit();
            }
        }
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.url && (nextProps.url !== this.props.url)) {
            this.loadDocument(nextProps.url);
        }
    }

    loadDocument(url) {
        this.setState({
            pdfDocument: null,
            pdfPage: null,
            currentPageNum: 0,
            currentScale: 1.0,
            loadingError: false
        });
        window.pdfjsDistBuildPdf.getDocument(url)
            .then(pdfDocument => this.documentLoaded(pdfDocument))
            .catch(
                reason => {
                    Console.error('Error: ' + reason);
                    this.setState({loadingError: true});
                }
            );
    }

    documentLoaded(pdfDocument) {
        this.setState(
            {pdfDocument: pdfDocument},
            () => this.loadPage(1)
        );
    }

    loadPage(pageNum) {
        this.state.pdfDocument.getPage(pageNum)
            .then(pdfPage => this.pageLoaded(pageNum, pdfPage));
    }

    pageLoaded(pageNum, pdfPage) {
        this.setState(
            {pdfPage: pdfPage, currentPageNum: pageNum},
            () => {
                if (this.state.shouldUpdateScaling) {
                    this.adjustScaleToFit();
                }
                else {
                    this.renderPage(pdfPage, this.state.currentScale);
                }
            }
        );
    }

    renderPage(pdfPage, currentScale) {
        if (this._rendering) {
            /* Attention: the PDF lib barfs when a new render is called while the
             * last one is not yet finished! For whatever reason, this can then
             * cause the PDF to be rendered upside down ...
             * See https://github.com/mozilla/pdf.js/issues/5273 for more, and
             * https://github.com/mozilla/pdf.js/blob/master/examples/learning/prevnext.html
             * as the template for the solution implemented here.
             */
            this._waitingPageToRender = {pdfPage, currentScale};
            return;
        }
        this._rendering = true;
        const viewport = pdfPage.getViewport(currentScale);
        const ctx = this._canvas.getContext('2d');
        this._canvas.width = viewport.width * window.devicePixelRatio;
        this._canvas.height = viewport.height * window.devicePixelRatio;
        this._canvas.style.width = viewport.width + 'px';
        this._canvas.style.height = viewport.height + 'px';

        ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);

        pdfPage.render({
            canvasContext: ctx,
            viewport: viewport
        }).promise.then(() => this.renderPageFinished());
    }

    renderPageFinished() {
        this._rendering = false;
        if (this._waitingPageToRender !== null) {
            const {pdfPage, currentScale} = this._waitingPageToRender;
            this._waitingPageToRender = null;
            this.renderPage(pdfPage, currentScale);
        }
    }

    setScaleToFit() {
        this.setState(
            {shouldUpdateScaling: true},
            () => this.adjustScaleToFit()
        );
    }

    adjustScaleToFit() {
        if (this._canvasWrapper) {
            this.setScale(this._canvasWrapper.clientWidth /
                this.state.pdfPage.getViewport(1.0).width);
        }
    }

    setScaleToValue(scale) {
        this.setState({shouldUpdateScaling: false});
        this.setScale(scale);
    }

    setScale(scale) {
        const {pdfPage} = this.state;
        const actScale = Math.min(3.0, Math.max(0.3, scale));
        this.renderPage(pdfPage, actScale);
        this.setState({currentScale: actScale});
    }

    render() {
        const {filename, minified, toolbar} = this.props;
        const {
            pdfDocument, pdfPage, currentPageNum, currentScale, shouldUpdateScaling
        } = this.state;
        if (!pdfPage) {
            const clsnames = classNames(
                `${componentNameSpace}-viewer`,
                `${componentNameSpace}-viewer-loading`
            );
            return (
                <ContentBlock className={clsnames}>
                    <ContentBlock.Body>
                       {this.state.loadingError ?
                            <Alert bsStyle="warning">
                                <b>{formatStrBase("preview_no_file_available_header")}</b><br />
                                {formatStr('stream_error_filename', {filename})}
                            </Alert> :
                        formatStr('loading')}
                    </ContentBlock.Body>
                </ContentBlock>
            );
        }
        const numPages = pdfDocument.pdfInfo.numPages;
        const viewport = pdfPage.getViewport(currentScale);
        const maxButtons = minified ? 1 : Math.min(7, numPages);
        const wrapperClassname = classNames(
            `${componentNameSpace}-viewer__wrapper`,
            {[`${componentNameSpace}-viewer__wrapper--minified`]: minified}
        );

        return (
            <ContentBlock collapsible={false} expanded={true}
                    title={filename}
                    className={`${componentNameSpace}-viewer`}>
                <ContentBlock.Header>
                    <ButtonToolbar>
                        <Pagination className={`${componentNameSpace}-viewer__pagination`}
                                    bsSize='small'
                                    prev next
                                    ellipsis={!minified}
                                    boundaryLinks={!minified}
                                    items={numPages}
                                    maxButtons={maxButtons}
                                    activePage={currentPageNum}
                                    onSelect={eventKey => this.loadPage(eventKey)}/>
                        {
                            minified ?
                                null :
                                <Zoomer currentScale={currentScale}
                                        onZoomIn={() => this.setScaleToValue(currentScale * 0.8)}
                                        onReset={() => this.setScaleToValue(1.0)}
                                        onZoomOut={() => this.setScaleToValue(currentScale * 1.2)}
                                        onZoomToFit={this.setScaleToFit}
                                        zoomToFitActive={shouldUpdateScaling} />
                        }
                        {toolbar}
                        <Button.DownloadButton
                            url = {this.props.url}
                        />
                    </ButtonToolbar>
                </ContentBlock.Header>
                <ContentBlock.Body>
                    <div ref={c => this._viewerWrapper = c} className={wrapperClassname}>
                        <div ref={c => {this._canvasWrapper = c}}
                            style={{height: `${viewport.height}px`}}>
                            <canvas ref={c => {this._canvas = c}}>
                            </canvas>
                        </div>
                    </div>
                </ContentBlock.Body>
            </ContentBlock>
        );
    }
}

PDFViewer.propTypes = {
    url: PropTypes.string,
    filename: PropTypes.string.isRequired,
    scaleToFit: PropTypes.bool,
    minified: PropTypes.bool,
    toolbar: PropTypes.node
};

PDFViewer.defaultProps = {
    scaleToFit: true,
    minified: false,
    toolbar: null
};

export default PDFViewer;
