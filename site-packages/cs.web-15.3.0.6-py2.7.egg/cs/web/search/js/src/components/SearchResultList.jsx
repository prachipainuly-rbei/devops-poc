/*
 * Copyright (C) 2016 CONTACT Software GmbH All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: SearchResultList.jsx 185887 2018-10-30 14:34:13Z sla $"
 */

import moment from 'moment';
import Immutable from 'immutable';
import React from 'react';
import {fetchNextSearchResult} from '../actions/actions.js';
import {PropTypes, connect} from 'cs-web-components-externals';
import {Collapsible, SVGIconAndLink, Button} from 'cs-web-components-base';
import {prefixNS} from '../helpers.js';
import {formatStr} from '../i18n.js';
import Spinner from './Spinner.jsx';

class SearchResult extends React.Component {

    renderTitle(hit) {
        const content = (
            <span dangerouslySetInnerHTML={{__html: hit.getIn(['attrs', 'title'])}} />
        );
        return (
            <SVGIconAndLink
                label={content}
                to={hit.getIn(['self', 'system:ui_link'])}
                src={hit.getIn(['self', 'system:icon_link'])}
            />
        );
    }

    renderExtract(hit) {
        const extract = hit.get('extract');
        if (extract === "-") {
            // no extract available
            return ("");
        }
        else if (extract === "") {
            // there are files, and they have an extract
            return ("");
        }
        else {
            // the object itself has an extract
            return (
                <div className={prefixNS('result__extract')}
                     dangerouslySetInnerHTML={{__html: extract}}>
                </div>
            );
        }
    }

    renderDetailInformation(hit) {
        const attrs = hit.get('attrs');
        return (
            <div className={prefixNS('result__detail')}>
                <div className={`${prefixNS('result__detail-line')} text-muted`}>
                    {[attrs.get('heading'),
                        attrs.get('person'),
                        moment(hit.get('date')).format('ll')].reduce((val, str) => {
                            if (val !== "" && val !== undefined && val !== null) {
                                return (val + ", " + str);
                            } else {
                                return str;
                            }
                        })}
                </div>
            </div>
        );
    }

    renderFile(file) {
        const attrs = file.get('attrs');
        const title = (
            <span dangerouslySetInnerHTML={{__html: attrs.get('title')}} />
        );
        return (
            <div key={file.get('cdb_object_id')} className={prefixNS('result__file')}>
                <SVGIconAndLink
                    label={title}
                    to={file.get('system:ui_link')}
                    src={file.get('icon')}
                />
                <div className={`${prefixNS('result__file-extract')}`}
                     dangerouslySetInnerHTML={{__html: file.get('extract')}} />
                <div className={`${prefixNS('result__file-detail')}`}>
                    <div className={`${prefixNS('result__file-detail-heading')} text-muted`}>
                        {attrs.get('heading')},
                        {moment(file.get('date')).format('ll')},
                        {attrs.get('person')}
                    </div>
                </div>
            </div>
        );
    }

    renderFileList(hit) {
        const files = hit.get('files');
        return files
            .filter(file => file !== "")
            .map(file => this.renderFile(file));
    }

    renderHeader(hit) {
        return (
            <div className={prefixNS('result__header')}>
                {this.renderTitle(hit)}
                {this.renderDetailInformation(hit)}
                {this.renderExtract(hit)}
            </div>
        );
    }

    render() {
        const hit = this.props.searchResult;
        const hasFiles = hit.get('files') ? hit.get('files').size > 0 : false;
        //FIXME: API error
        //react.js:19287 Warning: validateDOMNesting(...):
        // <a> cannot appear as a descendant of <a>. See SearchResult > t > a > ... > a.
        return (
            <div className={prefixNS('result')}>
                {hasFiles ?
                  <Collapsible header={this.renderHeader(hit)}>
                      <div className={prefixNS('result__file_list')}>
                        {this.renderFileList(hit)}
                      </div>
                  </Collapsible> : this.renderHeader(hit)}
            </div>
        );
    }
}
SearchResult.propTypes = {
    searchResult: PropTypes.instanceOf(Immutable.Map).isRequired
};

function topOfElement(element) {
    if (!element) {
        return 0;
    }
    return element.offsetTop + topOfElement(element.offsetParent);
}

class SearchResultList extends React.Component {
    constructor(props) {
        super(props);
        this.scrollListener = this.scrollListener.bind(this);
    }

    componentWillUnmount() {
        this.detachScrollListener();
    }

    componentDidMount() {
        this.attachScrollListener();
    }

    componentDidUpdate() {
        this.attachScrollListener();
    }

    scrollListener() {
        const el = this.domNode;
        const scrollTop = (window.pageYOffset !== undefined) ? window.pageYOffset :
            (document.documentElement || document.body.parentNode || document.body).scrollTop;
        const {offset, isFetching} = this.props;
        if (!isFetching &&
                topOfElement(el) + el.offsetHeight - scrollTop - window.innerHeight < offset) {
            this.detachScrollListener();
            if (this.props.hasMore) {
                this.props.fetchNextSearchResult();
            }
        }
    }

    attachScrollListener() {
        const {hasMore} = this.props;
        if (hasMore) {
            this.detachScrollListener();
            window.addEventListener('scroll', this.scrollListener);
            window.addEventListener('resize', this.scrollListener);
        }
    }

    detachScrollListener() {
        window.removeEventListener('scroll', this.scrollListener);
        window.removeEventListener('resize', this.scrollListener);
    }

    renderSpinner() {
        const {resultList, isFetching} = this.props;
        if (resultList.count() > 0) {
            return (<Spinner isFetching={isFetching} />);
        }
        else {
            return null;
        }
    }

    renderMoreButton() {
        const {hasMore, isFetching} = this.props;

        if (!hasMore) {
            return null;
        }

        return (
            <Button.TextButton
                disabled={isFetching}
                label={formatStr("more")}
                onClick={() => {
                    this.props.fetchNextSearchResult();
                }}>
            </Button.TextButton>
        );
    }

    render() {
        const {resultList} = this.props;
        return (
            <div className={prefixNS('result-list')} ref={elem => {this.domNode = elem}}>
                {resultList.map(function(hit) {
                    return (<SearchResult key={hit.get('cdb_object_id')} searchResult={hit} />);
                })}
                {this.renderMoreButton()}
                {this.renderSpinner()}
            </div>
        );
    }
}

SearchResultList.propTypes = {
    offset: PropTypes.number,
    resultList: PropTypes.instanceOf(Immutable.List),
    isFetching: PropTypes.bool.isRequired,
    hasMore: PropTypes.bool,
    searchText: PropTypes.string,
    fetchNextSearchResult: PropTypes.func
};

SearchResultList.defaultProps = {
    offset: 350, // px from the bottom
    resultList: [],
    hasMore: false,
    isFetching: true
};

function mapStateToProps(state) {
    const hasMore = state.search.settings.get('has_more');
    return {
        searchText: state.search.settings.get('query'),
        hasMore: hasMore !== undefined && hasMore
    };
}

const actions = {fetchNextSearchResult};

export default connect(mapStateToProps, actions)(SearchResultList);
