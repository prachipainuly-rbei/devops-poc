# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

__revision__ = "$Id: "
__docformat__ = "restructuredtext en"

import cdbwrapc
import sys

from cdb import sqlapi
from cdb import testcase
from cdb import util
from cdb.objects import org
from cdb.plattools import killableprocess
from cdb.uberserver import usutil
from cdb.uberserver.management import Management
from cdb.validationkit import generateUser
from cdb.validationkit import operation
from cdb.validationkit import run_with_added_roles

from cs.workflow import constraints
from cs.workflow import processes
from cs.taskmanager.settings import DebugMode
from cs.taskmanager.web import webdriver_support

__docformat__ = "restructuredtext en"
__revision__ = "$Id: environment.py 183859 2018-09-14 06:22:48Z cso $"

BROWSER = "chrome"
TIMEOUT = 20 if webdriver_support.IS_BUILDBOT else 5
TESTUSER = "behave_test"


def ensure_running_service_daemon(context):
    """If a service daemon isn't already running,
    then a temporary one gets started"""
    svc = Management()
    if svc._check_if_its_up(usutil.UBERSERVER):
        context.temp_service_daemon = None
    else:
        svc.start()
        context.temp_service_daemon = svc


def terminate_temp_service_daemon(context):
    if context.temp_service_daemon:
        try:
            context.temp_service_daemon.shutdown()
        except Exception as ex:
            print ex
            if sys.platform == "win32":
                # workaround for shutdown method not functioning properly (on
                # windows)
                killableprocess.call(
                    ['taskkill', '/f', '/t', '/im', 'cdbsvcd.exe'])


class EventListener(util.DBEventListener):
    __listener = None

    def __init__(self):
        super(EventListener, self).__init__()
        self.__events = []

    def notify(self, relation, event):
        self.__events.append(
            (event.m_event,
             relation,
             event.m_keys.items()))

    def rollback(self):
        def generateWhere(keys):
            where = ""
            for key, value in keys:
                where += "%s='%s' AND " % (key, value)
            return where[:-5]
        try:
            self.doUnregister()
            self.__events.reverse()
            for t, relation, keys in self.__events:
                if t == util.kRecordInserted and relation != "cdb_global_subj":
                    sqlapi.SQLdelete(
                        "FROM %s where %s" % (
                            relation, generateWhere(keys)))
        finally:
            self.clear()
            self.doRegister()

    def clear(self):
        self.__events = []

    @classmethod
    def getListener(cls):
        if not EventListener.__listener:
            EventListener.__listener = EventListener()
        return EventListener.__listener


def before_scenario(context, scenario):
    listener = EventListener.getListener()
    listener.doRegister()


def after_scenario(context, scenario):
    @run_with_added_roles(["cdbwf: Process Administrator"])
    def delete_process(process):
        # reset status of all components to get
        # the access, then delete
        process.status = processes.Process.NEW.status
        process._reset_schema()
        try:
            operation("CDB_Delete", process)
        except RuntimeError:
            force_delete(process)

    def force_delete(process):
        for constraint in constraints.Constraint.KeywordQuery(
                cdb_process_id=process.cdb_process_id):
            operation("CDB_Delete", constraint)
        operation("CDB_Delete", process)

    # clean up processes
    for process in processes.Process.KeywordQuery(subject_id="behave_test"):
        delete_process(process)

    listener = EventListener.getListener()
    listener.rollback()
    listener.doUnregister()


def before_all(context):
    testcase.run_level_setup()
    # Create a new User to use for testing and login as this one
    users = org.User.KeywordQuery(personalnummer=TESTUSER)
    if users:
        context.user = users[0]
    else:
        context.user = generateUser(TESTUSER)

    DebugMode.activate(TESTUSER)

    # Log him in
    assert cdbwrapc.set_user(context.user.personalnummer),\
        "The User couldn't be logged in"

    # run CDB server
    ensure_running_service_daemon(context)

    # setup webdriver
    try:
        context.webdriver = webdriver_support.WebDriver(
            browser=BROWSER,
            timeout=TIMEOUT,
        )
        context.webdriver.Login(
            username=context.user.personalnummer,
            password=""
        )
        context.server_url = context.webdriver.ServerUrl
    except:
        after_all(context)
        raise


def after_all(context):
    if hasattr(context, "webdriver"):
        context.webdriver.Logout()
        context.webdriver.quit()

    terminate_temp_service_daemon(context)

    # Delete the created user
    if hasattr(context, "user"):
        sqlapi.SQLdelete("FROM cdb_global_subj WHERE subject_id='{}'".format(
            context.user.personalnummer))
        context.user.Delete()

    # Delete files uploaded to the test fixture
    sqlapi.SQLdelete(
        "FROM cdb_file WHERE "
        "cdbf_object_id='0a68595e-4239-11e8-92a7-5cc5d4123f3b' AND "
        "cdb_object_id !='1e68969f-4239-11e8-bc7e-5cc5d4123f3b'")

    # temp. workaround: kill orphaned cdbsrv processes, which
    # the test execution may leak.
    if sys.platform == "win32":
        killableprocess.call(["taskkill", "/IM", "cdbsrv.exe", "/F"])
