# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

"""
Module workflow_designer

Behave steps for testing the workflow designer
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: workflow_designer.py 183859 2018-09-14 06:22:48Z cso $"

import os
import platform
import time

from selenium.common.exceptions import WebDriverException
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.wait import IGNORED_EXCEPTIONS
from selenium.webdriver.support.wait import POLL_FREQUENCY
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys

from cdb import CADDOK
from cdb.validationkit import given
from cdb.validationkit import when
from cdb.validationkit import then

from cs.workflow import tasks
from cs.workflow import taskgroups
from cs.workflow.extensions import ExtensionAssignment
from cs.workflowtest.cdbwf_task_extension import SimpleTaskExtension

IS_BUILDBOT = platform.node().lower().startswith("de-bre-bbc")
TIMEOUT = 120 if IS_BUILDBOT else 20
AJAX_STABILITY = 5 if IS_BUILDBOT else 3


def waitForElement(driver, element=None,
                   byClass=None, byId=None, byCSS=None, byText=None,
                   byTag=None):
    if byCSS:  # does not work with IE driver
        func = "find_element_by_css_selector"
        arg = byCSS
    if byClass:
        func = "find_element_by_class_name"
        arg = byClass
    if byId:
        func = "find_element_by_id"
        arg = byId
    if byText:
        func = "find_element_by_link_text"
        arg = byText
    if byTag:
        func = "find_element_by_tag_name"
        arg = byTag

    if element:
        function = lambda d: getattr(element, func)(arg)
    else:
        function = lambda d: getattr(d, func)(arg)

    return WebDriverWait(driver, TIMEOUT).until(function)


def waitUntilXTimes(driver, method, x=0, fail_message=""):
    from selenium.common.exceptions import TimeoutException

    assert x >= 0, "at least one time required"

    end_time = time.time() + TIMEOUT
    while True:
        try:
            value = method(driver)
            if value and x == 0:
                return value
            elif value and x > 0:
                x -= 1
        except IGNORED_EXCEPTIONS:
            pass

        time.sleep(POLL_FREQUENCY)
        if time.time() > end_time:
            break

    raise TimeoutException(fail_message)


def waitForAjax(driver):
    def check_active_ajax(driver):
        try:
            res = driver.execute_script("return jQuery.active === 0")
            return res
        except WebDriverException:
            return True

    waitUntilXTimes(driver, check_active_ajax, AJAX_STABILITY)


def ensure_actable(driver, byClass=None, byId=None, byCSS=None, byText=None,
                   byTag=None):
    if byCSS:  # does not work with IE driver
        func = By.CSS_SELECTOR
        arg = byCSS
    if byClass:
        func = By.CLASS_NAME
        arg = byClass
    if byId:
        func = By.ID
        arg = byId
    if byText:
        func = By.LINK_TEXT
        arg = byText
    if byTag:
        func = By.TAG_NAME
        arg = byTag

    return WebDriverWait(driver, TIMEOUT).until(
        EC.element_to_be_clickable((func, arg)))


def select_first_task(context):
    # wait until the previous action is completed
    wait_loading(context)
    driver = context.webdriver

    start = waitForElement(driver, byClass="wf-process-start")
    ensure_actable(driver, byClass="wf-task")

    actions = ActionChains(driver)\
        .move_to_element(start)\
        .click_and_hold()\
        .move_by_offset(400, -200)\
        .release()
    actions.perform()

    # force redraw
    actions = ActionChains(driver).move_to_element(start).perform()

    # wait for the buttons to be shown, or for the timeout
    WebDriverWait(driver, TIMEOUT).until(
        lambda d: d.find_elements_by_class_name("wf-selection-operation"))


def open_collapse(driver):
    task = waitForElement(driver, byClass="wf-task")
    details = waitForElement(driver, element=task, byClass="wf-details")
    # apparently, a size of 0 is perfectly visible :)
    if not (details.is_displayed() and details.size["height"]):
        button = ensure_actable(driver, byCSS=".wf-task .toggle-details")
        button.click()


def wait_loading(context):
    driver = context.webdriver
    loader = waitForElement(driver, byId="elink_waiting")
    WebDriverWait(driver, TIMEOUT).until_not(EC.visibility_of(loader))


def create_task(context, label):
    driver = context.webdriver

    # wait until the page is loaded
    wait_loading(context)

    waitForElement(driver, byClass="wf-task-form")
    button = ensure_actable(driver, byCSS=".wf-task-form button")
    button.click()

    link = ensure_actable(driver, byText=label)
    link.click()

    wait_loading(context)
    # wait for the new task to be shown, or for the timeout
    waitForElement(driver, byClass="wf-task")


@given("the user has opened the workflow designer")
def userOpenedDesigner(context):
    url = "".join([context.server_url,
                   context.wfprocess.getWorkflowDesignerURL()])
    context.webdriver.get(url)


@when("the user adds a new execution task")
def userAddsExecutionTask(context):
    create_task(context, "Erledigung")


@then("the new task is created")
def newTaskCreated(context):
    context.wfprocess.Reload()
    assert len(context.wfprocess.Tasks) == 1, "Task has not been created"


@when("the user selects the task")
def userSelectsTask(context):
    select_first_task(context)


@when("the user clicks on the (?P<location>left|right|bottom) arrow")
def userClicksArrow(context, location):
    if location == "left":
        wrapper_class = "wf-add-before"
    elif location == "right":
        wrapper_class = "wf-add-after"
    elif location == "bottom":
        wrapper_class = "wf-add-parallel"

    driver = context.webdriver

    waitForElement(driver, byClass=wrapper_class)
    button = ensure_actable(driver, byCSS=".{} button".format(wrapper_class))
    button.click()

    link = ensure_actable(driver, byText="Genehmigung")
    link.click()


@then("a new task (?P<position>before|after|parallel to) the selected task is created")
def newTaskCreatedAt(context, position):
    driver = context.webdriver

    # wait until the previous action is completed
    WebDriverWait(driver, TIMEOUT).until(
        lambda d: len(d.find_elements_by_class_name("wf-task")) == 2)

    wait_loading(context)

    try:
        context.wfprocess.Reload()

        # The new task has been created
        newtasks = context.wfprocess.AllTasks\
            .Query(tasks.Task.task_id != context.wftask.task_id)

        assert len(newtasks) >= 1, "New task not created"
        assert len(newtasks) <= 1, "New task created more than once"
        newtask = newtasks[0]

        if position == "parallel to":
            assert len(context.wfprocess.Components) == 1, "Cannot find task group"
            taskgroup = context.wfprocess.Components[0]

            assert isinstance(taskgroup, taskgroups.ParallelTaskGroup),\
                "The task group is not of type 'parallel'"

            assert set(taskgroup.Components.task_id) == set([context.wftask.task_id,
                                                             newtask.task_id]), \
                "The task group does not contain the expected tasks"
        else:
            ids = context.wfprocess.Components\
                .Query("1=1", order_by="position").task_id
            if position == "before":
                assert ids == [newtask.task_id, context.wftask.task_id], \
                    "The tasks are in the wrong sequence"
            elif position == "after":
                assert ids == [context.wftask.task_id, newtask.task_id], \
                    "The tasks are in the wrong sequence"
    except AssertionError:
        filename = os.path.join(CADDOK.TMPDIR,
                                "wfdesigner_error_%s.png" % time.time())
        driver.get_screenshot_as_file(filename)
        raise


@given("the approval task type has a configured extension")
def approvalTaskHasExtension(context):
    exec_clsdef = tasks.ApprovalTask._getClassDef()
    asgns = ExtensionAssignment.getAssignments(exec_clsdef)
    extension = asgns.KeywordQuery(
        extension_cdb_classname=SimpleTaskExtension._getClassname())
    assert extension, "No such extension found"
    context.task_extension = extension[0]


@when("the user adds a new approval task with that extension")
def userAddsApprovalWithExtension(context):
    driver = context.webdriver

    # wait until the page is loaded
    wait_loading(context)

    waitForElement(driver, byClass="wf-task-form")
    button = ensure_actable(driver, byCSS=".wf-task-form button")
    button.click()

    link = ensure_actable(
        driver, byText=SimpleTaskExtension.getExtensionTypeDescription())
    link.click()

    # wait for the new task to be shown, or for the timeout
    wait_loading(context)
    waitForElement(driver, byClass="wf-task")


@then("the task has that extension")
def taskHasExtension(context):
    context.wfprocess.Reload()
    assert isinstance(
        context.wfprocess.Tasks[0].getExtensionObject(), SimpleTaskExtension), \
        "Wrong extension is assigned to the task"


@then("a extension tile is added to the overview of the task")
def extensionTilAdded(context):
    # this step should check whether the extension
    # is displayed in the UI (Workflow designer)
    driver = context.webdriver
    # wait until the page is loaded
    wait_loading(context)

    waitForElement(driver, byClass="simple_task_extension")


@given("the user added a new approval task with that extension")
def givenUserAddsApprovalWithExtension(context):
    driver = context.webdriver

    # wait until the page is loaded
    wait_loading(context)

    waitForElement(driver, byClass="wf-task-form")
    button = ensure_actable(driver, byCSS=".wf-task-form button")
    button.click()

    link = ensure_actable(
        driver, byText=SimpleTaskExtension.getExtensionTypeDescription())
    link.click()

    # wait for the new task to be shown, or for the timeout
    waitForElement(driver, byClass="wf-task")


@given("there is an editable field in the extension tile")
def editableExtensionField(context):
    driver = context.webdriver
    # wait until the page is loaded
    wait_loading(context)
    open_collapse(driver)

    waitForElement(driver, byClass="simple_task_extension")
    editable = ensure_actable(
        driver, byCSS=".simple_task_extension .example_text")

    editable.click()
    waitForElement(driver, element=editable, byTag="input")


@when("the user modifies the field of the extension")
def userModifiesExtensionField(context):
    driver = context.webdriver
    open_collapse(driver)

    extension = waitForElement(driver, byClass="simple_task_extension")
    waitForElement(driver, element=extension, byClass="example_text")

    context.extension_field_value = "foo"
    input_field = ensure_actable(
        driver, byCSS=".simple_task_extension .example_text input")
    input_field.send_keys(context.extension_field_value + Keys.RETURN)


@then("the field of the extension is modified")
def extensionFieldIsModified(context):
    driver = context.webdriver
    open_collapse(driver)

    extension = waitForElement(driver, byClass="simple_task_extension")
    example = waitForElement(driver, element=extension, byClass="example_text")

    # ensure that the GUI shows the correct value
    WebDriverWait(driver, TIMEOUT).until(
        lambda x: example.text == context.extension_field_value,
        "Field value is \"%s\", not as expected: \"%s\"" % (
            example.text, context.extension_field_value))

    # ensure that the back end also saved the correct value
    context.wfprocess.Reload()
    ext_obj = context.wfprocess.Tasks[0].getExtensionObject()
    assert ext_obj["example_text"] == context.extension_field_value, \
        "Field value is \"%s\", not as expected: \"%s\"" % (
            ext_obj["example_text"], context.extension_field_value)


@when('the user adds a new "run operation" system task')
def userAddeOperationTask(context):
    create_task(context, "Operation ausführen")


@when('the user selects the parameter "(?P<parameter>.*)"')
def userSelectsParameter(context, parameter):
    driver = context.webdriver
    select = ensure_actable(driver, byCSS=".btn.parameter-action")
    select.click()

    filter_input = ensure_actable(driver, byClass="filter-input")
    filter_input.send_keys(parameter)

    param_checkbox = waitForElement(driver, byClass="icon-check-empty")
    actions = ActionChains(driver).move_to_element(
        param_checkbox).click().release()
    actions.perform()

    modal = waitForElement(driver, byClass="modal")
    WebDriverWait(driver, TIMEOUT).until_not(EC.visibility_of(modal))
    # wait for obviel rerender
    waitForAjax(driver)


@when("the user deletes the parameter")
def userDeletesParameter(context):
    driver = context.webdriver
    select = ensure_actable(
        driver, byCSS=".parameter-list > li > .btn.wf-remove")
    select.click()
    # wait for obviel rerender
    waitForAjax(driver)


@then('the task\'s picture url is "(?P<relative_url>.+)"')
def taskPictureIs(context, relative_url):
    driver = context.webdriver
    image = waitForElement(
        driver,
        byCSS='.systemtask-icon > img[src*="{}"]'.format(relative_url))
    assert image, "img with src* '{}' not found".format(relative_url)
