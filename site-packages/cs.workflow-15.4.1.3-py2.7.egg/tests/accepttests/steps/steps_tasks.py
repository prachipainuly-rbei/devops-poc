# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

"""
Module steps_tasks

Behave steps for creating, editing or deleting task groups.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: steps_tasks.py 183859 2018-09-14 06:22:48Z cso $"

from cdb import auth
from cdb import cdbuuid
from cdb import constants

from cdb.validationkit import run_with_added_roles
from cdb.validationkit import given
from cdb.validationkit import when
from cdb.validationkit import then
from cdb.validationkit import operation
from cdb.validationkit import log
from cdb.validationkit import getStateNumber

from steps import common

from cs.workflow import tasks
from cs.workflow import briefcases
from cs.workflow import processes
from cs.workflow import constraints


def getTaskAttributesToChange():
    return {"title": "Changed"}


@given("^a task was created by (?P<role>.*?)$")
def taskWasCreatedBy(context, role):
    @run_with_added_roles(role.split(","))
    def create(context):
        context.wftask = common.generateTask(common.generateProcessOP())
        context.wftask_len = len(tasks.Task.Query())
    create(context)


@given("^the user (?P<subject_id>.*?) has created a process template$")
@run_with_added_roles(["cdbwf: Process Library Manager"])
def userCreatedTemplate(context, subject_id):
    process = common.generateProcessOP(is_template="1")
    process.Update(subject_id=subject_id, subject_type="Person")

    context.wftemplate = process


@given("^some task has no (?P<attribute>responsible|title)$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def taskHasNo(context, attribute):
    try:
        context.wftask_len = len(tasks.ExecutionTask.Query())

        preset = common.getObligatoryForExecutionTask(context.wfprocess)
        if attribute == "responsible":
            del preset["subject_id"]
            del preset["subject_type"]
        elif attribute == "title":
            del preset["title"]

        operation(
            constants.kOperationNew,
            tasks.ExecutionTask,
            preset=preset
        )
    except Exception, e:
        log("Error creating the execution task, details: %s" % e)


@given("^the(?: (?P<status>running|not running))? task has some"
       "(?: (?P<mode>info|edit))? briefcase"
       "(?: (?P<er_option>with|without) the extends rights option)?$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def taskHasBriefcase(context, status, mode, er_option):
    if mode is None:
        mode = "info"
    assert mode in [e.name for e in briefcases.IOType]

    if er_option == "with":
        extends_rights = 1
    else:
        extends_rights = 0

    if status == "running":
        wftask = context.running_task
    elif status == "not running":
        wftask = context.new_task
    else:
        wftask = context.wftask

    context.wfbriefcase = common.generateBriefcase(context.wfprocess)

    iotype = briefcases.IOType[mode].value
    if status != "running":
        context.wfbriefcaselink = common.genereateBriefcaseLink(
            context.wfprocess,
            wftask,
            context.wfbriefcase,
            iotype=iotype,
            extends_rights=extends_rights
        )
    else:
        # It is not allowed to add briefcase links to a running task
        # therefore we have to bypass the rights check
        attrs = common.getObligatoryForBriefcaseLink(context.wfprocess,
                                                     wftask,
                                                     context.wfbriefcase)
        attrs.update(iotype=iotype, extends_rights=extends_rights)
        context.wfbriefcaselink = briefcases.BriefcaseLink.Create(**attrs)


@given("^the(?: (?P<status>running|not running))? task "
       "has a (?P<obj>constraint)(?: (?P<addtl>with a briefcase))?$")
def constraintWithBriefcase(context, status, obj, addtl):
    if status == "running":
        task = context.running_task
    elif status == "not running":
        task = context.new_task
    else:
        task = context.wftask

    if obj == "constraint":
        args = common.getObligatoryForConstraint(context.wfprocess, task)
        if addtl == "with a briefcase":
            args["briefcase_id"] = context.wfbriefcase.briefcase_id
        edit_obj = constraints.Constraint.Create(**args)
        edit_attr = "rule_name"
        context.wfconstraint = edit_obj

    context.edit_obj = edit_obj
    context.edit_attr = edit_attr


@given("^the not running task has a constraint "
       "which evaluates to (?P<status>true|false)$")
def constraintEvaluatesTo(context, status):
    task = context.new_task

    if status == "true":
        rule = True
    else:
        rule = False

    args = common.getObligatoryForConstraint(context.wfprocess, task, rule)
    constraints.Constraint.Create(**args)


@when("^(?P<role>.*?) creates a new execution task$")
def roleCreatesExecutionTask(context, role):
    @run_with_added_roles(role.split(","))
    def create(context):
        try:
            context.wftask_len = len(tasks.ExecutionTask.Query())
            operation(
                "CDB_Create",
                tasks.ExecutionTask,
                preset=common.getObligatoryForExecutionTask(
                    context.wfprocess
                ),
                interactive=False
            )  # FIXME: should work interactively
        except Exception, e:
            log("Error creating the execution task, details: %s" % e)
    return create(context)


@when("^(?P<role>.*?) creates a new examination task$")
def roleCreatesExaminationTask(context, role):
    @run_with_added_roles(role.split(","))
    def create(context):
        try:
            context.wftask_len = len(tasks.ExaminationTask.Query())
            operation(
                "CDB_Create",
                tasks.ExaminationTask,
                preset=common.getObligatoryForExaminationTask(
                    context.wfprocess
                ),
                interactive=False
            )  # FIXME: should work interactively
        except Exception, e:
            log("Error creating the examination task, details: %s" % e)
    return create(context)


@when("^(?P<role>.*?) creates a new approval task$")
def roleCreatesApprovalTask(context, role):
    @run_with_added_roles(role.split(","))
    def create(context):
        try:
            context.wftask_len = len(tasks.ApprovalTask.Query())
            operation(
                "CDB_Create",
                tasks.ApprovalTask,
                preset=common.getObligatoryForApprovalTask(context.wfprocess),
                interactive=False
            )  # FIXME: should work interactively
        except Exception, e:
            log("Error creating the approval task, details: %s" % e)
    return create(context)


@when("^(?P<role>.*?) changes this task$")
def roleChangesTask(context, role):
    @run_with_added_roles(role.split(","))
    def change(context):
        try:
            operation(
                "CDB_Modify",
                context.wftask,
                user_input=getTaskAttributesToChange()
            )
        except Exception, e:
            log("Error changing the task, details: %s" % e)
    return change(context)


@when("^(?P<role>.*?) copies this task$")
def roleCopiesTask(context, role):
    @run_with_added_roles(role.split(","))
    def copy(context):
        try:
            position = max(
                context.wftask.Parent.Components.position + [0]
            ) + 10
            operation(
                "CDB_Copy",
                context.wftask,
                preset={
                    "task_id": tasks.Task.new_task_id(),
                    "position": position
                },
                interactive=False
            )  # FIXME: should work interactively
        except Exception, e:
            log("Error coping the task, details: %s" % e)
    return copy(context)


@when("^(?P<role>.*?) deletes this task$")
def roleDeletesTask(context, role):
    @run_with_added_roles(role.split(","))
    def delete(context):
        try:
            operation("CDB_Delete", context.wftask)
        except Exception, e:
            log("Error deleting the task, details: %s" % e)
    return delete(context)


@when("^(?P<role>.*?) changes the state of this task$")
def roleChangesTaskState(context, role):
    @run_with_added_roles(role.split(","))
    def state(context):
        try:
            context.state_from = getStateNumber(
                context.wftask.cdb_objektart,
                context.table[0]["FROM"]
            )
            context.state_to = getStateNumber(
                context.wftask.cdb_objektart,
                context.table[0]["TO"]
            )
            if context.wftask.status != context.state_from:
                @run_with_added_roles(["cdbwf: Process Administrator "])
                def c(context):
                    context.wftask.ChangeState(context.state_from)
                c(context)
            if context.state_to == context.wftask.EXECUTION.status:
                context.wftask.activate_task()
            elif context.state_to == context.wftask.COMPLETED.status:
                context.wftask.close_task()
            elif context.state_to == context.wftask.REJECTED.status:
                context.wftask.refuse_task()
            elif context.state_to == context.wftask.DISCARDED.status:
                context.wftask.cancel_task()
        except Exception, e:
            log("Error changing the state of the task, details: %s" % e)
    return state(context)


@when("^the logged user instantiates the template$")
def userInstantiatesTemplate(context):
    operation(
        "cdbwf_new_process_from_template",
        context.wftemplate,
        preset={}
    )
    context.wfprocess = processes.Process.Query(order_by="cdb_cdate")[-1]


@when("^the (?P<objname>briefcase|briefcase link) is deleted$")
def whenBriefcaseIsDeleted(context, objname):
    if objname == "briefcase":
        obj = context.wfbriefcase
    elif objname == "briefcase link":
        obj = context.wfbriefcaselink

    try:
        operation(
            constants.kOperationDelete,
            obj,
            preset={}
        )
        context.deleted = True
    except Exception:
        context.deleted = False


@when("^some task is edited$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def someTaskIsEdited(context):
    context.old_attr_value = context.running_task.cdb_mdate
    context.watched_attr = "cdb_mdate"

    try:
        operation(
            constants.kOperationModify,
            context.running_task,
            preset={"title": cdbuuid.create_uuid()}
        )  # set title to random string
    except Exception as _ex:
        pass


@when("^the (?P<attribute>.*) of the task is edited$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def attributeIsEdited(context, attribute):
    context.old_attr_value = getattr(context.running_task, attribute)

    field = tasks.Task.GetFieldByName(attribute)
    preset = {attribute: common.get_random_value(field.type)}

    context.watched_attr = attribute

    try:
        operation(
            constants.kOperationModify,
            context.running_task,
            preset=preset
        )
    except Exception as _ex:
        pass


@when("^the new task is started$")
def newTaskIsStarted(context):
    try:
        operation("cdbwf_close_task", context.running_task)
        context.new_task.Reload()
    except Exception as _ex:
        log("%s" % _ex)


@when("^the task is (?P<action>closed|refused|forwarded)"
      "(?: (?P<preposition>with|without) a comment)?$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def taskStateIs(context, action, preposition):
    def reload_objects():
        context.wfprocess.Reload()
        context.wftask.Reload()
        if hasattr(context, "wftask2"):
            context.wftask2.Reload()
        if hasattr(context, "wftaskgroup"):
            context.wftaskgroup.Reload()

    operation("cdbwf_start_workflow",
              context.wfprocess)
    reload_objects()

    if preposition == "without":
        preset = {"remark": ""}
    else:
        preset = {
            "remark": u"'ELLO POLLY!!!!! Testing! Testing! Testing! Testing! "
                      "This is your nine o'clock alarm call!"
        }

    if action == "closed":
        opname = "cdbwf_close_task"
    elif action == "refused":
        opname = "cdbwf_refuse_task"
    elif action == "forwarded":
        opname = "cdbwf_forward_task"

    try:
        operation(
            opname,
            context.wftask,
            preset=preset
        )
    except RuntimeError as _ex:
        pass
    reload_objects()


@then("^a new execution task is (?P<creation>(?:not )?generated)$")
def newExecutionTask(context, creation):
    if creation == "generated":
        assert len(tasks.ExecutionTask.Query()) - context.wftask_len == 1, (
            "No execution task has been created"
        )
    elif creation == "not generated":
        assert len(tasks.ExecutionTask.Query()) - context.wftask_len == 0, (
            "A execution task has been created"
        )


@then("^a new examination task is (?P<creation>(?:not )?generated)$")
def newExaminationTask(context, creation):
    if creation == "generated":
        assert len(tasks.ExaminationTask.Query()) - context.wftask_len == 1, (
            "No examination task has been created"
        )
    elif creation == "not generated":
        assert len(tasks.ExaminationTask.Query()) - context.wftask_len == 0, (
            "A examination task has been created"
        )


@then("^a new approval task is (?P<creation>(?:not )?generated)$")
def newApprovalTask(context, creation):
    if creation == "generated":
        assert len(tasks.ApprovalTask.Query()) - context.wftask_len == 1, (
            "No approval task has been created"
        )
    elif creation == "not generated":
        assert len(tasks.ApprovalTask.Query()) - context.wftask_len == 0, (
            "A approval task has been created"
        )


@then("^the changed task is (?P<status>(?:not )?saved)$")
def changedTaskIsSaved(context, status):
    context.wftask.Reload()
    s_attrs = set(getTaskAttributesToChange().items())
    if status == "saved":
        assert s_attrs.issubset(set(context.wftask.items())), (
            "The attributes differ"
        )
    elif status == "not saved":
        assert not s_attrs.issubset(set(context.wftask.items())), (
            "The attributes don't differ"
        )


@then("^the task is (?P<status>(?:not )?copied|(?:not )?deleted)$")
def taskIsCopiedOrDeleted(context, status):
    if status == "copied":
        assert len(tasks.Task.Query()) - context.wftask_len == 1, (
            "The task has not been copied"
        )
    elif status == "not copied":
        assert len(tasks.Task.Query()) - context.wftask_len == 0, (
            "The task has been copied"
        )
    elif status == "deleted":
        assert len(tasks.Task.Query()) - context.wftask_len == -1, (
            "The task has not been deleted"
        )
    elif status == "not deleted":
        assert len(tasks.Task.Query()) - context.wftask_len == 0, (
            "The task has been deleted"
        )


@then("^the state of the task is (?P<status>(?:not )?saved)$")
def taskStateIsSaved(context, status):
    context.wftask.Reload()
    if status == "saved":
        assert context.wftask.status == context.state_to, (
            "The state has not been changed"
        )
    elif status == "not saved":
        assert context.wftask.status == context.state_from, (
            "The state has been changed"
        )


@then("^the logged user is responsible for the process$")
def userIsResponsible(context):
    assert context.wfprocess.subject_id == auth.persno
    assert context.wfprocess.subject_type == "Person"


@then("^the (?P<objname>briefcase|briefcase link) is "
      "(?P<outcome>deleted|not deleted)$")
def briefcaseIsDeleted(context, objname, outcome):
    if outcome == "deleted":
        assert context.deleted
    else:
        assert not context.deleted


@then("^the task is(?: (?P<adverb>not))? modified$")
def taskIsModified(context, adverb):
    modified = getattr(
        context.running_task,
        context.watched_attr
    ) != context.old_attr_value

    if adverb == "not":
        assert not modified
    else:
        assert modified


@then("^the task is (?P<outcome>canceled|not canceled)$")
def theTaskIs(context, outcome):
    task = context.wftask
    task.Reload()

    canceled = (task.status == task.DISCARDED.status)

    if outcome == "canceled":
        assert canceled
    else:
        assert not canceled


@then("^the new task is (?P<outcome>started|canceled)$")
def theNewTaskIs(context, outcome):
    if outcome == "started":
        assert context.new_task.status == tasks.Task.EXECUTION.status, (
            "The status of the task is {}, but it should be {}".format(
                context.new_task.status,
                tasks.Task.EXECUTION.status
            )
        )
    elif outcome == "canceled":
        assert context.new_task.status == tasks.Task.DISCARDED.status, (
            "The status of the task is {}, but it should be {}".format(
                context.new_task.status,
                tasks.Task.DISCARDED.status
            )
        )


@then("^the (?:(?P<adjective>|following) )?"
      "task is (?P<outcome>started|closed|not closed|refused|canceled)$")
def thenTaskStatusIs(context, adjective, outcome):
    if adjective == "following":
        task = context.wftask2
    else:
        task = context.wftask

    if outcome == "started":
        assert task.status == tasks.Task.EXECUTION.status
    elif outcome == "closed":
        assert task.status == tasks.Task.COMPLETED.status
    elif outcome == "not closed":
        assert task.status != tasks.Task.COMPLETED.status
    elif outcome == "refused":
        assert task.status == tasks.Task.REJECTED.status
    elif outcome == "canceled":
        assert task.status == tasks.Task.DISCARDED.status


@then("the briefcase link has(?: (?P<negation>not)) the extends rights "
      "property")
def briefcaseLinkExtendsRights(context, negation=""):
    extends_rights = context.wfbriefcaselink.extends_rights
    if negation == "not":
        assert not extends_rights
    else:
        assert extends_rights
