#!/usr/bin/env powerscript
# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

__docformat__ = "restructuredtext en"
__revision__ = "$Id: access.py 183981 2018-09-17 15:39:29Z cso $"

from cdb.dberrors import DBConstraintViolation
from cdb.sqlapi import Record
from cdb.util import SkipAccessCheck
from cdb.validationkit import given
from cdb.validationkit import then
from cdb.validationkit import when
from cs.workflow.briefcases import Briefcase
from cs.workflow.constraints import Constraint
from cs.workflow.processes import Process
from cs.workflow.schemacomponents import SchemaComponent
from cs.workflow.tasks import Task


def _get_base_query(context):
    return {"cdb_process_id": context.process.cdb_process_id}


def get_constraints(context):
    query = _get_base_query(context)
    return Constraint.KeywordQuery(**query)


def get_briefcases(context):
    query = _get_base_query(context)
    return Briefcase.KeywordQuery(**query)


def get_briefcase_contents(context):
    result = []

    for briefcase in get_briefcases(context):
        for content in briefcase.Content:  # this already checks "read"
            result.append(content)

    return result


def _get_tasks_by_status(context, status=None):
    query = _get_base_query(context)

    if not status is None:
        query["status"] = status

    return SchemaComponent.KeywordQuery(**query)


def get_all_components(context):
    return _get_tasks_by_status(context)


def get_all_tasks(context):
    return _get_tasks_by_status(context).Query(
        "cdb_classname LIKE 'cdbwf_task%%'"
    )


def get_all_taskgroups(context):
    return _get_tasks_by_status(context).Query(
        "cdb_classname LIKE 'cdbwf_aggregate%%'"
    )


def get_past_tasks(context):
    return _get_tasks_by_status(context, 20).Query(
        "cdb_classname LIKE 'cdbwf_task%%'"
    )


def get_past_taskgroups(context):
    return _get_tasks_by_status(context, 20).Query(
        "cdb_classname LIKE 'cdbwf_aggregate%%'"
    )


def get_current_tasks(context):
    return _get_tasks_by_status(context, 10).Query(
        "cdb_classname LIKE 'cdbwf_task%%'"
    )


def get_future_tasks(context):
    return _get_tasks_by_status(context, 0).Query(
        "cdb_classname LIKE 'cdbwf_task%%'"
    )


def get_future_taskgroups(context):
    return _get_tasks_by_status(context, 0).Query(
        "cdb_classname LIKE 'cdbwf_aggregate%%'"
    )


@given("^test process exists$")
def testProcessExists(context):
    context.process = Process.ByKeys("ACCESS_TEST")


@given("^process is reset$")
def processIsReset(context):
    context.process._reset_schema()


@given("^briefcases are filled$")
def briefcasesAreFilled(context):
    for folder, content in [
        (
            "00043ccf-b7ed-11e8-92b3-5cc5d4123f3b",
            "0001cbd1-b7ed-11e8-96fe-5cc5d4123f3b"
        ),
        (
            "072b4acf-b7ed-11e8-80b1-5cc5d4123f3b",
            "0729c42e-b7ed-11e8-81bc-5cc5d4123f3b"
        ),
        (
            "af749c5e-b7ec-11e8-afae-5cc5d4123f3b",
            "6e3b1ca1-b7ed-11e8-b3aa-5cc5d4123f3b"
        ),
        (
            "b10a578f-b7ec-11e8-9be5-5cc5d4123f3b",
            "8394cf61-b7ed-11e8-a26a-5cc5d4123f3b"
        ),
        (
            "b4aaafcf-b7ec-11e8-aed8-5cc5d4123f3b",
            "6e3b1ca1-b7ed-11e8-b3aa-5cc5d4123f3b"
        ),
    ]:
        rec = Record(
            "cdbfolder_content",
            cdb_folder_id=folder,
            cdb_content_id=content,
        )
        try:
            rec.insert()
        except DBConstraintViolation:
            pass


@given("^process status is (?P<status>\d+)$")
def processStatusIs(context, status):
    status = int(status)
    context.process.Update(status=status)


class StopRecursion(Exception):
    pass


def activate(task, last_title):
    if task.title == last_title:
        raise StopRecursion

    task.close_task("ok")

    activate(
        Task.KeywordQuery(status=10, cdb_process_id=task.cdb_process_id)[0],
        last_title
    )


@given("^current process step is (?P<current>.+)$")
def currentProcessStepIs(context, current):
    with SkipAccessCheck():
        context.process.activate_process()

        try:
            activate(context.process.Components[0], current)
        except StopRecursion:
            pass


OBJECT_IDENTIFIERS = {
    "process": lambda context: [context.process],
    "constraints": get_constraints,
    "briefcases": get_briefcases,
    "briefcase contents": get_briefcase_contents,
    "all components": get_all_components,
    "all tasks": get_all_tasks,
    "all taskgroups": get_all_taskgroups,
    "past tasks": get_past_tasks,
    "past taskgroups": get_past_taskgroups,
    "current tasks": get_current_tasks,
    "future tasks": get_future_tasks,
    "future taskgroups": get_future_taskgroups,
}


def check_access_rights(objects, access_right, persno, expected):
    mismatch = []
    for obj in objects:
        if obj.CheckAccess(access_right, persno) != expected:
            mismatch.append(obj)
    if mismatch:
        raise AssertionError(
            "access '{}' for user '{}' {}granted on:\n\t{}".format(
                access_right,
                persno,
                "not " if expected else "",
                "\n\t".join([x.GetDescription() for x in mismatch])
            )
        )


@then('^user "(?P<user>.+)" is (?P<result>granted|denied) "(?P<acr>.+)" on '
      '(?P<objects>{})$'.format("|".join(OBJECT_IDENTIFIERS.keys())))
def thenUserAccess(context, user, result, acr, objects):
    expected = result == "granted"
    objs = OBJECT_IDENTIFIERS[objects](context)
    check_access_rights(objs, acr, user, expected)
