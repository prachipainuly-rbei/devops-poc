#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""
Module steps_processes

Behave steps for creating, editing or deleting processes.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: steps_processes.py 176417 2018-04-23 15:02:20Z cso $"

# Some imports
import os

from cdb import CADDOK

from cdb.objects import cdb_file
from cdb.platform import FolderContent
from cdb import constants

from cdb.validationkit import run_with_added_roles
from cdb.validationkit import when
from cdb.validationkit import then
from cdb.validationkit import given
from cdb.validationkit import operation
from cdb.validationkit import log
from cdb.validationkit import getStateNumber

from cs.workflow import processes
from cs.workflow import briefcases
from cs.workflow import taskgroups
from cs.workflow import tasks

from steps import common  # @UnresolvedImport


TMPFILE = u"cs_workflow_steps_tmp_file"


class File(cdb_file.CDB_File, briefcases.BriefcaseContent):
    pass


def getWfProcessAttributesToChange():
    return {"title": "Changed"}


# -- GIVEN ---------------------------------------------------------------------

@given("^a process was created by (?P<role>.*?)$")
def step(context, role):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def create(context):
        context.wfprocess = common.generateProcessOP()
        context.wfprocess_len = len(processes.Process.Query())
    create(context)


@given("^a process was created$")  # noqa
@run_with_added_roles(["cdbwf: Process Administrator"])
def step(context):  # @DuplicatedSignature
    context.wfprocess = common.generateProcessOP()
    context.wfprocess_len = len(processes.Process.Query())


@given("^a(?: (?P<status>not running|running|closed))? process"
       "(?: (?P<content>|with some tasks|with some running tasks|"
       "with some not running tasks|with some closed tasks))? exists$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def step(context, status, content):  # @DuplicatedSignature
    assert status != "closed" or content in [None, "with some tasks",
                                             "with some closed tasks"]

    context.wfprocess = common.generateProcessOP()

    with_tasks = status == "running" or\
        (content in ["with some tasks", "with some running tasks",
                     "with some not running tasks", "with some closed tasks"])

    if with_tasks:
        context.running_task = common.generateTask(context.wfprocess, position=10)

        if content in ["with some not running tasks", "with some closed tasks"]:
            context.new_task = common.generateTask(context.wfprocess, position=20)

    if status in ['running', 'closed']:
        operation("cdbwf_start_workflow", context.wfprocess)

    if with_tasks and (status == 'closed' or content == "with some closed tasks"):
        operation("cdbwf_close_task", context.running_task)
        context.running_task.Reload()

    if with_tasks and status == 'closed':
        if hasattr(context, "new_task"):
            operation("cdbwf_close_task", context.new_task)
            context.new_task.Reload()

        context.wfprocess.Reload()
        assert context.wfprocess.status == processes.Process.COMPLETED.status

    if with_tasks:
        context.wftask = context.running_task


@given("^some briefcase has some content$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def step(context):  # @DuplicatedSignature
    briefcase = context.wfprocess.AttachmentsBriefcase

    # Create file
    filepath = os.path.join(CADDOK.TMPDIR, TMPFILE)
    open(filepath, 'a').close()

    file_obj = File.NewFromFile(
        context.wfprocess.cdb_object_id,
        filepath,
        primary=False)

    context.briefcase_link = operation(constants.kOperationNew,  # @UndefinedVariable
                                       FolderContent,
                                       preset={"cdb_folder_id": briefcase.cdb_object_id,
                                               "cdb_content_id": file_obj.cdb_object_id})

    context.briefcase_content = file_obj


@given("^the (?P<objtype>process|task group) has a "
       "(?P<typ>execution|examination|approval|system) task"
       "(?: (?P<options>with finish option))?$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def step(context, objtype, typ, options):  # @DuplicatedSignature
    assert options != "with finish option" or typ in ["examination", "approval"]

    if objtype == "process":
        obj = context.wfprocess
    elif objtype == "task group":
        obj = context.wftaskgroup

    finish_option = 1 if options == "with finish option" else 0
    args = {"parent_id": getattr(obj, "task_id", ""),
            "finish_option": finish_option}

    if typ == "execution":
        preset = common.getObligatoryForExecutionTask(context.wfprocess)
        preset.update(args)
        context.wftask = operation(constants.kOperationNew,  # @UndefinedVariable
                                   tasks.ExecutionTask,
                                   preset=preset,
                                   interactive=False)
    elif typ == "examination":
        preset = common.getObligatoryForExaminationTask(context.wfprocess)
        preset.update(args)
        context.wftask = operation(constants.kOperationNew,  # @UndefinedVariable
                                   tasks.ExaminationTask,
                                   preset=preset,
                                   interactive=False)

        if finish_option:
            preset = common.getObligatoryForExaminationTask(context.wfprocess)
            preset.update(args)
            preset["position"] = 20
            context.wftask2 = operation(constants.kOperationNew,  # @UndefinedVariable
                                        tasks.ExaminationTask,
                                        preset=preset,
                                        interactive=False)
    elif typ == "approval":
        preset = common.getObligatoryForApprovalTask(context.wfprocess)
        preset.update(args)
        context.wftask = operation(constants.kOperationNew,  # @UndefinedVariable
                                   tasks.ApprovalTask,
                                   preset=preset,
                                   interactive=False)

        if finish_option:
            preset = common.getObligatoryForApprovalTask(context.wfprocess)
            preset.update(args)
            preset["position"] = 20
            context.wftask2 = operation(constants.kOperationNew,  # @UndefinedVariable
                                        tasks.ApprovalTask,
                                        preset=preset,
                                        interactive=False)
    elif typ == "system":
        preset = common.getObligatoryForCopyTask(context.wfprocess)
        preset.pop("extends_rights", None)
        context.wftask = operation(constants.kOperationNew,  # @UndefinedVariable
                                   tasks.SystemTask,
                                   preset=preset,
                                   interactive=False)


@given("^the process has a task group$")
def step(context):  # @DuplicatedSignature
    preset = common.getObligatoryForParallelTaskGroup(context.wfprocess)
    preset["parent_id"] = ""
    context.wftaskgroup = operation(constants.kOperationNew,  # @UndefinedVariable
                                    taskgroups.ParallelTaskGroup,
                                    preset=preset,
                                    interactive=False)


@given("^a process created by (?P<role>.*?) in state (?P<FROM>.*?), with a task$")
def step(context, role, FROM):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def create(context):
        context.wfprocess = common.generateProcessOP()
        context.wfprocess.status = getStateNumber(
                context.wfprocess.cdb_objektart, FROM)
        context.running_task = common.generateTask(context.wfprocess, position=10)
    create(context)


@given("^a process created by (?P<role>.*?) in state on hold which has a task$")
def step(context, role):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def create(context):
        context.wfprocess = common.generateProcessOP()
        context.wftask = common.generateTask(context.wfprocess, position=10)
        context.wfprocess.activate_process()
        context.wfprocess.onhold_process()
        context.wfprocess.Reload()
        context.wftask.Reload()
    create(context)


# -- WHEN ----------------------------------------------------------------------

@when("^(?P<role>.*?) creates a new process$")
def step(context, role):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def create(context):
        try:
            context.wfprocess_len = len(processes.Process.Query())
            context.wfbriefcase_len = len(briefcases.Briefcase.Query())
            context.wfglobal_info_briefcase_link_len = \
                len(briefcases.BriefcaseLink.Query("task_id='' AND iotype=0"))
            context.wfprocess_completion_task_group_len = \
                len(taskgroups.ProcessCompletionTaskGroup.Query())
            operation("CDB_Create",
                      processes.Process,
                      preset=common.getObligatoryForProcess())
        except Exception, e:
            log("Error creating the process, details: %s" % e)
    return create(context)


@when("^(?P<role>.*?) creates a new process from a template$")
def step(context, role):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def create(context):
        try:
            context.wfprocess_len = len(processes.Process.Query())
            context.wfbriefcase_len = len(briefcases.Briefcase.Query())
            context.wfglobal_info_briefcase_link_len = \
                len(briefcases.BriefcaseLink.Query("task_id='' AND iotype=0"))
            context.wfprocess_completion_task_group_len = \
                len(taskgroups.ProcessCompletionTaskGroup.Query())
            operation("cdbwf_new_process_from_template",
                      context.wfprocess_template)
        except Exception, e:
            log("Error creating the process, details: %s" % e)
    return create(context)


@when("^(?P<role>.*?) changes this process$")
def step(context, role):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def change(context):
        try:
            operation("CDB_Modify",
                      context.wfprocess,
                      preset=getWfProcessAttributesToChange())
        except Exception, e:
            log("Error changing the process, details: %s" % e)
    return change(context)


@when("^(?P<role>.*?) copies this process$")
def step(context, role):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def copy(context):
        try:
            operation("CDB_Copy",
                      context.wfprocess,
                      preset={"cdb_process_id": processes.Process.new_process_id()})
        except Exception, e:
            log("Error coping the process, details: %s" % e)
    return copy(context)


@when("^(?P<role>.*?) deletes this process$")
def step(context, role):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def delete(context):
        try:
            operation("CDB_Delete", context.wfprocess)
        except Exception, e:
            log("Error deleting the process, details: %s" % e)
    return delete(context)


@when("^(?P<role>.*?) changes the state of this process$")  # noqa
def step(context, role):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def state(context):
        try:
            context.state_from = getStateNumber(
                context.wfprocess.cdb_objektart,
                context.table[0]["FROM"])
            context.state_to = getStateNumber(
                context.wfprocess.cdb_objektart,
                context.table[0]["TO"])
            if context.wfprocess.status != context.state_from:
                @run_with_added_roles(["cdbwf: Process Administrator"])
                def c(context):
                    context.wfprocess.ChangeState(context.state_from)
                c(context)
            if context.state_to == context.wfprocess.EXECUTION.status:
                context.wfprocess.op_activate_process(None)
            elif context.state_to == context.wfprocess.COMPLETED.status:
                context.wfprocess.propagate_done(None)
            elif context.state_to == context.wfprocess.REJECTED.status:
                context.wfprocess.propagate_refuse(None, "")
            elif context.state_to == context.wfprocess.FAILED.status:
                context.wfprocess.propagate_cancel(None, "")
        except Exception, e:
            log("Error changing the state of the process, details: %s" % e)
    return state(context)


@when("^(?P<role>.*?) changes the state of this process from (?P<FROM>.*?) to (?P<TO>.*?)$")  # noqa
def step(context, role, FROM, TO):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def state(context):
        try:
            context.state_from = getStateNumber(
                context.wfprocess.cdb_objektart, FROM)
            context.state_to = getStateNumber(
                context.wfprocess.cdb_objektart, TO)
            if context.wfprocess.status != context.state_from:
                @run_with_added_roles(["cdbwf: Process Administrator"])
                def c(context):
                    context.wfprocess.ChangeState(context.state_from)
                c(context)
            if context.state_to == context.wfprocess.EXECUTION.status:
                context.wfprocess.op_activate_process(None)
            elif context.state_to == context.wfprocess.COMPLETED.status:
                context.wfprocess.propagate_done(None)
            elif context.state_to == context.wfprocess.DISCARDED.status:
                context.wfprocess.dismiss_process(None, "")
            elif context.state_to == context.wfprocess.FAILED.status:
                context.wfprocess.propagate_cancel(None, "")
            elif context.state_to == context.wfprocess.FROZEN.status:
                context.wfprocess.op_onhold_process(None)
            context.wfprocess.Reload()
        except Exception, e:
            log("Error changing the state of the process, details: %s" % e)
    return state(context)


@when("^the responsible starts the process$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def step(context):  # @DuplicatedSignature
    try:
        operation("cdbwf_start_workflow",
                  context.wfprocess)
    except:
        pass


@when("^the process is copied$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def step(context):  # @DuplicatedSignature
    context.copied_process = operation(constants.kOperationCopy,  # @UndefinedVariable
                                       context.wfprocess,
                                       interactive=False)


@when("^the process is deleted$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def step(context):  # @DuplicatedSignature
    context.deleted_process_id = context.wfprocess.cdb_process_id

    briefcase = context.wfprocess.AttachmentsBriefcase
    context.deleted_briefcase_object_id = briefcase.cdb_object_id

    context.deleted_content_object_id = context.briefcase_content.cdb_object_id

    operation(constants.kOperationDelete,  # @UndefinedVariable
              context.wfprocess)


@when("^a new task is created (?P<position>before|after) the other task$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def step(context, position):  # @DuplicatedSignature
    if position == "before":
        t_position = context.running_task.position - 5
    else:
        t_position = context.running_task.position + 5

    preset = common.getObligatoryForExecutionTask(context.wfprocess)
    preset["position"] = t_position
    context.other_position = t_position

    try:
        common.operation(constants.kOperationNew,  # @UndefinedVariable
                         tasks.ExecutionTask,
                         preset=preset,
                         interactive=False)
    except Exception as _ex:
        pass


@when("^the process is canceled$")
@run_with_added_roles(["cdbwf: Process Administrator"])
def step(context):  # @DuplicatedSignature
    try:
        operation("cdbwf_cancel_workflow",
                  context.wfprocess,
                  interactive=False)
    except Exception:
        pass


@when("^the process is (?P<action>started|closed|canceled)$")
def step(context, action):  # @DuplicatedSignature
    # create task
    preset = common.getObligatoryForExecutionTask(context.wfprocess)

    context.wftask = operation(constants.kOperationNew,  # @UndefinedVariable
                               tasks.ExecutionTask,
                               preset=preset,
                               interactive=False)

    # start process
    context.wfprocess.activate_process()
    context.wftask.Reload()

    if action == "closed":
        context.wftask.close_task("test")
    elif action == "canceled":
        context.wftask.cancel_task("test")
    context.wfprocess.Reload()


@when("^(?P<role>.*?) changes the process$")
def step(context, role):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def change(context):
        context.old_process_title = context.wfprocess.title
        context.new_process_title = "qqq"
        assert context.old_process_title != context.new_process_title
        try:
            operation("CDB_Modify",
                      context.wfprocess,
                      preset={"title": context.new_process_title})
        except Exception, e:
            pass
    return change(context)


@when("^(?P<role>.*?) changes the status of the task to (?P<state>.*?)$")
def step(context, role, state):  # @DuplicatedSignature
    @run_with_added_roles(role.split(","))
    def change(context):
        context.old_task_status = context.wftask.status
        context.new_task_status = getStateNumber(
                context.wftask.cdb_objektart, state)
        try:
            if state == "done":
                operation("cdbwf_close_task",
                          context.wftask,
                          {"remark": "test"})
            elif state == "refused":
                operation("cdbwf_refuse_task",
                          context.wftask,
                          {"remark": "test"})
        except Exception, e:
            pass
    return change(context)


# -- THEN ----------------------------------------------------------------------

@then("^a new process is (?P<creation>(?:not )?generated)$")
def step(context, creation):  # @DuplicatedSignature
    if creation == "generated":
        assert len(processes.Process.Query()) - context.wfprocess_len == 1, \
            "No process has been created"
    elif creation == "not generated":
        assert len(processes.Process.Query()) - context.wfprocess_len == 0, \
            "A process has been created"


@then("^the changed process is (?P<status>(?:not )?saved)$")
def step(context, status):  # @DuplicatedSignature
    s_attrs = set(getWfProcessAttributesToChange().items())
    context.wfprocess.Reload()
    if status == "saved":
        assert s_attrs.issubset(set(context.wfprocess.items())), \
            "The attributes differ"
    elif status == "not saved":
        assert not s_attrs.issubset(set(context.wfprocess.items())), \
            "The attributes don't differ"


@then("^the process is (?P<status>(?:not )?copied|(?:not )?deleted)$")
def step(context, status):  # @DuplicatedSignature
    if status == "copied":
        assert len(processes.Process.Query()) - context.wfprocess_len == 1, \
            "The process has not been copied"
    elif status == "not copied":
        assert len(processes.Process.Query()) - context.wfprocess_len == 0, \
            "The process has been copied"
    elif status == "deleted":
        assert len(processes.Process.Query()) - context.wfprocess_len == -1, \
            "The process has not been deleted"
    elif status == "not deleted":
        assert len(processes.Process.Query()) - context.wfprocess_len == 0, \
            "The process has been deleted"


@then("^the state of the process is (?P<status>(?:not )?saved)$")
def step(context, status):  # @DuplicatedSignature
    context.wfprocess.Reload()
    if status == "saved":
        assert context.wfprocess.status == context.state_to, \
            "The state has not been changed"
    elif status == "not saved":
        assert context.wfprocess.status == context.state_from, \
            "The state has been changed"


@then("^the (?P<objtype>process|task group) is(?: (?P<proposition>|not))? "
      "(?P<status>started|closed|canceled|refused)$")
def step(context, objtype, proposition, status):  # @DuplicatedSignature
    if objtype == "process":
        obj = context.wfprocess
    elif objtype == "task group":
        obj = context.wftaskgroup

    if status == "started":
        expected_status = obj.EXECUTION.status
    elif status == "closed":
        expected_status = obj.COMPLETED.status
    elif status == "canceled":
        if objtype == "process":
            expected_status = obj.FAILED.status
        elif objtype == "task group":
            expected_status = obj.DISCARDED.status
    elif status == "refused":
        expected_status = obj.REJECTED.status

    status_changed = obj.status == expected_status
    if proposition == "not":
        assert not status_changed
    else:
        assert status_changed


@then("^the new process and its tasks are in the state new$")
def step(context):  # @DuplicatedSignature
    process = context.copied_process

    assert process.status == processes.Process.NEW.status
    assert all([task.status == tasks.Task.NEW.status for task in process.Components])


@then("^the new process has the same briefcase content$")
def step(context):  # @DuplicatedSignature
    briefcase = context.copied_process.AttachmentsBriefcase
    content_id = context.briefcase_content.cdb_object_id

    assert content_id in briefcase.FolderContents.cdb_content_id


@then("^the links to the content are deleted$")
def step(context):  # @DuplicatedSignature
    deleted_id = context.deleted_briefcase_object_id

    assert len(FolderContent.KeywordQuery(cdb_folder_id=deleted_id)) == 0


@then("^the task is (?P<outcome>created|not created)$")
def step(context, outcome):  # @DuplicatedSignature
    created = context.wfprocess.Tasks.KeywordQuery(position=context.other_position)

    if outcome == "created":
        assert created
    else:
        assert not created


@then("^the state change is (?P<saved>.*?)$")
def step(context, saved):
    context.wfprocess.Reload()
    if saved == "yes":
        assert context.wfprocess.status == context.state_to
    elif saved == "no":
        assert context.wfprocess.status == context.state_from
    else:
        assert False


@then("^the process change is (?P<saved>.*?)$")
def step(context, saved):
    context.wfprocess.Reload()
    if saved == "yes":
        assert context.wfprocess.title == context.new_process_title
    elif saved == "no":
        assert context.wfprocess.title == context.old_process_title
    else:
        assert False


@then("^the task state change is (?P<saved>.*?)$")
def step(context, saved):
    context.wftask.Reload()
    if saved == "yes":
        assert context.wftask.status == context.new_task_status
    elif saved == "no":
        assert context.wftask.status == context.old_task_status
    else:
        assert False


@given("^a (?P<FROM>.*?) process created by (?P<role>.*?) has a closed task and a started task$")
def step(context, FROM, role):
    assert FROM in ["Frozen", "Execution"]

    @run_with_added_roles(role.split(","))
    def created(context):
        context.wfprocess = common.generateProcessOP()

        context.closed_task = common.generateTask(context.wfprocess, position=10)

        context.started_task = common.generateTask(context.wfprocess, position=20)

        operation("cdbwf_start_workflow", context.wfprocess)

        operation("cdbwf_close_task", context.closed_task)
        context.closed_task.Reload()
        context.started_task.Reload()
        context.wfprocess.Reload()

        if FROM == "Frozen":
            operation("cdbwf_onhold_workflow", context.wfprocess)
            assert context.wfprocess.status == processes.Process.FROZEN.status
        else:
            assert context.wfprocess.status == processes.Process.EXECUTION.status

        assert context.closed_task.status == tasks.Task.COMPLETED.status
        assert context.started_task.status == tasks.Task.EXECUTION.status
    created(context)


@then("^the (?P<before>closed|started) task stays (?P<after>closed|started)$")
def step(context, before, after):
    assert before == after

    context.closed_task.Reload()
    context.started_task.Reload()
    context.wfprocess.Reload()

    target_task = context.closed_task
    should_be = tasks.Task.COMPLETED.status
    if before == "started":
        target_task = context.started_task
        should_be = tasks.Task.EXECUTION.status

    assert target_task.status == should_be
