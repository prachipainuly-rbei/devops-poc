#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""
Module test_process

This is the documentation for the test_process module.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: test_process.py 176417 2018-04-23 15:02:20Z cso $"

# Some imports
import unittest

from cdb import auth
from cdb import constants
from cdb import testcase
from cdb.objects.operations import operation

from cs.workflow.processes import Process
from cs.workflow.tasks import Task
from cs.workflow.taskgroups import TaskGroup
from cs.workflow.constraints import Constraint
from cs.workflow import briefcases
from cs.workflow import exceptions

# E044611 import mock


class TestSuccessfulFlag(testcase.RollbackTestCase):
    "test handling of cdbwf_process.completing_ok flag"

    def test_new_process(self):
        "completing_ok flag is 1 after creating a new process"
        pr = operation(
            constants.kOperationNew,
            Process,
            cdb_objektart="cdbwf_process")
        self.assertEqual(pr.completing_ok, 1)

    def test_activate_process(self):
        "completing_ok flag is 1 when process is ready"
        pr = operation(
            constants.kOperationNew,
            Process,
            cdb_objektart="cdbwf_process")
        self.assertEqual(pr.completing_ok, 1)
        pr.Update(completing_ok=None,
                  subject_id="caddok",
                  subject_type="Person")
        self.assertEqual(pr.completing_ok, None)
        pr.activate_process()
        self.assertEqual(pr.completing_ok, 1)

    def test_cancel_process(self):
        "completing_ok flag is 0 when process is canceled"
        pr = operation(
            constants.kOperationNew,
            Process,
            cdb_objektart="cdbwf_process")
        pr.cancel_process()
        self.assertEqual(pr.completing_ok, 0)

    def test_dismiss_process(self):
        "completing_ok flag is 0 when process is dismissed"
        pr = operation(
            constants.kOperationNew,
            Process,
            cdb_objektart="cdbwf_process")
        pr.dismiss_process()
        self.assertEqual(pr.completing_ok, 0)

# E044611
# class TestActivateProcess(testcase.PlatformTestCase):
#     """ Test the method Process.activate_process """
#
#     @mock.patch("cs.workflow.processes.set_state")
#     @mock.patch("cs.workflow.processes.Process.Components")
#     def test_activate_process(self, Components, set_state):
#         """ The process is activated, the first task is activated """
#         pr = Process()
#         Components.return_value = [mock.Mock(spec=Task)]
#
#         pr.activate_process()
#
#         set_state.assert_called_with(pr, Process.EXECUTION)
#         assert pr.Components[0].activate_task.called
#
#     @mock.patch("cs.workflow.processes.set_state")
#     @mock.patch("cs.workflow.processes.Process.Constraints")
#     def test_process_constraint_violated(self, Constraints, set_state):
#         """ If a process constraint is violated, the process is not started """
#         pr = Process()
#
#         constraint = mock.Mock(spec=Constraint)
#         constraint.check_violation.side_effect = Exception
#         Constraints.return_value = [constraint]
#
#         try:
#             pr.activate_process()
#         except Exception:
#             excepted = True
#         else:
#             excepted = False
#
#         assert excepted
#         assert not set_state.called
#
#     @mock.patch("cs.workflow.processes.set_state")
#     @mock.patch("cs.workflow.processes.Process.Components")
#     def test_task_canceled(self, Components, set_state):
#         """ If the task is cancelled the process is also cancelled """
#         pr = Process(cdb_process_id="TEST")
#
#         task = mock.Mock(spec=Task)
#         Components.return_value = [task]
#         Components[0].activate_task.side_effect = exceptions.TaskCancelledException
#
#         pr.activate_process()
#
#         set_state.assert_called_with(pr, Process.FAILED, comment="")
#
#
# class TestCancelProcess(testcase.PlatformTestCase):
#     """ Test the method Process.cancel_process """
#
#    @mock.patch.object(Process, "get_cancel_info_setting", return_value=False)
#    @mock.patch("cs.workflow.processes.Process._cancel_info_messages")
#    @mock.patch("cs.workflow.processes.set_state")
#    @mock.patch("cs.workflow.processes.Process.Components")
#    @mock.patch("cs.workflow.processes.Process.ProcessCompletion", spec=Task)
#    def test_without_process_completion_no_info_cancel(self, ProcessCompletion, Components, set_state, _cancel_info_messages, get_cancel_info_setting):
#        "If the process doesn't have a completion task, it will be canceled, info messages are not deactivated."
#        task = mock.Mock(spec=Task)
#        Components.Query.return_value = [task]
#
#        ProcessCompletion.activate_task.side_effect = exceptions.TaskClosedException
#
#        pr = Process()
#        pr.cancel_process()
#
#        assert Components.Query()[0].cancel_task.called
#        set_state.assert_called_with(pr, Process.FAILED, comment="")
#        get_cancel_info_setting.assert_called_with()
#        self.assertFalse(_cancel_info_messages.called)
#
#    @mock.patch.object(Process, "get_cancel_info_setting", return_value=True)
#    @mock.patch("cs.workflow.processes.Process._cancel_info_messages")
#    @mock.patch("cs.workflow.processes.set_state")
#    @mock.patch("cs.workflow.processes.Process.Components")
#    @mock.patch("cs.workflow.processes.Process.ProcessCompletion", spec=Task)
#    def test_without_process_completion_info_cancel(self, ProcessCompletion, Components, set_state, _cancel_info_messages, get_cancel_info_setting):
#        "If the process doesn't have a completion task, it will be canceled, info messages outside of the completion task are deactivated."
#        task = mock.Mock(spec=Task)
#        Components.Query.return_value = [task]
#
#        ProcessCompletion.activate_task.side_effect = exceptions.TaskClosedException
#
#        pr = Process()
#        pr.cancel_process()
#
#        assert Components.Query()[0].cancel_task.called
#        set_state.assert_called_with(pr, Process.FAILED, comment="")
#        get_cancel_info_setting.assert_called_with()
#        _cancel_info_messages.assert_called_with()
#
#    @mock.patch.object(Process, "get_cancel_info_setting", return_value=False)
#    @mock.patch("cs.workflow.processes.Process._cancel_info_messages")
#    @mock.patch("cs.workflow.processes.set_state")
#    @mock.patch("cs.workflow.processes.Process.Components")
#    @mock.patch("cs.workflow.processes.Process.ProcessCompletion", spec=TaskGroup)
#    def test_with_process_completion_no_info_cancel(self, ProcessCompletion, Components, set_state, _cancel_info_messages, get_cancel_info_setting):
#        "The completion task is started, info messages are not deactivated."
#        task = mock.Mock(spec=Task)
#        Components.Query.return_value = [task]
#
#        ProcessCompletion.status = TaskGroup.NEW.status
#        ProcessCompletion.NEW = mock.Mock()
#        ProcessCompletion.NEW.status = TaskGroup.NEW.status
#
#        pr = Process()
#        pr.cancel_process()
#
#        assert Components.Query()[0].cancel_task.called
#        assert not set_state.called
#        assert ProcessCompletion.activate_task.called
#        get_cancel_info_setting.assert_called_with()
#        self.assertFalse(_cancel_info_messages.called)
#
#    @mock.patch.object(Process, "get_cancel_info_setting", return_value=True)
#    @mock.patch("cs.workflow.processes.Process._cancel_info_messages")
#    @mock.patch("cs.workflow.processes.set_state")
#    @mock.patch("cs.workflow.processes.Process.Components")
#    @mock.patch("cs.workflow.processes.Process.ProcessCompletion", spec=TaskGroup)
#    def test_with_process_completion_info_cancel(self, ProcessCompletion, Components, set_state, _cancel_info_messages, get_cancel_info_setting):
#        "The completion task is started, info messages are deactivated."
#        task = mock.Mock(spec=Task)
#        Components.Query.return_value = [task]
#
#        ProcessCompletion.status = TaskGroup.NEW.status
#        ProcessCompletion.NEW = mock.Mock()
#        ProcessCompletion.NEW.status = TaskGroup.NEW.status
#
#        pr = Process()
#        pr.cancel_process()
#
#        assert Components.Query()[0].cancel_task.called
#        assert not set_state.called
#        assert ProcessCompletion.activate_task.called
#        get_cancel_info_setting.assert_called_with()
#        _cancel_info_messages.assert_called_with()
#
#
# class TestCloseProcess(testcase.PlatformTestCase):
#     import mock
#
#     """ Test the method Process.close_process """
#
#     @mock.patch("cs.workflow.processes.set_state")
#     @mock.patch("cs.workflow.processes.Process.ProcessCompletion", spec=Task)
#     def test_without_process_completion(self, ProcessCompletion, set_state):
#         """ If the process doesn't have a completion task, it will be closed """
#         ProcessCompletion.activate_task.side_effect = exceptions.TaskClosedException
#
#         pr = Process()
#         pr.close_process()
#
#         set_state.assert_called_with(pr, Process.COMPLETED)
#
#     @mock.patch("cs.workflow.processes.set_state")
#     @mock.patch("cs.workflow.processes.Process.ProcessCompletion", spec=TaskGroup)
#     def test_with_process_completion(self, ProcessCompletion, set_state):
#         """ The completion task is started """
#         import mock
#         ProcessCompletion.status = TaskGroup.NEW.status
#         ProcessCompletion.NEW = mock.Mock()
#         ProcessCompletion.NEW.status = TaskGroup.NEW.status
#
#         pr = Process()
#         pr.close_process()
#
#         assert not set_state.called
#         assert ProcessCompletion.activate_task.called
#
#
# class TestActivateTasks(testcase.PlatformTestCase):
#     import mock
#
#     """ Test the method Process.activate_tasks """
#
#     @mock.patch("cs.workflow.processes.Process.Components")
#     def test_activate_tasks(self, Components):
#         """ When the process is activated, the first task is activated """
#         import mock
#         task = mock.Mock(spec=Task)
#         Components.return_value = [task]
#
#         pr = Process()
#         pr.activate_tasks()
#
#         assert Components[0].activate_task.called
#
#
# class TestPropagateCancel(testcase.PlatformTestCase):
#     import mock
#
#     """ Test the method Process.propagate_cancel """
#
#     @mock.patch("cs.workflow.processes.Process.cancel_process")
#     @mock.patch("cs.workflow.processes.Process.ProcessCompletion", spec=Task)
#     def test_without_process_completion(self, ProcessCompletion, cancel_process):
#         """ If the process doesn't have a completion task, it will be canceled """
#         import mock
#
#         ProcessCompletion.activate_task.side_effect = exceptions.TaskClosedException
#
#         pr = Process()
#         pr.propagate_cancel(mock.sentinel.task, mock.sentinel.comment)
#
#         cancel_process.assert_called_with(mock.sentinel.comment)
#
#     @mock.patch("cs.workflow.processes.Process.ProcessCompletion", spec=TaskGroup)
#     def test_with_process_completion(self, ProcessCompletion):
#         """ The completion task is started """
#         import mock
#         ProcessCompletion.status = TaskGroup.NEW.status
#         ProcessCompletion.NEW = mock.Mock()
#         ProcessCompletion.NEW.status = TaskGroup.NEW.status
#
#         pr = Process(cdb_process_id="TEST")
#         pr.propagate_cancel(mock.sentinel.task, mock.sentinel.comment)
#
#         assert ProcessCompletion.activate_task.called
#
#
# class TestPropagateDone(testcase.PlatformTestCase):
#     import mock
#
#     """ Test the method Process.propagate_done """
#
#     @mock.patch("cs.workflow.taskgroups.TaskGroup.has_finish_option", return_value=False)
#     def test_propagate_done(self, has_finish_option):
#         """ When a task is closed, the next one is activated """
#         import mock
#         task = mock.Mock(spec=Task)
#         task.Next.return_value = task
#
#         pr = Process()
#         pr.close_process = mock.Mock()
#
#         pr.propagate_done(task)
#
#         assert task.Next.activate_task.called
#
#     def test_propagate_done_finished(self):
#         """ If there are no more tasks, the process is closed """
#         import mock
#         task = mock.Mock(spec=Task)
#         task.Next = None
#
#         pr = Process()
#         pr.close_process = mock.Mock()
#
#         pr.propagate_done(task)
#
#         assert pr.close_process.called
#
#     @mock.patch("cs.workflow.taskgroups.TaskGroup.has_finish_option", return_value=False)
#     def test_propagate_done_cancelled(self, TaskGroup):
#         """ If the next Task is cancelled the process is also cancelled """
#         import mock
#         task = mock.Mock(spec=Task)
#         task.Next.return_value = task
#
#         task.Next.activate_task.side_effect = exceptions.TaskCancelledException
#
#         pr = Process()
#         pr.cancel_process = mock.Mock()
#
#         pr.propagate_done(task)
#
#         assert pr.cancel_process.called
#
#     @mock.patch("cs.workflow.taskgroups.TaskGroup.has_finish_option", return_value=False)
#     def test_propagate_done_closed(self, has_finish_option):
#         """ If the next Task is closed the the next one is activated"""
#         import mock
#         task = mock.Mock(spec=Task)
#         task.Next.return_value = task
#         next_task = task.Next
#
#         next_task.activate_task.side_effect = exceptions.TaskClosedException
#         next_task.Next.return_value = task
#
#         pr = Process()
#         pr.propagate_done(task)
#
#         assert next_task.Next.activate_task.called
#
#
# class TestMakeAttachmentsBriefcase(testcase.PlatformTestCase):
#     import mock
#
#     """ Test the method make_attachments_briefcase """
#
#     @mock.patch("cs.workflow.processes.Process.AttachmentsBriefcase")
#     @mock.patch("cs.workflow.processes.briefcases.Briefcase")
#     @mock.patch("cs.workflow.processes.briefcases.BriefcaseLink")
#     def test_without_attachments(self, BriefcaseLink, Briefcase, AttachmentsBriefcase):
#         """ If it doesn't exits, the attachment briefcase is created """
#         import mock
#         AttachmentsBriefcase.return_value = []
#
#         pr = Process()
#         pr.cdb_process_id = mock.sentinel.cdb_process_id
#         pr.make_attachments_briefcase()
#
#         Briefcase.Create.called_once_with(
#             cdb_process_id=mock.sentinel.cdb_process_id,
#             briefcase_id=0,
#             name="Attachments")
#         BriefcaseLink.Create.called_once_with(
#             cdb_process_id=mock.sentinel.cdb_process_id,
#             task_id='',
#             briefcase_id=0,
#             iotype=briefcases.IOType.info.value,  # @UndefinedVariable
#             extends_rights=0)
#
#     @mock.patch("cs.workflow.processes.Process.AttachmentsBriefcase")
#     @mock.patch("cs.workflow.processes.briefcases.Briefcase")
#     @mock.patch("cs.workflow.processes.briefcases.BriefcaseLink")
#     def test_with_attachments(self, BriefcaseLink, Briefcase, AttachmentsBriefcase):
#         """ If it does exits, the attachment briefcase isn't created """
#         import mock
#         AttachmentsBriefcase.return_value = [mock.Mock(spec=briefcases.Briefcase)]
#
#         pr = Process()
#         pr.make_attachments_briefcase()
#
#         assert not Briefcase.Create.called
#         assert not BriefcaseLink.Create.called
#
#
# def _check_access(rights):
#     def func(acs_right, *args, **kwargs):
#         return acs_right in rights
#     return func
#
#
# def _mock_access(rights):
#     import mock
#     return mock.Mock(CheckAccess=mock.Mock(side_effect=_check_access(rights)))
#
#
# class TestStartWithRights(testcase.PlatformTestCase):
#     import mock
#
#     """ Test the method check_briefcase_rights """
#
#     @mock.patch.object(Task, "getContent")
#     @mock.patch.object(Task, "Process")
#     def test_check_briefcase_rights(self, Process, getContent):
#         """ When a task is activated, the access rights on its content are checked """
#
#         def side_effect(mode, *args, **kwargs):
#             if mode == "info":
#                 return [_mock_access(["read", "read_file"])]
#             elif mode == "edit":
#                 return [_mock_access(["save", "write_file", "accept"])]
#             else:
#                 return [_mock_access([])]
#
#         getContent.side_effect = side_effect
#
#         Process.subject_id = auth.persno
#         task = Task()
#
#         has_briefcase_rights = task.check_briefcase_rights()
#
#         assert has_briefcase_rights


if __name__ == "__main__":
    unittest.main()
