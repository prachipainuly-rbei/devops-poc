# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com

__revision__ = "$Id: __init__.py 183859 2018-09-14 06:22:48Z cso $"
__docformat__ = "restructuredtext en"

import os
import sys
from cdb import ElementsError
from cdb import rte
from cdb import sig
from cdb import util
from cdb.lru_cache import lru_cache
from cdb.objects.org import User
from cs.platform.web import static
from cs.taskmanager import settings
from cs.taskmanager.mixin import WithTasksIntegration
from cs.workflow.forms import Form

FILE = __file__.decode(sys.getfilesystemencoding())
PLUGIN = "cs-tasks-workflow-plugin"
VERSION = "15.1.0"
APPDIR = os.path.dirname(FILE)


@lru_cache(maxsize=1, clear_after_ue=False)
def get_wf_task_proceed_attributes():
    return {
        "comment": {
            "mandatory": True,
            "label": util.get_label("cdbwf_comment"),
        }
    }


class WorkflowTaskWithCsTasks(WithTasksIntegration):
    __hidden_statuses__ = set([35])  # Task.CANCELLED
    __proceed_map__ = {
        20: "close_task",
        30: "refuse_task",
        35: "cancel_task",
    }
    __icon__ = "/resources/icons/byname/cdbwf_status?status={}"

    def getCsTasksContexts(self):
        return [self.Process, self.Project]

    def csTasksDelegate_get_default(self):
        subj_id = self.Process.started_by
        if subj_id:
            user = User.ByKeys(subj_id)
            if user:
                return (subj_id, "Person", user.name)

        return ("", "", "")

    def _filterBriefcaseContents(self, content_object):
        return (
            not isinstance(content_object, Form) and
            content_object.CheckAccess("read"))

    def _resolveBriefcase(self, briefcase, mode):
        if briefcase.CheckAccess("read"):
            return {
                "relshipName": "CsTasks{}Briefcases".format(mode.capitalize()),
                "mappedName": briefcase.GetDescription(),
                "mode": mode,
                "references": [
                    c for c in briefcase.Content
                    if self._filterBriefcaseContents(c)]
            }

    def _getAllBriefcases(self, mode, task=None):
        task = task or self

        result = []
        if not (task.CheckAccess("read")
                and hasattr(task, "getBriefcases")):
            return result

        seen = {}
        for obj in [task.Process, task]:  # global and local briefcases
            for b in obj.getBriefcases(mode):
                if b.cdb_object_id not in seen.keys():
                    b_result = self._resolveBriefcase(b, mode)
                    if b_result:
                        result.append(b_result)
                    seen[b.cdb_object_id] = None

        return result

    @property
    def CsTasksInfoBriefcases(self):
        return self._getAllBriefcases("info")

    @property
    def CsTasksEditBriefcases(self):
        return self._getAllBriefcases("edit")

    def _resolveForm(self, form, mode):
        return {
            "relshipName": "CsTasks{}Forms".format(mode.capitalize()),
            "mappedName": form.GetDescription(),
            "mode": mode,
            "form_object_id": form.cdb_object_id,
            "references": [form],
        }

    def _resolveForms(self, mode, task=None):
        task = task or self

        if not task.CheckAccess("read"):
            return []

        forms = "{}Forms".format(mode.capitalize())
        return set(f.cdb_object_id for f in getattr(self, forms, []))

    @property
    def CsTasksInfoForms(self):
        """
        return only unique info forms that are not also edit forms
        """
        mode = "info"
        edit_oids = self._resolveForms("edit")
        oids = self._resolveForms(mode).difference(edit_oids)
        return [self._resolveForm(f, mode)
                for f in Form.KeywordQuery(cdb_object_id=oids)]

    @property
    def CsTasksEditForms(self):
        """
        return only unique edit forms
        """
        mode = "edit"
        oids = self._resolveForms(mode)
        return [self._resolveForm(f, mode)
                for f in Form.KeywordQuery(cdb_object_id=oids)]

    def _csTasksProceedNow(self, proceed_to, **kwargs):
        comment = kwargs.get("comment", "")
        try:
            getattr(self, self.__proceed_map__[proceed_to["status"]])(
                comment=comment)
        except (RuntimeError, ElementsError), error:
            return {"error": error.message}

    def getProceedAttributes(self, status):
        if status in [self.COMPLETED.status,
                      self.REJECTED.status] and self.requiresComment():
            return get_wf_task_proceed_attributes()
        return {}

    def getCsTasksStatusData(self, status=None, request=None):
        result = super(WorkflowTaskWithCsTasks, self).getCsTasksStatusData(
            status, request)
        result["data"].update({
            "icon_url": self.__icon__.format(result["data"]["status"]),
        })
        return result

    def getCsTasksProceedData(self, request=None, targets=False):
        extension = self.getExtensionObject()

        if extension and hasattr(extension, "getCsTasksProceedData"):
            # cs.dsig provides an example extension
            result = extension.getCsTasksProceedData(
                request=request,
                targets=targets
            )
        else:
            result = super(
                WorkflowTaskWithCsTasks,
                self
            ).getCsTasksProceedData(
                request=request,
                targets=targets
            )

            # status_objects are required to be dicts with key "data"
            # containing another dict
            def get_numerical_status(status_object):
                return status_object["data"].get("status", None)

            result["targets"] = [
                t for t in result["targets"]
                if get_numerical_status(t) not in self.__hidden_statuses__
            ]

        return result

    def getPluginDiscriminator(self, std_name):
        """
        Returns the name of the discriminator that should be used to find
        plugins. `std_name` is the name that is used by the standard if this
        function returns ``None`` or if no specific plugin is configured.
        """
        extension = getattr(self, "getExtensionObject", lambda: None)()
        if extension:
            return extension.getPluginDiscriminator(std_name)
        return None


class WorkflowInfoMessageWithCsTasks(WorkflowTaskWithCsTasks):
    __inactive__ = 999
    __status_cache__ = None
    __icon__ = "/resources/icons/byname/cdbwf_info_message_obj?is_active={}"

    def getCsTasksContexts(self):
        return [self.Process, self.Project]

    @property
    def CsTasksInfoBriefcases(self):
        return self._getAllBriefcases("info", task=self.Task)

    @property
    def CsTasksEditBriefcases(self):
        return self._getAllBriefcases("edit", task=self.Task)

    @classmethod
    def getStatusCache(cls):
        if not cls.__status_cache__:
            cls.__status_cache__ = {
                0: {
                    "data": {
                        "status": 0,
                        "label": util.get_label("cdbwf_info_message_unread"),
                        "color": "",
                        "icon_url": cls.__icon__.format(1),
                        "attributes": {},
                    },
                },
                999: {
                    "data": {
                        "status": 999,
                        "label": util.get_label("cdbwf_info_message_read"),
                        "color": "#00FF00",
                        "icon_url": cls.__icon__.format(0),
                        "attributes": {},
                    }
                },
            }
        return cls.__status_cache__

    def getProceedAttributes(self, status):
        return {}

    def getCsTasksStatusData(self, status=None, request=None):
        if status != self.__inactive__:
            status = 0
        return self.getStatusCache()[status]

    def _csTasksProceedNow(self, proceed_to, **kwargs):
        if proceed_to["status"] == self.__inactive__:
            self.Update(is_active=0)

    def getCsTasksProceedData(self, request=None, targets=False):
        return {
            "current": self.getCsTasksStatusData(0, request=request),
            "targets": [] if not targets else [
                self.getCsTasksStatusData(self.__inactive__, request=request)]
        }


@sig.connect(settings.REGISTER_TABLE_SETTINGS)
def register_table_settings(register_file):
    register_file(os.path.join(APPDIR, "table_settings.json"))


@sig.connect(rte.APPLICATIONS_LOADED_HOOK)
def _register_libraries():
    lib = static.Library(
        PLUGIN,
        VERSION,
        os.path.join(APPDIR, 'js', 'build'))
    lib.add_file("{}.js".format(PLUGIN))
    lib.add_file("{}.js.map".format(PLUGIN))
    static.Registry().add(lib)
