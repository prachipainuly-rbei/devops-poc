#!/usr/bin/env powerscript
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

"""
Module SchemaComponents

This is the documentation for the SchemaComponents module.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: schemacomponents.py 184830 2018-10-09 06:35:09Z cso $"

from cdb import util
from cdb import i18n
from cdb.objects import Forward
from cdb.objects import NULL
from cdb.objects import Object
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import ReferenceMethods_1
from cdb.objects import ReferenceMethods_N

from cs.workflow.misc import create_user_posting
from cs.workflow.misc import get_state_text
from cs.workflow.protocols import MSGCANCEL, MSGSYSTEM

__all__ = ['SchemaComponent']

fSchemaComponent = Forward(__name__ + ".SchemaComponent")

fConstraint = Forward("cs.workflow.constraints.Constraint")
fProcess = Forward("cs.workflow.processes.Process")


class SchemaComponent(Object):

    __maps_to__ = "cdbwf_task"

    def _get_PreviousSibling(self):
        if self.Parent:
            if self.Parent.is_sequential():
                objects = self.Parent.Components.Query(SchemaComponent.position < self.position,
                                                       order_by=(-SchemaComponent.position))
                if objects:
                    return objects[0]
    PreviousSibling = ReferenceMethods_1(Object, _get_PreviousSibling)

    # Only used for constraints (cdb_pyterm.attribute):
    PreviousOfParent = ReferenceMethods_N(fSchemaComponent,
                                          lambda self: [getattr(self.Parent, "Previous", None)])

    def _get_PreviousTask(self):
        """ Return the task or task group in the workflow,
            which comes immediately before the current task or task group
            (i.e. the component that triggers activation of the current object),
            if any.
        """
        if self.PreviousSibling:
            return self.PreviousSibling
        elif self.Parent:
            return getattr(self.Parent, "Previous", None)
    Previous = ReferenceMethods_1(Object, _get_PreviousTask)

    def _get_PreviousTasks(self):
        previous = self.Previous
        if previous:
            return previous.get_last_tasks()
        else:
            return []
    PreviousTasks = ReferenceMethods_N(Object, _get_PreviousTasks)

    # Only used for constraints (cdb_pyterm.attribute):
    PreviousN = ReferenceMethods_N(fSchemaComponent,
                                   lambda self: [getattr(self, "Previous", None)])

    def _get_NextSibling(self):
        if self.Parent:
            if self.Parent.is_sequential():
                objects = self.Parent.Components.Query(SchemaComponent.position > self.position,
                                                       order_by=SchemaComponent.position)
                if objects:
                    return objects[0]
    NextSibling = ReferenceMethods_1(Object, lambda self: self._get_NextSibling())

    def _get_NextTask(self):
        """ Return the task or task group in the workflow,
            which comes immediately after the current task or task group
            (i.e. the component whose activation is triggered by the current object),
            if any.
        """
        if self.NextSibling:
            return self.NextSibling
        elif self.Parent:
            return getattr(self.Parent, "Next", None)
    Next = ReferenceMethods_1(Object, _get_NextTask)

    # Only used for constraints (cdb_pyterm.attribute):
    NextN = ReferenceMethods_N(fSchemaComponent,
                                   lambda self: [getattr(self, "Next", None)])

    def _get_Parent(self):
        if self.parent_id not in ["", None, NULL]:
            return SchemaComponent.ByKeys(self.parent_id, self.cdb_process_id)
        from cs.workflow.processes import Process
        return Process.ByKeys(self.cdb_process_id)
    Parent = ReferenceMethods_1(Object, lambda self: self._get_Parent())

    def _get_ancestors(self):
        result = []
        if isinstance(self.Parent, SchemaComponent):
            result += self.Parent._get_ancestors()
        result.append(self.Parent)
        return result
    Ancestors = ReferenceMethods_N(fSchemaComponent, _get_ancestors)

    Process = Reference_1(fProcess, fProcess.cdb_process_id)

    # Empty reference to content
    # We need to use this in the object rules, but there is no way
    # to define an object rule for cs.workflow.tasks.Task.
    # Therefore we need this reference already in the base class.
    Content = ReferenceMethods_N(Object, lambda x: [])

    Constraints = Reference_N(fConstraint,
                              fConstraint.cdb_process_id == fSchemaComponent.cdb_process_id,
                              fConstraint.task_id == fSchemaComponent.task_id)

    # event map

    event_map = {
        ("create", "pre"): "setObjectLifeCycle"
    }

    def addProtocol(self, msg, msgtype=MSGSYSTEM):
        if self.Process.status != self.Process.NEW.status:
            self.Process.addProtocol(msg, msgtype, self.task_id)

    def addASComment(self, comment):
        if self.Process.status != self.Process.NEW.status:
            create_user_posting(self, comment)

    def setObjectLifeCycle(self, ctx):
        if not self.cdb_objektart:
            self.cdb_objektart = self.getObjectLifeCycle()

    @classmethod
    def getObjectLifeCycle(cls):
        return getattr(cls, "__obj_class__", "")

    @classmethod
    def GetStateText(cls, state, lang=None):
        if lang is None:
            lang = i18n.default()
        return get_state_text(cls.getObjectLifeCycle(), state.status, lang)

    def AbsolutePath(self):
        obj = self
        lpos = []
        while obj and 'position' in obj.keys():
            lpos.insert(0, "%g" % (obj.position if obj.position else -1))
            obj = obj.Parent
        return "/".join(lpos)

    def make_position(self, ctx):
        position = 10

        if self.Parent:
            max_pos = max(self.Parent.Components.position + [0])
            position = max_pos + 10
        self.position = position

    def check_position(self, ctx):
        if ctx.action == "modify":
            try:
                if "position" in ctx.dialog.get_attribute_names():
                    if float(ctx.dialog.position) == float(ctx.object.position):
                        return
            except ValueError:
                pass

        if SchemaComponent.KeywordQuery(cdb_process_id=self.cdb_process_id,
                                        parent_id=self.parent_id,
                                        position=self.position):
            raise util.ErrorMessage("cdbwf_err110")

        if self.Parent and not self.Parent.is_position_editable(self.position):
            raise util.ErrorMessage("cdbwf_err108", "%d" % (self.position))

    def is_position_editable(self, position):
        """Check if the addition of a new task in the given position is allowed."""

        return NotImplementedError("To be implemented by the subclasses")

    def check_constraints(self, interactive=False):
        """If 'interactive' is set to True, then an error message is displayed via UE exception, if
        any constraint is violated. If 'interactive' is set to False, then a protocol entry is made
        with the error message and the process component is reset to NEW, if any constraint is
        violated.

        :param interactive: True or False
        :type interactive: Bool

        :returns: Bool -- If 'interactive' is set to False

        :raises: ue.Exception -- If 'interactive' is set to True

        """
        for constraint in self.Constraints:
            if interactive:
                constraint.check_violation(self)
            else:
                if constraint.is_violated(self):
                    self.addProtocol(constraint.get_message_constraint_violated(self),
                                     MSGCANCEL)
                    # TODO: notify process owner via mail?
                    return False
        return True

    def allow_new_task(self, ctx):
        from cs.workflow.tasks import Task
        if self.Parent.status > Task.EXECUTION.status:
            raise util.ErrorMessage("cdbwf_err111")
