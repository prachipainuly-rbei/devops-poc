#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

"""
Module constraints

This is the documentation for the constraints module.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: constraints.py 109093 2014-04-23 12:47:48Z gda $"

from cdb import ue, util
from cdb.objects import Forward, Object, Reference_1

from cs.workflow.protocols import MSGCANCEL

__all__ = ['Constraint']

fConstraint = Forward(__name__ + ".Constraint")

fBriefcase = Forward("cs.workflow.briefcases.Briefcase")

fRule = Forward("cdb.objects.Rule")


class Constraint(Object):

    __maps_to__ = "cdbwf_constraint"
    __classname__ = "cdbwf_constraint"

    Briefcase = Reference_1(fBriefcase,
                            fBriefcase.cdb_process_id == fConstraint.cdb_process_id,
                            fBriefcase.briefcase_id == fConstraint.briefcase_id)

    Rule = Reference_1(fRule, fRule.name == fConstraint.rule_name)

    def get_message_constraint_violated(self, parent):
        """If the constraint is directly linked to a briefcase of the parent, then the violation is
        always because of the briefcase content. Thus the briefcase is mentioned in the error
        message instead of the process or process component.

        :param parent: Process or process component
        :type parent: Object

        :returns: str -- "Constraint violated (object='%s', rule='%s')"

        """
        if self.Briefcase:
            parent = self.Briefcase
        return util.get_label("cdbwf_constraint_violated") % \
            (parent.GetDescription(), self.Rule.GetDescription())

    def is_violated(self, parent):
        """If the constraint is directly linked to a briefcase of the parent, then it is only
        checked on the briefcase, else it is only checked on the process or process component
        itself.

        :param parent: Process or process component
        :type parent: Object

        :returns: Bool

        """
        if self.Briefcase:
            obj = self.Briefcase
        else:
            obj = parent
        if not self.invert_rule:
            return not self.Rule.match(obj)
        else:
            return self.Rule.match(obj)

    def check_violation(self, parent):
        """Displays an error message and adds it to the protocol, if the constraint is violated.

        :param parent: Process or process component
        :type parent: Object

        :returns: None

        :raises: ue.Exception

        """
        if self.is_violated(parent):
            err_msg = self.get_message_constraint_violated(parent)
            parent.addProtocol(err_msg, MSGCANCEL)
            raise ue.Exception(1024, err_msg)


if __name__ == "__main__":

    # test: validate process and task constraints (only print results)
    #       - either of all processes if no argument is given
    #       - or of a specific process if cdb_process_id is given as argument
    # TODO: maybe outsource to a special (customer-friendly) gherkin test later on
    import sys
    from cs.workflow.processes import Process
    if len(sys.argv) > 1:
        # use of decode is intentional, do not modify
        process_id = sys.argv[1].decode("utf8")
        procs = [Process.ByKeys(process_id)]
    else:
        procs = Process.Query()
    for proc in procs:
        print 'Process:', proc.title
        for constraint in proc.Constraints:
            print '  Constraint:', constraint.rule_name,
            print '[INVERTED!]' if (constraint.invert_rule == 1) else '',
            print '...', 'VIOLATED!' if constraint.is_violated(proc) else 'ok'
        for comp in proc.AllComponents:
            print '    Component:', comp.title
            for constraint in comp.Constraints:
                print '      Constraint:', constraint.rule_name,
                print '[INVERTED!]' if (constraint.invert_rule == 1) else '',
                print '...', 'VIOLATED!' if constraint.is_violated(comp) else 'ok'
