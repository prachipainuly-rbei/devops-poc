#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""
Module systemtasks

This is the documentation for the systemtasks module.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: systemtasks.py 176417 2018-04-23 15:02:20Z cso $"

import cdbwrapc
import os
from collections import defaultdict
from collections import namedtuple

from cdb import util
from cdb import constants
from cdb import CADDOK
from cdb import ElementsError

from cdb.lru_cache import lru_cache
from cdb.misc import log_traceback
from cdb.objects import ByID
from cdb.objects import common
from cdb.objects import Object
from cdb.objects import Forward
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import ReferenceMethods_1
from cdb.objects import LocalizedField
from cdb.objects import org
from cdb.objects import operations
from cdb.platform import gui
from cdb.platform.mom.operations import OperationConfig
from cs.sharing.share_objects import WithSharing
from cs.workflow import misc
from cs.workflow import protocols
from cs.workflow.briefcases import FolderContent
from cs.workflow.forms import Form
from cs.workflow.tasks_plugin import WorkflowInfoMessageWithCsTasks


acs = None


def deferred_import_acs():
    # import only when needed so cdb.acs does not need to be distributed to
    # high-security environments
    from cdb import acs


__all__ = ['STATUS_CHANGE_UNLOCK',
           'abort_process',
           'CloseTaskAsynchronously',
           'convert_files',
           'copy_objects',
           'create_new_index',
           'generate_info_message',
           'InfoMessage',
           'ParameterDefinition',
           'ProcessAbortedException',
           'status_change',
           'SystemTaskDefinition',
           'TaskCancelledException',
           'TaskRefusedException']

STATUS_CHANGE_UNLOCK = "cs.workflow.status_change_unlock"

fParameterDefinition = Forward(__name__ + ".ParameterDefinition")
fSystemTaskDefinition = Forward(__name__ + ".SystemTaskDefinition")

fProcess = Forward("cs.workflow.processes.Process")
fTask = Forward("cs.workflow.tasks.Task")
fInfoMessage = Forward(__name__ + ".InfoMessage")
fCDB_File = Forward("cdb.objects.cdb_file.CDB_File")


# ===============================================================================
# Object Framework classes
# ===============================================================================

class SystemTaskDefinition(Object):
    __maps_to__ = "cdbwf_system_task_definition"
    __classname__ = "cdbwf_system_task_definition"

    Parameters = Reference_N(fParameterDefinition,
                             fParameterDefinition.task_definition_id ==
                             fSystemTaskDefinition.cdb_object_id)

    Images = Reference_N(fCDB_File,
                         fCDB_File.cdbf_object_id == fSystemTaskDefinition.cdb_object_id)

    def _getImage(self):
        if self.Images:
            return self.Images[0]
        else:
            return None

    Image = ReferenceMethods_1(fCDB_File, _getImage)

    Name = LocalizedField("name")


class ParameterDefinition(Object):
    __maps_to__ = "cdbwf_parameter_definition"
    __classname__ = "cdbwf_parameter_definition"

    SystemTaskDefinition = Reference_1(fSystemTaskDefinition, fParameterDefinition.task_definition_id)


# ===============================================================================
# Exceptions used for communication with the wfqueue service
# ===============================================================================

class TaskCancelledException(Exception):
    """
    Exception raised by custom methods to cancel the current task
    """
    pass


class TaskRefusedException(Exception):
    """
    Exception raised by custom methods to refuse the current task
    """
    pass


class ProcessAbortedException(Exception):
    """
    Exception raised by custom methods to abort the current process
    """
    pass


class CloseTaskAsynchronously(Exception):
    """
    Exception raised by methods, which need to close the workflow task
    asynchronously (such as convert tasks)
    """
    pass


# ===============================================================================
# System tasks implementations
# ===============================================================================

@lru_cache(maxsize=10, clear_after_ue=True)
def get_status_change_unlock_param(classname):
    allowed = set([cdbwrapc.kNoUnlock,
                   cdbwrapc.kUnlockIfLockOwner,
                   cdbwrapc.kUnlockIfGranted])

    try:
        configured_value = util.PersSettings().getValue(
            STATUS_CHANGE_UNLOCK, classname)
    except KeyError:
        return None

    # raises TypeError or ValueError if value is not an integer!
    if int(configured_value) in allowed:
        return int(configured_value)


def status_change(task, content, target_state):
    """ Changes the state of all objects into target_state.
    """
    cancel_task = False
    if isinstance(target_state, list):
        task.addProtocol(
            "Ignoring additional status values: {}".format(target_state[1:]),
            msgtype=protocols.MSGSYSTEM)
        target_state = int(target_state[0])
    else:
        target_state = int(target_state)

    for obj in set(content["info"] + content["edit"]):
        unlock = get_status_change_unlock_param(obj.GetClassname())
        try:
            if unlock is None:
                obj.ChangeState(target_state)
            else:
                obj.ChangeState(target_state, unlock=unlock)
        except RuntimeError, err:
            msg = "Error when changing status of object '%s': %s" % \
                (obj.GetDescription(), unicode(err))
            task.addProtocol(msg, msgtype=protocols.MSGINFO)
            cancel_task = True

    if cancel_task:
        raise TaskCancelledException("Error when changing the status "
                                     "of some objects")


def copy_objects(task, content):
    """Copy all objects in content["info"] and put them in the "edit" briefcase"""

    # This task requires exactly one out briefcase
    if len(task.EditBriefcases) != 1:
        msg = util.get_label("cdbwf_only_one_out_briefcase") % task.GetDescription()
        raise TaskCancelledException(msg)
    briefcase = task.EditBriefcases[0]

    for obj in content["info"]:
        copyobj = operations.operation(
            constants.kOperationCopy,  # @UndefinedVariable
            obj)

        # unlock new object
        try:
            cd = obj.GetClassDef()
            if constants.kOperationUnlock in [oi.get_opname() for oi in cd.getOperationInfos()]:
                operations.operation(constants.kOperationUnlock, copyobj)  # @UndefinedVariable
        except RuntimeError:
            task.addProtocol("cannot unlock object %s" % obj.GetDescription(),
                             msgtype=protocols.MSGINFO)

        operations.operation(constants.kOperationNew,  # @UndefinedVariable
                             FolderContent,
                             cdb_folder_id=briefcase.cdb_object_id,
                             cdb_content_id=copyobj.cdb_object_id)


def create_new_index(task, content):
    """ Create a new index of all objects in content["info"] and puts
        the new indexes in the "edit" briefcase
    """

    # This task requires exactly one out briefcase
    if len(task.EditBriefcases) != 1:
        msg = util.get_label("cdbwf_only_one_out_briefcase") % task.GetDescription()
        raise TaskCancelledException(msg)
    briefcase = task.EditBriefcases[0]

    for obj in content["info"]:
        newindex = operations.operation(
            constants.kOperationIndex,  # @UndefinedVariable
            obj)

        operations.operation(constants.kOperationNew,  # @UndefinedVariable
                             FolderContent,
                             cdb_folder_id=briefcase.cdb_object_id,
                             cdb_content_id=newindex.cdb_object_id)


def abort_process(task, content):
    msg = util.get_label("cdbwf_process_aborted_by") % task.GetDescription()
    raise ProcessAbortedException(msg)


# Information task

class InfoMessage(org.WithSubject, common.WithEmailNotification, WithSharing, WorkflowInfoMessageWithCsTasks):
    __maps_to__ = "cdbwf_info_message"
    __classname__ = "cdbwf_info_message"

    _EMAIL_TEMPLATE = "cdbwf_info_message.html"
    __notification_template_folder__ = os.path.join(
        os.path.dirname(__file__), "chrome")

    Process = Reference_1(fProcess, fInfoMessage.cdb_process_id)
    Task = Reference_1(fTask,
                       fInfoMessage.cdb_process_id == fTask.cdb_process_id,
                       fInfoMessage.task_id == fTask.task_id)

    def sendNotification(self, ctx=None):
        if misc.notification_enabled():
            self.Super(InfoMessage).sendNotification(ctx)

    def getNotificationTitle(self, ctx):
        title = self.Process.title if self.Process else ''
        l = gui.Label.ByKeys("cdbwf_info_message_email_title")
        return "%s/%s: %s" % (l.Text["de"], l.Text["en"], title)

    def getNotificationTemplateName(self, ctx):
        return self._EMAIL_TEMPLATE

    def isNotificationReceiver(self, pers, ctx):
        return all([
            # TODO wait for public API (E043114)
            pers.active_account == "1",
            pers.email_notification_task(),
        ])

    def getNotificationReceiver(self, ctx):
        tolist = []
        subject = self.Subject

        if isinstance(subject, org.AbstractRole):
            persons = subject.Persons
        else:
            persons = [subject]

        for person in persons:
            if self.isNotificationReceiver(person, ctx):
                tolist.append((person.e_mail, person.name))
        return [{"to": tolist}]

    # customisable
    def setNotificationContext(self, sc, ctx=None):
        sc.task_manager_url = misc.get_taskmanager_url(self)

        if self.Task:
            briefcases = self.Task.Briefcases + self.Task.Process.Briefcases
            for briefcase in briefcases:
                if len(briefcase.Content) > 0:
                    # don't show the briefcase group at all in the notification
                    # when there's no content anyway
                    sc.briefcases = briefcases
                    break

    event_map = {('create', 'post'): 'sendNotification'}


def generate_info_message(task, content, **args):
    # args contains already the attributes
    # cdb_project_id, subject_id, subject_type

    # FIXME: Move PCS roles to cs.pcs

    subject_type = args["subject_type"]
    subject_id = args["subject_id"]

    if subject_type == "Common Role" or subject_type == "PCS Role":
        # fetch the role object
        if subject_type == "Common Role":
            from cdb.objects.org import CommonRole
            role = CommonRole.ByKeys(role_id=subject_id)
        else:
            from cs.pcs.projects import Role  # FIXME: Nach pcs verschieben
            role = Role.ByKeys(cdb_project_id=task.cdb_project_id,
                               role_id=subject_id)

        # generate one object for every owner
        if role:
            for owner in role.Owners:
                owner_args = dict(args, **{"subject_id": owner.personalnummer,
                                           "subject_type": "Person"})
                generate_info_message(task, content, **owner_args)
    elif subject_type == "Person":
        kwargs = {"is_active": 1,
                  "cdb_process_id": task.cdb_process_id,
                  "cdb_project_id": task.cdb_project_id,
                  "task_id": task.task_id,
                  "title": task.title,
                  "description": task.description}
        kwargs.update(args)

        message = InfoMessage.Create(**kwargs)
        if kwargs["is_active"] == 1:
            message.sendNotification()

# Run Operation task
OPERATION_CONFIG = namedtuple("operation_config",
                              ["meta", "cdef_classnames", "obj_classnames"])
INDEXED_CONTENT = namedtuple("indexed_content",
                             ["keys", "object_list_by_classname"])


def get_form_data(content):
    """
    Read values additively from all Form objects in info, then edit content
    (overwriting any duplicate keys).

    Returns tuple (target, target_name, values) for read values. See
    ``get_operation_context`` for further information on return value.
    """
    values = {}

    def _update_values(objs):
        for obj in objs:
            if isinstance(obj, Form):
                values.update(obj.read_data())

    _update_values(content["info"])
    _update_values(content["edit"])

    return values


def get_operation_config(operation_name):
    """
    Returns a three-tuple ``(meta, cdef_classnames, obj_classnames)``:

    :guilabel:`meta`
        Bool. If ``True``, at least one operation configuration with
        applicability ``Meta`` exists for given ``operation_name``.

    :guilabel:`cdef_classnames`
        Set of classnames with applicability ``Class`` for given
        ``operation_name``. The classname ``cdbwf_form`` is never included.

    :guilabel:`obj_classnames`
        Set of classnames with applicability other than ``Meta`` and ``Class``
        for given ``operation_name``. The classname ``cdbwf_form`` is never
        included.
    """
    meta = False
    cdef_classnames = set()
    obj_classnames = set()

    for conf in OperationConfig.KeywordQuery(name=operation_name):
        applicability = conf.applicability

        if applicability == constants.kOpApplicabilityMeta:
            meta = True

        elif applicability == constants.kOpApplicabilityClassDef:
            cdef_classnames.add(conf.classname)

        else:
            obj_classnames.add(conf.classname)

    # ignore "cdbwf_form"
    form_class = set([Form.__classname__])
    cdef_classnames.difference_update(form_class)
    obj_classnames.difference_update(form_class)

    return OPERATION_CONFIG(meta, cdef_classnames, obj_classnames)


def index_content_by_classname(object_list):
    """
    Returns a two-tuple ``keys``, ``object_list_by_classname``:

    :guilabel:`keys`
        Set of all classnames of objects in list ``object_list``.

    :guilabel:`object_list_by_classname`
        Dict containing lists of objects from ``object_list`` indexed by
        classname.
    """
    result = defaultdict(list)

    for obj in object_list:
        result[obj.GetClassname()].append(obj)

    return INDEXED_CONTENT(set(result.keys()), result)


def run_operation(task, content, operation_name):
    """
    :guilabel:`task`
        The workflow task calling this function.

    :guilabel:`content`
        Briefcase contents of task indexed by iotype (``info``, ``edit``).

    :guilabel:`operation_name`
        Name of the operation to run.

    Runs the operation named ``operation_name`` using values additively read
    from all forms attached to this task's briefcases.

    .. warning::
        Make sure forms do not overlap when using multiple forms. They are
        applied in natural order (e.g. no user-controlled order), although
        EditForms are applied after InfoForms, effectively overwriting any
        conflicting values.

    If at least one operation configuration for given ``operation_name`` with
    applicability ``Meta`` exists, the operation is run once without context.

    For each other operation configuration for given ``operation_name``, the
    operation is run:

    - Once for each distinct classname of objects in content["edit"] (except
      for ``cdbwf_form``) if an operation configuation for given
      ``operation_name``, classname and applicability ``Class`` exists.
    - Once for each non-form object in content["edit"] if an operation
      configuation for given ``operation_name``, object's classname and
      applicability other than ``Meta`` and ``Class`` exists.
    """
    op_config = get_operation_config(operation_name)
    form_data = get_form_data(content)
    edit_content = index_content_by_classname(content["edit"])

    def _run_op(target, description):
        task.addProtocol(
            util.get_label("cdbwf_run_operation_now") % (
                operation_name, description, form_data),
            msgtype=protocols.MSGINFO)
        try:
            operations.operation(operation_name, target, **form_data)
        except (ValueError, ElementsError), err:
            log_traceback("Operation failed")
            task.addProtocol(
                util.get_label("cdbwf_run_operation_failed") % unicode(err),
                msgtype=protocols.MSGSYSTEM)
            raise TaskCancelledException("Operation failed")

    if op_config.meta:
        _run_op(None, "Meta")

    for classname in edit_content.keys.intersection(op_config.cdef_classnames):
        for obj in edit_content.object_list_by_classname[classname]:
            _run_op(classname, "Class '{}'".format(classname))

    for classname in edit_content.keys.intersection(op_config.obj_classnames):
        for obj in edit_content.object_list_by_classname[classname]:
            _run_op(obj, obj.GetDescription())


# File conversion task
def ensure_acs_payload_dir():
    deferred_import_acs()
    # 1) an acs payloaddir isn't defined by default but required for parameterized acs jobs
    # 2) both processes (acs and wfqueue) must run on the same machine and have access rights to the
    #    payloaddir
    if not acs.getQueue().payloaddir:
        acs.getQueue().payloaddir = os.path.join(CADDOK.TMPDIR, u'acs_queue_payload')


def convert_files(task, content, file_reference=None, destination_file_types=None):
    """
    Convert files in the content. If, for instance, all primary files of the content's objects
    should be converted, then file_reference must be 'PrimaryFiles'. If files should be converted,
    which are directly contained in the content, then file_reference must be None.
    If destination_file_types is given, then convert to given destination file type(s), else convert
    to all registered conversion file types.
    """
    from cs.workflow import systemtasks
    from cdb.objects.cdb_file import CDB_File
    # TODO: validate in/out-briefcase conditions
    ensure_acs_payload_dir()
    jobs = []
    for obj in content['edit']:
        obj_files = []
        if file_reference in ["", None]:
            if not isinstance(obj, CDB_File):
                continue  # or raise an Exception?
            obj_files = [obj]
        else:
            if not hasattr(obj, file_reference):
                continue  # or raise an Exception?
            obj_files = getattr(obj, file_reference)
        for f in obj_files:
            if not isinstance(destination_file_types, list):
                destination_file_types = [destination_file_types]
            targets = []
            for ft in destination_file_types:
                if ft in ["", None]:
                    # get all registered target file types
                    targets.extend([rc[0] for rc in acs.registered_conversions(f.cdbf_type)])
                else:
                    targets.append(ft)
            targets = list(set(targets))
            for target in targets:
                # callback methods only get called if they are module level
                # methods (class methods can't be callback methods)
                task_keys = {'cdb_process_id': task.cdb_process_id,
                             'task_id': task.task_id}
                job = acs.convertFile(f, target,
                                      callback=(systemtasks,
                                                systemtasks.convert_files_done,
                                                systemtasks.convert_files_failed),
                                      paramDict=task_keys)
                jobs.append(job)
    if len(jobs) > 0:
        msg = util.get_label("cdbwf_n_file_conversions_initiated") % len(jobs)
        raise CloseTaskAsynchronously(msg)
    else:
        task.addProtocol("[No conversions initiated]", protocols.MSGSYSTEM)


def convert_files_done(job):
    """Called by the ACS-Server after a successfull file conversion"""
    ensure_acs_payload_dir()
    task_keys = job.getParameters()
    from cs.workflow.tasks import Task
    task = Task.ByKeys(**task_keys)
    # TODO: -check if all jobs attached to given cdb_process_id/task_id are done, else return
    #       -get all in-objets again
    #       -copy only files with destination_file_type from in-objects to out-objects???
    task.addProtocol("[Task running asynchronously] " +
                     util.get_label("cdbwf_1_file_conversion_successful"),
                     protocols.MSGSYSTEM)
    task.close_task()


def convert_files_failed(job):
    """Called by the ACS-Server after a failed file conversion"""
    ensure_acs_payload_dir()
    task_keys = job.getParameters()
    from cs.workflow.tasks import Task
    task = Task.ByKeys(**task_keys)
    task.addProtocol("[Task running asynchronously] " +
                     util.get_label("cdbwf_1_file_conversion_failed"),
                     protocols.MSGSYSTEM)
    if task.status == Task.EXECUTION.status:
        task.cancel_task()
