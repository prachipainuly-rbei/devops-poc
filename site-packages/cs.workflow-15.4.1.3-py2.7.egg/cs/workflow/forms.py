#!/usr/bin/env powerscript
# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 2017 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""
Workflow Forms

"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: forms.py 170177 2017-12-07 16:36:02Z cso $"

import json

from cdb import sig
from cdb import util
from cdb.classbody import classbody
from cdb.objects import ByID
from cdb.objects import Forward
from cdb.objects import Object
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import ReferenceMethods_1
from cdb.objects import ReferenceMethods_N
from cdb.platform import FolderContent

from cs.workflow.briefcases import Briefcase
from cs.workflow.briefcases import BriefcaseContent

fFormTemplate = Forward("{}.FormTemplate".format(__name__))
fForm = Forward("{}.Form".format(__name__))
fMask = Forward("cdb.platform.gui.Mask")
fProcess = Forward("cs.workflow.processes.Process")
fTask = Forward("cs.workflow.tasks.Task")
fBriefcase = Forward("cs.workflow.briefcases.Briefcase")
fBriefcaseLink = Forward("cs.workflow.briefcases.BriefcaseLink")
fFolderContent = Forward("cdb.platform.FolderContent")

CDB_ARGUMENT = "cdb::argument"


def transform_key(key, include_prefix=False):
    """
    Returns transformed key:

    If include_prefix is True and no prefix is detected in key, prepend it with
    "." for dialog usage.

    If include_prefix is False, drop detected prefixes from key for object
    usage.

    Always keep ``cdb::argument`` prefix.
    """
    try:
        prefix, attr = key.split(".", 1)
        if prefix == CDB_ARGUMENT:
            return key  # return cdb::argument.attr
        else:
            return key if include_prefix else attr
    except ValueError:
        return ".{}".format(key) if include_prefix else key


def transform_data(data, include_prefix=False):
    """
    Returns a dict with transformed keys (values are unchanged). See
    ``tranform_key`` for details.
    """
    return {transform_key(k, include_prefix): v for k, v in data.items()}


# FIXME not tested, as this is to become a public API of the platform (E043077)
def obj2dict(obj):
    """
    Returns a dictionary that contains the object's data as a
    dictionary that is suitable to be returned using JSON.
    """
    from cdbwrapc import CDBObjectHandle
    from cdbwrapc import is_cdb_pq
    from cdb.typeconversion import to_python_rep
    from cs.platform.web.rest.generic.convert import dump
    cdef = obj.GetClassDef()
    data = {}
    for adef in cdef.getAttributeDefs():
        name = adef.getName()
        if adef.is_text():
            if isinstance(obj, CDBObjectHandle):
                data[name] = obj[name]
            else:
                data[name] = obj.GetText(name)
        else:
            sqltype = adef.getSQLType()
            if is_cdb_pq(sqltype):
                if isinstance(obj, CDBObjectHandle):
                    data[name] = obj[name]
                else:
                    # cdb.objects.Object cannot handle pq - we have to provide
                    # both attributes (name and name_pq)
                    for sqlname in adef.getSQLSelectNames():
                        try:
                            data[sqlname] = to_python_rep(adef.getSQLType(),
                                                          obj[sqlname])
                        except KeyError:
                            # If the pq is missing this is no problem at all
                            pass
            else:
                data[name] = to_python_rep(adef.getSQLType(), obj[name])

    return dump(data, cdef)


class FormTemplate(Object):
    __maps_to__ = "cdbwf_form_template"
    __classname__ = "cdbwf_form_template"

    Masks = Reference_N(fMask, fMask.name == fFormTemplate.mask_name)
    Forms = Reference_N(
        fForm, fForm.form_template_id == fFormTemplate.cdb_object_id)


class Form(Object, BriefcaseContent):
    __maps_to__ = "cdbwf_form"
    __classname__ = "cdbwf_form"
    __content_attr__ = "cdbwf_form_contents_txt"

    Template = ReferenceMethods_1(
        fFormTemplate, lambda self: ByID(self.form_template_id))
    Masks = ReferenceMethods_N(fMask, lambda self: self.Template.Masks)
    Process = Reference_1(fProcess, fForm.cdb_process_id)
    Task = Reference_1(fTask, fForm.task_id, fForm.cdb_process_id)

    @property
    def Data(self):
        return self.GetText(self.__content_attr__)

    def read_data(self):
        """
        Returns persisted form data as dict.
        """
        data = self.Data
        if data:
            return json.loads(data)

        return {}

    def write_data(self, json_data):
        """
        Persist given ``json_data``, which must be a JSON-serializable dict.

        Raises a ValueError if json_data is not a dict.
        Raises a TypeError if json_data is not JSON-serializable.
        """
        if isinstance(json_data, dict):
            json_data = transform_data(json_data)
            try:
                json_data = json.dumps(json_data)
            except TypeError:
                raise TypeError("need a JSON-serializable dictionary")
        else:
            raise ValueError("need a dictionary")

        self.SetText(self.__content_attr__, json_data)

    def preset_data(self):
        """
        Presets form data using all non-form objects in the same briefcase.
        Already present data is not overwritten.

        Caller is responsible for checking access, especially if the briefcase
        is an edit briefcase.
        """
        for briefcase in fBriefcase.ByContent(self):
            data = {}

            for content in briefcase.getContent():
                if not isinstance(content, Form):
                    data.update(transform_data(obj2dict(content)))

            data.update({
                k: v for k, v in self.read_data().items() if v != None})

            self.write_data(data)
            return data

        return self.read_data()

    def get_empty_mandatory_fields(self):
        """
        Returns a set of all mandatory field names containing NULL values.
        """
        data = self.read_data()
        mandatory = set()

        for m in self.Masks:
            for a in m.MandatoryAttributes():
                mandatory.add(a.attribut)

        return [a for a in mandatory if data.get(a, None) is None]

    def _get_form_counter(self):
        briefcases = fBriefcase.Query(
            "cdb_process_id='{}' AND name LIKE '{}%%'".format(
                self.cdb_process_id, self.joined_template_name))

        return len(briefcases) + 1

    @classmethod
    def InitializeForm(cls, task, form_template):
        """
        1. Initializes a form using FormTemplate object ``form_template``
        2. Creates a new local briefcase for given Task object ``task`` named
           like the form template
        3. Adds the form to the briefcase's contents
        4. Returns the new form
        """
        keys = {
            "cdb_process_id": task.cdb_process_id,
            "task_id": task.task_id,
            "form_template_id": form_template.cdb_object_id,
        }

        for form in task.AllForms:
            if form.form_template_id == keys["form_template_id"]:
                raise util.ErrorMessage("cdbwf_form_task_exists")

        if cls.ByKeys(**keys):
            raise util.ErrorMessage("cdbwf_form_task_exists")

        form = cls.Create(**keys)

        briefcase = fBriefcase.Create(
            briefcase_id=fBriefcase.new_briefcase_id(),
            cdb_process_id=keys["cdb_process_id"],
            name="{} {}".format(form.joined_template_name,
                                form._get_form_counter()),
        )
        fBriefcaseLink.Create(
            cdb_process_id=keys["cdb_process_id"],
            task_id=keys["task_id"],
            briefcase_id=briefcase.briefcase_id,
            iotype=1,
            extends_rights=0,
        )
        fFolderContent.Create(cdb_folder_id=briefcase.cdb_object_id,
                              cdb_content_id=form.cdb_object_id)
        return form

    def on_cdbwf_submit_form_pre_mask(self, ctx):
        data = self.preset_data()

        for k, v in data.iteritems():
            ctx.set(k, v)

    def on_cdbwf_submit_form_now(self, ctx):
        dialog = {k: ctx.dialog[k] for k in ctx.dialog.get_attribute_names()}
        self.write_data(dialog)


class TaskWithForm(object):
    def _getForms(self, iotype):
        result = [x for x in self.getContent(iotype) if isinstance(x, Form)]
        if self.Process:
            result += [x for x in self.Process.getContent(iotype)
                       if isinstance(x, Form)]
        return result

    AllForms = ReferenceMethods_N(fForm, lambda self: self._getForms("all"))
    InfoForms = ReferenceMethods_N(fForm, lambda self: self._getForms("info"))
    EditForms = ReferenceMethods_N(fForm, lambda self: self._getForms("edit"))

    def preset_data(self):
        for form in self.AllForms:
            form.preset_data()

    def check_form_data(self):
        empty = []
        prefix = "\n- "

        for form in self.EditForms:
            empty_fields = form.get_empty_mandatory_fields()

            if empty_fields:
                empty.append("{}{}: {}".format(
                    prefix,
                    form.joined_template_name,
                    ", ".join(empty_fields)))

        if empty:
            raise util.ErrorMessage(
                "cdbwf_task_mandatory_fields", prefix.join(empty))

    def on_cdbwf_add_task_form_now(self, ctx):
        template_id = getattr(ctx.dialog, "form_template_id", None)
        success = False

        if template_id:
            template = ByID(template_id)
            if template:
                Form.InitializeForm(self, template)
                success = True

        if not success:
            raise util.ErrorMessage("cdbwf_form_template_missing", template_id)


@classbody
class FolderContent(object):
    def fix_form_reference(self):
        "replace references to template process's forms with copies"
        folder_obj = ByID(self.cdb_folder_id)
        content_obj = ByID(self.cdb_content_id)

        if (folder_obj and isinstance(folder_obj, Briefcase)
            and content_obj and isinstance(content_obj, Form)
        ):
            copy = {k: v for k, v in content_obj.items()
                    if k != "cdb_object_id"}
            copy["cdb_process_id"] = folder_obj.cdb_process_id

            for form_copy in Form.KeywordQuery(**copy):
                self.Update(cdb_content_id=form_copy.cdb_object_id)
