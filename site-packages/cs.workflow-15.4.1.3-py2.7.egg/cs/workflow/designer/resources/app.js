(function($, obviel) {
    var templates = cs_workflow_designer_templateUrl;

    var DISTANCE = 30;
    var SELECTION_MARGIN = 15;
    var ENTER_KEYCODE = 13;

    function getCookie(name) {
        var cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    var csrfToken = getCookie("CSRFToken");

    function csrfSafeMethod(method) {
        // these HTTP methods do not require CSRF protection
        return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
    }
    $.ajaxSetup({
        beforeSend: function(xhr, settings) {
            if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
                xhr.setRequestHeader("X-CSRF-Token", csrfToken);
            }
        }
    });


    var getDesignerView = function(el) {
        return el.is('.cs-workflow-designer') ? el.view() : el.closest('.cs-workflow-designer').view();
    };

    var designerAjax = function(view, option) {
            return $.ajax(option).fail(function(jqXHR) {
               if(jqXHR.responseText !== undefined) {
                   getDesignerView(view.el).showErrorMessage(
                           jqXHR.responseText);
                }
            });
     };

    var modifyObject = function(view, url, field, value, revertValue) {
        var result = revertValue;
        designerAjax(view, {
            url: url,
            data: {attribute: field,
                   value: value},
            dataType: 'json',
            type: 'POST',
            async: false,
            success: function(data) {
                if (data[field] !== undefined) {
                    result = data[field];
                }
            }
        });
        return result;
    };

    var startWaiting = function() {
      var waiting = cdb.elink.startWaiting();
      // synchronize rendering(for IE)
      waiting.find('img').height(0).height('auto');
      return waiting;
    };

    var stopWaiting = function() {
      return cdb.elink.stopWaiting();
    };

    var numbersOnly = function (e) {
      var key;
      var keychar;

      if (window.event) {
         key = window.event.keyCode;
      }
      else if (e) {
         key = e.which;
      }
      else {
         return true;
      }
      keychar = String.fromCharCode(key);

      if ((key==null) || (key==0) || (key==8) ||  (key==9) || (key==13) || (key==27) ) {
         return true;
      }
      else if ((("0123456789").indexOf(keychar) > -1)) {
         return true;
      }
      else
         return false;
   };

    $.editable.addInputType('number', {
      element: $.editable.types.text.element,
      plugin: function (settings, original) {
          $('input', this).bind('keypress', function (event) {
            return numbersOnly(event);
          });
      }
    });

    obviel.view({
        iface: 'cs-workflow-designer',
        obvtUrl: templates + 'main.obvt',
        before: function() {
            // bind zooming object as connection between actions and graph
            var graph = this.obj.graph;
            var self = this;
            this.obj.zooming = this.obj.actions.zooming = graph.zooming = {
                  ratio: 1.0,
                  prevRatio: 1.0,
                  viewport: {
                      w: 0,
                      h: 0
                  },
                  scrollPos: {
                      top: 0,
                      left: 0
                  },
                  disabled: false,
                  autoScale: false,
                  scale: function(ratio) {
                      ratio += this.ratio;
                      if (ratio < 0.2) {
                          ratio = 0.2;
                      }
                      this.setZoom(ratio);
                  },
                  disable: function() {
                      this.setZoom(1.0);
                      this.disabled = true;
                  },
                  resetScroll: function() {
                      if (self.viewport && !this.autoScale) {
                          this.scrollPos.left = self.viewport.scrollLeft();
                          this.scrollPos.top = self.viewport.scrollTop();
                          self.viewport.scrollLeft(0);
                          self.viewport.scrollTop(0);
                      }
                  },
                  restoreScroll: function() {
                      if (self.viewport && !this.autoScale) {
                          self.viewport.scrollLeft(this.scrollPos.left);
                          self.viewport.scrollTop(this.scrollPos.top);
                      }
                  },
                  setZoom: function(ratio) {
                      this.prevRatio = this.ratio;
                      this.ratio = ratio;
                      if (this.disabled) {
                          this.disabled = false;
                      }
                  },
                  calcZoom: function(el) {
                      if (!this.autoScale) {
                          return;
                      }
                      var w = el.width(),
                          wr = 1.0,
                          h = el.height(),
                          hr = 1.0;
                      if (w > 0 && h > 0) {
                          wr = this.viewport.w * 1.0 / w;
                          hr = this.viewport.h * 1.0 / h;
                      }
                      this.setZoom(Math.min(wr, hr, 1.0));
                  },
                  undo: function() {
                      this.setZoom(this.prevRatio);
                  },
                  zoomIn: function() {
                      this.scale(0.2);
                      this.autoScale = false;
                      self.viewport.css('overflow', 'auto');
                      $(graph).trigger('zoom');
                  },
                  zoomOut: function() {
                      this.scale(-0.2);
                      this.autoScale = false;
                      self.viewport.css('overflow', 'auto');
                      $(graph).trigger('zoom');
                  },
                  toggleZoomAll: function(initValue) {
                      this.autoScale = initValue === undefined ?
                              !this.autoScale : initValue;
                      if (this.autoScale) {
                          // IE9 takes always the original size of the scaled div
                          // to calculate for scrollbar
                          self.viewport.css('overflow', 'hidden');
                          self.resizeViewport();
                          $(graph).trigger('updateViewport');
                      }
                  }
            };

            $(window).resize(function() {
                self.resizeViewport();
                $(graph).trigger('updateViewport');
            });
        },
        render: function() {
            var self = this;
            // set container height
            self.triggerTitleChanged();
            if (self.obj.modifyUrl) {
                $(this.el).find('.wf-process-title .editable').editable(
                        function(value) {
                            var title = modifyObject(
                                    self,
                                    self.obj.modifyUrl,
                                    'title',
                                    _.unescape(value),
                                    this.revert);
                            if (title !== this.revert) {
                                self.obj.title = title;
                                self.triggerTitleChanged();
                            }
                            return _.unescape(title);
                        },
                        {
                            onblur: 'submit'
                        });
            }
            $(this.el).on('rerenderDesigner', function(event){
                event.stopPropagation();
                cdb.elink.reloadPage();
            });
            this.viewport = $(this.el).find('.wf-viewport');
            this.toolbar = $(this.el).find('.wf-designer-toolbar');
            // initial zooming
            this.resizeViewport();
            this.obj.zooming.toggleZoomAll(this.obj.autoScale);
            var actions = this.toolbar.find('.wf-actions').view();
            actions.checkZoomAll();

            // detail collapse
            $(this.el).find('.wf-details .detail-collapse').collapse({toggle: false});
            this.toolbar.on(
                    'click',
                    '.detail-actions .toggle-details',
                    function(ev) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        self.toolbar.find('.wf-details .detail-collapse').collapse('toggle');
                        $(ev.currentTarget).children('i').toggleClass('disabled');
                    });
            // connect briefcase and tasks for highlighting
            $(this.el).find('.wf-sidebar').on(
                    'click',
                    '.wf-briefcase',
                    function(ev) {
                        var briefcaseId = $(ev.currentTarget).parentView().obj.briefcase_id;
                        self.highlightBriefcases([briefcaseId]);
                        self.highlightTasksWithBriefcaseLink(briefcaseId);
                    });
            this.getGraphElement().on(
                    'click',
                    '.wf-task',
                    function(ev) {
                        var taskEl = $(ev.currentTarget);
                        self.highlightTask(taskEl);
                        var briefcaseLinks = taskEl.parentView().obj.briefcaselinks.links,
                            briefcaseIds = _.pluck(briefcaseLinks, 'briefcase_id');
                        self.highlightBriefcases(briefcaseIds);
                    });
        },
        resizeViewport: function() {
            if (this.viewport === undefined) {
              return;
            }
            var height = $(window).height() - this.viewport.offset().top
                - (this.viewport.outerHeight(/*includeMargin=*/ true)
                - this.viewport.height() - 30);  // 30px for padding-bottom
            this.viewport.height(height);
            this.obj.zooming.viewport.w = this.viewport.width();
            this.obj.zooming.viewport.h = this.viewport.height();
        },
        getGlobalBriefcases: function() {
            return [].concat(this.obj.sidebar.briefcases.globalBriefcases.briefcases);
        },
        getLocalBriefcases: function() {
            return [].concat(this.obj.sidebar.briefcases.localBriefcases.briefcases);
        },
        triggerTitleChanged: function() {
            $(this.el).trigger('processTitleChanged', this.obj.title);
        },
        highlightTasksWithBriefcaseLink: function(briefcaseId) {
            if (briefcaseId !== undefined) {
                $(this.el).find('.wf-task').removeClass('wf-hightlighting');
                $(this.el).find('.wf-task').has('.wf-briefcase-link[data-briefcase-id=' + briefcaseId + ']').addClass('wf-hightlighting');
            }
        },
        highlightBriefcases: function(briefcaseIds) {
            var self = this;
            $(self.el).find('.wf-briefcase').removeClass('wf-hightlighting');
            _.each(briefcaseIds, function(briefcaseId) {
                $(self.el).find('.wf-briefcase[data-briefcase-id=' + briefcaseId + ']').addClass('wf-hightlighting');
            });
        },
        highlightTask: function(taskEl) {
            $(this.el).find('.wf-task').removeClass('wf-hightlighting');
            taskEl.addClass('wf-hightlighting');
        },
        removeTaskBriefcaseLink: function(briefcaseId) {
            if (briefcaseId !== undefined) {
                this.el.find('.wf-briefcase-links').has('.wf-briefcase-link[data-briefcase-id=' + briefcaseId + ']').each(function() {
                    $(this).parentView().removeBriefcaseLink(briefcaseId);
                });
            }
        },
        getGraphElement: function() {
            return this.el.find('.wf-process');
        },
        showErrorMessage: function(msg, msgcls) {
            this.el.find('.wf-error-message').render({
                iface: 'cs-workflow-error-message',
                message: msg,
                msgcls: msgcls ? msgcls : 'alert-error'
            });
        }
    });

    obviel.view({
        iface: 'cs-workflow-designer-no-process',
        obvt: '<div>Sorry, no such process: {processId}</div>'
    });

    obviel.view({
        iface: 'cs-workflow-sidebar',
        obvtUrl: templates + 'sidebar.obvt',
        showActivities: function (event) {
            var target = $(event.target);
            var self = this;
            var sbContainer = this.el.find('.wf-sidebar').first();
            sbContainer.empty();
            $("#ajax_animation_whitebg").clone()
                .removeAttr("id")
                .appendTo(sbContainer)
                .removeClass("hide");
            blogPosting.loadPostingListInto(
                    sbContainer,
                    {'topic_id': self.obj.process_object_id,
                     'cnt': ''},
                    function() {
                        blogPosting.readLabels();
                        blogPosting.checkReplyTitles(sbContainer);
                    });
        },
        showBriefcases: function (event) {
            var target = $(event.target);
            this.el.find('.wf-sidebar').first().render(this.obj.briefcases);
        },
        render: function() {
            var self = this;
            $(this.el).off('refreshLocalBriefcases').on(
                'refreshLocalBriefcases',
                function(ev, data) {
                    ev.stopPropagation();
                    $.extend(
                        self.obj.briefcases,
                        data
                    );
                    self.el.rerender();
                });
        }
    });

    obviel.view({
        iface: 'cs-workflow-briefcases',
        obvtUrl: templates + 'briefcases_sidebar.obvt'
    });

    obviel.view({
        iface: 'cs-workflow-actions',
        obvtUrl: templates + 'actions.obvt',
        render: function() {
            var self = this;
            // zoom in
            $(this.el).on(
                    'click',
                    '.zoom-in',
                    function() {
                        self.obj.zooming.zoomIn();
                        self.checkZoomAll();
            }).on(
                    'click',
                    '.zoom-out',
                    function() {
                        self.obj.zooming.zoomOut();
                        self.checkZoomAll();
            }).on(
                    'click',
                    '.zoom-all',
                    function() {
                        self.obj.zooming.toggleZoomAll();
            });

            $(this.el).on(
                'click',
                '.save-as-template',
                function() {
                    $.ajax({
                        type: 'GET',
                        url: self.obj.saveAsTemplateUrl,
                        async: false,
                        dataType: 'json',
                        success: function(data) {
                            if (data && data.url) {
                                // redirect to new process
                                window.location.href = data.url;
                            }
                        }
                    });
                });

            $(this.el).on(
                    'click',
                    '.start-workflow',
                    function() {
                        $.ajax({
                            type: 'GET',
                            url: self.obj.startUrl,
                            async: false,
                            dataType: 'json',
                            success: function(data) {
                                // either started or not, rerender the whole workflow
                                if (data.message) {
                                    cdb.elink.alertCDBMessage(data.message.replace(/\n/g, '<br/>'));
                                    if (cdb.elink.alertWindow) {
                                        cdb.elink.alertWindow.one('hide', function() {
                                            $(self.el).trigger('rerenderDesigner');
                                        });
                                    }
                                } else {
                                    $(self.el).trigger('rerenderDesigner');
                                }
                            }
                        });
                    });
            $(this.el).on(
                'click',
                '.hold-workflow',
                function() {
                    $.ajax({
                        type: 'GET',
                        url: self.obj.onHoldUrl,
                        async: false,
                        dataType: 'json',
                        success: function(data) {
                            // either started or not, rerender the whole workflow
                            if (data.message) {
                                cdb.elink.alertCDBMessage(data.message.replace(/\n/g, '<br/>'));
                                if (cdb.elink.alertWindow) {
                                    cdb.elink.alertWindow.one('hide', function() {
                                        $(self.el).trigger('rerenderDesigner');
                                    });
                                }
                            } else {
                                $(self.el).trigger('rerenderDesigner');
                            }
                        }
                    });
                });
            $(this.el).on(
                    'click',
                    '.cancel-workflow',
                    function() {
                        self.askConfirmation(self.obj.cancelConfirmText, function () {
                            $.ajax({
                                type: 'GET',
                                url: self.obj.cancelUrl,
                                async: false,
                                dataType: 'json',
                                success: function(data) {
                                    // either canceled or not, rerender the whole workflow
                                    if (data.message) {
                                        cdb.elink.alertCDBMessage(data.message.replace(/\n/g, '<br/>'));
                                        if (cdb.elink.alertWindow) {
                                            cdb.elink.alertWindow.one('hide', function() {
                                                $(self.el).trigger('rerenderDesigner');
                                            });
                                        }
                                    } else {
                                        $(self.el).trigger('rerenderDesigner');
                                    }
                                }
                            });
                        });
                    });

            $(this.el).on(
                    'click',
                    '.dismiss-workflow',
                    function() {
                        self.askConfirmation(self.obj.dismissConfirmText, function () {
                            $.ajax({
                                type: 'GET',
                                url: self.obj.dismissUrl,
                                async: false,
                                dataType: 'json',
                                success: function(data) {
                                    // either canceled or not, rerender the whole workflow
                                    if (data.message) {
                                        cdb.elink.alertCDBMessage(data.message.replace(/\n/g, '<br/>'));
                                        if (cdb.elink.alertWindow) {
                                            cdb.elink.alertWindow.one('hide', function() {
                                                $(self.el).trigger('rerenderDesigner');
                                            });
                                        }
                                    } else {
                                        $(self.el).trigger('rerenderDesigner');
                                    }
                                }
                            });
                        });
                    });

            this.el.on(
                'click',
                '.modify-workflow',
                function() {
                  if (self.obj.modifyOperation) {
                    cdb.elink.openURL(self.obj.modifyOperation.url, '_self');
                    cdb.elink.reloadPage();
                  }
                });
        },
        checkZoomAll: function() {
            var btnSel = '.zoom-all' + (this.obj.zooming.autoScale ?
                    ':not(.active)' : '.active');
            $(this.el).find(btnSel).button('toggle');
        },
        addCompletionTask: function(ev) {
            getDesignerView(this.el).getGraphElement().view().openNewTaskForm({
                iface: 'cs-workflow-new-task',
                where: 'completion',
                selection: []
            });
        },
        selectTask: function(ev) {
          getDesignerView(this.el).showErrorMessage(this.obj.selectTaskTip, 'alert-info');
          getDesignerView(this.el).getGraphElement().view().selectTask();
        },
        askConfirmation: function (text, callback) {
            var self = this;

            cdb.elink.modal({
                pre_mask: function (mask) {
                    mask.find(".modal-header .modal-header-slot i")
                        .removeClass("icon-info-sign")
                        .addClass("icon-warning-sign");

                    mask.find(".modal-header .modal-header-slot")
                        .append(self.obj.cancelConfirmHeader);

                    $("<p>", {"class": "alert"}).text(text).appendTo(mask.find(".modal-body"));

                    mask.find("button.lbl-ok").text(self.obj.cancelOK);
                    mask.find("button.lbl-cancel").text(self.obj.cancelNO);

                    mask.width();
                },
                ok: function(mask) {
                  mask.modal('hide');
                  callback();
                },
                cancel: null
            });
        },
    });

    var nodes = function(container) {
        return container.children('.wf-component');
    };

    var tasks = function(container) {
        return container.find('.wf-task');
    };

    // get normalized position
    var getPosition = function(el, graph) {
        if (! graph) {
            graph = getGraphView(el);
        }
        // graph is available only after initialization
        return graph ? graph.normalizePosition(el.position()) : el.position();
    };

    // this could be optimized as sequential only need to consider
    // the last added item to calculate the width, and parallel only needs
    // the last added item to calculate the height.
    var resize = function(container) {
        var n = nodes(container),
            graph = getGraphView(container);
            var width = _.max(n.map(
                function() {
                    return getPosition($(this), graph).left + $(this).outerWidth();
                }));
            var height = _.max(n.map(
                function() {
                    return getPosition($(this), graph).top + $(this).outerHeight();
                }));
        container.width(width);
        container.height(height);
    };

    var nextLeft = function(last) {
        if (last === null) {
            return 0;
        }
        return getPosition(last).left + last.outerWidth() + DISTANCE;
    };

    var nextTop = function(last) {
        if (last === null) {
            return 0;
        }
        return getPosition(last).top + last.outerHeight() + DISTANCE;
    };

    var alignHorizontal = function(container, children, offset) {
        // use offset to deal with the asymmetrical group dimension
        // (e.g. with parallel start but without end)
        var width = container.outerWidth();
        if (offset == undefined) {
            offset = 0;
        }
        children.each(function() {
            $(this).css({
                left: Math.round((width - $(this).outerWidth()) / 2) + offset});
        });
    };

    var alignVertical = function(container, children) {
        var height = container.outerHeight();
        children.each(function() {
            $(this).css({top: Math.round((height - $(this).outerHeight()) / 2)});
        });
    };

    var connect = function(start, end, junct) {
        var distance = end.get(0).getBoundingClientRect().left -
                       start.get(0).getBoundingClientRect().right;
        var stub = [10, distance - 10];
        if (junct) {
            stub.reverse();
        }
        var conf = {stub: stub, cornerRadius: 8, gap: 0, alwaysRespectStubs: true};
        jsPlumb.connect({
            source: start,
            target: end,
            endpoint: 'Blank',
            connector: ['Flowchart', conf],
            anchors: ['Right', 'Left']
        });
    };

    var layoutAncestors = function(container) {
        var view,
            repaint = function() {
                jsPlumb.repaint($(this));
            };
        while (true) {
            view = container.view();
            view.layout(true);
            nodes(container).each(repaint);
            if (container.hasClass('wf-process')) {
                break;
            }
            container = container.parent();
        }
    };

    var selectedNodes = function(container, rect) {
        var result = [];
        nodes(container).each(function() {
            var view = $(this).view();
            if (view) {
                extendArray(result, view.selectedNodes(rect));
            }
        });
        return result;
    };

    var selectorRect = function(startPos, endPos) {
        var left = startPos.left, top = startPos.top,
            width = endPos.left - startPos.left,
            height = endPos.top - startPos.top;
        if (width < 0) {
            left = endPos.left;
            width = - width;
        }
        if (height < 0) {
            top = endPos.top;
            height = - height;
        }
        return {
            left: left,
            top: top,
            width: width,
            height: height
        };
    };

    var extendArray = function(first, second) {
        first.push.apply(first, second);
    };

    var processPosition = function(el) {
        var parent = el.offsetParent(),
            graph = getGraphView(el),
            result = graph.normalizePosition(el.position()),
            parentPosition;
        if (!parent.hasClass('wf-component')) {
            return result;
        }
        parentPosition = processPosition(parent);
        result.left += parentPosition.left;
        result.top += parentPosition.top;
        return result;
    };

    var nodeRect = function(el) {
        var pos = processPosition(el);
        return {
            left: pos.left,
            top: pos.top,
            width: el.outerWidth(),
            height: el.outerHeight()
        };
    };

    var boundingRect = function(els, margin) {
        var rects = _.map(els, function(el) {
            return nodeRect(el);
        }),
            bottom, right, left, top;
        if (margin === undefined) {
            margin = 0;
        }
        left = _.min(_.map(rects, function(rect) {
            return rect.left;
        }));
        top = _.min(_.map(rects, function(rect) {
            return rect.top;
        }));
        right = _.max(_.map(rects, function(rect) {
            return rect.left + rect.width;
        }));
        bottom = _.max(_.map(rects, function(rect) {
            return rect.top + rect.height;
        }));
        return {
            left: left - margin,
            top: top - margin,
            width: (right - left) + margin * 2,
            height: (bottom - top) + margin * 2
        };
    };

    var getGraphView = function(el) {
        return el.is('.wf-process') ? el.view() : el.closest('.wf-process').view();
    };

    var getComponent = function(obj, id) {
        var i, component;
        if (id === undefined) {
            return null;
        }
        if (!obj.components) {
            return null;
        }
        for (i = 0; i < obj.components.length; i++) {
            component = obj.components[i];
            if (component.task_id === id) {
                return component;
            }
            var found = getComponent(component, id);
            if (found !== null) {
                return found;
            }
        }
        return null;
    };

    var relayoutComponent = function(el) {
        jsPlumb.reset();
        startWaiting();
        el.rerender().done(function() {
            var graph = getGraphView(el);
            if (graph != el.view()) {
                graph.updateLayout();
                graph.hideSelection();
            }
            stopWaiting();
        });
    };

    var fading = function(el, todo) {
      el.fadeTo(200, 0, function() {
          todo();
          el.fadeTo(200, 1);
      });
    };

    obviel.view({
        iface: 'cs-workflow-graph',
        obvtUrl: templates + 'graph.obvt',
        objectEvents: {
            relayout: 'relayout',
            zoom: 'zoom',
            updateViewport: 'updateViewport'
        },
        before: function() {
          $(this.el).fadeTo(100, 0);
        },
        render: function() {
            var self = this;
            // always draw components in original size
            this.obj.zooming.disable();
            this.zoom();
            this.layout();
            this.connect();
            // back to previous zooming if necessary
            this.obj.zooming.undo();
            this.updateViewport();

            $(this.el).fadeTo(100, 1);
            // XXX doing this on document makes the behavior much
            // nicer, but makes it harder to include this component somewhere
            // else
            // $(document).on('mousedown', function(ev) {
            this.el.parent().off('mousedown').on('mousedown', function(ev) {
                self.startSelector(ev);
            });
            // we don't want the selection buttons to trigger selection
            $('.wf-selection-operation').off('mousedown').on('mousedown', function(ev) {
                ev.stopPropagation();
            });
            $(this.el).off('updateLayout').on('updateLayout', function(ev) {
                ev.stopPropagation();
                self.updateLayout();
            });
            // Workaround: we need to render these objects
            // once at the beginning
            $.each(["before", "after", "parallel"], function (_, where) {
                $(".wf-add-" + where).render({
                    iface: "cs-workflow-add-task-button",
                    selection: [],
                    title: "",
                    where: where,
                    primary: true});
            });
        },
        start: function() {
            return this.el.children('.wf-process-start');
        },
        layout: function() {
            var last = null,
                all = nodes(this.el),
                start = this.start();
            all.each(function() {
                var view = $(this).view();
                if (view) {
                    view.layout();
                }
                $(this).css({ left: nextLeft(last),
                              top: 0 });
                last = $(this);
            });
            resize(this.el);
            alignVertical(this.el, all);
        },
        connect: function() {
            jsPlumb.detachEveryConnection();
            // XXX shared with something else?
            var last = this.start();
            nodes(this.el).slice(1).each(function() {
                $(this).view().connect();
                if (last !== null) {
                    connect(last, $(this));
                }
                last = $(this);
            });
        },
        relayout: function() {
            relayoutComponent(this.el);
        },
        updateLayout: function() {
            // just only update graph layout without any component rerendering
            var self = this;
            // The connections must be redrawn in ratio 1.0 for now
            fading($(self.el), function() {
                self.obj.zooming.disable();
                self.zoom();
                self.layout();
                // XXX this is called after graph changes, so reconnecting everything
                // makes sense. but it's also called after expanding a task box,
                // and reconnecting everything seems wasteful. Still, it appears to work,
                // but we need to verify whether this doesn't create a lot of wasteful
                // double connections
                self.connect();
                self.obj.zooming.undo();
                self.updateViewport();
            });
        },
        newTask: function(data) {
            startWaiting();
            return designerAjax(this, {
                type: 'POST',
                url: this.obj.operationUrl,
                data: JSON.stringify(data),
                processData: false,
                dataType: 'json',
                contentType: 'application/json'
            }).done(this.serverUpdate.bind(this))
              .always(stopWaiting);
        },
        removeTask: function(taskId) {
            startWaiting();
            return designerAjax(this, {
                type: 'POST',
                url: this.obj.removeUrl,
                data: JSON.stringify(taskId),
                processData: false,
                dataType: 'json',
                contentType: 'application/json'
            }).done(this.serverUpdate.bind(this))
              .always(stopWaiting);
        },
        serverUpdate: function(components) {
            // components is an array of workflow components that has
            // changed. if the 'components' property is not undefined,
            // subcomponents have also changed
            // XXX can this ever be an actual array or only a single
            // component? if so change server API
            if (! $.isArray(components)) {
                return;
            }
            var self = this;
            components.forEach(function(component) {
                var clientComponent = self.getComponent(component);
                if (clientComponent === null) {
                    throw new Error("Unknown component id: " +
                                    component.task_id);
                }
                $.extend(clientComponent, component);
                $(clientComponent).trigger('relayout');
            });
        },
        getComponent: function(component) {
            // special case for when the whole graph is updated
            if (component.iface === 'cs-workflow-graph') {
                return this.obj;
            }
            return getComponent(this.obj, component.task_id);
        },
        startSelector: function(ev) {
            if (!inScrollRange(ev)) {
                if ($(ev.target).closest('.wf-node').length) {
                    return;
                }
                if ($(ev.target).closest('.wf-new-task').length) {
                    return;
                }
                this.hideSelection();
                var self = this,
                    pos = this.cursorPosition(ev),
                    selector = $('.wf-selector', this.el);
                selector.css({
                    left: pos.left,
                    top: pos.top,
                    width: 0,
                    height: 0
                });
                // $(document).on('mousemove', function(ev) {
                this.el.parent().on('mousemove', function(ev) {
                    self.changeSelector(ev, selector, pos);
                });
                // XXX this sometimes seems to get triggered too early when we
                // drag to the right
                // $('body').on('mouseleave', function(ev) {
                this.el.parent().on('mouseleave', function(ev) {
                    self.endSelector(ev, selector, pos);
                    ev.stopPropagation();
                });
                // Fix IE bug of not firing mouseup on scrollbar
                this.el.parent().on('scroll', function(ev) {
                    self.endSelector(ev, selector, pos);
                });
                $(document).on('mouseup', function(ev) {
                    self.endSelector(ev, selector, pos);
                });
            }
        },
        changeSelector: function(ev, selector, startPos) {
            selector.show();
            selector.css(selectorRect(startPos, this.cursorPosition(ev)));
        },
        endSelector: function(ev, selector, startPos) {
            selector.hide();
            // $(document).off('mousemove');
            // $(document).off('mouseup');
            // $('body').off('mouseleave');
            this.el.parent().off('mousemove');
            $(document).off('mouseup');
            this.el.parent().off('mouseleave');
            this.el.parent().off('scroll');
            this.drawSelection(ev, startPos);
        },
        drawSelection: function(ev, startPos) {
            var views = this.selectedNodes(
              selectorRect(startPos, this.cursorPosition(ev)));
            this.renderSelection(views);
        },
        renderSelection: function(views) {
            this.hideSelectionButtons();
            // we have to pass the buttons and this graph view itself
            // to the selection. the buttons cannot be rendered inside of
            // the selection because they won't show properly
            $('.wf-selection', this.el).render({
                iface: 'cs-workflow-selection',
                selectedIds:_.map(views, function(view) {
                    // FIXME: fix the data structure at first
                    return view.obj.id; // component.PRIMARY_KEYS.task_id;
                }),
                rect: boundingRect(
                    _.map(views,
                          function(view) { return view.el; }),
                    SELECTION_MARGIN),
                before: $('.wf-add-before', this.el),
                after: $('.wf-add-after', this.el),
                parallel: $('.wf-add-parallel', this.el),
                graph: this,
                operationUrl: this.obj.operationUrl,
                allowedOperationsUrl: this.obj.allowedOperationsUrl
            });
        },
        hideSelection: function() {
            this.getNewTaskForm().hide();
            this.hideSelectionButtons();
            $('.wf-selection', this.el).hide();
        },
        hideSelectionButtons: function() {
            $('.wf-selection-operation', this.el).off('click');
            $('.wf-selection-operation', this.el).hide();
        },
        cursorPosition: function(ev) {
            var offset = this.el.offset();
            return this.normalizePosition({'left': ev.pageX  - offset.left,
                                           'top': ev.pageY - offset.top});
        },
        selectedNodes: function(rect) {
            return selectedNodes(this.el, rect);
        },
        updateViewport: function() {
            this.obj.zooming.calcZoom($(this.el));
            this.zoom();
        },
        zoom: function() {
            // avoid repeating zooming
            if (this.scaleRatio != this.obj.zooming.ratio) {
                var ratio = this.scaleRatio = this.obj.zooming.ratio;
                // TODO: updating instead of setting
                // (because there can be scale and translate transforms
                // at the same time)
                $(this.el).css('transform', 'scale('+ratio+')');
                $(this.el).css({'-ms-transform': 'scale('+ratio+')'});
                // also tell jsPlumb we zoomed
                jsPlumb.setZoom(ratio);
            }
            this.translatePosition();
        },
        translatePosition: function() {
            if (this.obj.zooming.disabled) {
                return;
            }
            // for IE: set scroll back to 0,0 temporarily otherwise the position would be wrong
            // FF: scroll position get automatically reset to 0,0
            // (maybe because of 0-size content?)
            this.obj.zooming.resetScroll();
            // translate the container to right position after zooming
            var translating = {left: 0, top: 0};
            $(this.el).css(translating);
            if (this.obj.zooming.ratio != 1) {
                var rect = $(this.el).position();
                translating = {left: -rect.left, top: -rect.top};
            }
            // vertically align the graph if possible
            var realH = this.el.height() * this.obj.zooming.ratio;
            if (realH < this.obj.zooming.viewport.h) {
                translating.top += Math.round((this.obj.zooming.viewport.h - realH) / 2);
            }
            $(this.el).css(translating);
            // try to restore the scroll position
            this.obj.zooming.restoreScroll();
        },
        normalizePosition: function(pos) {
            // normalize the position against the scaling
            // assumption: the component position is supposed to be in ration 1.0,
            // because the visual offset/scaling adjust would be done by graph
            if (this.obj.zooming.ratio != 0) {
                pos.left = pos.left / this.obj.zooming.ratio;
                pos.top = pos.top / this.obj.zooming.ratio;
            }
            return pos;
        },
        getNewTaskForm: function() {
            return this.el.find('.wf-new-task');
        },
        openNewTaskForm: function(withObj) {
            if (withObj.where == 'completion') {
                // add new task form at the end
                var endComp = this.el.find('.wf-process-end').closest('.wf-component');
                withObj.position = this.normalizePosition(endComp.position());
                withObj.position.left += endComp.width();
            }
            this.getNewTaskForm().render(withObj);
        },
        selectTask: function() {
            var _tasks = tasks(this.el),
                selected;
            if (_tasks.length == 1) {
                selected = _tasks.first();
            } else {
              // just consider the highlighted task as selected
              var highlighted = _tasks.filter('.wf-hightlighting');
              if (highlighted.length) {
                  selected = highlighted.first();
              }
            }
            var compNode;
            if (selected) {
                compNode = selected.closest('.wf-component');
            }
            if (compNode) {
                this.renderSelection([$(compNode).view()]);
            }
        }
    });

    obviel.view({
        iface: 'cs-workflow-add-task-button',
        obvtUrl: templates + 'add_task_button.obvt',
        render: function() {
            this.el.find(".dropdown-menu").render({iface: "cs-workflow-new-task-menu"});

            if (this.obj.primary) {
                var btn = this.el.find(".btn");
                btn.addClass("btn-primary");
                btn.addClass("btn-small");
            }
        },
        dropdownSelect: function(ev) {
            var ttype = $(ev.target).data('task-type');
            if (!ttype) {
                return;
            }

            return getGraphView(this.el).newTask({
                where: this.obj.where,
                selection: this.obj.selection,
                title: this.obj.title,
                ttype: ttype,
                extension: $(ev.target).data('task-extension'),
                task_definition: $(ev.target).data('task-definition')
            });
        },
        setTitle: function (ev) {
            var task_form = this.el.siblings('.wf-task-title');
            var title = task_form.find('input[name="task_title"]').val();

            if (title) {
                this.obj.title=title;
            }
            var designerView = getDesignerView(this.el),
                viewport = designerView.viewport,
                ratio = designerView.obj.zooming.ratio,
                dropdown = this.el.find('ul.dropdown-menu');

            // keep the list in the viewport
            var hoffset = viewport.offset().top + viewport[0].clientHeight - this.el.offset().top - (dropdown.height() + 50) * ratio,
                woffset;

            if (hoffset >= 0) {
                hoffset = undefined;
            }

            if (this.el.css('float') != 'right') {
                woffset = viewport.width() - this.el.position().left - (dropdown.width() + 30) * ratio;
                woffset = woffset < 0 ? - (dropdown.width() - this.el.width()) * ratio : undefined;
            }

            var offset = {
                top: hoffset !== undefined ? Math.min(0, hoffset / ratio) : '',
                left: woffset !== undefined ? Math.min(0, woffset / ratio) : ''
            };

            dropdown.css(offset);
        },
    });

    obviel.view({
        iface: 'cs-workflow-selection',
        ephemeral: true,
        render: function() {
            if (!this.obj.selectedIds.length) {
                return;
            }

            var self = this;

            $.each(["before", "after", "parallel"], function (_, where) {
                self.obj[where].render({
                    iface: "cs-workflow-add-task-button",
                    selection: self.obj.selectedIds,
                    title: "",
                    where: where,
                    primary: true});
            });

            $("#ajax_animation").appendTo(this.el).removeClass("hide");

            this.el.show();
            this.el.css(this.obj.rect);

            var promise = this.allowedSelectionOperations();
            promise.done(function(allowedOperations) {
                self.drawSelectionButtons(allowedOperations);
            });
        },
        drawSelectionButtons: function(operations) {
            var before = this.obj.before,
                after = this.obj.after,
                parallel = this.obj.parallel;
            before.css(this.beforePosition()).removeClass("open");
            after.css(this.afterPosition()).removeClass("open");
            parallel.css(this.parallelPosition()).removeClass("open");
            if (operations.before) {
                before.show();
            }
            if (operations.after) {
                after.show();
            }
            if (operations.parallel) {
                parallel.show();
            }
        },
        beforePosition: function() {
            var before = this.obj.before, rect = this.obj.rect;
            return {
                left: rect.left - before.outerWidth(),
                top: rect.top + (rect.height - before.outerHeight()) / 2
            };
        },
        afterPosition: function() {
            var after = this.obj.after, rect = this.obj.rect;
            return {
                left: rect.left + rect.width,
                top: rect.top + (rect.height - after.outerHeight()) / 2
            };
        },
        parallelPosition: function() {
            var parallel = this.obj.parallel, rect = this.obj.rect;
            return {
                left: rect.left + (rect.width - parallel.outerWidth()) / 2,
                top: rect.top + rect.height
            };
        },
        allowedSelectionOperations: function() {
            // XXX passing data as request parameters, could use AJAX body
            return $.getJSON(
                    this.obj.allowedOperationsUrl,
                    $.param({selection: this.obj.selectedIds}, true),
                    function () {
                $("#ajax_animation").addClass("hide");
            });
        },
    });

    obviel.view({
        iface: 'cs-workflow-new-task',
        obvtUrl: templates + 'new_task.obvt',
        render: function() {
            this.el.find(".dropdown").render({
                iface: "cs-workflow-add-task-button",
                selection: [],
                where: this.obj.where,
                primary: false
            });

            var position = this.obj.position;
            if (position === undefined) {
                position = { left: 0, top: 0};
            }
            this.el.css({
                left: position.left - (this.el.outerWidth()),
                top: position.top - (this.el.outerHeight() / 2)
            });
            this.el.show();
            this.titleInput().focus();
        },
        titleInput: function() {
            var form = $(".wf-task-form", this.el);
            return $('input[name="task_title"]', form);
        },
        popupTypeSelector: function(ev) {
            if (ev.keyCode !== ENTER_KEYCODE) {
                return;
            }
            ev.stopPropagation();
            ev.preventDefault();
            $('.dropdown-toggle', this.el).click();
            return false;
        }
    });

    obviel.view({
        iface: 'cs-workflow-new-task-menu',
        obvtUrl: templates + 'new_task_menu.obvt',
    });

    obviel.view({
        iface: 'cs-workflow-node',
        obvtUrl: templates + 'node.obvt',
        render: function() {
            this.el.addClass('wf-component');
        },
        layout: function() {
        },
        connect: function() {
        },
        selectedNodes: function(rect) {
            if (this.obj.nonselectable) {
                return [];
            }
            var pos = processPosition(this.el),
                left = pos.left,
                top = pos.top,
                width = this.el.outerWidth(),
                height = this.el.outerHeight();
            if (rect.left + rect.width < left) {
                return [];
            }
            if (rect.top + rect.height < top) {
                return [];
            }
            if (rect.left > left + width) {
                return [];
            }
            if (rect.top > top + height) {
                return [];
            }
            return [this];
        }
    });

    obviel.view({
        iface: 'cs-workflow-task',
        obvtUrl: templates + 'task.obvt',
        render: function() {
            var self = this;
            $(this.el).find('.detail-actions .toggle-details').on(
                'click',
                function(ev) {self.toggleDetails(ev)});
            $(this.el).off('detailChanged').on(
                'detailChanged',
                function(ev) {
                    ev.stopPropagation();
                    self.checkDetails();
                    $(self.el).trigger('updateLayout');
                });
            // initialize collapse, stoping browser that dose not support
            // transitions fires 'toggle' twice on first toggle event.
            $(this.el).find('.wf-details .detail-collapse')
                .collapse({toggle: false})
                .on('shown hidden',
                    function(ev) {
                        $(self.el).trigger('updateLayout');
                    })
                .on('shown hide',
                    function(ev) {
                        $(this).toggleClass('allow-overflow');
                        self.el.toggleClass('detail-view');
                    });
            if (self.obj.modifyUrl && self.obj.schemaEditable) {
                $(this.el).find('.task-title .editable').editable(
                        function(value, settings) {
                            return modifyObject(
                                    self,
                                    self.obj.modifyUrl,
                                    'title',
                                    value,
                                    this.revert);
                        }, {
                            placeholder: task_title_placeholder,
                            onblur: "submit"
                        });
            }
            this.checkDetails();
        },
        checkDetails: function() {
            var dActions = this.el.find('.detail-actions');
            if(this.obj.constraints.constraints.length) {
                dActions.find('.has-constraints').show();
            } else {
                dActions.find('.has-constraints').hide();
            }
            if(this.obj.briefcaselinks.links.length) {
                dActions.find('.has-briefcaselinks').show();
            } else {
                dActions.find('.has-briefcaselinks').hide();
            }
        },
        toggleDetails: function(ev) {
            ev.preventDefault();
            $(this.el).find('.wf-details .detail-collapse').collapse('toggle');
            $(ev.currentTarget).children("i").toggleClass('disabled');
        },
        getStatusClass: function(el) {
           el.addClass(this.obj.statusStyle || 'label-default');
        },
        remove: function(ev) {
            if (!this.obj.taskDeletable) {
                return;
            }
            ev.stopPropagation();
            getGraphView(this.el).removeTask(this.obj.task_id);
        },
        getSelectableBriefcases4Constraint: function() {
            return getDesignerView($(this.el)).getGlobalBriefcases().concat(
                    _.map(this.obj.briefcaselinks.links, function(bcl) {
                        bcl.name = bcl.briefcase_name;
                        return bcl;
                    }));

        },
        getSelectableBriefcases: function() {
            var self = this;
            return _.filter(
                    getDesignerView($(this.el)).getLocalBriefcases(),
                    function(bc) {
                        return _.findWhere(
                                self.obj.briefcaselinks.links,
                                {briefcase_id: bc.briefcase_id}) === undefined;
                    });
        }
    });

    obviel.view({
        iface: 'cs-workflow-task-info',
        obvtUrl: templates + 'task_info.obvt',
        render: function() {
            var self = this;
            if (this.obj.modifyUrl) {
            }
        }
    });

    obviel.view({
        iface: 'cs-workflow-task-fields',
        obvtUrl: templates + 'task_fields.obvt',
        render: function() {
            var self = this;
            if (this.obj.modifyUrl) {
                // deadline modification
                $(this.el).find('.info-state .deadline-action').datepicker({
                    language: cdb.elink.currentLanguage,
                    format: 'dd.mm.yyyy',
                    weekStart: 1,
                    autoclose: true,
                    clearBtn: true,
                    todayHighlight: true
                }).datepicker('setDate', self.obj.deadline)
                        .on('changeDate', function(e){
                    $(self.el).find('.info-state .deadline').text(
                        modifyObject(
                            self,
                            self.obj.modifyUrl,
                            'deadline',
                            e.format(),
                            self.obj.deadline));
                }).on('show', function() {
                    if ($('.datepicker').is('.datepicker-orient-bottom')) {
                        // fix the top position = NaN problem
                        var top = $(this).offset().top - $('.datepicker').outerHeight();
                        $('.datepicker').css('top', top);
                    }
                }).on('show hide shown hidden', function(ev) {
                    // avoid triggering collapse events
                    ev.stopPropagation();
                });
                $(this.el).find('.max-duration').editable(function(value, settings) {
                    return modifyObject(
                            self,
                            self.obj.modifyUrl,
                            'max_duration',
                            value,
                            this.revert);
                }, {
                    onblur: "submit",
                    type: 'number',
                    placeholder: '-',
                    width: '70%',
                    callback: function(value, settings) {
                        if (value != this.revert) {
                            self.obj.max_duration = value;
                        }
                    }
                });
                if (this.obj.schemaEditable) {
                    $(this.el).find('.wf-checkbox input:checkbox').on(
                            'click',
                            function(ev) {
                                self.toggleCheckbox(ev);
                            });
                }
            }
        },
        toggleCheckbox: function(ev) {
            var field = $(ev.target).attr("data-field");
            var self = this,
            value = $(ev.target).prop('checked') ? 1 : 0,
            result = modifyObject(
                this,
                this.obj.modifyUrl,
                field,
                value,
                1-value);
            this.obj[field] = result;
            this.setAttribute($(ev.target));
        },
        setAttribute: function(el) {
            var field = el.attr("data-field");
            el.prop('checked', $(this.obj).attr(field) === 1);
            el.prop('disabled', this.obj.modifyUrl && this.obj.schemaEditable ? false : true);
        },
        formatDuration: function(value) {
          if (value === '-' || value === '') {
            return value;
          }
          return parseInt(value);
        }
    });

    obviel.view({
        iface: 'cs-workflow-systemtask-fields',
        obvtUrl: templates + 'systemtask_fields.obvt',
        render: function() {
            var self = this;
            if (this.obj.modifyUrl && this.obj.schemaEditable) {
                $(this.el).find('.wf-checkbox input:checkbox').on(
                        'click',
                        function(ev) {
                            self.toggleCheckbox(ev);
                        });
            }
        },
        toggleCheckbox: function(ev) {
            var field = $(ev.target).attr("data-field");
            var self = this,
            value = $(ev.target).prop('checked') ? 1 : 0,
            result = modifyObject(
                this,
                this.obj.modifyUrl,
                field,
                value,
                1-value);
            this.obj[field] = result;
            this.setAttribute($(ev.target));
        },
        toggleFinishOption: function(ev) {
            this.toogleCheckbox(ev, 'finish_option');
        },
        setAttribute: function(el) {
            var field = el.attr("data-field");
            el.prop('checked', $(this.obj).attr(field) === 1);
            el.prop('disabled', this.obj.modifyUrl && this.obj.schemaEditable ? false : true);
        }
    });

    obviel.view({
        iface: 'cs-workflow-responsible',
        obvtUrl: templates + 'responsible.obvt',
        remove: function() {
            $(this.el).find('.responsible-action').trigger(
                'responsibleSelected',
                {'result': [{
                    'subject_id': {'text': ''},
                    'subject_type': {'text': ''},
                    'mapped_subject_name': {'text': ''}
                }]}
            );
        },
        render: function() {
            var self = this;
            if (this.obj.setResponsibleUrl) {
                // responsible
                $(this.el).find('.responsible-action').on(
                    'click',
                    function() {
                        $(this).trigger('openResponsibleCatalog');
                }).on('responsibleSelected', function(ev, data) {
                    if (data.result.length && data.result[0].subject_id) {
                        designerAjax(self, {
                            url: self.obj.setResponsibleUrl,
                            data: {subject_id: data.result[0].subject_id.text,
                                   subject_type: data.result[0].subject_type.text},
                            dataType: 'json',
                            type: 'POST',
                            async: false,
                            success: function(data) {
                                if (data) {
                                    $.extend(self.obj, data);
                                    self.rerender();
                                }
                            }
                        });
                    }
                });
            }
        }
    });

    obviel.view({
        iface: 'cs-workflow-systemtask-info',
        obvtUrl: templates + 'systemtask_info.obvt',
    });

    obviel.view({
        iface: 'cs-workflow-sequential',
        obvtUrl: templates + 'sequential.obvt',
        objectEvents: {
            relayout: 'relayout'
        },
        render: function() {
            this.el.addClass('wf-sequential wf-component');
        },
        layout: function() {
            var last = null;
            nodes(this.el).each(function() {
                $(this).view().layout();
                $(this).css({ left: nextLeft(last),
                              top: 0 });
                last = $(this);
            });
            resize(this.el);
            alignVertical(this.el, nodes(this.el));
        },
        connect: function() {
            var last = null;
            nodes(this.el).each(function() {
                $(this).view().connect();
                if (last !== null) {
                    connect(last, $(this));
                }
                last = $(this);
            });
        },
        selectedNodes: function(rect) {
            return selectedNodes(this.el, rect);
        },
        relayout: function() {
            relayoutComponent(this.el);
        }
    });

    obviel.view({
        iface: 'cs-workflow-parallel',
        obvtUrl: templates + 'parallel.obvt',
        objectEvents: {
            relayout: 'relayout'
        },
        render: function() {
            this.el.addClass('wf-parallel wf-component');
            if (this.obj.isCompletion) {
                this.el.addClass('is-completion');
            }
            var self = this, start = this.start();
            start.on(
                    'click',
                    '.detail-actions .toggle-details',
                    function(ev) {
                        self.toggleDetails(ev);
                    });
            start.on(
                    'shown hidden',
                    '.wf-details .detail-collapse',
                    function(ev) {
                        getGraphView(self.el).updateLayout();
                    });
            // initialize collapse
            $(this.el).find('.wf-details .detail-collapse').collapse({toggle: false});
            $(this.el).off('detailChanged').on(
                    'detailChanged',
                    function(ev) {
                        ev.stopPropagation();
                        $(self.el).trigger('updateLayout');
            });
        },
        start: function() {
            return this.el.children('.wf-parallel-start');
        },
        end: function() {
            return this.el.children('.wf-parallel-end');
        },
        layout: function() {
            var last = null,
                all = nodes(this.el),
                n = all.slice(1, -1),
                start = this.start(),
                end = this.end(),
                parallelLeft = null;
            start.css({ left: 0, top: 0 });

            parallelLeft = nextLeft(start);

            n.each(function() {
                $(this).view().layout();
                $(this).css({left: parallelLeft,
                             top: nextTop(last) });
                last = $(this);
            });

            // stop the end point from causing relayout to expand the box
            end.css({ left: 0, top: 0 });
            resize(this.el);

            end.css({ left: this.el.outerWidth() + DISTANCE,
                      top: 0 });
            resize(this.el);
            alignVertical(this.el, start);
            alignVertical(this.el, end);
            var offset = Math.round((start.outerWidth() - end.outerWidth()) / 2);
            alignHorizontal(this.el, n, offset);
        },
        connect: function() {
            var last = null,
                all = nodes(this.el),
                n = all.slice(1, -1),
                start = this.start(),
                end = this.end();
            n.each(function() {
                $(this).view().connect();
                connect(start, $(this));
                connect($(this), end, true);
            });
        },
        selectedNodes: function(rect) {
            return selectedNodes(this.el, rect);
        },
        relayout: function() {
            relayoutComponent(this.el);
        },
        toggleDetails: function(ev) {
            this.start()
                .toggleClass('details-opened')
                .find('.wf-details .detail-collapse')
                .collapse('toggle')
                .toggleClass('allow-overflow');
            $(ev.currentTarget).children().toggleClass('disabled');
        },
    });

    var count = 0;

    obviel.view({
        iface: 'cs-workflow-global-briefcases',
        obvtUrl: templates + 'global_briefcases.obvt',
        render: function() {
            var self = this;
            if (this.obj.addUrl) {
                this.el.find('.briefcaselink-meanings.dropdown-menu').render(
                        {iface: 'cs-workflow-briefcase-link-meanings'});
            }
            this.el.off('briefcaseDeleted').on(
                    'briefcaseDeleted',
                    function(ev, data) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        $.extend(self.obj, data);
                        self.rerender();
                    });
        },
        addBriefcase: function(ev) {
            var self = this,
                meaning = $(ev.target).data('meaning'),
                name = $('input[name="name"]', this.el).val();
            if (!meaning || !name) {
                return;
            }
            designerAjax(self, {
                type: 'POST',
                url: this.obj.addUrl,
                data: JSON.stringify({name: name, meaning: meaning}),
                processData: false,
                dataType: 'json',
                contentType: 'application/json'
            }).done(function(obj) {
                // this is a global change
                $.extend(self.obj, obj);
                self.rerender();
            });
        },
        popupTypeSelector: function(ev) {
            if (ev.keyCode !== ENTER_KEYCODE) {
                return;
            }
            ev.stopPropagation();
            ev.preventDefault();
            $('.dropdown-toggle', this.el).click();
            return false;
        }
    });

    obviel.view({
        iface: 'cs-workflow-local-briefcases',
        obvtUrl: templates + 'local_briefcases.obvt',
        render: function() {
            var self = this;
            $(this.el).off('briefcaseDeleted').on(
                    'briefcaseDeleted',
                    function(ev, data) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        $.extend(self.obj, data);
                        // self.el.rerender();
                        self.rerender();
                    });
        },
        addBriefcase: function(ev) {
            var self = this,
                name = $('input[name="name"]', this.el).val();
            if (!name) {
                return;
            }
            designerAjax(self, {
                type: 'POST',
                url: this.obj.addUrl,
                data: JSON.stringify({name: name}),
                processData: false,
                dataType: 'json',
                contentType: 'application/json'
            }).done(function(obj) {
                // this is a global change
                $.extend(self.obj, obj);
                self.rerender();
            });
        },
        createOnEnter: function(ev) {
            if (ev.keyCode !== ENTER_KEYCODE) {
                return;
            }
            ev.stopPropagation();
            ev.preventDefault();
            this.el.find('.wf-add-breifcase .btn').first().click();
            return false;
        }
    });

    obviel.view({
        iface: 'cs-workflow-global-briefcase',
        obvtUrl: templates + 'global_briefcase.obvt',
        render: function() {
            var self = this;
            if(this.obj.modifyUrl) {
                $('.briefcase-name', this.el).editable(
                        function(value, settings) {
                            return modifyObject(
                                self,
                                self.obj.modifyUrl,
                                'name',
                                value,
                                this.revert);
                        },
                        {
                            onblur: "submit"
                        }
                );
            }
            // new content can be added?
            if(this.obj.addContentUrl) {
                $('<div>').appendTo(this.el).render({
                    iface: 'cs-workflow-briefcase-newcontent'});
                this.el.off('addContent').on(
                        'addContent',
                        function(ev) {
                            ev.stopPropagation();
                            ev.preventDefault();

                            var data = $.makeArray(arguments).slice(1, arguments.length);
                            self.addContent(data);
                        });
            }
            if(this.obj.deleteContentUrl) {
                $(this.el).find('.wf-briefcase-contents').on(
                        'deleteContent',
                        function(ev, data) {
                            ev.stopPropagation();
                            ev.preventDefault();
                            self.deleteContent(data);
                        });
            }
            this.toggleButton().on(
                'click',
                function(ev) {self.toggleDetails(ev)});
            this.toggleArea().collapse({toggle: false});
        },
        toggleButton: function() {
          return this.el.find('.toggle-details');
        },
        toggleArea: function() {
          return this.el.find('.wf-briefcase-contents.collapse');
        },
        toggleDetails: function(ev) {
          ev.preventDefault();
          this.toggleArea().collapse('toggle');
          $(ev.currentTarget).children("i").toggleClass('disabled');
        },
        remove: function() {
            return designerAjax(this, {
                type: 'POST',
                url: this.obj.deleteUrl,
                processData: false,
                dataType: 'json',
                contentType: 'application/json'
            }).done(this.collectionUpdate.bind(this));
        },
        collectionUpdate: function(data) {
            getDesignerView(this.el).removeTaskBriefcaseLink(this.obj.briefcase_id);
            // Is there a better way?
            $(this.el).trigger('briefcaseDeleted', data);
        },
        updateContents: function(data, expand) {
            $.extend(this.obj, data);
            this.rerender();
        },
        addContent: function(data) {
            var self = this;
            designerAjax(self, {
                url: self.obj.addContentUrl,
                data: {cmsgs: data},
                dataType: 'json',
                type: 'POST',
                async: false,
                success: function(data) {
                    if (data) {
                        self.updateContents(data, true);
                    }
                }
            });
        },
        deleteContent: function(data) {
            var self = this;
            designerAjax(self, {
                url: self.obj.deleteContentUrl,
                data: {content_object_id: data},
                dataType: 'json',
                type: 'POST',
                async: false,
                success: function(data) {
                    if (data) {
                        self.updateContents(data);
                    }
                }
            });
        },
        checkToggleButton: function(el) {
            if (this.obj.contents.length) {
                el.removeClass('invisible');
                el.children().toggleClass('disabled');
            } else {
                el.addClass('invisible');
            }
        },
        checkDocumentExistance: function(el) {
            if (this.obj.contents.length) {
                el.addClass('in');
            } else {
                el.removeClass('in');
            }
        },
        changeMeaning: function(ev) {
            var self = this,
                value = $(ev.currentTarget).data('meaning');
            if (value == this.obj.meaning) {
              return;
            }
            designerAjax(self, {
                url: self.obj.setMeaningUrl,
                data: {attribute: 'meaning', value: value},
                dataType: 'json',
                type: 'POST',
                async: false,
                success: function(data) {
                    if (data) {
                        $.extend(self.obj, data);
                        // rerender constraint
                        self.el.rerender();
                    }
                },
                error: function() {
                    self.el.rerender();
                }
            });
        },
        checkModeButton: function (el) {
            if (this.obj.meaning == el.data('meaning')) {
                el.addClass("active");
            }
        },
   });

    obviel.view({
        iface: 'cs-workflow-local-briefcase',
        obvtUrl: templates + 'local_briefcase.obvt',
        render: function() {
            var self = this;
            if (this.obj.modifyUrl) {
                $('.briefcase-name', this.el).editable(
                        function(value, settings) {
                            return modifyObject(
                                self,
                                self.obj.modifyUrl,
                                'name',
                                value,
                                this.revert);
                        },
                        {
                            onblur: "submit"
                        }
                    );
            }
            // new content can be added?
            if(this.obj.addContentUrl) {
                $('<div>').appendTo(this.el).render({
                    iface: 'cs-workflow-briefcase-newcontent'});
                this.el.off('addContent').on(
                        'addContent',
                        function(ev) {
                            ev.stopPropagation();
                            ev.preventDefault();

                            var data = $.makeArray(arguments).slice(1, arguments.length);
                            self.addContent(data);
                        });
            }
            if(this.obj.deleteContentUrl) {
                $(this.el).find('.wf-briefcase-contents').on(
                        'deleteContent',
                        function(ev, data) {
                            ev.stopPropagation();
                            ev.preventDefault();
                            self.deleteContent(data);
                        });
            }
            this.toggleButton().on(
                'click',
                function(ev) {self.toggleDetails(ev)});
            this.toggleArea().collapse({toggle: false});
        },
        toggleButton: function() {
          return this.el.find('.toggle-details');
        },
        toggleArea: function() {
          return this.el.find('.wf-briefcase-contents.collapse');
        },
        toggleDetails: function(ev) {
          ev.preventDefault();
          this.toggleArea().collapse('toggle');
          $(ev.currentTarget).children("i").toggleClass('disabled');
        },
        remove: function() {
            return designerAjax(this, {
                type: 'POST',
                url: this.obj.deleteUrl,
                processData: false,
                dataType: 'json',
                contentType: 'application/json'
            }).done(this.collectionUpdate.bind(this));
        },
        collectionUpdate: function(data) {
            getDesignerView(this.el).removeTaskBriefcaseLink(this.obj.briefcase_id);
            // Is there a better way?
            $(this.el).trigger('briefcaseDeleted', data);
        },
        updateContents: function(data, expand) {
            $.extend(this.obj, data);
            this.rerender();
        },
        addContent: function(data) {
            var self = this;
            designerAjax(self, {
                url: self.obj.addContentUrl,
                data: {cmsgs: data},
                dataType: 'json',
                type: 'POST',
                async: false,
                success: function(data) {
                    if (data) {
                        self.updateContents(data, true);
                    }
                }
            });
        },
        deleteContent: function(data) {
            var self = this;
            designerAjax(self, {
                url: self.obj.deleteContentUrl,
                data: {content_object_id: data},
                dataType: 'json',
                type: 'POST',
                async: false,
                success: function(data) {
                    if (data) {
                        self.updateContents(data);
                    }
                }
            });
        },
        checkToggleButton: function(el) {
            if (this.obj.contents.length) {
                el.removeClass('invisible');
                el.children().toggleClass('disabled');
            } else {
                el.addClass('invisible');
            }
        },
        checkDocumentExistance: function(el) {
            if (this.obj.contents.length) {
                el.addClass('in');
            } else {
                el.removeClass('in');
            }
        }
    });

    obviel.view({
        iface: 'cs-workflow-briefcase-newcontent',
        obvtUrl: templates + 'new_briefcase_content.obvt',
        dropIn: function() {
            // The Drag&Drop of cdb object only works in cdb client(IE)
            // delay the drop handler, because the element would be
            // actually added little later
            _.delay(_.bind(this.dropFinished, this), 100);
        },
        dropFinished: function() {
            var data = $.map($(this.el).find('a'), function (el) {
                return $(el).prop('href');
            });

            $(this.el).trigger('addContent', data);
        }
    });

    obviel.view({
        iface: 'cs-workflow-briefcase-content',
        obvtUrl: templates + 'briefcase_content.obvt',
        remove: function() {
           $(this.el).trigger('deleteContent', this.obj.content_object_id);
        }
    });

    obviel.view({
        iface: 'cs-workflow-constraints',
        obvtUrl: templates + 'constraints.obvt',
        render: function() {
            var self = this;
            if (this.obj.addConstraintUrl) {
                // constraints
                $(this.el).find('.constraints-action').on(
                    'click',
                    function() {
                        $(this).trigger('openConstraintCatalog');
                }).on('constraintSelected', function(ev, data) {
                    if (data.result.length && data.result[0].name) {
                        designerAjax(self, {
                            url: self.obj.addConstraintUrl,
                            data: {constraint: data.result[0].name.text},
                            dataType: 'json',
                            type: 'POST',
                            async: false,
                            success: function(data) {
                                if (data) {
                                    $.extend(self.obj, data);
                                    // rerender constraints, tell component to check
                                    // detail icons and layouts.
                                    self.el.rerender().done(function() {
                                        self.el.trigger('detailChanged');
                                    });
                                }
                            }
                        });
                    }
                });
            }
            $(this.el).off('constraintDeleted').on(
                    'constraintDeleted',
                    function(ev, data) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        $.extend(self.obj, data);
                        self.el.rerender().done(function() {
                            self.el.trigger('detailChanged');
                        });
                    });
        }
    });

    obviel.view({
        iface: 'cs-workflow-constraint',
        obvtUrl: templates + 'constraint.obvt',
        render: function() {
            var self = this;
            if (self.obj.modifyUrl) {
                $(this.el).find('.constraint-invert input:checkbox').on(
                        'click',
                        function() {
                            var value = $(this).is(':checked') ? 1 : 0;
                            self.updateConstraint('invert_rule', value);
                        });
                $(this.el).find('.constraint-action').on(
                        'click',
                        '.briefcase-dropdown:not(.open) .dropdown-toggle',
                        function(ev) {
                            // better way to do this?
                            var briefcases = _.result(
                                    $(self.el).closest('.wf-task').parentView(),
                                    'getSelectableBriefcases4Constraint') || [];

                            // emtpy entry, to delete briefcase association
                            var empty = {
                                    briefcase_id: "",
                                    name: "-"
                            };
                            var bcDropdown = {
                                    iface: 'cs-workflow-briefcase-dropdown',
                                    briefcases: [empty].concat(briefcases)
                            };
                            $(self.el).find('.briefcase-dropdown ul.dropdown-menu').render(bcDropdown);
                        });
                $(this.el).find('.briefcase-dropdown .dropdown-menu').on(
                        'click',
                        'li a',
                        function(ev) {
                            ev.stopPropagation();
                            ev.preventDefault();
                            var value = $(ev.target).data('briefcase_id');
                            self.updateConstraint('briefcase_id', value);
                        });
            }
        },
        updateConstraint: function(field, value) {
            var self = this;
            designerAjax(self, {
                url: self.obj.modifyUrl,
                data: {attribute: field, value: value},
                dataType: 'json',
                type: 'POST',
                async: false,
                success: function(data) {
                    if (data) {
                        $.extend(self.obj, data);
                        // rerender constraint
                        self.el.rerender();
                    }
                }
            });
        },
        remove: function() {
            return designerAjax(this, {
                type: 'POST',
                url: this.obj.deleteUrl,
                processData: false,
                dataType: 'json',
                contentType: 'application/json'
            }).done(this.collectionUpdate.bind(this));
        },
        collectionUpdate: function(data) {
            // Is there a better way?
            $(this.el).trigger('constraintDeleted', data);
        },
        checkCheckbox: function(el) {
            el.prop('checked', this.obj.invert_rule == 1);
        }
    });

    obviel.view({
        iface: 'cs-workflow-briefcase-dropdown',
        obvtUrl: templates + 'briefcase_dropdown.obvt'
    });

    obviel.view({
        iface: 'cs-workflow-briefcase-links',
        obvtUrl: templates + 'briefcase_links.obvt',
        render: function() {
            var self = this;
            if (this.obj.addUrl) {
                $(this.el).find('.briefcase-dropdown').on(
                        'click',
                        '.briefcase-dropdown:not(.open) .dropdown-toggle',
                        function(ev) {
                            // better way to do this?
                            var briefcases = _.result(
                                    $(self.el).closest('.wf-task').parentView(),
                                    'getSelectableBriefcases') || [];
                            var bcDropdown = {
                                    iface: 'cs-workflow-briefcase-dropdown',
                                    briefcases: briefcases
                            };
                            $(self.el).find('.briefcase-dropdown ul.dropdown-menu').render(bcDropdown);
                        });
            }
            $(this.el).off("refreshLocalBriefcases").on(
                "refreshLocalBriefcases",
                function(ev, data) {
                    ev.stopPropagation();
                    $.extend(
                        self.obj,
                        data
                    );
                    self.el.rerender();
                }
            );
            $(this.el).off('briefcaselinkDeleted').on(
                    'briefcaselinkDeleted',
                    function(ev, data) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        $.extend(self.obj, data);
                        self.el.rerender().done(function() {
                            $(self.el).trigger('detailChanged');
                        });
                    });
        },
        addBriefcaseLink: function(ev) {
            ev.stopPropagation();
            ev.preventDefault();
            if (!this.obj.addUrl) {
                return;
            }
            var self = this,
                briefcase_id = $(ev.target).data('briefcase_id');
            if (briefcase_id == undefined) {
                return;
            }
            designerAjax(self, {
                url: self.obj.addUrl,
                data: {briefcase_id: briefcase_id},
                dataType: 'json',
                type: 'POST',
                async: false,
                success: function(data) {
                    if (data) {
                        $.extend(self.obj, data);
                        // rerender briefcase links, tell component to check
                        // detail icons and layouts.
                        self.el.rerender().done(function() {
                            $(self.el).trigger('detailChanged');
                        });
                    }
                }
            });
        },
        removeBriefcaseLink: function(briefcaseID) {
            var idx = _.find(this.obj.links, function(blink) {
                return blink.briefcase_id == briefcaseID;
            });
            if (idx === undefined) {
                return;
            }
            this.obj.links.splice(idx, 1);
            this.rerender();
            this.el.trigger('detailChanged');
        }
    });

    obviel.view({
        iface: 'cs-workflow-briefcase-link',
        obvtUrl: templates + 'briefcase_link.obvt',
        render: function() {
            var self = this;
            if (this.obj.modifyUrl) {
                $(this.el).find('label.checkbox input:checkbox').on(
                        'click',
                        function(ev) {
                            self.toggleCheckbox(ev);
                        });
            }
        },
        remove: function() {
            if (!this.obj.deleteUrl) {
                return;
            }
            return designerAjax(this, {
                type: 'POST',
                url: this.obj.deleteUrl,
                processData: false,
                dataType: 'json',
                contentType: 'application/json'
            }).done(this.collectionUpdate.bind(this));
        },
        collectionUpdate: function(data) {
            // Is there a better way?
            $(this.el).trigger('briefcaselinkDeleted', data);
        },
        changeMeaning: function(ev) {
            var self = this,
                value = $(ev.currentTarget).data('meaning');
            if (value == this.obj.meaning) {
              return;
            }
            designerAjax(self, {
                url: self.obj.modifyUrl,
                data: {attribute: 'meaning', value: value},
                dataType: 'json',
                type: 'POST',
                async: false,
                success: function(data) {
                    if (data) {
                        $.extend(self.obj, data);
                        // rerender constraint
                        self.el.rerender();
                    }
                },
                error: function() {
                    self.el.rerender();
                }
            });
        },
        checkModeButton: function (el) {
            if (this.obj.meaning == el.data('meaning')) {
                el.addClass("active");
            }
        },
    });

    obviel.view({
        iface: 'cs-workflow-briefcase-link-meanings',
        obvtUrl: templates + 'briefcase_link_meanings.obvt'
    });

    obviel.view({
        iface: 'cs-workflow-forms',
        obvtUrl: templates + 'forms.obvt',
        render: function() {
            // TODO on non-empty selection: fire operation + reload
            var self = this;
            $(this.el).find('.add-form').on(
                'click',
                function() {
                    $(this).trigger('openFormTemplateCatalog');
            }).on('formTemplateSelected', function(ev, data) {
                if (data.result.length && data.result[0].cdb_object_id) {
                    designerAjax(self, {
                        url: self.obj.addFormUrl,
                        data: {
                            cdb_process_id: self.cdb_process_id,
                            task_id: self.task_id,
                            form_template_id: data.result[0].cdb_object_id
                        },
                        dataType: 'json',
                        type: 'POST',
                        async: false,
                        success: function(data) {
                            if (data) {
                                self.obj.enabled = true;
                                self.el.rerender().done(function() {
                                    $(self.el)
                                        .closest(".wf-details")
                                        .find(".wf-briefcase-links")
                                        .trigger(
                                            "refreshLocalBriefcases",
                                            data.task_local_briefcases
                                    );
                                    $(".wf-sidebar").trigger(
                                        "refreshLocalBriefcases",
                                        {localBriefcases: data.sidebar_local_briefcases}
                                    );
                                });
                            }
                        }
                    });
                }
            });
        }
    });

    obviel.view({
        iface: 'cs-workflow-process-end',
        obvtUrl: templates + 'process_end.obvt'
    });

    obviel.view({
        iface: 'cs-workflow-description',
        obvtUrl: templates + 'description.obvt',
        render: function() {
            var self = this;
            if (this.obj.modifyUrl) {
                var descForm = $(this.el).find(
                    '.editable').editable(
                        function(value, settings) {
                            return modifyObject(
                                    self,
                                    self.obj.modifyUrl,
                                    'description',
                                    value,
                                    this.revert);
                        }, {
                            type: 'textarea',
                            placeholder: '-',
                            width: '90%',
                            callback: function(value, settings) {
                                descForm.attr('title', value);
                                if (value != this.revert) {
                                    self.obj.description = value;
                                    $(self.el).trigger('updateLayout');
                                }
                            },
                            onblur: 'submit'
                        }
                    );
            }
        }
    });

    obviel.view({
        iface: 'cs-workflow-parameters',
        obvtUrl: templates + 'parameters.obvt',
        before: function() {
          var maxParametersToShow = 2;
          this.obj.showAllParameters = this.obj.parameters.length <= maxParametersToShow;
        },
        expandDetails: function() {
          this.el.closest('.wf-task').find('.detail-actions .toggle-details').trigger('click');
        },
        updateIcon: function(ev, data) {
            // if first parameter has an icon, use it for the task
            if (data.parameters[0] && data.parameters[0].icon) {
                var parentSysTask = $($(ev.target).closest(".system-task-info")[0]).parentView();
                $.extend(parentSysTask.obj, {picture: data.parameters[0].icon});
                parentSysTask.rerender();
            }
        },
        render: function() {
            var self = this;
            if (this.obj.modifyUrl) {
                $(this.el).off('parameterChanged').on(
                        'parameterChanged',
                        '.parameter-list',
                        function(ev, data) {
                            designerAjax(self, {
                                url: self.obj.modifyUrl,
                                data: data,
                                dataType: 'json',
                                type: 'POST',
                                async: false,
                                success: function(data) {
                                    if (data) {
                                        $.extend(self.obj, data);
                                        self.updateIcon(ev, data);
                                    }
                                }
                            }).always(function() {
                                self.rerender();
                            });
                        });
            }
            if (this.obj.deleteUrl) {
                $(this.el).off('removeParameter').on(
                        'removeParameter',
                        '.parameter-list',
                        function(ev, data) {
                            designerAjax(self, {
                                url: self.obj.deleteUrl,
                                data: data,
                                dataType: 'json',
                                type: 'POST',
                                async: false,
                                success: function(data) {
                                    if (data) {
                                        $.extend(self.obj, data);
                                        self.updateIcon(ev, data);
                                    }
                                }
                            }).always(function() {
                                self.rerender();
                            });
                        });
            }
        }
    });

    obviel.view({
        iface: 'cs-workflow-error-message',
        obvtUrl: templates + 'error_message.obvt'
    });

    obviel.view({
        iface: 'cs-workflow-project',
        obvtUrl: templates + 'project.obvt',
        render: function() {
            var self = this;
            if (this.obj.setProjectUrl) {
              // project
              $(this.el).find('.project-action').on(
                  'click',
                  function() {
                      $(this).trigger('openProjectCatalog');
              }).on(
                    'projectSelected',
                    function(ev, data) {
                        if (data.result.length && data.result[0].cdb_project_id) {
                            designerAjax(self, {
                              url: self.obj.setProjectUrl,
                              data: {cdb_project_id: data.result[0].cdb_project_id.text},
                              dataType: 'json',
                              type: 'POST',
                              async: false,
                              success: function(data) {
                                  if (data) {
                                      $.extend(self.obj, data);
                                      self.rerender();
                                  }
                              }
                            });
                        }
              });
            }
      }
    });

    obviel.view({
        iface: 'cs-workflow-task-extension',
        obvtUrl: templates + 'task_extension.obvt',
        render: function() {
            var self = this;
            if (this.obj.modifyUrl) {
                $(this.el).off('extensionChanged').on(
                        'extensionChanged',
                        function(ev, data) {
                            designerAjax(self, {
                                url: self.obj.modifyUrl,
                                data: data,
                                dataType: 'json',
                                type: 'POST',
                                async: false,
                                success: function(data) {
                                    if (data) {
                                        $.extend(self.obj, data);
                                    }
                                }
                            }).always(function() {
                                self.rerender();
                            });
                        });
            }
        }
    });

    obviel.view({
      iface: 'cs-workflow-operation-dropdown',
      obvtUrl: templates + 'operation_dropdown.obvt'
    });

    var ieUnselectable = function() {
        // turn off selection behavior in IE 9 as user-select is not
        // supported yet
        var notSelectable = function(ev) {
            var target = $(ev.target);
            // we do want content of input boxes to be selectable
            if (target.closest('input').length !== 0 ||
                target.closest('textarea').length !== 0) {
                return;
            }
            return false;
        };

        $('.unselectable').on('selectstart', notSelectable);
        // XXX crazily enough .unselectable doesn't select wf-designer-toolbar
        // on IE 9, is this a bug in jquery?
        $('.wf-designer-toolbar').on('selectstart', notSelectable);
    };

    $(document).ready(function() {
        startWaiting();
        jsPlumb.ready(function() {
            $('.cs-workflow-designer').each(function() {
                $(this)
                    .render($(this).data('app_url'))
                    .done(function() {
                        stopWaiting();
                        ieUnselectable();
                        setTimeout(function() {
                            // load responsible catalog data after initial render
                            $('.cs-workflow-designer').trigger('projectSelected');
                        }, 0);
                    });
            });
        });
    });

    /*
     * Disable select when clicking on scrollbar
     */

    var RECT = function(top, left, bottom, right){
        this.top = top;
        this.left = left;
        this.bottom = bottom;
        this.right = right;
    };

    function inRect(rect, x, y){
        return (y >= rect.top && y <= rect.bottom) &&
            (x >= rect.left && x <= rect.right);
    }

    function inScrollRange(event){
        var viewport = $(event.currentTarget),
            x = event.pageX,
            y = event.pageY;

        var rV = new RECT(
            /*top=*/ viewport.offset().top,
            /*left=*/ viewport.offset().left,
            /*bottom=*/ viewport.offset().top + viewport[0].clientHeight,
            /*right=*/ viewport.offset().left + viewport[0].clientWidth
        );

        return !inRect(rV, x, y);
    }

}(jQuery, obviel));
