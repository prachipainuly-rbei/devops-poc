# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

__revision__ = "$Id: "
__docformat__ = "restructuredtext en"

from collections import defaultdict

from cdb import sqlapi
from cdb import util
from cdb.lru_cache import lru_cache
from cdb.objects import ByID
from cdb.platform.mom import operations

from cs.workflow.forms import Form
from cs.workflow.processes import Process
from cs.workflow.protocols import Protocol
from cs.workflow.tasks import Task
from cs.workflow.tasks import SystemTask
from cs.workflow.taskgroups import ParallelTaskGroup
from cs.workflow.taskgroups import SequentialTaskGroup
from cs.workflow.taskgroups import ProcessCompletionTaskGroup
from cs.workflow.briefcases import Briefcase
from cs.workflow.briefcases import BriefcaseLink
from cs.workflow.briefcases import FolderContent
from cs.workflow.briefcases import IOType
from cs.workflow.constraints import Constraint
from cs.workflow.schemacomponents import SchemaComponent
from cs.workflow.designer import router
from cs.workflow.designer import urls
from cs.workflow.designer import wfinterface
from cs.workflow.webforms.main import MOUNTEDPATH

from cs.workflow.misc import get_pydate_format
from cs.workflow.misc import get_state_text

PROCESS_COMPLETION = "cdbwf_aggregate_proc_completion"


@lru_cache(maxsize=1)
def check_access_proactively_enabled():
    """
    Returns ``True`` if the Designer should check write access for objects
    before rendering. This has performance implications and is discouraged.

    If the value of personal setting ``cs.workflow.designer`` /
    ``check_access_proactively`` is ``"1"``, the access checks are made.
    Otherwise, interactive elements just assume write access is granted (it is
    checked before actually doing something anyway).
    """
    settings = util.PersonalSettings()
    settings.invalidate()
    result = settings.getValueOrDefault(
        "cs.workflow.designer",
        "check_access_proactively",
        "1"
    )
    return result == "1"


def check_access_proactively(obj, access):
    """
    Returns ``True`` if the user is granted ``access`` on ``obj``. If proactive
    access checking is disabled for the user, no access is checked and ``True``
    is returned anyway. See ``check_access_proactively_enabled`` for details.
    """
    if check_access_proactively_enabled():
        return obj.CheckAccess(access)
    return True


@lru_cache(maxsize=None)
def get_cached_briefcase_contents(page, cdb_object_id):
    obj = ByID(cdb_object_id)
    if obj and obj.CheckAccess("read"):
        return get_briefcase_contents(page, obj)


def load_process_data(page, cdb_process_id):
    """
    Load all process data in as few database queries as possible and return an
    indexed data structure to access data in-memory.

    .. warning ::
        Because read access is not limited in the default configuration of
        ``cs.workflow``, it is only checked for the workflow itself and
        briefcase contents, not for other related objects, including but not
        limited to tasks, constraints and forms.

    Returns a dictionary with the following keys:

    +--------------------+-------------------------------------------------------+
    | Key                | Contents                                              |
    +====================+=======================================================+
    | process            | The root ``cs.workflow.processes.Process`` object     |
    +--------------------+-------------------------------------------------------+
    | components         | "Flat" ``ObjectCollection`` of all process components |
    +--------------------+-------------------------------------------------------+
    | forms              | Dict of ``Forms`` indexed by ``task_id`` values       |
    +--------------------+-------------------------------------------------------+
    | constraints        | Dict of ``Constraints`` indexed by ``task_id``        |
    +--------------------+-------------------------------------------------------+
    | briefcases         | Dict of ``Briefcases`` indexed by ``briefcase_id``    |
    +--------------------+-------------------------------------------------------+
    | briefcase_links    | Dict of ``BriefcaseLinks`` indexed by ``task_id``     |
    +--------------------+-------------------------------------------------------+
    | briefcase_contents | Dict of ``Objects`` indexed by briefcase object IDs   |
    +--------------------+-------------------------------------------------------+
    """
    cdb_process_id = sqlapi.quote(cdb_process_id)
    process = Process.ByKeys(cdb_process_id)

    if not process or not process.CheckAccess("read"):
        return {"process": None}

    query = {"cdb_process_id": cdb_process_id}

    def _load(cls, indexed_by=None, **kwargs):
        query_args = dict(query)
        query_args.update(kwargs)
        data = cls.KeywordQuery(**query_args)
        if indexed_by:
            result = defaultdict(list)
            for x in data:
                result[x[indexed_by]].append(x)
            return result
        else:
            return data

    get_cached_briefcase_contents.cache_clear()
    briefcases = _load(Briefcase)
    bc_contents = defaultdict(list)

    for x in FolderContent.KeywordQuery(
            cdb_folder_id=briefcases.cdb_object_id):
        content = get_cached_briefcase_contents(page, x.cdb_content_id)
        if content:
            bc_contents[x.cdb_folder_id].append(content)

    return {
        "process": process,
        "components": _load(SchemaComponent, order_by="position"),
        "forms": _load(Form, "task_id"),
        "constraints": _load(Constraint, "task_id"),
        "briefcases": {b.briefcase_id: b for b in briefcases},
        "briefcase_links": _load(BriefcaseLink, "task_id"),
        "briefcase_contents": bc_contents,
    }


def get_process_structure(page, data):
    components = data["components"]

    # pass 1: index components by task_id
    nodes = {c.task_id: get_component_data(page, c, data) for c in components}
    # pass 2: create trees and parent-child relations
    result = {
        "main": [],
        "completion": [],
    }

    for c in components:
        node = nodes[c.task_id]
        # either make the node a new tree or link it to its parent
        if not c.parent_id:
            if c.cdb_classname == PROCESS_COMPLETION:
                forest = result["completion"]
            else:
                forest = result["main"]

            # start a new tree in the forest
            forest.append(node)
        else:
            # add new_node as child to parent
            nodes[c.parent_id]["components"].append(node)

    return result


def get_graph_data(page, data):
    process = data["process"]
    structure = get_process_structure(page, data)
    components = structure["main"]
    have_main_components = bool(components)

    # if there are no main components, we let the user add a new task
    if not have_main_components:
        components.append(make_new_task_component(page, process))

    components.append(make_process_end(page, process))

    # there _should_ always be a completion task, but we don't enforce it
    completion = structure["completion"]
    if completion and completion[0]["components"]:
        components.append(completion[0])

    # TODO: the path is double defined by router registration and here
    cdb_process_id = process.cdb_process_id
    return {
        "iface": "cs-workflow-graph",
        "cdb_process_id": cdb_process_id,
        "components": components,
        "allowedOperationsUrl": page.make_link(
            [cdb_process_id, "allowed_operations"]
        ),
        "operationUrl": page.make_link([cdb_process_id, "create_task"]),
        "removeUrl": page.make_link([cdb_process_id, "remove_task"]),
    }


def clean_text(txt):
    if txt is None:
        return ""
    return txt


def get_task_status_style(obj):
    if obj.status == obj.EXECUTION.status:
        return "status-execution"
    elif obj.status == obj.COMPLETED.status:
        return "status-completed"
    elif obj.status == obj.REJECTED.status:
        return "status-rejected"
    elif obj.status == obj.DISCARDED.status:
        return "status-discarded"
    return ""


def make_node(page, component, **kwargs):
    node = {"iface": "cs-workflow-node"}
    node.update(kwargs)
    node["task"] = component
    return node


def get_constraints(page, obj, readonly=False, data=None):
    # currently only task constraints
    constraints = []

    if data is None:  # use cdb.objects - slow
        obj_constraints = obj.Constraints
    else:  # use pre-fetched objects
        obj_constraints = data["constraints"].get(obj.task_id, [])

    for constraint in obj_constraints:
        constraints.append(get_constraint_data(page, constraint))

    if check_access_proactively(obj, "edit schema"):
        add_url = page.make_link([
            obj.cdb_process_id,
            "tasks",
            obj.task_id,
            "add_constraint",
        ])
    else:
        add_url = ""

    return {
        "iface": "cs-workflow-constraints",
        "constraints": constraints,
        "addConstraintUrl": add_url,
    }


def get_constraint_data(page, constraint, readonly=False):
    result = {
        "iface": "cs-workflow-constraint",
        "rule_name": constraint.rule_name,
        "invert_rule": constraint.invert_rule,
        "briefcase_id": clean_text(constraint.briefcase_id),
        "briefcase_name": clean_text(constraint.briefcase_name),
        "modifyUrl": "",
        "deleteUrl": "",
    }
    if not readonly:
        save_granted = check_access_proactively(constraint, "save")
        delete_granted = check_access_proactively(constraint, "delete")

        result.update({
            "modifyUrl": page.make_link([
                constraint.cdb_process_id,
                "tasks",
                constraint.task_id,
                "constraints",
                constraint.cdb_object_id,
                "modify",
            ]) if save_granted else "",
            "deleteUrl": page.make_link([
                constraint.cdb_process_id,
                "tasks",
                constraint.task_id,
                "constraints",
                constraint.cdb_object_id,
                "delete",
            ]) if delete_granted else "",
        })
    return result


def get_component_data(page, obj, data=None):
    result = None

    if isinstance(obj, Task):
        # wrap the node for layouts
        result = get_task_data(page, obj, data)
    elif isinstance(obj, ParallelTaskGroup):
        result = get_parallel_data(page, obj, data)
    elif isinstance(obj, SequentialTaskGroup):
        result = get_sequential_data(page, obj, data)
    elif isinstance(obj, ProcessCompletionTaskGroup):
        result = get_completion_data(page, obj, data)
    elif isinstance(obj, Process):
        if data is None:
            # SLOW; will reload the whole process
            # used to get results of write operations
            data = load_process_data(page, obj.cdb_process_id)
        # wrap the node for layouts
        result = get_graph_data(page, data)
    return result


def get_responsible_info(page, obj, save_granted=None):
    if save_granted is None:
        save_granted = check_access_proactively(obj, "save")

    result = {
        "iface": "cs-workflow-responsible",
        "setResponsibleUrl": page.make_link([
            obj.cdb_process_id,
            "tasks",
            obj.task_id,
            "set_responsible",
        ]) if save_granted else "",
    }
    return dict(result, **obj.GetResponsiblePersonInfo())


def get_description(page, obj, **url_dict):
    return {
        "iface": "cs-workflow-description",
        "description": obj.description if obj.description else "",
        "modifyUrl": url_dict.get("modify", ""),
    }


def _get_deadline(obj):
    return obj.deadline.strftime(get_pydate_format()) if obj.deadline else ""


def get_task_info(page, obj, **kwargs):
    task_info = {
        "modifyUrl": kwargs["modify"],
        "schemaEditable": kwargs["schemaEditable"],
        "icon": obj.GetObjectIcon(),
    }
    if isinstance(obj, SystemTask):
        task_info.update({
            "iface": "cs-workflow-systemtask-info",
            "type_desc": unicode(obj.Definition.GetDescription()),
            "picture": obj.get_system_task_icon(),
            "parameters": get_parameters(
                page,
                obj,
                edit_schema_granted=kwargs["schemaEditable"]
            ),
        })
    else:
        task_info.update({
            "iface": "cs-workflow-task-info",
            "type_desc": unicode(obj.mapped_classname),
            "responsible": kwargs["responsible"],
            "deadline": kwargs["deadline"],
            "cdb_status_txt": kwargs["cdb_status_txt"],
        })
    return task_info


def get_task_fields(page, obj, **kwargs):
    task_fields = {
        "modifyUrl": kwargs["modify"],
        "schemaEditable": kwargs["schemaEditable"],
        "description": get_description(page, obj, modify=kwargs["modify"]),
    }
    if obj.isSystemTask():
        task_fields.update({
            "iface": "cs-workflow-systemtask-fields",
            "uses_global_maps": int(bool(obj.uses_global_maps)),
        })
    else:
        task_fields.update({
            "iface": "cs-workflow-task-fields",
            "responsible": kwargs["responsible"],
            "deadline": kwargs["deadline"],
            "max_duration": obj.max_duration if obj.max_duration else "",
            "cdb_status_txt": kwargs["cdb_status_txt"],
            "has_finish_option": False,
        })
        if util.get_prop("wffo") == "true":
            task_fields.update({
                "has_finish_option": (
                    obj.isApprovalTask() or obj.isExaminationTask()
                ),
                "finish_option": int(bool(obj.finish_option)),
            })
    return task_fields


def get_parameters(page, task, readonly=False, edit_schema_granted=None):
    if not task.isSystemTask() or not task.Definition:
        return None
    defid = task.Definition.name
    handler = router.handle_request(page, ["parameter_extensions", defid])
    if handler is None:
        return {
            "iface": "cs-workflow-parameters",
            "parameters": [],
        }
    plabel = handler.get("label", "")
    plist_class = handler.get("parameter_list_class", "")
    parameters = []
    if "getter" in handler:
        parameters = handler["getter"](page, task, readonly)
    result = {
        "iface": "cs-workflow-parameters",
        "label": plabel,
        "plist_class": plist_class,
        "parameters": parameters,
        "modifyUrl": "",
        "deleteUrl": "",
    }
    if not readonly:
        if edit_schema_granted is None:
            edit_schema_granted = check_access_proactively(task, "edit schema")
        result.update({
            "modifyUrl": page.make_link([
                task.cdb_process_id,
                "tasks",
                task.task_id,
                "modify_parameter",
            ]) if edit_schema_granted else "",
            "deleteUrl": page.make_link([
                task.cdb_process_id,
                "tasks",
                task.task_id,
                "delete_parameter",
            ]) if edit_schema_granted else "",
        })
    return result


def get_task_extension(page, task, readonly=False, save_granted=None):
    extension_object = None
    if hasattr(task, "getExtensionObject"):
        extension_object = task.getExtensionObject()
        if extension_object:
            extension_name = extension_object.getDesignerExtensionName()
            handler = router.handle_request(
                page,
                ["task_extension", extension_name],
            )
            if handler and "getter" in handler:
                result = {
                    "iface": "cs-workflow-task-extension",
                    "title": extension_object.getExtensionAreaTitle(),
                    "icon": extension_object.getExtensionIcon(),
                }
                result.update({
                    "extension_object": handler["getter"](
                        page,
                        extension_object,
                        readonly,
                    ),
                })
                modify_url = ""
                if not readonly:
                    if save_granted is None:
                        save_granted = check_access_proactively(task, "save")
                    if save_granted:
                        modify_url = page.make_link([
                            task.cdb_process_id,
                            "tasks",
                            task.task_id,
                            "modify_extension"
                        ])
                result.update({
                    "modifyUrl": modify_url,
                    "readonly": readonly,
                })
                return result
    return None


def get_task_data(page, obj, data):
    save_granted = check_access_proactively(obj, "save")
    edit_schema_granted = check_access_proactively(obj, "edit schema")
    delete_granted = check_access_proactively(obj, "delete")

    shared_vals = {
        "save_granted": save_granted,
        "schemaEditable": edit_schema_granted,
        "modify": page.make_link([
            obj.cdb_process_id,
            "tasks",
            obj.task_id,
            "modify",
        ]) if save_granted else "",
        "responsible": get_responsible_info(page, obj, save_granted),
        "deadline": _get_deadline(obj),
        "cdb_status_txt": get_state_text(obj.cdb_objektart, obj.status),
    }

    result = {
        "iface": "cs-workflow-task",
        "components": [],
        "modifyUrl": shared_vals["modify"],
        "title": obj.title,
        "task_id": obj.task_id,
        "statusStyle": get_task_status_style(obj),
        "status": obj.status,
        "constraints": get_constraints(page, obj, data=data),
        "forms": get_task_forms(page, obj, data),
        "briefcaselinks": get_briefcase_links(page, obj, data),
        "taskDeletable": delete_granted,
        "schemaEditable": edit_schema_granted,
        "info": get_task_info(page, obj, **shared_vals),
        "fields": get_task_fields(page, obj, **shared_vals),
        "task_extension": get_task_extension(
            page,
            obj,
            save_granted=save_granted
        ),
    }

    result = make_node(page, result)
    result["id"] = obj.task_id
    return result


def get_parallel_data(page, obj, data):
    return {
        "task_id": obj.task_id,
        "components": [],
        "iface": "cs-workflow-parallel",
        "constraints": get_constraints(page, obj, data=data),
    }


def get_sequential_data(page, obj, data):
    return {
        "task_id": obj.task_id,
        "components": [],
        "iface": "cs-workflow-sequential",
    }


def get_completion_data(page, obj, data):
    result = get_parallel_data(page, obj, data)
    result["isCompletion"] = True
    return result


def get_briefcase_contents(page, cnt):
    # the delete url for each content would not be generated:
    # - content object is out of scope of workflow designer:
    #   it is not the reference, but the real object
    # - the "global_briefcases" or "local_briefcases" part differs
    return {
        "iface": "cs-workflow-briefcase-content",
        "content_object_id": cnt.GetObjectID(),
        "icon": cnt.GetObjectIcon(),
        "description": cnt.GetDescription(),
        "url": urls.get_object_url(cnt),
        "deletable": False,  # may be overridden later on
        "operations": get_briefcase_content_operations(page, cnt),
    }


def get_contents_for_briefcase(page, briefcase, data, deletable=False):
    result = []

    if data is None:
        contents = []
        for x in FolderContent.KeywordQuery(
                cdb_folder_id=briefcase.cdb_object_id):
            content = get_cached_briefcase_contents(page, x.cdb_content_id)
            if content:
                contents.append(content)
    else:
        contents = data["briefcase_contents"].get(briefcase.cdb_object_id, [])

    for cnt in contents:
        cnt_data = dict(cnt)
        cnt_data["deletable"] = deletable
        result.append(cnt_data)

    return result


def get_briefcase_content_operations(page, obj):
    oplist = []
    opdata = page.application.getOptions()["operations"]
    for op in opdata.get_object_operations_for_context(obj):
        # TODO wait for E045377 for supporting other operations
        if op["info"].get_opname() == "CDB_ShowObject":
            oplist.append({
                "url": urls.get_object_url(obj),
                "tooltip": op["tooltip"],
                "icon": op["icon"],
                "label": op["fullpath_label"],
            })
    return {
        "iface": "cs-workflow-operation-dropdown",
        "oplist": oplist,
    }


def get_global_briefcase(page, obj, data=None):
    bc = obj.Briefcase
    modify_url = page.make_link([
        obj.cdb_process_id,
        'global_briefcases',
        bc.briefcase_id,
        'modify',
    ])
    set_meaning_url = page.make_link([
        obj.cdb_process_id,
        'global_briefcases',
        bc.briefcase_id,
        'setmeaning',
    ])
    delete_url = page.make_link([
        obj.cdb_process_id,
        'global_briefcases',
        bc.briefcase_id,
        'delete',
    ])
    ac_url = page.make_link([
        obj.cdb_process_id,
        'global_briefcases',
        bc.briefcase_id,
        'add_content',
    ])
    dc_url = page.make_link([
        obj.cdb_process_id,
        'global_briefcases',
        bc.briefcase_id,
        'delete_content',
    ])
    return {
        "iface": "cs-workflow-global-briefcase",
        "briefcase_id": bc.briefcase_id,
        "name": bc.name,
        "iotype": obj.iotype,
        "meaning": IOType(obj.iotype).name,
        "icon": obj.GetObjectIcon(),
        "modifyUrl": modify_url,
        "setMeaningUrl": set_meaning_url,
        "addContentUrl": ac_url,
        "deleteUrl": delete_url,
        "deleteContentUrl": dc_url,
        "contents": get_contents_for_briefcase(page, bc, data, bool(dc_url)),
    }


def get_global_briefcases(page, process, data=None):
    if data is None:
        global_links = process.BriefcaseLinks
    else:
        global_links = data["briefcase_links"].get("", [])

    return {
        "iface": "cs-workflow-global-briefcases",
        "briefcases": [
            get_global_briefcase(page, l, data) for l in global_links
        ],
        "addUrl": page.make_link(
            [process.cdb_process_id, "create_global_briefcase"]
        ),
    }


def get_local_briefcase(page, obj, data=None):
    modify_url = page.make_link([
        obj.cdb_process_id,
        'local_briefcases',
        obj.briefcase_id,
        'modify',
    ])
    delete_url = page.make_link([
        obj.cdb_process_id,
        'local_briefcases',
        obj.briefcase_id,
        'delete',
    ])
    ac_url = page.make_link([
        obj.cdb_process_id,
        'local_briefcases',
        obj.briefcase_id,
        'add_content',
    ])
    dc_url = page.make_link([
        obj.cdb_process_id,
        'local_briefcases',
        obj.briefcase_id,
        'delete_content',
    ])
    return {
        "iface": "cs-workflow-local-briefcase",
        "briefcase_id": obj.briefcase_id,
        "name": obj.name,
        "icon": obj.GetObjectIcon(),
        "modifyUrl": modify_url,
        "addContentUrl": ac_url,
        "deleteUrl": delete_url,
        "deleteContentUrl": dc_url,
        "contents": get_contents_for_briefcase(page, obj, data, True),
    }


def get_local_briefcases(page, process, data=None):
    if data is None:
        briefcases = process.GetLocalBriefcases()
    else:
        global_links = [
            l.briefcase_id for l in data["briefcase_links"].get("", [])
        ]
        briefcases = [
            b for b in data["briefcases"].values()
            if b.briefcase_id not in global_links
        ]

    return {
        "iface": "cs-workflow-local-briefcases",
        "briefcases": [
            get_local_briefcase(page, b, data) for b in briefcases
        ],
        "addUrl": page.make_link([
            process.cdb_process_id,
            "create_local_briefcase",
        ]),
    }


def get_sidebar(page, data):
    process = data["process"]
    return {
        "iface": "cs-workflow-sidebar",
        "briefcases": get_briefcases(page, process, data),
        "process_object_id": process.cdb_object_id,
    }


def get_briefcases(page, process, data=None):
    return {
        "iface": "cs-workflow-briefcases",
        "globalBriefcases": get_global_briefcases(page, process, data),
        "localBriefcases": get_local_briefcases(page, process, data),
    }


def get_task_forms(page, task, data=None):
    if data is None:
        forms = task.AllForms
    else:
        forms = data["forms"].get("task_id", [])

    if check_access_proactively(task, "edit schema"):
        add_url = page.make_link([
            task.cdb_process_id,
            "tasks",
            task.task_id,
            "add_form",
        ])
    else:
        add_url = ""

    display_url = "{}/{}".format(MOUNTEDPATH, task.cdb_object_id)

    return {
        "iface": "cs-workflow-forms",
        "enabled": len(forms) > 0,
        "displayFormLabel": util.get_label("cdbwf_display_forms"),
        "displayFormUrl": display_url,
        "addFormLabel": util.get_label("cdbwf_add_form"),
        "addFormUrl": add_url,
    }


def get_briefcase_links(page, task, data=None):
    if data is None:
        links = task.BriefcaseLinksByType.all()
    else:
        links = data["briefcase_links"].get(task.task_id, [])

    edit_schema_granted = check_access_proactively(task, "edit schema")

    if edit_schema_granted:
        add_url = page.make_link([
            task.cdb_process_id,
            "tasks",
            task.task_id,
            "link_briefcase",
        ])
    else:
        add_url = ""

    return {
        "iface": "cs-workflow-briefcase-links",
        "links": [
            get_briefcase_link(page, l, edit_schema_granted) for l in links
        ],
        "addUrl": add_url,
    }


def get_briefcase_link(page, brlink, edit_schema_granted=None):
    result = {
        "iface": "cs-workflow-briefcase-link",
        "briefcase_name": unicode(brlink.briefcase_name),
        "briefcase_id": brlink.briefcase_id,
        "icon": brlink.GetObjectIcon(),
        "iotype": brlink.iotype,
        "meaning": IOType(brlink.iotype).name,
        "deleteUrl": "",
        "modifyUrl": "",
    }
    if edit_schema_granted is None:
        edit_schema_granted = brlink.Task.CheckAccess("edit schema")

    if edit_schema_granted:
        result.update({
            "deleteUrl": page.make_link([
                brlink.cdb_process_id,
                "tasks",
                brlink.task_id,
                "briefcaselinks",
                brlink.briefcase_id,
                "delete",
            ]),
            "modifyUrl": page.make_link([
                brlink.cdb_process_id,
                "tasks",
                brlink.task_id,
                "briefcaselinks",
                brlink.briefcase_id,
                "modify",
            ]),
        })
    return result


def get_project_data(page, process):
    pcs_installed = wfinterface._is_pcs_enabled()
    result = {
        "iface": "cs-workflow-project",
        "pcs_installed": pcs_installed,
        "cdb_project_id": clean_text(process.cdb_project_id),
        "description": "",
        "link": "",
        "setProjectUrl": "",
    }

    if pcs_installed and hasattr(process, "Project"):
        if process.Project:
            result.update({
                "description": clean_text(process.Project.GetDescription()),
                "link": urls.get_object_url(process.Project),
            })

        result["setProjectUrl"] = page.make_link(
            [process.cdb_process_id, "set_project"]
        )

    return result


def get_app_data(page, cdb_process_id):
    data = load_process_data(page, cdb_process_id)
    process = data["process"]

    if not process:
        return {
            "iface": "cs-workflow-designer-no-process",
            "processId": cdb_process_id,
        }

    edit_schema_granted = check_access_proactively(process, "edit schema")
    process_manage_granted = process.CheckAccess("process manage")

    actions = {
        "iface": "cs-workflow-actions",
        "addTask": edit_schema_granted,
        "selectTaskTip": util.get_label("cdbwf_select_task_tip"),
        "addCompletion": edit_schema_granted,
        "protocol": None,
    }

    if process_manage_granted:
        if process.isActivatable():
            actions["startUrl"] = page.make_link([cdb_process_id, "start"])
        else:
            if process.isHoldableOrCancelable():
                actions.update({
                    "onHoldUrl": page.make_link([cdb_process_id, "hold"]),
                    "cancelUrl": page.make_link([cdb_process_id, "cancel"]),
                    "cancelConfirmHeader": util.get_label("cdbwf_confirm"),
                    "cancelConfirmText": util.get_label(
                        "cdbwf_confirm_cancel_workflow"
                    ),
                    "cancelOK": util.get_label("cdbwf_yes"),
                    "cancelNO": util.get_label("cdbwf_no"),
                })
            elif process.isDismissable():
                actions.update({
                    "dismissUrl": page.make_link([cdb_process_id, "dismiss"]),
                    "cancelConfirmHeader": util.get_label("cdbwf_confirm"),
                    "dismissConfirmText": util.get_label(
                        "cdbwf_confirm_dismiss_workflow"
                    ),
                })

    try:
        op_info = operations.OperationInfo(
            Protocol._getClassname(),
            "CDB_Search"
        )
        disable = not op_info.is_visible()
    except AttributeError:
        disable = True

    if not disable:
        protocol_url = urls.get_protocol_url(cdb_process_id)
        actions["protocol"] = {
            "url": protocol_url,
            "img": Protocol.GetClassIcon(),
            "tooltip": util.get_label("cdbwf_rp2prot"),
        }

    modifyUrl = page.make_link([cdb_process_id, "modify"])
    project = get_project_data(page, process)

    return {
        "iface": "cs-workflow-designer",
        "title": process.title,
        "pcs_installed": project.get('pcs_installed', False),
        "project": project,
        "description": get_description(page, process, modify=modifyUrl),
        "icon": process.GetObjectIcon(),
        "cdb_status_txt": get_state_text(process.cdb_objektart, process.status),
        "graph": get_graph_data(page, data),
        "sidebar": get_sidebar(page, data),
        "modifyUrl": modifyUrl,
        "actions": actions,
        "autoScale": True,
    }


def make_new_task_component(page, process):
    return make_node(
        page,
        {"iface": "cs-workflow-new-task"},
        nonselectable=1,
    )


def make_process_end(page, process):
    return make_node(
        page,
        {"iface": "cs-workflow-process-end"},
        nonselectable=1,
    )
