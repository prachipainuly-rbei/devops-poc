#!/usr/bin/env powerscript
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Module cs.workflow.designer.catalogs
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: catalogs.py 177730 2018-05-28 11:49:04Z cso $"

import re
import json
from cdb import misc
from cdb import sig
from cdb import sqlapi
from cdb.objects.org import CommonRole
from cs.shared.elink_plugins import catalog
from cs.workflow.processes import Process
from cs.workflow.designer import wfinterface
from cs.workflow.misc import ResponsibleBrowserEntry

CATALOG_CONDITION = sig.signal()


class CatalogWithCustomizableCondition(object):
    """
    Catalogs of this class allow for customizing the default search conditions
    which are not accessible to the user.

    Provide custom conditions by connecting to the ``cdb.sig.signal``
    ``cs.worklfow.designer.catalogs.CATALOG_CONDITION``. Your functions will
    receive a single parameter containing the fully-qualified Python name of
    the calling catalog instance and is expected to return a list or set.

    If you provide any custom conditions for a catalog, the default conditions
    will be ignored. Include the default conditions in your custom conditions
    if you want to keep them.

    Usage examples:

    .. code-block:: python

        from cdb import sig
        from cs.workflow.designer.catalogs import CATALOG_CONDITION

        @sig.connect(CATALOG_CONDITION)
        def custom_catalog_condition(fqpyname):
            if fqpyname == "cs.workflow.designer.catalogs.ConstraintsCatalog":
                return ["cdb_module_id='my.constrs'", "name LIKE 'wf-designer:%'"]

            if fqpyname == "cs.workflow.designer.catalogs.FormTemplateCatalog":
                return ["status = 20"]

            if fqpyname == "cs.workflow.designer.catalogs.OperationCatalog":
                return ["inactive=0 OR inactive IS NULL"]

        @sig.connect(CATALOG_CONDITION)
        def another_condition(fqpyname):
            if fqpyname == "cs.workflow.designer.catalogs.FormTemplateCatalog":
                return ["mask_name != 'forbidden'"]

    """
    __default_conditions__ = []

    @property
    def __catalog_rules_conditions__(self):
        fqpyname = "{}.{}".format(self.__module__, self.__class__.__name__)
        custom_conditions = set()

        for result in sig.emit(CATALOG_CONDITION)(fqpyname):
            if isinstance(result, (list, set)):
                custom_conditions.update(result)
            else:
                misc.log_error("ignoring non-list/non-set "
                               "catalog search condition '{}'".format(result))

        return custom_conditions or self.__default_conditions__


class ResponsiblePerson(object):
    """
    Person data for responsible catalog
    """
    def __getitem__(self, name):
        try:
            return self.__dict__.__getitem__(name)
        except KeyError:
            return ""

    def match(self, condition):
        for key, value in condition.items():
            if self[key].lower().find(value.lower()) < 0:
                return False
        return True


class ResponsibleCatalog(catalog.ElinkResponsibleCatalog):

    __catalog_name__ = "cdbwf_resp_browser"

    def get_table_def(self, **varkw):
        from cdb.platform.gui import Table
        table = Table.KeywordQuery(name=self.__catalog_name__).pop()
        table_def = {"searchable": True,
                     "columns": []}
        # visible = table.Attributes.Query("visible_len>0").attribut
        for col in table.Attributes.KeywordQuery(itemtype="Value"):
            attr_dict = {}
            attr_dict["label"] = col.Label[""]
            attr_dict["attribute"] = col.attribut
            attr_dict["type"] = catalog.CatalogTools.get_field_type(sqlapi.SQL_CHAR)
            attr_dict["visible"] = col.visible_len > 0 and col.anzeigen == 1
            attr_dict["searchable"] = attr_dict["visible"]
            table_def["columns"].append(attr_dict)
        # Fix filter problem with invisible columns(show them at the end)
        table_def["columns"].sort(key=lambda x: not x["visible"])
        return table_def

    def get_catalog_title(self, **varkw):
        from cdb.platform.gui import Browser
        return Browser.ByKeys(self.__catalog_name__).Label[""]

    def _wrap_person(self, person):
        result = ResponsiblePerson()
        result.__dict__.update({
            "subject_id": person["personalnummer"],
            "description": person["name"],
            "subject_type": "Person",
            "subject_name": person["name"],
            "order_by": "1"
        })
        return result

    def _extract_person_from_role(self, role, search_condition):
        result = []
        for person in role.Owners:
            wrapped = self._wrap_person(person)
            if wrapped.match(search_condition):
                result.append(wrapped)
            result.sort(key=lambda x: x["description"])
        return result

    def get_data(self, **varkw):
        cdb_process_id = varkw.get("cdb_process_id", "")
        subject_id = ""
        subject_type = ""
        plugin_condition = varkw.get("catalog_plugin_conditions", None)
        if plugin_condition:
            parsed = {}
            try:
                parsed = json.loads(plugin_condition)
                subject_id = parsed.get("subject_id", "")
                subject_type = parsed.get("subject_type", "")
            except Exception:
                pass
        search_cond = {}
        if "catalog_search_conditions" in varkw:
            try:
                search_cond = json.loads(varkw["catalog_search_conditions"])
            except ValueError, e:
                from cdb import misc
                misc.cdblogv(
                    misc.kLogErr,
                    7,
                    "Error by parsing catalog search conditions: %s" % e)

        result = []
        process = Process.ByKeys(cdb_process_id)
        if process:
            if subject_type == 'Common Role':
                role = CommonRole.ByKeys(role_id=subject_id)
                if role:
                    result = self._extract_person_from_role(role, search_cond)
            elif subject_type == 'PCS Role':
                if hasattr(process, 'Project') and process.Project:
                    role = process.Project.RolesByID[subject_id]
                    if role:
                        result = self._extract_person_from_role(role, search_cond)
            # Person or nothing (field empty)
            else:
                # search multilanguage fields not existing in the db...
                for attr, attr_name_getter in [
                    ("subject_name", ResponsibleBrowserEntry.SubjectNameAttr),
                    ("description", ResponsibleBrowserEntry.DescriptionAttr),
                ]:
                    if attr in search_cond:
                        search_cond[attr_name_getter()] = search_cond[attr]
                        del search_cond[attr]

                varkw["catalog_search_conditions"] = json.dumps(search_cond)
                result = process.GetSubjectCandidates(
                    catalog.CatalogTools.get_search_conditions(**varkw))
        return result

    def render(self, context, **varkw):
        # TODO: check access(only access for workflow designer/responsible)
        result = super(ResponsibleCatalog, self).render(context, **varkw)
        if len(result["datalist"]) and \
           isinstance(result["datalist"][0], ResponsiblePerson):
            result["datalist"] = self._data_wrapper(self.__table_def__,
                                                    result["datalist"])
        return result

    def make_responsible_id(self, data):
        return re.sub("[^0-9a-zA-Z]+",
                      "_",
                      "%s_%s" % (data["subject_type"], data["subject_id"]))

    def _data_wrapper(self, table_def, datalist):
        new_datalist = []
        if table_def and "columns" in table_def:
            for data in datalist:
                new_data = []
                for column_def in table_def["columns"]:
                    result = {"name": column_def["attribute"],
                              "text": data[column_def["attribute"]]}
                    new_data.append(result)
                new_data.insert(0, {"name": "_description",
                                    "text": ""})
                new_data.insert(0, {"name": "_id",
                                    "text": self.make_responsible_id(data)})
                new_datalist.append(new_data)
        return new_datalist


class ConstraintsCatalog(catalog.ElinkCatalogStandard,
                         CatalogWithCustomizableCondition):

    __catalog_table_name__ = "cdb_pyrule"
    __catalog_table_class__ = "cdb_pyrule"
    __catalog_table_searchable__ = ["name", "description"]
    __default_conditions__ = ["name LIKE 'wf-designer:%'"]

    def get_data(self, **varkw):
        # TODO: check access(only access for workflow designer/responsible)
        cond = catalog.CatalogTools.get_search_conditions(**varkw)
        from cdb.objects import Rule

        if "all_rules" in varkw:
            return Rule.Query(cond)

        fcondition = reduce(lambda x, y: "(%s) OR (%s)" % (x, y),
                            self.__catalog_rules_conditions__)
        return Rule.Query("(%s) AND (%s)" % (cond, fcondition))

    def get_table_def(self, **varkw):
        result = super(ConstraintsCatalog, self).get_table_def(**varkw)
        result["columns"] = [col for col in result["columns"]
                             if col["attribute"] != "cdb_module_id"]
        return result

    def _data_wrapper(self, table_def, datalist):
        new_datalist = []
        if table_def and "columns" in table_def:
            for data in datalist:
                new_data = []
                for column_def in table_def["columns"]:
                    result = {"name": column_def["attribute"],
                              "text": data[column_def["attribute"]]}
                    new_data.append(result)
                new_data.insert(0, {"name": "_description",
                                    "text": ""})
                new_data.insert(0, {"name": "_id",
                                    "text": data.ID()})
                new_datalist.append(new_data)
        return new_datalist


class FormTemplateCatalog(catalog.ElinkCatalogStandard,
                          CatalogWithCustomizableCondition):
    __catalog_table_name__ = "cdbwf_form_template"
    __catalog_table_class__ = "cdbwf_form_template"
    __catalog_table_searchable__ = ["mask_name"]
    # FIXME "name" should be searchable, but multilanguage is not supported
    __default_conditions__ = ["status = 20"]

    def get_data(self, **varkw):
        cond = catalog.CatalogTools.get_search_conditions(**varkw)
        from cs.workflow.forms import FormTemplate
        fcondition = reduce(lambda x, y: "(%s) OR (%s)" % (x, y),
                            self.__catalog_rules_conditions__)
        return FormTemplate.Query("(%s) AND (%s)" % (cond, fcondition))

    def get_table_def(self, **varkw):
        result = super(FormTemplateCatalog, self).get_table_def(**varkw)
        result["columns"] = [col for col in result["columns"]
                             if col["attribute"] != "cdb_module_id"]
        return result

    def _data_wrapper(self, table_def, datalist):
        new_datalist = []
        if table_def and "columns" in table_def:
            for data in datalist:
                new_data = []
                for column_def in table_def["columns"]:
                    result = {"name": column_def["attribute"],
                              "text": data[column_def["attribute"]]}
                    new_data.append(result)
                new_data.insert(0, {"name": "_description",
                                    "text": ""})
                new_data.insert(0, {"name": "_id",
                                    "text": data.ID()})
                new_datalist.append(new_data)
        return new_datalist


class OperationCatalog(catalog.ElinkCatalogStandard,
                       CatalogWithCustomizableCondition):
    __catalog_table_name__ = "cdb_op_names_tab"
    __catalog_table_class__ = "cdb_op_names"
    __catalog_table_searchable__ = ["name"]
    __default_conditions__ = ["name LIKE 'CDB_%'"]

    def get_data(self, **varkw):
        cond = catalog.CatalogTools.get_search_conditions(**varkw)
        from cdb.platform.mom.operations import Operation
        fcondition = reduce(lambda x, y: "(%s) OR (%s)" % (x, y),
                            self.__catalog_rules_conditions__)
        return Operation.Query("(%s) AND (%s)" % (cond, fcondition))

    def get_table_def(self, **varkw):
        result = super(OperationCatalog, self).get_table_def(**varkw)
        result["columns"] = [col for col in result["columns"]
                             if col["attribute"] != "cdb_module_id"]
        return result

    def _data_wrapper(self, table_def, datalist):
        new_datalist = []
        if table_def and "columns" in table_def:
            for data in datalist:
                new_data = []
                for column_def in table_def["columns"]:
                    result = {"name": column_def["attribute"],
                              "text": data[column_def["attribute"]]}
                    new_data.append(result)
                new_data.insert(0, {"name": "_description",
                                    "text": ""})
                new_data.insert(0, {"name": "_id",
                                    "text": data.ID()})
                new_datalist.append(new_data)
        return new_datalist


class ProjectCatalog(catalog.ElinkCatalogBase):

    def get_table_def(self, **varkw):
        table_def = {"searchable": True,
                     "columns": []}
        # visible = table.Attributes.Query("visible_len>0").attribut
        if not wfinterface._is_pcs_enabled():
            return table_def
        from cs.pcs.projects import Project  # @UnresolvedImport
        clsdef = Project._getClassDef()
        for col in ["cdb_project_id", "project_name"]:
            attr_dict = {}
            attr_dict["label"] = unicode(
                clsdef.getAttributeDefinition(col).getLabel())
            attr_dict["attribute"] = col
            attr_dict["type"] = catalog.CatalogTools.get_field_type(
                sqlapi.SQL_CHAR)
            attr_dict["visible"] = True
            attr_dict["searchable"] = attr_dict["visible"]
            table_def["columns"].append(attr_dict)
        return table_def

    def get_catalog_title(self, **varkw):
        if not wfinterface._is_pcs_enabled():
            return ""
        from cs.pcs.projects import Project  # @UnresolvedImport
        clsdef = Project._getClassDef()
        return unicode(clsdef.getDesignation())

    def get_data(self, **varkw):
        cdb_process_id = varkw.get("cdb_process_id", "")
        result = []
        if not wfinterface._is_pcs_enabled():
            return result

        from cs.pcs import projects

        process = Process.ByKeys(cdb_process_id)
        if not process:
            return result
        cond = catalog.CatalogTools.get_search_conditions(**varkw)
        return projects.Project.Query(cond, access="read")


def get_roles(**varkw):
    cdb_process_id = varkw.get("cdb_process_id", "")
    roles = []
    process = Process.ByKeys(cdb_process_id)
    if process:
        roles = process.GetRoleCandidates()
    return [[role["subject_name"],
             dict(subject_id=role["subject_id"],
                  subject_type=role["subject_type"])] for role in roles]
