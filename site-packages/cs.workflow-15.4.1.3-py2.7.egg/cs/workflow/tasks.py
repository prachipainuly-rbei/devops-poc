#!/usr/bin/env powerscript
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

"""
Module Tasks

This is the documentation for the Tasks module.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: tasks.py 185101 2018-10-16 07:02:15Z cso $"

import datetime
import json
import os

from cdb import auth
from cdb import misc
from cdb import util
from cdb.typeconversion import to_legacy_date_format

from cdb.objects import Object
from cdb.objects import org
from cdb.objects import ByID
from cdb.objects import Forward
from cdb.objects import NULL
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import ReferenceMapping_N
from cdb.objects import ReferenceMethods_1
from cdb.objects import Reference_Methods
from cdb.objects import State
from cdb.objects import Rule
from cdb.objects.common import WithStateChangeNotification
from cdb.objects.iconcache import _LabelValueAccessor
from cdb.objects.iconcache import IconCache
from cdb.objects.org import User

from cs.sharing.share_objects import WithSharing
from cs.workflow.forms import TaskWithForm
from cs.workflow.tasks_plugin import WorkflowTaskWithCsTasks
from cs.workflow.misc import deprecation_warning
from cs.workflow.misc import calc_deadline
from cs.workflow.misc import set_state
from cs.workflow.misc import set_state_interactive
from cs.workflow.misc import get_taskmanager_url
from cs.workflow.misc import get_object_class_by_name
from cs.workflow.misc import notification_enabled
from cs.workflow.misc import require_feature_viewing
from cs.workflow.protocols import MSGCANCEL
from cs.workflow.protocols import MSGDONE
from cs.workflow.protocols import MSGINFO
from cs.workflow.protocols import MSGREFUSE
from cs.workflow.protocols import MSGSYSTEM
from cs.workflow.protocols import MSGTASKREADY
from cs.workflow.protocols import Protocol
from cs.workflow.schemacomponents import SchemaComponent
from cs.workflow import briefcases
from cs.workflow import exceptions

__all__ = ["ApprovalTask",
           "ExaminationTask",
           "ExecutionTask",
           "FilterParameter",
           "InteractiveTask",
           "SystemTask",
           "Task",
           "TaskDataIncompleteException"]

fTask = Forward(__name__ + ".Task")
fFilterParameter = Forward(__name__ + ".FilterParameter")

fProcess = Forward("cs.workflow.processes.Process")
fSchemaComponent = Forward("cs.workflow.schemacomponents.SchemaComponent")
fTaskGroup = Forward("cs.workflow.taskgroups.TaskGroup")
fSystemTaskDefinition = Forward("cs.workflow.systemtasks.SystemTaskDefinition")
fBriefcase = Forward("cs.workflow.briefcases.Briefcase")
fBriefcaseLink = Forward("cs.workflow.briefcases.BriefcaseLink")
fOperation = Forward("cdb.platform.mom.operations.Operation")

fRule = Forward("cdb.objects.Rule")

_TASK_RULES = ["cdbtodo: task_approval",
               "cdbtodo: task_examination",
               "cdbtodo: task_execution"]


class TaskDataIncompleteException(Exception):
    """
    Exception raised by `check_process_start_preconditions` if
    the conditions are not fulfilled.
    """
    pass


# WithBriefcase should come before SchemaComponent, otherwise SchemaComponent
# will overwrite the reference 'Content'
class Task(briefcases.WithBriefcase, SchemaComponent,
           org.WithSubject, WithStateChangeNotification, TaskWithForm):
    """
    Base class for both interactive task and system task types.
    Defines some common APIs to handle workflow task.
    """

    __classname__ = "cdbwf_task"
    __match__ = fSchemaComponent.cdb_classname >= __classname__
    __obj_class__ = "cdbwf_task"

    __notification_template_folder__ = os.path.join(
        os.path.dirname(__file__), "chrome")

    # Attribute that may contain a fully qualified python name to
    # add object specific workflow behavior.
    __wf_handler_attr__ = "task_handler"

    TaskGroup = Reference_1(fTaskGroup, fTask.parent_id, fTask.cdb_process_id)
    Process = Reference_1(fProcess, fTask.cdb_process_id)

    # References to briefcases

    BriefcaseLinksByType = ReferenceMapping_N(
        fBriefcaseLink,
        (fBriefcaseLink.cdb_process_id == fTask.cdb_process_id) &
        (fBriefcaseLink.task_id == fTask.task_id),
        indexed_by=fBriefcaseLink.iotype)

    BriefcaseLinks = Reference_N(fBriefcaseLink,
                                 fBriefcaseLink.cdb_process_id == fTask.cdb_process_id,
                                 fBriefcaseLink.task_id == fTask.task_id)

    event_map = {
        (("create", "copy"), "pre"): ("check_position",
                                      "make_task_id",
                                      "make_project_id"),
        (("create", "copy"), "pre_mask"): ("allow_new_task",
                                           "make_position",
                                           "make_project_id"),
        (("create", "copy", "modify"), "pre"): "check_max_duration",
        (("modify"), "pre"): "check_position",
        ("cdbwf_close_task", "now"): "op_close_task",
        ("cdbwf_refuse_task", "now"): "op_refuse_task",
        ("cdbwf_forward_task", "now"): "op_forward_task",
    }

    def op_close_task(self, ctx):
        comment = getattr(ctx.dialog, "remark", "")
        self._op_change_task("close", comment)

    def op_refuse_task(self, ctx):
        comment = getattr(ctx.dialog, "remark", "")
        self._op_change_task("refuse", comment)

    def op_forward_task(self, ctx):
        if not self.isForwardable():
            raise util.ErrorMessage("cdbwf_task_not_forwardable")

        comment = getattr(ctx.dialog, "remark", "")
        self._op_change_task("forward", comment)

    def _op_change_task(self, op, comment):
        assert(op in ["close", "refuse", "forward"])

        if self.status != self.EXECUTION.status:
            raise util.ErrorMessage("cdbwf_task_not_ready")

        try:
            getattr(self, op + "_task")(comment)
        except Exception:
            misc.log_traceback("could not change task's status")
            raise util.ErrorMessage("cdbwf_status_change_failed")

    # obsolete status classes
    def READY(cls):
        deprecation_warning(__name__, "READY", "EXECUTION")
        return cls.EXECUTION

    def DONE(cls):
        deprecation_warning(__name__, "DONE", "COMPLETED")
        return cls.COMPLETED

    def REFUSED(cls):
        deprecation_warning(__name__, "REFUSED", "REJECTED")
        return cls.REJECTED

    def CANCELLED(cls):
        deprecation_warning(__name__, "CANCELLED", "DISCARDED")
        return cls.DISCARDED

    class NEW(State):
        status = 0

        def pre_mask(state, self, ctx):  # @NoSelf
            if not ctx.batch:
                if (self.Parent.is_sequential()
                        or self.Parent.status != self.Parent.EXECUTION.status):
                    ctx.excl_state(Task.EXECUTION.status)
            super(Task.NEW, state).pre_mask(self, ctx)

        def pre(state, self, ctx):  # @NoSelf
            self.reserved_by = ""
            self.start_date = ""
            self.end_date_act = ""
            super(Task.NEW, state).pre(self, ctx)

    class EXECUTION(State):
        status = 10

        def pre_mask(state, self, ctx):  # @NoSelf
            if not self.isRefuseable():
                ctx.excl_state(self.REJECTED.status)
            super(Task.EXECUTION, state).pre_mask(self, ctx)

        def pre(state, self, ctx):  # @NoSelf
            # if title and responsible are not set, set them to default
            self.set_title()
            self.set_responsible()

            for briefcase in self.BriefcaseLinks:
                briefcase.check_obj_rights(ctx, persno=self.Process.started_by)

            self.start_date = datetime.datetime.now()
            calc_deadline(self)
            self.reserved_by = ""
            self.preset_data()  # defined in TaskWithForm
            self.addProtocol(util.get_label("cdbwf_task_set_ready"), MSGTASKREADY)
            super(Task.EXECUTION, state).pre(self, ctx)

    class COMPLETED(State):
        status = 20

        def pre(state, self, ctx):  # @NoSelf
            self.check_form_data()  # defined in TaskWithForm
            comment = getattr(ctx.dialog, "comment", "")
            if self.requiresComment() and comment == "":
                raise util.ErrorMessage("cdbwf_err101")
            self.reserved_by = ""
            self.end_date_act = datetime.datetime.now()
            lbl = util.get_label("cdbwf_task_done")
            self.addProtocol("%s \n%s" % (lbl, comment), MSGDONE)
            self.addASComment(comment)
            super(Task.COMPLETED, state).pre(self, ctx)

    class REJECTED(State):
        status = 30

        def pre(state, self, ctx):  # @NoSelf
            comment = getattr(ctx.dialog, "comment", "")
            if self.requiresComment() and comment == "":
                raise util.ErrorMessage("cdbwf_err101")
            self.reserved_by = ""
            self.end_date_act = datetime.datetime.now()
            lbl = util.get_label("cdbwf_task_refused")
            self.addProtocol("%s \n%s" % (lbl, comment), MSGREFUSE)
            self.addASComment(comment)
            super(Task.REJECTED, state).pre(self, ctx)

        def post(state, self, ctx):  # @NoSelf
            super(Task.REJECTED, state).post(self, ctx)

    class DISCARDED(State):
        status = 35

        def pre(state, self, ctx):  # @NoSelf
            super(Task.DISCARDED, state).pre(self, ctx)

            comment = getattr(ctx.dialog, "comment", "")
            self.addProtocol("[Task discarded] \n" + comment, MSGCANCEL)
            self.addASComment(comment)

    # ===========================================================================
    # New interface
    # ===========================================================================

    def activate_task(self):
        """
        Attempts to set the current task ready. If the constraints check fails,
        the task would be cancelled.
        """
        require_feature_viewing()
        if not self.check_constraints():
            self.cancel_task()
            raise exceptions.TaskCancelledException()

        if not self.isSystemTask():
            self.set_briefcase_rights()

        self.setReady()

    def cancel_task(self, comment=""):
        """
        Attempts to cancel the current task.
        """
        require_feature_viewing()
        self.setCancelled(comment)

    def close_task(self, comment=""):
        """
        Attempts to close the current task by set it as done.
        """
        self.setDone(comment)

        if self.Parent:
            self.Parent.propagate_done(self)

    def refuse_task(self, comment=""):
        """
        Attempts to refuse the current task.
        """

        self.setRefused(comment)

        if self.Parent:
            self.Parent.propagate_refuse(self, comment)

    def forward_task(self, comment=""):
        """
        Attempts to close the current task and forward
        the decision to another task.
        """
        if self.requiresComment() and comment == "":
            raise util.ErrorMessage("cdbwf_err101")

        self.addProtocol("[Task forwarded]", MSGSYSTEM)
        self.__forwarded__ = True

        self.close_task(comment)

    # ===========================================================================
    # End new interface
    # ===========================================================================

    # Other methods

    @classmethod
    def new_task_id(cls):
        return "T%08d" % util.nextval("cdbwf_task.task_id")

    def on_cdb_show_responsible_now(self, ctx):
        return self.openSubject()

    def on_cdbwf_lock_task_now(self, ctx):
        if not self.lock_allowed():
            raise util.ErrorMessage("cdbwf_err100",
                                    self.get_responsible_name())
        else:
            obj = ByID(self.ID())
            obj.Update(reserved_by=auth.persno)
            ctx.refresh_tables([self.GetTableName()])
            user = User.ByKeys(personalnummer=auth.persno)
            self.addProtocol(util.get_label("cdbwf_task_set_reserved_by") % user.name, MSGINFO)

    def on_cdbwf_unlock_task_now(self, ctx):
        if not self.unlock_allowed():
            raise util.ErrorMessage("cdbwf_err100",
                                    self.get_responsible_name())
        else:
            obj = ByID(self.ID())
            obj.Update(reserved_by="")
            ctx.refresh_tables([self.GetTableName()])
            self.addProtocol(util.get_label("cdbwf_task_set_unreserved"), MSGINFO)

    def on_modify_pre_mask(self, ctx):
        if self.status > Task.NEW.status:
            ctx.set_fields_readonly(["position", "mapped_classname"])

    def on_modify_pre(self, ctx):
        # Fixing E014422
        obj = Task.ByKeys(self.task_id, self.cdb_process_id)
        for fdname in obj.GetFieldNames():
            if fdname[:4] != "cdb_" and fdname in ctx.dialog.get_attribute_names():
                if ctx.dialog[fdname] != obj[fdname]:
                    fd_value = obj[fdname]
                    if isinstance(fd_value, (datetime.datetime, datetime.date)):
                        fd_value = to_legacy_date_format(fd_value)
                    ctx.keep("prot_old_%s" % fdname, fd_value)
        obj.Lock()

    def on_modify_post(self, ctx):
        # Fixing E014422
        msgs = []

        def not_equal(a, b):
            result = False
            if isinstance(b, (datetime.datetime, datetime.date)):
                if len(a):
                    result = a != to_legacy_date_format(b)
                # no else branch, because then a is uninitialized and we return false
            else:
                result = "%s" % (old_value) != "%s" % (new_value)
            return result

        for fdname in ctx.ue_args.get_attribute_names():
            if fdname[:9] == "prot_old_":
                name = fdname[9:]
                old_value = ctx.ue_args[fdname]
                new_value = self[name]
                if (old_value or new_value) and not_equal(old_value, new_value):
                    msgs.append("%s: %s -> %s" % (name,
                                                  old_value,
                                                  new_value))
        if msgs:
            self.addProtocol("[Task modified] \n" + "\n".join(msgs))
        self.Unlock()

    def check_max_duration(self, ctx):
        if self.max_duration is not None and self.max_duration < 1:
            raise util.ErrorMessage("cdbwf_max_duration_greater_0")

    def make_task_id(self, ctx):
        if ctx.action == "copy":
            # No need to change the task_id if the process id has changed
            template_id = getattr(ctx.cdbtemplate, "cdb_process_id", self.cdb_process_id)
            if template_id == self.cdb_process_id:
                self.task_id = self.new_task_id()
        else:
            self.task_id = self.new_task_id()

    def allow_new_task(self, ctx):
        # No creation of tasks out of a process context
        if len(ctx.parent.get_attribute_names()) == 0:
            raise util.ErrorMessage("cdbwf_err103")
        self.Super(Task).allow_new_task(ctx)

    def make_project_id(self, ctx):
        if self.Process:
            # derive process's project id
            self.cdb_project_id = self.Process.cdb_project_id

    def isExaminationTask(self):
        return (Task.cdb_classname >= "cdbwf_task_examination").eval(self)

    def isExecutionTask(self):
        return (Task.cdb_classname >= "cdbwf_task_execution").eval(self)

    def isApprovalTask(self):
        return (Task.cdb_classname >= "cdbwf_task_approval").eval(self)

    def isSystemTask(self):
        return (Task.cdb_classname >= "cdbwf_system_task").eval(self)

    def isForwardable(self):
        """
        Manually check whether a task can be forwarded or not.
        """

        return False

    def isRefuseable(self):
        """
        Manually check whether a task can be refused or not.
        """
        return False

    def isReservable(self):
        """
        Manually check whether a process can be reserved or not.
        """
        return True

    def requiresComment(self):
        """
        Manually check whether the comment is required while closing
        or canceling a task.
        """
        return False

    def setReady(self):
        set_state(self, self.EXECUTION)

    def setDone(self, comment="", interactive=False):
        if interactive:
            set_state_interactive(self, self.COMPLETED, comment=comment)
        else:
            set_state(self, self.COMPLETED, comment=comment)

    def setNew(self):
        set_state(self, self.NEW)

    def setRefused(self, comment="", interactive=False):
        if interactive:
            set_state_interactive(self, self.REJECTED, comment=comment)
        else:
            set_state(self, self.REJECTED, comment=comment)

    def setCancelled(self, comment=""):
        set_state(self, self.DISCARDED, comment=comment)

    def setReserved(self):
        # Return True, if reservation has been done,
        # False otherwise
        if self.lock_allowed():
            self.reserved_by = auth.persno
            return 1
        elif self.unlock_allowed():
            self.reserved_by = ""
            return 0
        # else raise (another person is responsible resp. owns the reservation)
        raise util.ErrorMessage("cdbwf_err100",
                                self.get_responsible_name())

    def RenderHtml(self, request, **kwargs):
        args = kwargs.copy()
        args["commenthref"] = Protocol.MakeCdbcmsg(
            "CDB_Create",
            cdb_process_id=self.cdb_process_id,
            task_id=self.task_id).eLink_url()
        args["commenticon"] = Protocol.GetClassIcon()
        args["reserved_titleu"] = \
            "Hier klicken, um die Aufgabe zu reservieren.\n[%s]" % \
            (self.Subject.GetDescription())
        args["reserved_titlel"] = "Diese Aufgabe ist reserviert. Hier " \
            "klicken, um die Reservierung abzugeben."
        args["reserved_icon"] = "cdbwf_task_unlocked"
        args["reserved_title"] = args["reserved_titleu"]
        if self.reserved_by:
            args["reserved_icon"] = "cdbwf_task_locked"
            args["reserved_title"] = args["reserved_titlel"]
        args["reserved_icon"] = "%s/byname/icon/%s/" % \
            (request.base_uri, args["reserved_icon"])
        args["reservable"] = (self.isReservable())

        args["checkboxonly"] = not self.requiresComment()

        args["links"] = self.Process._Links()

        return super(Task, self).RenderHtml(request, **args)

    def get_responsible_name(self):
        rname = self.subject_id
        if self.reserved_by:
            rname = User.ByKeys(self.reserved_by).name
        elif self.subject_type == "Person":
            rname = User.ByKeys(self.subject_id).name
        return rname

    # simple checks. Redefine in derived class if unwanted.
    def lock_allowed(self):
        allow = 0
        if not self.subject_type == "Person" and not self.reserved_by:
            allow = 1
        return allow

    def unlock_allowed(self):
        allow = 0
        if self.reserved_by == auth.persno:
            allow = 1
        return allow

    def get_last_tasks(self):
        return [self]

    @classmethod
    def get_all_tasks_by_user(cls, condition=""):
        """All (non-new and non-cancelled) tasks which are either
        directly assigned to a given user id or indirectly via a role"""

        tasks = []
        for rulename in _TASK_RULES:
            rule = Rule.ByKeys(name=rulename)
            tasks.extend(rule.getObjects())

        hidden_task_status = ["%d" % status.status
                              for status in [cls.NEW, cls.DISCARDED]]

        sql_condition = ("status NOT IN ({hidden_states})")\
            .format(hidden_states=",".join(hidden_task_status))
        if condition:
            sql_condition = "(%s) AND (%s)" % (sql_condition, condition)

        task_condition = InteractiveTask.cdb_object_id\
            .one_of(*[task.cdb_object_id for task in tasks])
        result = InteractiveTask.Query(task_condition)\
            .Query(sql_condition, order_by="deadline DESC")
        return result

    def GetActivityStreamTopics(self, posting):
        """Topics for Postings"""
        return [self, self.Process, self.Project if hasattr(self, "Project") else None]

    def set_title(self, ctx=None):
        if not self.title:
            self.title = unicode(self.mapped_classname)

    def set_responsible(self):
        if not self.subject_id:
            self.subject_id = self.Process.subject_id
            self.subject_type = self.Process.subject_type

    def get_violated_process_start_preconditions(self):
        """
        Checks preconditions for starting the process. If at least one
        precondition is violated, returns a non-empty error message.
        """
        from cdb.platform import gui
        missing_mandatory_fields = []

        extension_obj = self.getExtensionObject()
        errmsg = ""

        if extension_obj:
            missing_mandatory_fields.extend(
                extension_obj.getMissingMandatoryFieldsAtProcessStart())
            try:
                extension_obj.checkProcessStartConditions()
            except TaskDataIncompleteException as e:
                errmsg = unicode(e)

        if missing_mandatory_fields:
            if errmsg:
                errmsg += " / "

            if len(missing_mandatory_fields) == 1:
                errmsg += gui.Message.GetMessage("cdbwf_task_mandatory_field",
                                                 missing_mandatory_fields[0])
            else:
                errmsg += gui.Message.GetMessage(
                    "cdbwf_task_mandatory_fields",
                    ", ".join(missing_mandatory_fields))

        return errmsg

    def check_process_start_preconditions(self):
        """
        Checks preconditions for starting the process. If at least one
        precondition is violated, raises a `TaskDataIncompleteException`.
        """
        errmsg = self.get_violated_process_start_preconditions()

        if errmsg:
            raise TaskDataIncompleteException(errmsg)

    def getExtensionObject(self):
        """
        Get the task extension object instance, if the current task
        is extended. You can overwrite this function if your kind of
        task supports extensions.
        """
        return None

    def sendNotification(self, ctx=None):
        if notification_enabled():
            self.Super(Task).sendNotification(ctx)


class SystemTask(Task):
    __classname__ = "cdbwf_system_task"
    __match__ = fTask.cdb_classname >= __classname__

    Definition = Reference_1(fSystemTaskDefinition, fTask.task_definition_id)

    AllParameters = Reference_N(fFilterParameter,
                                (fFilterParameter.cdb_process_id == fTask.cdb_process_id) &
                                (fFilterParameter.task_id == fTask.task_id))

    Parameters = Reference_N(fFilterParameter,
                             (fFilterParameter.cdb_process_id == fTask.cdb_process_id) &
                             (fFilterParameter.task_id == fTask.task_id) &
                             (fFilterParameter.rule_name == ""))

    FilterParameters = ReferenceMapping_N(fFilterParameter,
                                          (fFilterParameter.cdb_process_id == fTask.cdb_process_id) &
                                          (fFilterParameter.task_id == fTask.task_id),
                                          indexed_by=fFilterParameter.rule_name)

    def _getObjectFilters(self):
        rules = set(self.AllParameters.Query(fFilterParameter.rule_name != "").rule_name)
        return Rule.Query(Rule.name.one_of(*rules))

    ObjectFilters = Reference_Methods(Rule, _getObjectFilters)

    event_map = {
        (("create", "copy"), "pre"): ("set_service_user"),
        ("create", "pre"): "set_title",
    }

    def set_service_user(self, ctx):
        from cs.workflow.services import WFServer
        user = WFServer.get_service_user()
        if user not in ["", None, NULL]:
            self.subject_id = user
            self.subject_type = "Person"

    def set_title(self, ctx=None):
        """ Set the title to the name of the System task definition
            in the login language.
        """
        if not self.title:
            self.title = self.Definition.Name[""]

    def get_system_task_icon(self):
        iconfile = self.Definition.Image
        if iconfile:
            from cs.workflow.designer import wfinterface
            return wfinterface.get_picture_url(iconfile)

    class EXECUTION(Task.EXECUTION):
        status = 10

        def post(state, self, ctx):  # @NoSelf
            super(SystemTask.EXECUTION, state).post(self, ctx)

            # Send Job to WFQueue
            from cs.workflow import wfqueue
            wfqueue.wfqueue.put(cdb_process_id=self.cdb_process_id,
                                task_id=self.task_id)

    __required_params__ = {
        "cs.workflow.systemtasks.status_change": set(["target_state"]),
        "cs.workflow.systemtasks.generate_info_message": set(["subject_id",
                                                              "subject_type"]),
    }

    def get_violated_process_start_preconditions(self):
        """
        Checks preconditions for starting the process. If at least one
        precondition is violated, returns a non-empty error message.
        """
        errmsg = super(SystemTask,
                       self).get_violated_process_start_preconditions()

        errors = [errmsg] if errmsg else []

        if self.Definition:
            fqpyname = self.Definition.function_fqpyname
        else:
            fqpyname = None
            errors.append(unicode(util.ErrorMessage(
                "cdbwf_no_task_definition",
                self.GetDescription())))

        if fqpyname == "cs.workflow.systemtasks.copy_objects":
            # requires exactly one out briefcase
            if len(self.EditBriefcases) != 1:
                errors.append(util.get_label(
                    "cdbwf_only_one_out_briefcase") % self.GetDescription())

        if fqpyname == "cs.workflow.systemtasks.status_change":
            # requires global briefcase flag or local briefcase
            if not self.uses_global_maps and not self.Briefcases:
                errors.append(unicode(util.ErrorMessage(
                    "cdbwf_task_no_briefcase", self.GetDescription())))

        parameters = set(self.AllParameters.name)
        missing_parameters = self.__required_params__.get(
            fqpyname, set()).difference(parameters)

        if missing_parameters:
            errors.append(unicode(util.ErrorMessage(
                "cdbwf_missing_parameters",
                self.GetDescription(),
                ", ".join(missing_parameters))))

        return " / ".join(errors)


class RunOperationSystemTask(SystemTask):
    __match__ = (
        fTask.cdb_classname >= SystemTask.__classname__ and
        fTask.task_definition_id == "f16b8b40-706e-11e7-9aef-68f7284ff046")
    __default_icon__ = "operation_placeholder"

    def _getOperation(self):
        for param in self.Parameters.KeywordQuery(name="operation_name"):
            return fOperation.ByKeys(param.value)

    Operation = ReferenceMethods_1(fOperation, _getOperation)

    def get_system_task_icon(self, base_uri=None):
        if base_uri is None:
            from cdb import elink
            base_uri = getattr(
                elink.getCurrentRequest(), "base_uri", "BASE_URI/")

        result = IconCache.getIcon(self.__default_icon__)
        op = self.Operation

        if op and op.icon_id:
            try:
                result = IconCache.getIcon(
                    op.icon_id, accessor=_LabelValueAccessor(op, True))
            except (KeyError, AttributeError):
                obj = op.ToObjectHandle()
                if obj:
                    result = IconCache.getIcon(
                        op.icon_id, accessor=_LabelValueAccessor(obj))

        return u"".join([base_uri[:-1], result])


class InteractiveTask(Task, WithSharing, WorkflowTaskWithCsTasks):
    __classname__ = "cdbwf_interactive_task"
    __match__ = fTask.cdb_classname >= __classname__
    __template__ = "cdbwf_task.html"

    event_map = {
        (("create", "copy", "modify"), "pre_mask"): ("set_responsible_mandatory"),
        ("modify", "pre"): "check_modification_pre",
        ("modify", "post"): "check_modification_post",
        ("modify", "final"): "check_modification_final",
        ("create", "post"): "check_extension_title"
    }

    # if following attributes of an active task get changed, then the task
    # responsibles get directly notified about it via mail/protocol
    NOTIFIABLE_ATTRS = ["subject_id", "subject_type",
                        "deadline", "max_duration"]

    def get_violated_process_start_preconditions(self):
        """
        Checks preconditions for starting the process. If at least one
        precondition is violated, returns a non-empty error message.
        """
        errmsg = super(InteractiveTask,
                       self).get_violated_process_start_preconditions()

        if not self.Subject:
            if errmsg:
                errmsg += " / "

            from cdb.platform import gui
            errmsg += gui.Message.GetMessage("cdbwf_task_mandatory_field",
                                             util.get_label("cdbwf_ahwf_27"))
        return errmsg

    @classmethod
    def get_running_tasks_by_briefcase(cls, briefcase):
        """
        Find out which running tasks are linked with a
        given briefcase.

        :return: a list of tasks
        """
        tasks = []
        for briefcase_link in briefcase.Links:
            task = briefcase_link.Task
            if task:
                if task.status == task.EXECUTION.status:
                    tasks.append(task)
            else:
                # global briefcase
                tasks.extend(InteractiveTask.Query(
                    "cdb_process_id = '%s' AND status = '%s'" %
                    (briefcase_link.cdb_process_id, InteractiveTask.EXECUTION.status)))
        return tasks

    def check_modification_pre(self, ctx):
        if self.status == self.EXECUTION.status:
            # keep some old values for the diffing in the 'post' event
            for attr in self.NOTIFIABLE_ATTRS:
                ctx.keep("%s_old" % attr, getattr(ctx.object, attr))

            # fields not in NOTIFIABLE_ATTRS should not be modified
            unknown_attrs = set(ctx.dialog.get_attribute_names()) -\
                set(self.NOTIFIABLE_ATTRS)
            clsdef = self.GetClassDef()
            fields = self.GetFieldNames()
            for attr in unknown_attrs:
                if attr not in fields and\
                   not clsdef.getFacetAttributeDefinition(attr):
                    continue
                dval = getattr(ctx.dialog, attr)
                oval = getattr(ctx.object, attr)
                if attr == "position":
                    try:
                        if float(dval) == float(oval):
                            continue
                    except Exception:
                        pass
                if dval != oval:
                    raise util.ErrorMessage("cdbwf_modify_ready_task")

    def check_modification_post(self, ctx):
        from cdb.platform.mom.fields import DDField
        if self.status == self.EXECUTION.status:
            changed_attrs = {}
            for attr in self.NOTIFIABLE_ATTRS:
                old_value = getattr(ctx.ue_args, "%s_old" % attr)
                new_value = getattr(ctx.object, attr)
                if old_value != new_value:
                    setattr(ctx, "modified_task_attrs", changed_attrs)
                    field = DDField.ByKeys("cdbwf_process_component", attr)
                    changed_attrs[attr] = {"label": field.getLabel(),
                                           "value": new_value}
                    if attr == "subject_id":
                        # special case when changing task responsibles:
                        # also inform the old one(s) about losing the responsibility
                        self.reserved_by = ""
                        if hasattr(ctx.ue_args, "subject_type_old"):
                            self.subject_type = getattr(ctx.ue_args, "subject_type_old")
                        self.subject_id = old_value
                        self.sendNotification(ctx)
                        if hasattr(ctx.ue_args, "subject_type_old"):
                            self.subject_type = getattr(ctx.object, "subject_type")
                        self.subject_id = new_value
            if changed_attrs:
                ctx.keep('modified_task_attrs', json.dumps(changed_attrs))

    def check_modification_final(self, ctx):
        if self.status == self.EXECUTION.status:
            if hasattr(ctx.ue_args, 'modified_task_attrs'):
                modified_task_attrs = json.loads(getattr(ctx.ue_args, 'modified_task_attrs'))
                msg = "\n".join(['%s: %s' % (attr['label'], attr['value'])
                                 for attr in modified_task_attrs.values()])
                self.addProtocol(util.get_label("cdbwf_notifiable_task_attrs_modified") %
                                 msg, MSGINFO)
                # don't send the notification in the 'post' event,
                # since it might result in wrong mail receivers
                setattr(ctx, "modified_task_attrs", modified_task_attrs)
                self.sendNotification(ctx)

    def set_responsible_mandatory(self, ctx):
        # If process is already running, a responsible must be specified
        from cs.workflow.processes import Process
        if self.Process and self.Process.status == Process.EXECUTION.status:
            ctx.set_mandatory("mapped_subject_name")

    # == Email notification ==
    def getNotificationTemplateName(self, ctx=None):
        if not ctx:
            # no ctx object means default case (task set ready)
            return "cdbwf_task_ready.html"
        elif hasattr(ctx, "modified_task_attrs"):
            return "cdbwf_task_modified.html"
        elif hasattr(ctx, "content_change_bobject"):
            return "cdbwf_content_change.html"
        else:
            raise util.ErrorMessage("Unsupported context type")

    def setNotificationContext(self, sc, ctx=None):
        sc.ctx = ctx
        sc.sender = User.ByKeys(personalnummer=auth.persno)

        sc.action_url = get_taskmanager_url(self)

        all_briefcases = self.Briefcases + self.Process.Briefcases
        for briefcase in all_briefcases:
            if len(briefcase.Content) > 0:
                # don't show the briefcase group at all in the notification
                # when there's no content anyway
                sc.briefcases = all_briefcases
                break

    def getNotificationTitle(self, ctx=None):
        # Advantages of the eval workaround for cdb labels below:
        # 1) able to omit 'self.'
        # 2) able to access all attributes of the object
        # Example:
        # '"CIM DATABASE - Task ready: " + title + " / " + Process.title' +
        # ((" / " + Project.project_name) if (has_key("Project") and Project) else "")
        eval_dict = {}
        for attr_name in dir(self):
            eval_dict[attr_name] = getattr(self, attr_name)
        if not ctx:
            # no ctx object means default case (task set ready)
            prefix = "cdbwf_notification_title_prefix_task_ready"
        elif hasattr(ctx, "modified_task_attrs"):
            prefix = "cdbwf_notification_title_prefix_task_modified"
        elif hasattr(ctx, "content_change_bobject"):
            prefix = "cdbwf_notification_title_prefix_content_change"
        else:
            raise util.ErrorMessage("Unsupported context type")

        prefix = eval(util.get_label(prefix), globals(), eval_dict)
        suffix = eval(util.get_label("cdbwf_notification_title_suffix"), globals(), eval_dict)
        return "%s %s" % (prefix, suffix)

    def getNotificationSender(self, ctx=None):
        if ctx:
            # cases: -task modified
            #        -document added or removed
            #        -object changed
            current_pers = User.ByKeys(personalnummer=auth.persno)
            sender_mail = current_pers.e_mail
            sender_name = current_pers.name
        else:
            # case: task set ready
            responsible_pers = self.Process.StartedBy

            if not (responsible_pers and responsible_pers.e_mail):
                misc.log_error(util.ErrorMessage("cdbwf_no_wf_starter"))
                return ("", "")

            sender_mail = responsible_pers.e_mail
            sender_name = responsible_pers.name
        return (sender_mail, sender_name)

    def isNotificationReceiver(self, pers, ctx):
        # exclude the task responsible(s) in some cases
        # no ctx object means default case (task set ready)
        if ctx:
            if hasattr(ctx, "modified_task_attrs"):
                if pers.personalnummer == auth.persno:
                    # operation was triggered by this person.. exclude him
                    return False
            elif hasattr(ctx, "content_change_bobject"):
                if pers.personalnummer == auth.persno:
                    # operation was triggered by this person.. exclude him
                    return False
            else:
                raise util.ErrorMessage("Unsupported context type")

        return all([
            # TODO wait for public API (E043114)
            pers.active_account == "1",
            pers.email_notification_task(),
            self.reserved_by in [None, "", auth.persno],
        ])

    def getNotificationReceiver(self, ctx=None):
        rcvr = {}
        if self.Subject:
            for pers in self.Subject.getPersons():
                if self.isNotificationReceiver(pers, ctx):
                    tolist = rcvr.setdefault("to", set())
                    tolist.add((pers.e_mail, pers.name))

        # flag "wf_owner_ok" ensures only a single mail is sent even
        # for operations triggering multiple sendNotification calls
        # (e.g. content changes)
        if not (ctx and "wf_owner_ok" in ctx.ue_args.get_attribute_names()):
            for pers in self.Process.Subject.getPersons():
                # always include wf owners if they didn't trigger the
                # operation ('task ready' notifications excluded)

                if pers.email_notification_task() and \
                   (pers.personalnummer != auth.persno):
                    tolist = rcvr.setdefault("to", set())
                    tolist.add((pers.e_mail, pers.name))

            if ctx:
                ctx.keep("wf_owner_ok", True)

        return [rcvr]
    # == End email notification ==

    @classmethod
    def getPossibleExtensions(cls):
        """
        Get the possible extension types for the current task type.

        :return: a list of dictionary with keys `label` and `classname`  of
                 each available extension type.
        """
        result = []
        from cs.workflow.extensions import ExtensionAssignment
        assignments = ExtensionAssignment.getAssignments(cls._getClassDef())
        for asgn in assignments:
            ext_cls = get_object_class_by_name(asgn.extension_cdb_classname)
            if not ext_cls:
                continue
            label = ""
            if getattr(ext_cls, "getExtensionTypeDescription"):
                label = ext_cls.getExtensionTypeDescription()
            if label:
                result.append(dict(label=label,
                                   classname=asgn.extension_cdb_classname))
        return result

    def getExtensionObject(self):
        """
        Get the task extension object instance, if the current task
        is extended.
        """
        if not self.cdb_extension_class:
            return None
        ext_cls = get_object_class_by_name(self.cdb_extension_class)
        if not ext_cls:
            return None
        return ext_cls.ByKeys(cdb_process_id=self.cdb_process_id,
                              task_id=self.task_id)

    def check_extension_title(self, ctx):
        if self.title:
            return
        extension = self.getExtensionObject()
        if extension:
            self.getPersistentObject().title = extension.getTaskTitle()


class ExecutionTask(InteractiveTask):
    __classname__ = "cdbwf_task_execution"
    __match__ = fTask.cdb_classname >= __classname__


class ApprovalTask(InteractiveTask):

    __classname__ = "cdbwf_task_approval"
    __match__ = fTask.cdb_classname >= __classname__

    def isRefuseable(self):
        return True

    def requiresComment(self):
        return True

    def isForwardable(self):
        return self.finish_option and self.Next \
            and self.Parent.is_sequential()


class ExaminationTask(InteractiveTask):

    __classname__ = "cdbwf_task_examination"
    __match__ = fTask.cdb_classname >= __classname__

    def isRefuseable(self):
        return True

    def requiresComment(self):
        return True

    def isForwardable(self):
        return self.finish_option and self.Next \
            and self.Parent.is_sequential()

    def refuse_task(self, comment=""):
        self.setRefused(comment)

        if self.Parent:
            self.Parent.propagate_done(self)


class FilterParameter(Object):
    __maps_to__ = "cdbwf_filter_parameter"
    __classname__ = "cdbwf_filter_parameter"
