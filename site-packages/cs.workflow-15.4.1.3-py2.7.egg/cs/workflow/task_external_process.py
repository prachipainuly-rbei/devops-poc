#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""
Module task_external_process

This is the documentation for the task_external_process module.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: task_external_process.py 170560 2017-12-14 22:11:24Z cso $"

# Some imports
import sys
import traceback

from cdb import fls
from cdb import misc
from cdb import tools
from cdb.objects import Forward

from cs.workflow import tasks
from cs.workflow import briefcases
from cs.workflow import systemtasks
from cs.workflow import protocols
from cs.workflow import wfqueue

fParameterDefinition = Forward("cs.workflow.systemtasks.ParameterDefinition")


def run(cdb_process_id, task_id):
    misc.log(1, "running system task {}:{}".format(cdb_process_id, task_id))
    fls.allocate_server_license("WORKFLOW_006")

    try:
        task = tasks.SystemTask.ByKeys(cdb_process_id=cdb_process_id,
                                       task_id=task_id)

        if not task:
            misc.log_error("task {}:{} not found".format(
                cdb_process_id, task_id))
        elif not task.Definition:
            raise systemtasks.TaskCancelledException("cannot find system "
                                                     "task definition\n",
                                                     protocols.MSGCANCEL)
        else:
            # find system task implementation
            callableobj = tools.getObjectByName(task.Definition.function_fqpyname)

            # build content dictionary
            content = {}
            for mode in briefcases.IOType:
                content[mode.name] = task.getContent(mode.name)

                if task.uses_global_maps:
                    content[mode.name] += task.Process.getContent(mode.name)

                    # eliminate duplicates
                    content[mode.name] = list(set(content[mode.name]))

            # find parameters for the function call
            params = {}
            for param in task.Parameters:
                if param.name in params.keys():
                    # allow value lists (multiple params with same name)
                    if not isinstance(params[param.name], list):
                        params[param.name] = [params[param.name]]
                    params[param.name].append(param.value)
                else:
                    params[param.name] = param.value

            if task.ObjectFilters:
                for rule in task.ObjectFilters:
                    # extend parameter dictionary with rule-specific
                    # parameters
                    ofparams = dict(params)
                    ofparams.update({param.name: param.value
                                     for param in task.FilterParameters[rule.name]})

                    # filtered content
                    fcontent = {key: [obj for obj in value if rule.match(obj)]
                                for key, value in content.iteritems()}

                    # call system task implementation
                    callableobj(task=task, content=fcontent, **ofparams)
            else:
                # call system task implementation
                try:
                    callableobj(task=task, content=content, **params)
                except TypeError as ex:
                    msg = unicode(ex)
                    misc.log_error("error\n{}".format(msg))
                    missing_pars = task.Definition.Parameters.Query(
                        fParameterDefinition.name.not_one_of(*task.Parameters.name))
                    par_names = ', '.join(missing_pars.name)
                    raise Exception("cdbwf_missing_parameters",
                                    task.GetDescription(), par_names)

            task.close_task()
    except systemtasks.TaskCancelledException as ex:
        msg = unicode(ex)
        task.addProtocol("[Task cancelled] " + msg, protocols.MSGCANCEL)
        task.cancel_task(msg)
        if task.Parent:
            task.Parent.propagate_cancel(task)
    except systemtasks.CloseTaskAsynchronously as ex:
        # The system task implementation will take care of closing the task
        msg = unicode(ex)
        task.addProtocol("[Task continuing asynchronously] " + msg, protocols.MSGSYSTEM)
    except systemtasks.TaskRefusedException as ex:
        msg = unicode(ex)
        task.addProtocol("[Task refused] " + msg, protocols.MSGCANCEL)
        task.refuse_task(msg)
    except systemtasks.ProcessAbortedException as ex:
        process = task.Process
        msg = unicode(ex)
        process.cancel_process(msg)
    except Exception as ex:
        msg = unicode("WFQueue: error\n %s" % traceback.format_exc(),
                      errors='replace')
        task.addProtocol("[Task failed] " + msg, protocols.MSGCANCEL)
        misc.log_error(msg)
        task.Process.cancel_process()


# Guard importing as main module
if __name__ == "__main__":
    wfqueue.initialize_tool()
    args = iter(sys.argv[1:])

    cdb_process_id = next(args, "")
    task_id = next(args, "")
    run(cdb_process_id, task_id)
