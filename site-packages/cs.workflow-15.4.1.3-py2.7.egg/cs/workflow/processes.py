#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

"""
This module contains the cdb.objects class of the workflow.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: processes.py 182986 2018-08-28 18:06:14Z cso $"

import datetime

from cdb import ue
from cdb import auth
from cdb import util
from cdb import sqlapi
from cdb import transactions
from cdb import constants
from cdb import i18n
from cdb import misc

from cdb.objects import org
from cdb.objects import Object
from cdb.objects import Forward
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import ReferenceMapping_N
from cdb.objects import ReferenceMethods_1
from cdb.objects import ReferenceMethods_N
from cdb.objects import Rule
from cdb.objects import State
from cdb.objects import operations

from cdb.platform import gui
from cdb.platform import mom
from cdb import tools

from cs.workflow.misc import deprecation_warning
from cs.workflow.misc import calc_deadline
from cs.workflow.misc import get_state_text
from cs.workflow.misc import set_state
from cs.workflow.misc import Link
from cs.workflow.misc import require_feature_viewing
from cs.workflow.misc import require_feature_templating

from cs.workflow import protocols
from cs.workflow import briefcases
from cs.workflow import exceptions
from cs.sharing.share_objects import WithSharing

__all__ = ['Process']

fProcess = Forward(__name__ + ".Process")
fProcessPyruleAssignment = Forward(__name__ + ".ProcessPyruleAssignment")

fConstraint = Forward("cs.workflow.constraints.Constraint")
fSchemaComponent = Forward("cs.workflow.schemacomponents.SchemaComponent")
fTaskGroup = Forward("cs.workflow.taskgroups.TaskGroup")
fTask = Forward("cs.workflow.tasks.Task")
fBriefcase = Forward("cs.workflow.briefcases.Briefcase")
fBriefcaseLink = Forward("cs.workflow.briefcases.BriefcaseLink")
fProtocol = Forward("cs.workflow.protocols.Protocol")
fRule = Forward("cdb.objects.Rule")
fInfoMessage = Forward("cs.workflow.systemtasks.InfoMessage")
fUser = Forward("cdb.objects.org.User")


class Process(org.WithSubject, briefcases.WithBriefcase, WithSharing):

    __maps_to__ = "cdbwf_process"
    __classname__ = "cdbwf_process"
    __obj_class__ = "cdbwf_process"

    TaskGroups = Reference_N(fTaskGroup,
                             fTaskGroup.cdb_process_id == fProcess.cdb_process_id,
                             fTaskGroup.parent_id == '',
                             fTaskGroup.cdb_classname != "cdbwf_aggregate_proc_completion",
                             order_by=fTaskGroup.position)

    Tasks = Reference_N(fTask,
                        fTask.cdb_process_id == fProcess.cdb_process_id,
                        fTask.parent_id == '',
                        order_by=fTaskGroup.position)
    # all top level tasks of current workflow

    Components = Reference_N(fSchemaComponent,
                             fSchemaComponent.cdb_process_id == fProcess.cdb_process_id,
                             fSchemaComponent.parent_id == '',
                             fSchemaComponent.cdb_classname != "cdbwf_aggregate_proc_completion",
                             order_by=fSchemaComponent.position)

    Protocols = Reference_N(fProtocol,
                            fProtocol.cdb_process_id == fProcess.cdb_process_id)

    # Queries below are intentionally unordered, because we want
    # to get all components from the schema tree, and ordering
    # does not make any sense.
    AllTaskGroups = Reference_N(fTaskGroup,
                                fTaskGroup.cdb_process_id == fProcess.cdb_process_id)

    def _ProcessCompletion(self):
        from cs.workflow.taskgroups import ProcessCompletionTaskGroup
        pctg = ProcessCompletionTaskGroup.KeywordQuery(
            cdb_process_id=self.cdb_process_id,
            cdb_classname=ProcessCompletionTaskGroup.__classname__)
        return pctg[0] if (pctg != []) else None
    ProcessCompletion = ReferenceMethods_1(fTaskGroup, lambda self: self._ProcessCompletion())

    AllTasks = Reference_N(fTask, fTask.cdb_process_id == fProcess.cdb_process_id)
    # all tasks of current workflow, no matter on which level

    AllComponents = Reference_N(fSchemaComponent,
                                fSchemaComponent.cdb_process_id == fProcess.cdb_process_id)

    # References to briefcases
    BriefcaseLinksByType = ReferenceMapping_N(
        fBriefcaseLink,
        (fBriefcaseLink.cdb_process_id == fTask.cdb_process_id) &
        (fBriefcaseLink.task_id == ''),
        indexed_by=fBriefcaseLink.iotype)

    AllBriefcaseLinksByType = ReferenceMapping_N(
        fBriefcaseLink,
        fBriefcaseLink.cdb_process_id == fTask.cdb_process_id,
        indexed_by=fBriefcaseLink.iotype)

    AllBriefcaseLinks = Reference_N(
        fBriefcaseLink,
        fBriefcaseLink.cdb_process_id == fProcess.cdb_process_id)

    BriefcaseLinks = Reference_N(fBriefcaseLink,
                                 fBriefcaseLink.cdb_process_id == fProcess.cdb_process_id,
                                 fBriefcaseLink.task_id == '')

    AllBriefcases = Reference_N(fBriefcase,
                                fBriefcase.cdb_process_id == fProcess.cdb_process_id)

    # References to the content of the process and every task
    def _getAllContent(self, iotype):
        return self.getContent(iotype, "AllBriefcaseLinksByType")

    AllInfoContent = ReferenceMethods_N(Object, lambda self: self._getAllContent("info"))
    AllEditContent = ReferenceMethods_N(Object, lambda self: self._getAllContent("edit"))
    AllContent = ReferenceMethods_N(Object, lambda self: self._getAllContent("all"))

    # Direct process constraints
    Constraints = Reference_N(fConstraint,
                              fConstraint.cdb_process_id == fSchemaComponent.cdb_process_id,
                              fConstraint.task_id == '')

    # All process and component constraints
    AllConstraints = Reference_N(fConstraint,
                                 fConstraint.cdb_process_id == fSchemaComponent.cdb_process_id)

    AttachmentsBriefcase = Reference_1(fBriefcase,
                                       fBriefcase.cdb_process_id == fProcess.cdb_process_id,
                                       fBriefcase.briefcase_id == 0)

    StartedBy = Reference_1(fUser, fProcess.started_by)

    event_map = {
        (('create', 'copy'), 'pre'): ("make_process_id", "setObjektArt"),
        (('create', 'copy'), 'post'): "set_follow_up",
        (('create'), 'post'): ('ensure_process_completion', 'make_attachments_briefcase',
                               'setup_ahwf'),
        (('create', 'copy', 'modify'), 'pre'): "check_max_duration",
        (('create', 'copy', 'modify'), 'post'): "update_cdb_project_id",
        ('modify', 'pre_mask'): "disable_template",
        ('cdbwf_start_workflow', 'now'): 'op_activate_process',
        ('cdbwf_onhold_workflow', 'now'): 'op_onhold_process',
        ('cdbwf_cancel_workflow', 'now'): 'op_cancel_process',
        ('cdbwf_dismiss_workflow', 'now'): 'op_dismiss_process',
        ('relship_copy', 'post'): 'deep_copy_briefcases',
        ('delete', 'pre'): ('deep_delete_briefcases', 'deep_delete_components'),
        ('copy', 'pre'): 'check_copy_from_template'
    }

    def lock_is_template(self, ctx):
        # deprecated
        self.is_template = ctx.cdbtemplate.is_template
        ctx.set_readonly("is_template")

    def getWorkflowDesignerURL(self):
        from cs.workflow.designer import WorkflowDesigner
        return "{}?cdb_process_id={}".format(WorkflowDesigner.getModuleURL(),
                                             self.cdb_process_id)

    def set_follow_up(self, ctx):
        if ctx.error:
            return
        if not ctx.uses_webui:
            ctx.set_followUpOperation("cdbwf_start_workflow_designer",
                                      use_result=True)

    def op_activate_process(self, ctx=None):
        if self.isTemplate():
            raise ue.Exception("cdbwf_operation_template_not_allowed")
        if self.status != self.NEW.status and self.status != self.FROZEN.status:
            raise ue.Exception("cdbwf_process_not_activable")
        self.activate_process()

    def op_onhold_process(self, ctx=None):
        if self.isTemplate():
            raise ue.Exception("cdbwf_operation_template_not_allowed")
        if self.status != self.EXECUTION.status:
            raise ue.Exception("cdbwf_process_not_holdable")
        self.onhold_process()

    def op_cancel_process(self, ctx=None):
        if self.isTemplate():
            raise ue.Exception("cdbwf_operation_template_not_allowed")
        if self.status not in [self.NEW.status, self.EXECUTION.status]:
            raise util.ErrorMessage("cdbwf_operation_allowed")
        else:
            self.cancel_process()

    def op_dismiss_process(self, ctx=None):
        if self.status not in [self.NEW.status, self.FAILED.status]:
            raise util.ErrorMessage("cdbwf_operation_allowed")
        else:
            self.dismiss_process()

    def setup_ahwf(self, ctx):
        if set(["ahwf_classpath", "ahwf_content"]) <= \
                set(ctx.sys_args.get_attribute_names()):
            classpath = ctx.sys_args.ahwf_classpath
            cdbclass = tools.getObjectByName(classpath)

            object_ids = ctx.sys_args.ahwf_content.split(";")
            objects = cdbclass.Query(cdbclass.cdb_object_id.one_of(*object_ids))

            cdbclass.setup_ahwf(self.getPersistentObject(), objects)

    def handleSubscriptions(self):
        if self.status == self.EXECUTION.status:
            if self.GetClassDef().isActivityChannel():
                from cdb.objects.blog import Subscription
                for person in self.Subject.getPersons():
                    Subscription.subscribeToChannel(self.cdb_object_id,
                                                    person.personalnummer)

    # ===========================================================================
    # New interface
    # ===========================================================================

    def activate_process(self):
        """
        Start the current workflow.
        The tasks would be set to ready if possible.
        """
        try:
            require_feature_viewing()
            if self.status == self.FROZEN.status:
                self.setReady()
            else:
                # check constraints on process and global briefcases
                if self.Constraints:
                    self.addProtocol("[Process starting] Checking constraints..",
                                     protocols.MSGSYSTEM)
                    for constraint in self.Constraints:
                        constraint.check_violation(self)

                self.set_briefcase_rights()

                self.update_change_log()

                self.setReady()

                # Subscribe to activity stream
                self.handleSubscriptions()

                if self.Components:
                    self.activate_tasks()
                else:
                    self.close_process()
        except exceptions.TaskCancelledException as ex:
            msg = unicode(ex)
            self.cancel_process(msg)
        except RuntimeError as ex:
            raise ue.Exception(1024, unicode(ex))

    def onhold_process(self):
        """
        Hold on the current workflow.
        Do not reset the state of the tasks.
        """
        try:
            require_feature_viewing()
            self.setOnhold()
        except RuntimeError as ex:
            raise ue.Exception(1024, unicode(ex))

    def get_cancel_info_setting(self):
        cancel = util.PersonalSettings().getValueOrDefault(
            "cs.workflow",
            "cancel_info_on_failure",
            None)
        return cancel == "1"

    def _cancel_info_messages(self):
        with transactions.Transaction():
            info = fInfoMessage.KeywordQuery(
                cdb_process_id=self.cdb_process_id)

            if self.ProcessCompletion:
                completion_info = self.ProcessCompletion.AllTasks.task_id
                info = info.Query("task_id NOT IN ('{}')".format(
                    "', '".join(completion_info)))

            info.Update(is_active=0)
            self.addProtocol(
                unicode(util.get_label("cdbwf_cancel_info_messages")),
                protocols.MSGINFO)

    def cancel_info_messages(self):
        if self.get_cancel_info_setting():
            self._cancel_info_messages()

    def cancel_process(self, comment=""):
        """
        Cancel the current workflows.
        The `completion` tasks would be activated if exist.
        """
        require_feature_viewing()
        self.Update(completing_ok=0)
        from cs.workflow.taskgroups import TaskGroup
        components = self.Components.Query(
            fSchemaComponent.status.one_of(TaskGroup.EXECUTION.status,
                                           TaskGroup.NEW.status))

        for component in components:
            component.cancel_task(comment)

        self.cancel_info_messages()

        try:
            if self.ProcessCompletion and \
               (self.ProcessCompletion.status == self.ProcessCompletion.NEW.status):
                self.ProcessCompletion.activate_task()
            else:
                self.setCancelled(comment)
        except (exceptions.TaskCancelledException, exceptions.TaskClosedException):
            self.setCancelled(comment)
        except RuntimeError as ex:
            raise ue.Exception(1024, unicode(ex))

    def dismiss_process(self):
        """
        Dismiss the current workflow.
        The `completion` tasks would be cancelled.
        """
        require_feature_viewing()
        self.Update(completing_ok=0)
        from cs.workflow.taskgroups import TaskGroup
        components = self.Components.Query(
            fSchemaComponent.status.one_of(TaskGroup.EXECUTION.status,
                                           TaskGroup.NEW.status))

        for component in components:
            component.cancel_task()

        self.cancel_info_messages()

        if self.ProcessCompletion and \
           (self.ProcessCompletion.status in [
                self.ProcessCompletion.NEW.status,
                self.ProcessCompletion.EXECUTION.status]):
            self.ProcessCompletion.cancel_task()

        try:
            self.setDismissed()
        except RuntimeError as ex:
            raise ue.Exception(1024, unicode(ex))

    def close_process(self):
        """
        Attempts to close the workflow.
        The `completion` tasks would be activated if exist.
        """
        try:
            require_feature_viewing()
            if self.ProcessCompletion and \
               (self.ProcessCompletion.status == self.ProcessCompletion.NEW.status):
                self.ProcessCompletion.activate_task()
            else:
                self.setDone()
        except (exceptions.TaskCancelledException, exceptions.TaskClosedException):
            self.setDone()
        except RuntimeError as ex:
            raise ue.Exception(1024, unicode(ex))

    def activate_tasks(self):
        require_feature_viewing()
        components = self.Components
        if components:
            first = components[0]
            first.activate_task()

    def propagate_done(self, child):
        from cs.workflow.taskgroups import TaskGroup

        if TaskGroup.has_finish_option(child):
            # cancel running and new tasks
            components = self.Components.Query(
                fSchemaComponent.status.one_of(TaskGroup.EXECUTION.status,
                                               TaskGroup.NEW.status))
            for component in components:
                component.cancel_task()

            self.close_process()
        else:
            try:
                next_sibling = child.Next
                cycle = True

                while next_sibling and cycle:
                    try:
                        next_sibling.activate_task()
                        cycle = False
                    except exceptions.TaskClosedException:
                        next_sibling = next_sibling.Next

                if not next_sibling:
                    self.close_process()
            except exceptions.TaskCancelledException as ex:
                msg = unicode(ex)
                self.cancel_process(msg)

    def propagate_onhold(self, child):
        self.onhold_process()

    def propagate_cancel(self, child, comment=""):
        # there should always be a process completing task group,
        # but for backward compatibility we don't rely on it
        self.cancel_process(comment)

    def propagate_refuse(self, child, comment=""):
        self.cancel_process(comment)

    # ===========================================================================
    # End new interface
    # ===========================================================================

    def is_sequential(self):
        return True

    def is_parallel(self):
        return False

    class NEW(State):
        status = 0

        def pre(state, self, ctx):  # @NoSelf
            self._reset_schema()

    # obsolete status classes
    def READY(cls):
        deprecation_warning(__name__, "READY", "EXECUTION")
        return cls.EXECUTION

    def DONE(cls):
        deprecation_warning(__name__, "DONE", "COMPLETED")
        return cls.COMPLETED

    def CANCELLED(cls):
        deprecation_warning(__name__, "CANCELLED", "FAILED")
        return cls.FAILED

    def DISMISSED(cls):
        deprecation_warning(__name__, "DISMISSED", "DISCARDED")
        return cls.DISCARDED

    def ONHOLD(cls):
        deprecation_warning(__name__, "ONHOLD", "FROZEN")
        return cls.FROZEN

    def CHECKING(cls):
        deprecation_warning(__name__, "CHECKING", "REVIEW")
        return cls.REVIEW

    class EXECUTION(State):
        status = 10

        def pre(state, self, ctx):  # @NoSelf
            for briefcase in self.AllBriefcaseLinks:
                briefcase.check_obj_rights(ctx)

            from cs.workflow import tasks
            # Check project roles, if cs.pcs installed
            if hasattr(self, "_check_project_roles"):
                self._check_project_roles()

            errmsgs = []
            for task in self.AllTasks:
                try:
                    task.check_process_start_preconditions()
                except tasks.TaskDataIncompleteException as e:
                    errmsgs.append((task, unicode(e)))

            if errmsgs:
                msg = "\n".join(["%s %s: %s" % (task.AbsolutePath(),
                                                task.title,
                                                errmsg)
                                 for (task, errmsg) in errmsgs])
                raise util.ErrorMessage("cdbwf_err102", msg)

            # Set the title, for those tasks which don't have one
            # Check that every task has a title
            condition = (tasks.Task.title == '') | (tasks.Task.title == None)
            for task in self.AllTasks.Query(condition):
                task.set_title()

            # set start date and deadline
            self.start_date = datetime.date.today()
            calc_deadline(self)

            # Reset everything to NEW here if not recovered from on hold
            if int(ctx.old.status) != self.FROZEN.status:
                self._reset_schema()

        def post(state, self, ctx):  # @NoSelf
            self.addProtocol("[Process started] ", protocols.MSGSYSTEM)
            if int(ctx.old.status) == self.FROZEN.status:
                self.AllComponents.Update(process_is_onhold=0)
            # Set first group to EXECUTION.

    class COMPLETED(State):  # or RELEASED (template)
        status = 20

        def pre(state, self, ctx):  # @NoSelf
            if self.isTemplate():
                lbl = util.get_label("cdbwf_process_template_approved")
                msg = protocols.MSGAPPROVED
            else:
                lbl = util.get_label("cdbwf_process_done")
                msg = protocols.MSGDONE
            self.addProtocol("%s " % lbl, msg)

    class FAILED(State):
        status = 30

        def pre(state, self, ctx):  # @NoSelf
            comment = getattr(ctx.dialog, 'comment', '')
            # intentionally using MSGREFUSE instead of MSGCANCEL
            lbl = util.get_label("cdbwf_process_cancelled")
            self.addProtocol("%s \n%s" % (lbl, comment), protocols.MSGREFUSE)

        def post(state, self, ctx):  # @NoSelf
            if int(ctx.old.status) == self.FROZEN.status:
                self.AllComponents.Update(process_is_onhold=0)

    class DISCARDED(State):  # or INVALID (template)
        status = 40

        def pre(state, self, ctx):  # @NoSelf
            self.addProtocol("[Process discarded] ", protocols.MSGREFUSE)

    class FROZEN(State):
        status = 50

        def pre(state, self, ctx):  # @NoSelf
            self.addProtocol("[Process on hold] ", protocols.MSGSYSTEM)
            self.AllComponents.Update(process_is_onhold=1)

    class REVIEW(State):
        status = 100

    def on_cdbwf_start_workflow_designer_now(self, ctx):
        ctx.url(self.getWorkflowDesignerURL())

    def setObjektArt(self, ctx):
        self.cdb_objektart = self.GetObjectKind()

    def GetObjectKind(self):
        obj_art = self.GetClassname()
        if self.isTemplate():
            obj_art += '_template'
        return obj_art

    def GetStateText(self, state, lang=None):
        if lang is None:
            lang = i18n.default()

        return get_state_text(self.GetObjectKind(), state.status, lang)

    @classmethod
    def CreateFromTemplate(cls, template_id, defaults=None):
        defaults = defaults or {}
        args = dict(defaults, is_template="0", cdb_objektart="cdbwf_process")
        if "subject_id" not in args:
            args["subject_id"] = auth.persno
            args["subject_type"] = "Person"

        template = Process.ByKeys(template_id)
        return operations.operation(constants.kOperationCopy,  # @UndefinedVariable
                                    template,
                                    **args)

    @classmethod
    def new_process_id(cls):
        return "P%08d" % util.nextval("cdbwf_process.cdb_process_id")

    @classmethod
    def on_cdbwf_new_process_from_template_now(cls, ctx):
        new_process = cls.CreateFromTemplate(ctx.dialog.cdb_process_id)
        return new_process.Open(action="cdbwf_start_workflow_designer")

    def on_wf_step_post(self, ctx):
        ctx.refresh_tables(['cdbwf_task'])

    def on_relship_copy_post(self, ctx):
        if ctx.relationship_name == 'cdbwf_p2task':
            from cs.workflow.tasks import Task
            self.AllTasks.Update(status=Task.NEW.status,
                                 cdb_status_txt=Task.GetStateText(Task.NEW),
                                 reserved_by='', start_date='',
                                 end_date_act='',
                                 cdb_project_id=self.cdb_project_id)
        elif ctx.relationship_name == 'cdbwf_p2aggr2':
            from cs.workflow.taskgroups import TaskGroup
            self.AllTaskGroups.Update(
                status=TaskGroup.NEW.status,
                cdb_status_txt=TaskGroup.GetStateText(TaskGroup.NEW),
                cdb_project_id=self.cdb_project_id)

    def on_copy_pre(self, ctx):
        calc_deadline(self)

    def on_create_pre_mask(self, ctx):
        self.subject_type = 'Person'
        self.subject_id = auth.persno

    def on_copy_pre_mask(self, ctx):
        if self.subject_type == '':
            self.subject_type = 'Person'
            self.subject_id = auth.persno

    def on_cdb_show_responsible_now(self, ctx):
        return self.openSubject()

    def on_state_change_pre_mask(self, ctx):
        self.Super(Process).on_state_change_pre_mask(ctx)

        # Templates must not be set ready
        if self.isTemplate() and self.status == 0:
            ctx.excl_state(10)

    def make_attachments_briefcase(self, ctx=None):
        if not self.AttachmentsBriefcase:
            briefcases.Briefcase.Create(cdb_process_id=self.cdb_process_id,
                                        briefcase_id=0,
                                        name=util.get_label("cdbwf_attachments"))
            briefcases.set_briefcase_count()

            briefcases.BriefcaseLink.Create(
                cdb_process_id=self.cdb_process_id,
                task_id='',
                briefcase_id=0,
                iotype=briefcases.IOType.info.value,  # @UndefinedVariable
                extends_rights=0)
            self.Reload()

    def make_process_id(self, ctx):
        self.cdb_process_id = self.new_process_id()

    def ensure_process_completion(self, ctx=None):
        from cs.workflow.taskgroups import ProcessCompletionTaskGroup
        ProcessCompletionTaskGroup.ensure_exists_for_process(self)

    def check_max_duration(self, ctx):
        if self.max_duration is not None and self.max_duration < 1:
            raise ue.Exception("cdbwf_max_duration_greater_0")

    def update_cdb_project_id(self, ctx=None):
        self.AllComponents.Update(cdb_project_id=self.cdb_project_id)

    def deep_copy_briefcases(self, ctx):
        if ctx.relationship_name == 'cdbwf_process2briefcase':
            old_briefcases = briefcases.Briefcase.KeywordQuery(
                cdb_process_id=ctx.cdbtemplate.cdb_process_id)
            for old_briefcase in old_briefcases:
                new_briefcase = briefcases.Briefcase.ByKeys(
                    cdb_process_id=ctx.object.cdb_process_id,
                    briefcase_id=old_briefcase.briefcase_id)
                for content in old_briefcase.FolderContents:
                    copy = content.Copy(
                        cdb_folder_id=new_briefcase.cdb_object_id)
                    # call 1; order of relationship copy is not deterministic
                    copy.fix_form_reference()

        elif ctx.relationship_name == "cdbwf_process2forms":
            for briefcase in self.AllBriefcases:
                for content in briefcase.FolderContents:
                    # call 2; order of relationship copy is not deterministic
                    content.fix_form_reference()

    def deep_delete_briefcases(self, ctx):
        old_briefcases = briefcases.Briefcase.KeywordQuery(
            cdb_process_id=ctx.object.cdb_process_id)
        for briefcase in old_briefcases:
            for link in briefcase.Links:
                link.Delete()
            for content in briefcase.FolderContents:
                content.Delete()

    def disable_template(self, ctx):
        ctx.set_readonly("is_template")

    def _Links(self):
        # Used for the email notifications
        linklist = []
        if hasattr(self, "Project") and self.Project:
            linklist.append(Link(self.Project.MakeURL("cdbpcs_project_info"),
                                 "%(project_name)s" % self.Project,
                                 "Projekt:"))
        return linklist

    def _reset_schema(self):
        from cs.workflow.tasks import Task
        from cs.workflow.taskgroups import TaskGroup
        self.AllTaskGroups.Query(TaskGroup.status != TaskGroup.NEW.status).\
            Update(status=TaskGroup.NEW.status,
                   cdb_status_txt=TaskGroup.GetStateText(TaskGroup.NEW))
        self.AllTasks.Query(Task.status != Task.NEW.status).\
            Update(status=Task.NEW.status,
                   cdb_status_txt=Task.GetStateText(Task.NEW),
                   reserved_by='', start_date='', end_date_act='')

    def addProtocol(self, msg, msgtype=protocols.MSGSYSTEM, task_id=""):
        with transactions.Transaction():
            # workaround while E026300 is open
            if msgtype == protocols.MSGTASKREADY:
                persno = None
                from cs.workflow.services import WFServer
                if WFServer:
                    persno = WFServer.get_service_user()
                if not persno:
                    # fallback to process responsible (service might not be running)
                    persons = self.Subject.getPersons()
                    if persons:
                        persno = persons[0].personalnummer
            else:
                persno = auth.persno
            protocols.Protocol.Create(cdb_process_id=self.cdb_process_id,
                                      task_id=task_id,
                                      entry_id=protocols.Protocol.MakeEntryId(),
                                      personalnummer=persno,
                                      timestamp=datetime.datetime.now(),
                                      description=msg[:protocols.Protocol.description.length],
                                      msgtype=msgtype)

    def setCancelled(self, comment=""):
        set_state(self, self.FAILED, comment=comment)

    def setDismissed(self):
        set_state(self, self.DISCARDED)

    def setReady(self):
        set_state(self, self.EXECUTION)

    def setDone(self):
        set_state(self, self.COMPLETED)

    def setNew(self):
        set_state(self, self.NEW)

    def setOnhold(self):
        set_state(self, self.FROZEN)

    def Subjects(self):
        """
        Returns all subjects that are defined as responsibles for at least one interactive
        task within the process. System tasks are not considered. The returned dictionary
        contains a lists of subject ids for each subject type.
        """
        result = {}
        for t in self.AllTasks:
            if not t.isSystemTask():
                if t.subject_type not in result.keys():
                    result[t.subject_type] = [t.subject_id]
                elif t.subject_id not in result[t.subject_type]:
                    result[t.subject_type].append(t.subject_id)
        return result

    @classmethod
    def get_processes_by_user(cls, persno):
        """
        All (non-new and non-discarded) processes with (non-new and non-cancelled)
        tasks which are either directly assigned to a given user id or indirectly
        via a role.
        """
        from cs.workflow.tasks import Task
        processes = [task.Process for task in Task.get_all_tasks_by_user()]
        processes = [proc for proc in processes if proc.status != cls.DISCARDED.status]
        return list(set(processes))

    @classmethod
    def get_global_coworkers(cls, persno):
        """
        All other users and roles participating in the same (non-new and non-discarded)
        processes as given user.
        """
        coworkers = []
        for process in cls.get_processes_by_user(persno):
            coworkers.extend(process.get_process_coworkers(persno))
        return list(set(coworkers))

    def get_process_coworkers(self, persno):
        """All other users and roles participating in this process."""
        coworkers = self.Subjects().values()
        # flatten the list
        coworkers = [coworker for sublist in coworkers for coworker in sublist]
        # always include the process owner (in case he's not a task owner)
        if self.subject_id not in coworkers:
            coworkers.append(self.subject_id)
        # exclude current user
        return [coworker for coworker in coworkers if coworker != auth.persno]

    def HandlesStateChange(self, obj, state):
        """ Returns True, if this process handles an automatic
        state change for the given object to the given target state."""
        raise Exception("not implemented since cs.workflow 2.0")

    def is_position_editable(self, position):
        """Check if the addition of a new task in the given position is allowed."""

        from cs.workflow.tasks import Task
        from cs.workflow.schemacomponents import SchemaComponent

        # Check ordering, if parent is already running and task processing is
        # sequential
        if self.status > self.NEW.status:
            positions = self.Components.Query(
                (SchemaComponent.status > Task.NEW.status) &
                (SchemaComponent.position >= position))

            if positions:
                return False
        return True

    def update_change_log(self):
        """ Set the attributes 'started_by' and 'started_at' """
        self.Update(started_by=auth.persno, started_at=datetime.datetime.now())

    def GetActivityStreamTopics(self, posting):
        """Topics for Postings."""
        return [self, self.Project if hasattr(self, "Project") else None]

    def get_last_tasks(self):
        from cs.workflow.tasks import Task

        if self.Components:
            pos = max(self.Components.position)
            comp = self.Components.KeywordQuery(position=pos)[0]
            if isinstance(comp, Task):
                return [comp]
            else:
                return comp.get_last_tasks()
        else:
            return []

    def deep_delete_components(self, ctx):
        comps = self.Components
        compl = self.ProcessCompletion
        if compl:
            comps = comps + [compl]
        # force delete component in batch mode
        opargs = {"cdbwf_force_delete": 1}
        for component in comps:
            operations.operation(constants.kOperationDelete,  # @UndefinedVariable
                                 component,
                                 operations.system_args(**opargs))

    def isTemplate(self):
        # is_template is a text field
        return self.is_template == "1"

    def check_copy_from_template(self, ctx):
        if ctx.cdbtemplate.is_template == "1" and self.is_template != ctx.cdbtemplate.is_template:
            require_feature_templating()


class ProcessPyruleAssignment(Object):
    """
    Powerscript representation of the class
    ``class cdbwf_process_pyrule_assign``.
    """

    __maps_to__ = "cdbwf_process_pyrule_assign"
    __classname__ = "cdbwf_process_pyrule_assign"

    Process = Reference_1(fProcess, fProcessPyruleAssignment.cdb_process_id)
    Pyrule = Reference_1(fRule, fProcessPyruleAssignment.name)


class ProcessTemplateCatalog(gui.CDBCatalog):
    """
    """
    def __init__(self):
        """ Initializes the catalog."""
        gui.CDBCatalog.__init__(self)

    def init(self):
        """
        Calculate whether we know something about the table
        """
        self.setResultData(ProcessTemplateCatalogContent(self))


class ProcessTemplateCatalogContent(gui.CDBCatalogContent):
    """
    """
    def __init__(self, catalog):
        """
        Initializes the content
        """
        tabdefname = catalog.getTabularDataDefName()
        self.cdef = catalog.getClassDefSearchedOn()
        tabdef = self.cdef.getProjection(tabdefname, True)
        gui.CDBCatalogContent.__init__(self, tabdef)
        self.data = None
        self.rule_assignments = None
        self.objects = catalog.getInvokingOpObjects()

    def _init_data(self):
        """
        Calculates the catalog content.
        """
        if self.data is None:
            self.data = []
            condition = self.getSQLCondition()
            if not condition:
                condition = "1=1"
            candidates = Process.FromRecords(sqlapi.RecordSet2("cdbwf_process", condition=condition, access='read'))
            # To avoid the garbage collection of all_rules before we use rule.ByKeys
            all_rules = None
            if not self.objects:
                self.data = candidates
            else:
                obj = self.objects[0]
                if self.rule_assignments is None:
                    self.rule_assignments = {}
                    assignments = ProcessPyruleAssignment.Query(order_by="cdb_process_id")
                    try:
                        # This is to get all Rules with one select
                        # The Rule.ByKeys construction will use the cached object
                        all_rules = Rule.Query(Rule.name.one_of(*assignments.name))
                        for rule in all_rules:
                            # Just to instantiate the rule
                            pass
                    except Exception as e:
                        misc.log_error("Failed to get all rules with one call:%s" % str(e))

                    last_process_id = None
                    rules = []
                    for ra in assignments:
                        if ra.cdb_process_id != last_process_id:
                            if last_process_id and rules:
                                self.rule_assignments[last_process_id] = rules
                                rules = []
                            last_process_id = ra.cdb_process_id
                        rules.append(ra)
                    if last_process_id and rules:
                        self.rule_assignments[last_process_id] = rules

                for candidate in candidates:
                    if candidate.cdb_process_id not in self.rule_assignments.keys():
                        self.data.append(candidate)
                    else:
                        for ra in self.rule_assignments[candidate.cdb_process_id]:
                            rule = Rule.ByKeys(ra.name)
                            try:
                                if rule and rule.match(obj):
                                    self.data.append(candidate)
                                    break
                            except:
                                # Rule seems to be not suitable for the object
                                pass

    def onSearchChanged(self):
        """
        Callback if the users search changes.
        """
        self.data = None

    def getNumberOfRows(self):
        """Called by CDB to retrieve the number of rows in the catalog"""
        self._init_data()
        if self.data:
            return len(self.data)
        else:
            return 0

    def getRowObject(self, row):
        """
        """
        self._init_data()
        ft = self.data[row]
        if ft:
            return ft.ToObjectHandle()
        else:
            return mom.CDBObjectHandle()
