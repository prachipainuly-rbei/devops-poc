#!/usr/bin/env powerscript
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

"""
Module misc

This is the documentation for the misc module.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: misc.py 184830 2018-10-09 06:35:09Z cso $"

import time
import datetime

from cdb import transaction
from cdb import CADDOK
from cdb import constants
from cdb import i18n
from cdb.tools import getObjectByName
from cdb.lru_cache import lru_cache
from cdb.misc import log_error
from cdb.objects.cdb_file import CDB_File
from cdb.objects.operations import operation
from cdb.platform.olc import StateDefinition

from cdb.platform import mom
from cdb.objects import Object
from cdb.objects.operations import operation
from cdb.fls import allocate_license

from cs.activitystream.objects import UserPosting
from cs.taskmanager.web.main import MOUNTEDPATH


__all__ = ['deprecation_warning',
           'calc_deadline',
           'DummyContext',
           'get_state_text',
           'is_auxiliary_file',
           'is_converted_file',
           'Link',
           'now',
           'set_state',
           'set_state_interactive',
           'is_installed',
           'get_base_url',
           'create_user_posting']

__STATE_TXT_CACHE = {}
DEPRECATION = "{name}.{old} is deprecated. Please use {new} instead."


def deprecation_warning(name, old, new):
    log_error(DEPRECATION.format(name=name, old=old, new=new))


def _get_pydate_format(_format):
    # Workaround for E032998
    import re

    conversions = [
        ("YYYY", "%Y"),
        ("MM", "%m"),
        ("DD", "%d"),
        ("hh", "%H"),
        ("mm", "%M"),
        ("ss", "%S")
    ]

    result = _format
    for wrong, right in conversions:
        result = re.sub(wrong, right, result)
    return result


def get_pydate_format():
    return _get_pydate_format(i18n.get_date_format())


def get_pydatetime_format():
    return _get_pydate_format(i18n.get_datetime_format())


def _run_op(opname, cls_or_obj, *args, **kwargs):
    return operation(opname, cls_or_obj, *args, **kwargs)


def calc_deadline(process):
    if process.max_duration and process.start_date:
        # FIXME: This code does not handle fractions of a day and
        # neither weekends nor holidays
        start_date = process.start_date
        delta = datetime.timedelta(days=process.max_duration)
        process.deadline = start_date + delta


def set_state(obj, state, **kwargs):
    with transaction.Transaction():
        obj.ChangeState(state.status, check_access=0, **kwargs)
        if getattr(obj, "notifyAfterStateChange", None):
            obj.notifyAfterStateChange()


# Fixed E015631: the state change action can only be called in
#                interactive mode from todo panel
def set_state_interactive(obj, state, **kwargs):
    with transaction:
        obj.ChangeState(state.status, check_access=1, **kwargs)
        if getattr(obj, "notifyAfterStateChange", None):
            obj.notifyAfterStateChange()


def get_state_text(objektart, status_number, lang=None):
    key = "%s:%s" % (objektart, status_number)
    if key not in __STATE_TXT_CACHE:
        txt = ''
        sd = StateDefinition.ByKeys(objektart=objektart,
                                    statusnummer=status_number)
        if sd:
            txt = sd.StateText[lang or CADDOK.ISOLANG]
        __STATE_TXT_CACHE[key] = txt
    return __STATE_TXT_CACHE[key]


def now(fmt='%d.%m.%Y'):
    return time.strftime(fmt, time.localtime(time.time()))


def is_converted_file(fobj):
    # files created by ACS/DCS (.pdf,..)
    if fobj.cdbf_derived_from:
        orig_file = CDB_File.ByKeys(cdb_object_id=fobj.cdbf_derived_from)
        if orig_file:
            return orig_file.cdbf_object_id == fobj.cdbf_object_id
    return False


def is_auxiliary_file(fobj):
    # auxiliary files (.appinfo, .png,..) pointing to the 'main' file
    return True if fobj.cdb_belongsto else False


class DummyContext(object):
    def get_attribute_names(self):
        return self.__dict__.keys()


class Link(object):
    def __init__(self, href, text, prompt="", icon=""):
        self.href = href
        self.text = text
        self.prompt = prompt
        self.icon = icon


def is_installed(module):
    try:
        __import__(module)
        return True
    except ImportError:
        return False


def get_object_class_by_name(clsname):
    extcls_conf = mom.entities.Class.ByClassname(clsname)
    if not extcls_conf:
        return None
    try:
        return getObjectByName(extcls_conf.getFqpyname())
    except Exception:
        pass
    return None


def notification_enabled():
    """
    Check flag: whether the email notification should be turned on or off.
    """
    return CADDOK.get("STOP_EMAIL_NOTIFICATION", None) is None


class ResponsibleBrowserEntry(Object):
    """Only for query.
    """
    __classname__ = "cdbwf_resp_browser"
    __maps_to__ = "cdbwf_resp_browser"

    @classmethod
    def DescriptionAttr(cls):
        return "description_{}".format(i18n.default())

    @classmethod
    def SubjectNameAttr(cls):
        return "subject_name_{}".format(i18n.default())

    def GetSubjectName(self):
        return getattr(self, self.SubjectNameAttr(), "")


def require_feature_viewing():
    # check license for viewing and excuting workflow
    allocate_license("WORKFLOW_001")


def require_feature_setup():
    # Check license for defining workflows
    allocate_license("WORKFLOW_002")


def require_feature_templating():
    # Check license for using workflow template
    allocate_license("WORKFLOW_003")


@lru_cache(maxsize=1, clear_after_ue=False)
def prefer_web_urls():
    preference = CADDOK.get("PREFER_LEGACY_URLS", None)
    return preference != "True"


@lru_cache(maxsize=1, clear_after_ue=False)
def get_base_url():
    base_url = CADDOK.get("WWWSERVICE_URL", "")
    if base_url in ["", "http://www.example.org"]:
        log_error("CADDOK_WWWSERVICE_URL is not set")
    return base_url


@lru_cache(maxsize=1, clear_after_ue=False)
def get_taskmanager_url(task):
    if prefer_web_urls():
        return "{}{}/{}".format(
            get_base_url(), MOUNTEDPATH, task.cdb_object_id)
    else:  # PC client
        return task.MakeURL(action="cs_tasks", plain=2)


def create_user_posting(context_object, comment):
    if comment:
        posting = operation(
            constants.kOperationNew,
            UserPosting,
            context_object_id=context_object.cdb_object_id,
        )
        posting.SetText("cdbblog_posting_txt", comment)
