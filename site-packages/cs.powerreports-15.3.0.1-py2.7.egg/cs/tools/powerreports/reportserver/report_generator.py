#!/usr/bin/env python
# $Id: report_generator.py 183800 2018-09-12 20:29:16Z kbu $
#
# Copyright (C) 1990 - 2009 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""Creation of PowerReports w/o interaction"""

import os
import time
import traceback

from cdb import misc
from cdb.plattools import killableprocess
from cs.tools.powerreports.reportserver.reportlib import getConfValue, log


class ReportGenerator(object):
    def __init__(self):
        import win32com.client
        win32com.client.gencache.EnsureModule(
            '{00020813-0000-0000-C000-000000000046}',
            0x0, 1, 5)
        self.my_excel = None
        self.my_workbook = None
        self.timeout = getConfValue("REPORT_SERVER_TIMEOUT", 0)
        self.timeout_exceeded = False

    def ensure_officelink(self):
        from glob import glob
        found = glob(os.path.expandvars(r"%PROGRAMFILES%\*OfficeLink*\OfficeLink.dll"))
        if not found:
            found = glob(os.path.expandvars(
                r"%PROGRAMFILES(X86)%\*OfficeLink*\OfficeLink.dll"))
        if not found:
            custom_install_dir = getConfValue("REPORT_OFFICELINK_INSTALLDIR", "")
            if custom_install_dir:
                custom_install_dir = os.path.join(custom_install_dir, "OfficeLink.dll")
                found = glob(os.path.expandvars(custom_install_dir))
        if found:
            log("OfficeLink installation found: %s" % found[0])
        else:
            raise Exception("Could not find an OfficeLink installation in any of these folders "
                            "on the report server:\n"
                            "-%PROGRAMFILES%\*OfficeLink*\n"
                            "-%PROGRAMFILES(X86)%\*OfficeLink*\n"
                            "-REPORT_OFFICELINK_INSTALLDIR (etc/power_reports.conf)")

        if getConfValue("REPORT_RESTORE_OFFICELINK", True):
            import _winreg
            # re-activate "disabled" OfficeLink (the correct default keys are in HKEY_LOCAL_MACHINE)
            try:
                with _winreg.OpenKey(_winreg.HKEY_CURRENT_USER,
                                     r"Software\Microsoft\Office\Excel\Addins",
                                     0, _winreg.KEY_ALL_ACCESS) as key:
                    _winreg.DeleteKey(key, "OfficeLink.Connect")
                    log(r"Deleted registry key HKCU\Software\Microsoft\Office"
                        r"\Excel\Addins\OfficeLink.Connect in order to re-activate OfficeLink")
            except WindowsError:
                pass
            # re-activate "deactivated" OfficeLink
            for office_version in ["11.0", "12.0", "14.0", "15.0", "16.0", "17.0"]:
                try:
                    with _winreg.OpenKey(_winreg.HKEY_CURRENT_USER,
                                         r"Software\Microsoft\Office"
                                         r"\%s\Excel\Resiliency\DisabledItems" % office_version,
                                         0, _winreg.KEY_ALL_ACCESS) as key:
                        for n in range(0, _winreg.QueryInfoKey(key)[1]):
                            subkey, val, _ = _winreg.EnumValue(key, n)
                            if "officelink" in val.replace("\x00", ""):
                                _winreg.DeleteValue(key, subkey)
                                log(r"Deleted registry key HKCU\Software\Microsoft\Office"
                                    r"\%s\Excel\Resiliency\DisabledItems in order to re-activate "
                                    "OfficeLink" % office_version)
                except WindowsError:
                    pass

    def open_doc(self, fname):
        import win32com.client
        self.my_excel = win32com.client.DispatchEx('Excel.Application')
        self.my_excel.Application.AskToUpdateLinks = 0
        # we don't use the API function 'Workbooks.Open()' at this point, since
        # it results in various issues (not inserted images, ignored print areas, etc.):
        fname = os.path.normpath(fname)
        # Currently (Win10 + Excel 2016) following os.startfile call returns after ~2 minutes,
        # even if Excel still isn't ready, so we gotta keep waiting afterwards for a while
        log("Calling os.startfile..")
        os.startfile('"%s"' % fname)
        log("os.startfile call finished")
        if self.my_excel:  # might be None due to the timeout kill
            tries = (self.timeout / 10) if self.timeout else 1
            while tries and self.my_excel:
                try:
                    log("Excel.Application.Ready=%s" % self.my_excel.Ready)
                    break
                except:
                    log("Excel.Application.Ready=False")
                    time.sleep(10)
                    if self.timeout:
                        tries -= 1
            awb = self.my_excel.ActiveWorkbook
            if (awb is not None) and (awb.FullName.lower() == fname.lower()):
                self.my_workbook = awb
            else:
                log("Target excel file doesn't seem to indirectly open in Office Excel "
                    "(via doubleclick in windows explorer).", 0, misc.kLogErr)

    def create_pdf(self, fname):
        from cs.officelink.converter import pdfconverter
        pdfconverter.convert(fname, cfgfile=None, znum=None, zidx=None)
        pdf_result = "%s.pdf" % os.path.splitext(fname)[0]
        return pdf_result

    def kill_excel(self):
        self.my_excel = None
        self.my_workbook = None
        with open(os.devnull, 'w') as FNULL:
            killableprocess.call(['taskkill', '/f', '/t', '/im', 'excel.exe'],
                                 stdout=FNULL, stderr=FNULL)

    def timeout_callback(self):
        self.timeout_exceeded = True
        self.kill_excel()

    def create_report(self, workdir, template_fname, xml_fname, target_basename, make_pdf):
        try:
            log("ReportGenerator.create_report(): START")

            # avoid running excel processes because of the open method above (os.startfile)
            self.kill_excel()

            self.ensure_officelink()

            if self.timeout:
                from threading import Timer
                tm = Timer(self.timeout, self.timeout_callback)
                tm.start()

            # if errors occure while OfficeLink fills the report template,
            # then they are written into follwing file
            cdbresult_file = "%s.cdbresult" % os.path.join(workdir, template_fname)
            open(cdbresult_file, 'a').close()

            self.open_doc(os.path.join(workdir, template_fname))

            if self.my_workbook is None:
                raise Exception("The report template file couldn't be opened.")

            if not target_basename:
                target_basename = "report"

            target_extension = os.path.splitext(template_fname)[1]
            target_fname = os.path.join(
                workdir,
                "%s%s" % (target_basename, target_extension))

            # Mit der Macroausfuehrung gibt es anscheinend
            # Synchronisationsprobleme. Ohne sleep sind die Diagramme teilweise
            # defekt.
            time.sleep(1)
            # Save the report
            self.my_workbook.SaveAs(Filename=target_fname)

            # evaluate potential errors reported by OfficeLink
            with open(cdbresult_file) as f:
                result = f.read()
                if result:
                    raise Exception("OfficeLink: %s" % result)

            if self.timeout:
                # stop monitoring now since pdfconverter has its own timeout handling
                tm.cancel()

            # optional pdf creation
            pdf_target = ""
            log("make_pdf = '%s'" % make_pdf)
            if make_pdf:
                # Excel doesn't like being fingered by GhostScript..
                # close it now!
                self.cleanup()
                pdf_target = self.create_pdf(target_fname)

        except Exception as ex:
            if self.timeout_exceeded:
                msg = "Timeout limit exceeded (%s seconds)" % self.timeout
            else:
                msg = "%s" % ex
                traceback.print_exc()
            log("ReportGenerator.create_report(): %s" % msg)
            ret = {"status": msg,
                   "xls": None,
                   "pdf": None}
        else:
            ret = {"status": "OK",
                   "xls": target_fname,
                   "pdf": pdf_target}

        log("ReportGenerator.create_report(): cleaning up")
        self.cleanup()
        log("ReportGenerator.create_report(): END, return value is %s" % ret)
        return ret

    def _close_workbook(self):
        if self.my_workbook:
            try:
                self.my_workbook.Close()
            except:
                pass
            if self.my_workbook is not None:
                del self.my_workbook
                self.my_workbook = None

    def _close_excel(self):
        if self.my_excel:
            try:
                self.my_excel.Quit()
            except Exception:
                pass
            if self.my_excel is not None:
                del self.my_excel
                self.my_excel = None

    def cleanup(self):
        self._close_workbook()
        self._close_excel()
