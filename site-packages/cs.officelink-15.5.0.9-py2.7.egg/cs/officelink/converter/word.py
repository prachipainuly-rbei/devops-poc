#!/usr/bin/env powerscript
# -*- python -*- coding: UTF-8 -*-
#
# Copyright (C) 2015 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Module word

This is the documentation for the word module.
"""

from __future__ import unicode_literals

__docformat__ = "restructuredtext en"
__revision__ = "$Id: word.py 173986 2018-03-02 15:19:55Z kbu $"

import os
import sys
import time
import traceback

from cdb import misc

from cs.officelink.converter import pdfconverter


class WordConverterBase(object):
    """
    Base class for MS-Word converters
    """

    __conversions__ = ['.doc', '.dot', '.docx', '.docm', '.rtf', '.tml', '.htm', '.html', '.txt']
    __application_name__ = "MS-Word"

    # minimum required word and type library versions
    __application_version_str__ = "Word 2003"
    __application_version__ = 11
    __tlb_clsid__ = "{00020905-0000-0000-C000-000000000046}"
    __tlb_lcid__ = 0
    __tlb_major_version__ = 8
    __tlb_minor_version__ = 3

    def __init__(self, filename, **kwargs):
        super(WordConverterBase, self).__init__(filename, **kwargs)

        try:
            self.conversion_timeout = self.conf_dict["wordconverter_conversion_timeout"]
        except Exception:
            pass
        try:
            self.window_timeout = self.conf_dict["wordconverter_window_timeout"]
        except Exception:
            pass
        # Dialog robot configuration
        if self.window_timeout != 0:
            self.application_name = self.get_conf_param("wordconverter_application_name", "")
            self.auto_confirmations = self.get_conf_param("wordconverter_dialog_confirmations", {})

    def setup_application(self, application):
        if not self.get_conf_param("wordconverter_shellexecute", False):
            application.Visible = self.get_conf_param("wordconverter_visible", False)
        application.DisplayAlerts = 0

    def open_doc(self):
        import win32com.client
        if self.get_conf_param("wordconverter_shellexecute", False):
            self.office_app_obj, self.office_doc_obj = self.open_office_file_indirectly(
                self.filename, "Word.Application", "ActiveDocument")
        else:
            self.office_app_obj = win32com.client.DispatchEx('Word.Application')
            self.setup_application(self.office_app_obj)
            self.office_doc_obj = self.office_app_obj.Documents.Open(
                self.filename, False, False, False)

    def get_document_variables(self):
        doc_vars = {}
        for var in self.office_doc_obj.Variables:
            name = var.Name
            if self.is_reading_document_variable(name):
                doc_vars[name] = None
        return doc_vars

    def cleanup(self):
        try:
            self.office_app_obj.Activate()
        except Exception:
            pass
        try:
            self.office_doc_obj.Close(0)  # 0 ==> Word.WdSaveOptions.wdDoNotSaveChanges
        except Exception:
            pass
        try:
            self.office_app_obj.Quit()
        except Exception:
            pass
        if self.office_doc_obj is not None:
            del self.office_doc_obj
        if self.office_app_obj is not None:
            del self.office_app_obj
        wordtmpfile = os.path.join(self.workdir, '~$' + self.basename[2:] + self.suffix)
        if (os.path.exists(wordtmpfile)):
            try:
                os.remove(wordtmpfile)
            except Exception:
                pass

    def handle_timeout(self):
        # Kill Word Process
        self.kill_app("WINWORD.EXE")


class Word2K7Converter(WordConverterBase, pdfconverter.O2K7PDFConverter):
    """
    Word 2007 built-in PDF converter
    """

    # minimum required word and type library versions
    __application_version__ = 12
    __application_version_str__ = "Word 2007"
    __tlb_major_version__ = 8
    __tlb_minor_version__ = 4

    def __init__(self, filename, **kwargs):
        super(Word2K7Converter, self).__init__(filename, **kwargs)

    def create_pdf(self):
        import pywintypes
        import win32com.client
        # first kill running word processes
        self.kill_app("WINWORD.EXE")
        try:
            # Include document markups into PDF ?
            WdExportItem = win32com.client.constants.wdExportDocumentContent
            if self.get_conf_param("wordconverter_show_markups", 0):
                WdExportItem = win32com.client.constants.wdExportDocumentWithMarkup
            create_pdf_a = self.get_conf_param("wordconverter_create_pdf_a", False)
            self.open_doc()
            if self.update_document_variables():
                self.store_source_file_changes = True
                self.office_doc_obj.Save()
            self.office_doc_obj.ExportAsFixedFormat(
                OutputFileName=self.targetfile,
                ExportFormat=win32com.client.constants.wdExportFormatPDF,
                OpenAfterExport=False,
                OptimizeFor=win32com.client.constants.wdExportOptimizeForPrint,
                Range=win32com.client.constants.wdExportAllDocument,
                From=1, To=1,
                Item=WdExportItem,
                IncludeDocProps=True,
                KeepIRM=True,
                CreateBookmarks=win32com.client.constants.wdExportCreateHeadingBookmarks,
                DocStructureTags=True,
                BitmapMissingFonts=True,
                UseISO19005_1=create_pdf_a)
        except pywintypes.com_error, exc:
            if hasattr(self, "log") and self.log:
                self.log("ERROR: %s on %s" % (exc, self.filename))
            else:
                misc.log_error("%s on %s" % (exc, self.filename))
            return False
        except Exception, exc:
            if hasattr(self, "log") and self.log:
                self.log("%s" % "\n".join(traceback.format_exception(*sys.exc_info())))
            else:
                misc.log_traceback("%s on %s" % (exc, self.filename))
            return False
        finally:
            self.cleanup()
        return True


kUseBuiltInHeadings = "BuiltInHeadings"


class WordConverter(WordConverterBase, pdfconverter.PDFConverter):

    # Print Zoom Formats in Twips
    # (20 Twips = 1 Punkt; 72 Punkte = 1 Zoll = 2,54 cm).
    print_zoom_mapping = {"A4": (11907, 16839),
                          "A5": (8391, 11907)
                          }

    def __init__(self, filename, **kwargs):
        super(WordConverter, self).__init__(filename, **kwargs)
        if not self.valid:
            return

        # overwrite default parameters, if defined
        try:
            self.printer = self.conf_dict["wordconverter_psprinter"]
        except Exception:
            pass

        # set converter specific parameters
        # Bookmarks
        self.handleBookmarks = self.get_conf_param("wordconverter_handle_bookmarks", 0)
        self.removeEmptyBookmarks = self.get_conf_param("wordconverter_remove_empty_bookmarks", 1)

        # Mark-Ups & Revision-Tracking
        self.handleMarkups = self.get_conf_param("wordconverter_show_markups", 0)

        # Links
        self.handleLinks = 0
        # left with default value (0), when 'wordconverter_show_markups' option is
        # used simultaneously.. see comments in 'pdfconverter.conf'
        if not self.handleMarkups:
            self.handleLinks = self.get_conf_param("wordconverter_handle_links", 0)

        # Scaling to target paper size
        self.print_zoom = self.get_conf_param("wordconverter_print_zoom", "A4")
        if self.print_zoom not in self.print_zoom_mapping:
            # invalid target paper format: use default
            self.print_zoom = "A4"
        (self.printZoomPW, self.printZoomPH) = self.print_zoom_mapping[self.print_zoom]

        # Heading formats to create bookmarks
        self.headlines = self.get_conf_param("wordconverter_headings", kUseBuiltInHeadings)

        # Debug link processing by setting a link border
        self.debug_link_processing = self.get_conf_param("wordconverter_debug_link_processing", 0)
        # valid border strings
        # '[0 0 0]'  noBorder
        # '[0 0 1]'  thinBorder
        # '[0 0 2]'  solidBorder
        # valid color strings
        # '[ 0 0 0 ]' Black
        # '[ 0 0 1 ]' Blue
        # '[ 0 1 1 ]' Cyan
        # '[ 0 1 0 ]' Green
        # '[ 1 0 1 ]' Magenta
        # '[ 1 0 0 ]' Red
        # '[ 1 1 0 ]' Yellow
        # '[ 1 1 1 ]' White
        if self.debug_link_processing:
            self.link_color_str = '[ 1 0 1 ]'
            self.link_border_str = '[ 0 0 1 ]'
        else:
            self.link_color_str = '[ 0 0 0 ]'
            self.link_border_str = '[ 0 0 0 ]'

    def convert_to_postscript(self):
        import pywintypes
        import win32com.client
        try:
            # first kill running word processes
            self.kill_app("WINWORD.EXE")
            self.open_doc()
            if self.update_document_variables():
                self.store_source_file_changes = True
                self.office_doc_obj.Save()

            self.office_app_obj.Application.ActivePrinter = self.printer
            self.office_app_obj.Visible = True
            self.office_doc_obj.Saved = True
            self.office_app_obj.Application.NormalTemplate.Saved = True
            time.sleep(2)
            self.office_app_obj.PrintPreview = True
            # Update Tables
            self.update_tables()
            misc.log(5, "WordConverter::convert_to_postscript: Printing Document")
            # Include document markups into PDF ?
            WdPrintOutItem = win32com.client.constants.wdPrintDocumentContent
            if self.handleMarkups:
                WdPrintOutItem = win32com.client.constants.wdPrintDocumentWithMarkup
            self.office_doc_obj.PrintOut(Range=win32com.client.constants.wdPrintAllDocument,
                                         Item=WdPrintOutItem,
                                         Copies=1, Pages="",
                                         PageType=win32com.client.constants.wdPrintAllPages,
                                         ManualDuplexPrint=False,
                                         Collate=True, Background=False,
                                         PrintToFile=True,
                                         PrintZoomColumn=0, PrintZoomRow=0,
                                         PrintZoomPaperWidth=self.printZoomPW,
                                         PrintZoomPaperHeight=self.printZoomPH,
                                         OutputFileName=self.psprintfile, Append=False)

            if self.suffix.lower() in ['.doc', '.dot', '.docx', '.docm']:
                self.applpath = self.office_doc_obj.FullName
                self.docdir = os.path.dirname(self.applpath)
                self.office_app_obj.PrintPreview = False
                self.office_app_obj.WindowState = win32com.client.constants.wdWindowStateMinimize
                bookmarks_doc_view = False
                if self.handleBookmarks:
                    try:
                        bookmarks = self.handle_word_headings()
                        self.append_to_psfile(bookmarks)
                        if len(bookmarks) > 0:
                            bookmarks_doc_view = True
                    except Exception:
                        misc.log_traceback(
                            "WordConverter::convert_to_postscript: Error creating bookmarks - "
                            "PDF will be created without bookmarks")
                if self.handleLinks:
                    try:
                        self.append_to_psfile(self.handle_word_links())
                    except Exception:
                        misc.log_traceback(
                            "WordConverter::convert_to_postscript: Error creating links - "
                            "PDF will be created without links")
                if not self.merge_mode:
                    self.append_to_psfile(self.create_doc_view(bookmarks_doc_view))
        except pywintypes.com_error, exc:
            misc.log_error("%s on %s" % (exc, self.filename))
            return False
        except Exception, exc:
            misc.log_traceback("%s on %s" % (exc, self.filename))
            return False
        finally:
            self.cleanup()
        return True

    def __setup_heading_styles(self):
        import win32com.client
        builtin_headlines = [win32com.client.constants.wdStyleHeading1,
                             win32com.client.constants.wdStyleHeading2,
                             win32com.client.constants.wdStyleHeading3,
                             win32com.client.constants.wdStyleHeading4,
                             win32com.client.constants.wdStyleHeading5,
                             win32com.client.constants.wdStyleHeading6,
                             win32com.client.constants.wdStyleHeading7,
                             win32com.client.constants.wdStyleHeading8,
                             win32com.client.constants.wdStyleHeading9]

        if self.headlines == kUseBuiltInHeadings:
            self.headlines = builtin_headlines
        else:
            # Benutzerdefinierte Formate nur verwenden, wenn alle Formate definiert sind
            for headline in self.headlines:
                self.office_app_obj.Selection.Start = 0
                self.office_app_obj.Selection.End = 0
                Find = self.office_app_obj.Selection.Find
                try:
                    Find.Style = headline
                except Exception:
                    misc.log(5, "WordConverter::__setup_heading_styles: "
                             "User defined heading style '%s' does not exist. "
                             "Using built-in heading styles for bookmarks.")
                    self.headlines = builtin_headlines
                    break

    def handle_word_headings(self):
        misc.log(5, "WordConverter::handle_word_headings: Creating Bookmarks from Headings ...")
        self.__setup_heading_styles()

        # Überschriften im Dokument suchen
        found_headings = []
        counter = 0
        for headline in self.headlines:
            counter = counter + 1
            style_info = StyleInfo(headline, counter)
            found_headings += self.find_word_headings(style_info)

        # Bei Konvertierung mehrerer Dokumente zu einem PDF Bookmark
        # für das Dokument einfügen
        if self.doc_bookmark is not None:
            for heading in found_headings:
                heading.level += 1
            found_headings.append(self.doc_bookmark)
            # Da bereits behandelt auf None setzen
            self.doc_bookmark = None

        # nach Position im Dokument sortieren
        found_headings.sort(pdfconverter.compareBookmarkStartPosition)

        # Adding dummy headings to keep PDF structure
        dummyHeadings = []
        PrevLevel = 0
        for heading in found_headings:
            Index = heading.level
            APage = heading.page
            if (Index - PrevLevel) > 1:
                j = PrevLevel + 1
                while j <= Index - 1:
                    newHeading = pdfconverter.Bookmark(0, APage, '', j, heading.start - 1)
                    dummyHeadings.append(newHeading)
                    j += 1
            PrevLevel = Index
        found_headings += dummyHeadings
        found_headings.sort(pdfconverter.compareBookmarkStartPosition)

        # remove empty nodes
        if self.removeEmptyBookmarks:
            level_offset = []
            for i in range(10):
                level_offset.append(0)
            for heading in found_headings:
                level = heading.level
                if heading.title == "":
                    level_offset[level - 1] = 1
                else:
                    level_offset[level - 1] = 0
                    i = 0
                    while i < level:
                        heading.level -= level_offset[i]
                        i += 1

        # Struktur ermitteln
        PInfo = []
        for i in range(10):
            PInfo.append(-1)
        i = 0
        for heading in found_headings:
            if not self.removeEmptyBookmarks or heading.title != "":
                level = heading.level
                PInfo[level] = i
                if level > 1:
                    if PInfo[level - 1] >= 0:
                        found_headings[PInfo[level - 1]].count += 1
            i += 1

        # Postscript erzeugen
        result = u""
        for heading in found_headings:
            if not self.removeEmptyBookmarks or heading.title != "":
                result += heading.to_ps(self.page_offset)

        return result

    def find_word_headings(self, style_info):
        import win32com.client
        result = []

        self.office_app_obj.Selection.Start = 0
        self.office_app_obj.Selection.End = 0
        Find = self.office_app_obj.Selection.Find
        Find.Style = style_info.name

        FindText = ''
        MatchCase = False
        MatchWholeWord = False
        MatchWildcards = False
        MatchSoundsLike = False
        MatchAllWordForms = False
        Forward = True
        Wrap = win32com.client.constants.wdFindStop
        Format = True
        ReplaceWith = ''
        Replace = win32com.client.constants.wdReplaceNone
        Found = Find.Execute(FindText, MatchCase, MatchWholeWord, MatchWildcards,
                             MatchSoundsLike, MatchAllWordForms, Forward, Wrap, Format,
                             ReplaceWith, Replace)
        while Found:
            text = self.office_app_obj.Selection.Paragraphs.Item(1).Range.Text
            if self.office_app_obj.Selection.Information(win32com.client.constants.wdWithInTable):
                # Bei Überschriften in Tabellen werden Steuerzeichen mit zurückgeliefert
                if len(text) >= 1 and text[-1] == chr(7):
                    text = text[:-1]
            text = text.strip(chr(13))  # strip new line characters
            text = text.strip(chr(12))  # strip new page characters
            selection_info = self.office_app_obj.Selection.Information(
                win32com.client.constants.wdActiveEndPageNumber)
            heading_info = pdfconverter.Bookmark(
                0,
                selection_info,
                text,
                style_info.level,
                self.office_app_obj.Selection.Start)
            if len(heading_info.title) > 0:
                result.append(heading_info)
            # To avoid getting stuck in tables/tocs with Heading1..9 style
            PrevEnd = self.office_app_obj.Selection.End
            self.office_app_obj.Selection.Start = self.office_app_obj.Selection.End
            Found = Find.Execute(FindText, MatchCase, MatchWholeWord, MatchWildcards,
                                 MatchSoundsLike, MatchAllWordForms, Forward, Wrap, Format,
                                 ReplaceWith, Replace)
            if PrevEnd == self.office_app_obj.Selection.End:
                break
        self.office_app_obj.Selection.Start = 0
        return result

    def __unprotect(self):
        import win32com.client
        if self.office_doc_obj.ProtectionType != win32com.client.constants.wdNoProtection:
            try:
                self.office_doc_obj.Unprotect()
            except Exception:
                # wrong password
                return False
        return True

    def update_tables(self):
        misc.log(5, "WordConverter::update_tables: Updating Tables: %s"
                 % self.office_doc_obj.TablesOfContents.Count)
        # Include document markups into PDF ?
        # 'accepting all changes' would mean loosing all markups
        if not self.handleMarkups:
            # try to unprotect document and accept all changes,
            # else Word may stuck while updating table of contents
            if self.__unprotect():
                self.office_app_obj.WordBasic.AcceptAllChangesInDoc
                self.office_doc_obj.TrackRevisions = False
            for i in range(self.office_doc_obj.TablesOfContents.Count):
                item = self.office_doc_obj.TablesOfContents.Item(i + 1)
                item.Update()

    def handle_word_links(self):
        import win32com.client
        misc.log(5, "WordConverter::handle_word_links: Processing Links ...")
        # ensure print view for correct link coordindate processing
        if self.office_app_obj.ActiveWindow.View.SplitSpecial == \
           win32com.client.constants.wdPaneNone:
            self.office_app_obj.ActiveWindow.ActivePane.View.Type = \
                win32com.client.constants.wdPrintView
        else:
            self.office_app_obj.ActiveWindow.View.Type = win32com.client.constants.wdPrintView

        links = u""
        field_types = [win32com.client.constants.wdFieldRef,
                       win32com.client.constants.wdFieldPageRef,
                       win32com.client.constants.wdFieldNoteRef,
                       win32com.client.constants.wdFieldFootnoteRef,
                       win32com.client.constants.wdFieldGoToButton]

        OldShow = self.office_doc_obj.Bookmarks.ShowHidden
        self.office_doc_obj.Bookmarks.ShowHidden = True

        # Scan Fields
        misc.log(5, "WordConverter::handle_word_links: Scanning Fields: %s"
                 % self.office_doc_obj.Fields.Count)
        field_results = []
        field_ranges = []
        for field in self.office_doc_obj.Fields:
            self.office_doc_obj.UndoClear()
            field_text = field.Code.Text
            misc.log(5, "WordConverter::handle_word_links: Processing Field '%s'" % field_text)
            if field.Type == win32com.client.constants.wdFieldTOC:
                if field_text.lower().find('\\h') <= 0:
                    field.Code.Text = field.Code.Text + ' \\h'
            elif field.Type in field_types:
                BMarkStr = self.ExtractBookmark(field_text)
                result = self.FindBookmark(BMarkStr)
                if result is not None:
                    field_results.append(result)
                    field_ranges.append(field.Result)

        counter = 0
        misc.log(5, "WordConverter::handle_word_links: Calculating Field Coordinates (%s) ..."
                 % (len(field_ranges)))
        for field_range in field_ranges:
            InfoStr = field_results[counter][1]
            LinkType = field_results[counter][2]
            links += self.HandleWordRange(field_range, LinkType, InfoStr)
            counter += 1

        # Update Tables
        self.update_tables()

        # Scan Hyperlinks
        misc.log(5, "WordConverter::handle_word_links: Scanning Hyperlinks: %s"
                 % self.office_doc_obj.Hyperlinks.Count)
        # ensure Microsoft Office 11 Object Library
        win32com.client.gencache.EnsureModule('{2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}', 0x0, 2, 3)
        hyperlinks = []
        hyperlink_results = []
        for i in range(self.office_doc_obj.Hyperlinks.Count):
            self.office_doc_obj.UndoClear()
            hLink = self.office_doc_obj.Hyperlinks.Item(i + 1)
            misc.log(5, "WordConverter::handle_word_links: Processing Hyperlink '%s'"
                        % hLink.Address)
            result = self.CheckHyperLink(hLink)
            if result is not None:
                hyperlink_results.append(result)
                hyperlinks.append(hLink)
        counter = 0
        misc.log(5, "WordConverter::handle_word_links: Calculating Hyperlink Coordinates (%s) ..."
                 % (len(hyperlinks)))
        for hyperlink in hyperlinks:
            InfoStr = hyperlink_results[counter][0]
            LinkType = hyperlink_results[counter][1]
            if hyperlink.Type == win32com.client.constants.msoHyperlinkRange:
                links += self.HandleWordRange(hyperlink.Range, LinkType, InfoStr)
            counter += 1
        self.office_doc_obj.Bookmarks.ShowHidden = OldShow
        return links

    kLinkTypeHyperlink = "hyperlink"
    kLinkTypeLink = "link"
    kLinkTypeFile = "file"

    def ExtractBookmark(self, AText):
        AText = AText.strip()
        SpacePos = AText.find(' ')
        if SpacePos > 0:
            AText = AText[SpacePos:]
        AText = AText.strip()
        SpacePos = AText.find(' ')
        if SpacePos > 0:
            AText = AText[:SpacePos]
        return AText.strip()

    def FindBookmark(self, bookmark):
        import win32com.client
        misc.log(9, "WordConverter::FindBookmark: %s" % bookmark)
        if self.office_doc_obj.Bookmarks.Exists(bookmark):
            bmark = self.office_doc_obj.Bookmarks.Item(bookmark)
            infoStr = "%s" % \
                      (bmark.Range.Information(win32com.client.constants.wdActiveEndPageNumber))
            linkType = self.kLinkTypeLink
            return (bmark, infoStr, linkType)
        else:
            return None

    def CheckHyperLink(self, HLink):
        if len(HLink.Address.strip()) == 0:
            result = self.FindBookmark(HLink.SubAddress)
            if result is not None:
                InfoStr = result[1]
                LinkType = result[2]
            else:
                return None
        else:
            if (os.path.exists(os.path.join(self.docdir, HLink.Address))):
                InfoStr = HLink.Address
                LinkType = self.kLinkTypeFile
            else:
                InfoStr = HLink.Address
                LinkType = self.kLinkTypeHyperlink

        return (InfoStr, LinkType)

    kOrientLandscape = "Landscape"
    kOrientPortrait = "Portrait"

    def HandleWordRange(self, wrange, LinkType, InfoStr, RHeight=0.0):
        import win32com.client
        self.office_doc_obj.UndoClear()
        result = ""
        Lines = wrange.ComputeStatistics(win32com.client.constants.wdStatisticLines)
        OrgEnd = wrange.End
        OrgStart = wrange.Start
        RSelec = self.office_app_obj.Selection
        RSelec.Start = OrgStart
        RSelec.End = OrgStart
        Unit_ = win32com.client.constants.wdCharacter
        Count = 1
        Extend = win32com.client.constants.wdMove
        # Bringing the page into focus by moving the cursor,
        if OrgStart > 0:
            RSelec.MoveLeft(Unit_, Count, Extend)
            RSelec.MoveRight(Unit_, Count, Extend)
        else:
            RSelec.MoveRight(Unit_, Count, Extend)
            RSelec.MoveLeft(Unit_, Count, Extend)

        # This sometimes happen with GotoButton fields...
        if Lines == 0:
            RSelec.MoveLeft(Unit_, Count, Extend)
            OrgStart = RSelec.Start
            RSelec.MoveRight(Unit_, Count, Extend)
            OrgEnd = RSelec.Start
            RSelec.MoveLeft(Unit_, Count, Extend)
            Lines = 1
        for i in range(Lines):
            RBorders = wrange.Borders
            # RBorders = RSelec.Borders
            # set horizontal range position
            XlDoc = RSelec.Information(
                win32com.client.constants.wdHorizontalPositionRelativeToPage) - \
                RBorders.DistanceFromLeft
            if XlDoc < 0:
                XlDoc = 0

            # Paragraph Correction
            paragraph_correction = 0
            currentRange = RSelec.Range
            Line = RSelec.Information(win32com.client.constants.wdFirstCharacterLineNumber)
            RSelec.Paragraphs(1).Range.Select()
            if RSelec.Paragraphs.Count == 1 \
                and RSelec.Information(win32com.client.constants.wdFirstCharacterLineNumber)\
                    < Line:
                        paragraph_correction = RSelec.ParagraphFormat.SpaceBefore
            currentRange.Select()

            # set vertical range position and height
            YtDoc = RSelec.Information(win32com.client.constants.wdVerticalPositionRelativeToPage)\
                - RBorders.DistanceFromTop - paragraph_correction

            # get width
            OrgLine = RSelec.Information(win32com.client.constants.wdFirstCharacterLineNumber)
            SLine = OrgLine
            PrevEnd = -1
            maxFontSize = RSelec.Font.Size
            while (SLine == OrgLine) and (PrevEnd != RSelec.End):
                PrevEnd = RSelec.End
                if RSelec.Font.Size > maxFontSize:
                    maxFontSize = RSelec.Font.Size
                RSelec.MoveRight(Unit_, Count, Extend)
                SLine = RSelec.Information(win32com.client.constants.wdFirstCharacterLineNumber)
            RSelec.MoveLeft(Unit_, Count, Extend)
            if RSelec.End > OrgEnd:
                RSelec.End = OrgEnd
            WDoc = RSelec.Information(win32com.client.constants.wdHorizontalPositionRelativeToPage)\
                + RBorders.DistanceFromRight - XlDoc
            if WDoc < 0:
                WDoc = 0

            # get height
            if RHeight < 1e-5:
                HDoc = maxFontSize + RBorders.DistanceFromTop + RBorders.DistanceFromBottom
            else:
                HDoc = RHeight

            # get page size, orientation and page number
            if RSelec.Sections.Item(1).PageSetup.Orientation == \
                    win32com.client.constants.wdOrientPortrait:
                Orien = self.kOrientPortrait
            else:
                Orien = self.kOrientLandscape
            PWidth = RSelec.Sections.Item(1).PageSetup.PageWidth
            PHeight = RSelec.Sections.Item(1).PageSetup.PageHeight
            Page = RSelec.Information(win32com.client.constants.wdActiveEndPageNumber)

            # calculate link coordinates
            coord = self.CreateCoord(XlDoc, YtDoc, WDoc, HDoc, Orien, PHeight, PWidth)
            if coord is not None:
                result += self.create_link(coord, Page, LinkType, InfoStr)
            else:
                misc.log(5, "WordConverter::HandleWordRange: Skipping link on page %s. "
                         "Link coordinates could not be calculated." % (Page))
            RSelec.MoveRight(Unit_, Count, Extend)
        return result

    # XlDoc/YtDoc     XY-Position oben links
    # WDoc/HDoc       Breite/Höhe des zu erzeugenden Links
    # PWidth/PHeight  Breite/Höhe der aktuellen Seite
    def CreateCoord(self, XlDoc, YtDoc, WDoc, HDoc, Orien, PHeight, PWidth):
        zoomFactor = self.getPrintZoomFactor(Orien, PHeight, PWidth)
        (xBorder, yBorder) = self.getZoomBorders(zoomFactor, Orien, PHeight, PWidth)
        (xCorrection, yCorrection, support_flag) = self.getZoomCorrection(zoomFactor, Orien)
        if not support_flag:
            return None

        if Orien == self.kOrientLandscape:
            Xl = int(round(zoomFactor * (YtDoc)) + xCorrection + xBorder / 2)
            Xr = int(round(zoomFactor * (YtDoc + HDoc)) + xCorrection + xBorder / 2)
            Yt = int(round(zoomFactor * (XlDoc + WDoc)) + yCorrection + yBorder / 2)
            Yb = int(round(zoomFactor * (XlDoc)) + yCorrection + yBorder / 2)
        else:
            Xl = int(round(zoomFactor * (XlDoc)) + xBorder / 2 + xCorrection)
            Xr = int(round(zoomFactor * (XlDoc + WDoc)) + xBorder / 2 + xCorrection)
            Yt = int(round(zoomFactor * (PHeight - YtDoc - HDoc)) + yBorder / 2 + yCorrection)
            Yb = int(round(zoomFactor * (PHeight - YtDoc)) + yBorder / 2 + yCorrection)
        return (Xl, Xr, Yt, Yb)

    # PHeight: Seitenhöhe in Pixel
    # PWidth:  Seitenbreite in Pixel
    # (20 Twips = 1 Punkt; 72 Punkte = 1 Zoll = 2,54 cm).
    def getPrintZoomFactor(self, Orien, PHeight, PWidth):
        ph = PHeight
        pw = PWidth
        if Orien == self.kOrientLandscape:
            ph = PWidth
            pw = PHeight
        vZoomFactor = (self.printZoomPH / 20) / (ph)
        if vZoomFactor > 0.99:
            vZoomFactor = 1
        hZoomFactor = (self.printZoomPW / 20) / (pw)
        if hZoomFactor > 0.99:
            hZoomFactor = 1
        # Der kleinere Faktor ist ausschlaggebend
        return min(vZoomFactor, hZoomFactor)

    def getZoomBorders(self, zoomFactor, Orien, PHeight, PWidth):
        ph = PHeight
        pw = PWidth
        if Orien == self.kOrientLandscape:
            ph = PWidth
            pw = PHeight
        # Oberen und unteren Rand ermitteln, der durch die Skalierung ensteht
        targetHeight = ph * zoomFactor  # tatsächliche Seitenhöhe nach Skalierung
        targetWidth = pw * zoomFactor  # tatsächliche Seitenbreite nach Skalierung
        # durch Skalierung enstandener oberer Rand
        vBorder = int(round((self.printZoomPH / 20) - targetHeight))
        # durch Skalierung enstandener seitlicher Rand
        hBorder = int(round((self.printZoomPW / 20) - targetWidth))
        return (hBorder, vBorder)

    def getZoomCorrection(self, zoomFactor, Orien):
        supported_printers = ["HP C LaserJet 4500-PS"]
        if zoomFactor < 1:
            # Bei Skalierung ist eine Korrektur der Koordinaten nötig.
            # Diese Korrektur ist Druckertreiber abhängig.
            if self.printer == "HP C LaserJet 4500-PS":
                if Orien == self.kOrientLandscape:
                    return (int(round(3 / zoomFactor)), int(round(3 / zoomFactor)), 1)
                else:
                    return (int(round(3 / zoomFactor)), int(round(-3 / zoomFactor)), 1)
            else:
                # Bei Skalierung können Links nur erzeugt werden,
                # wenn ein hierfür unterstützter Druckertreiber verwendet wird, da
                # die Berechnung der Koordinaten für die Links Druckertreiber
                # abhängig ist.
                misc.log(5, "WordConverter::getZoomCorrection: "
                         "Printer driver '%s' not supported for link processing in combination"
                         " with page scaling. "
                         "Please use one of the following supported printer drivers: %s" %
                         (self.printer, supported_printers))
                return (0, 0, 0)
        else:
            # keine Korrektur nötig
            return (0, 0, 1)

    def create_link(self, coord, SrcPage, LinkType, InfoStr):
        Xl = coord[0]
        Xr = coord[1]
        Yt = coord[2]
        Yb = coord[3]

        result_lines = []
        if (Xl < 0) or (Xr < 0) or (Yt < 0) or (Yb < 0):
            return ""
        result_lines.append('[ /Rect [ %s %s %s %s ]' % (Xl, Yb, Xr, Yt))
        result_lines.append('  /Border %s' % (self.link_border_str))
        result_lines.append('  /Color %s' % (self.link_color_str))
        result_lines.append('  /H /I')
        result_lines.append('  /SrcPg %s' % (int(SrcPage) + self.page_offset))
        if LinkType == self.kLinkTypeHyperlink:
            InfoStr = pdfconverter.pdfmarkstring(InfoStr)
            result_lines.append('  /Action << /Subtype /URI /URI (%s) >>' % (InfoStr))
            result_lines.append('  /Subtype /Link')
            result_lines.append('/ANN pdfmark')
        elif LinkType == self.kLinkTypeLink:
            result_lines.append('  /Page %s' % (int(InfoStr) + self.page_offset))
            result_lines.append('  /View [ /Fit  ]')
            result_lines.append('  /LNK pdfmark')
        elif LinkType == self.kLinkTypeFile:
            InfoStr = pdfconverter.pdfmarkstring(InfoStr)
            result_lines.append('  /Action /Launch')
            result_lines.append('  /File (%s)' % InfoStr)
            result_lines.append('  /Subtype /Link')
            result_lines.append('/ANN pdfmark')

        result = ""
        for line in result_lines:
            result += line + '\n'
        return result


class StyleInfo:

    def __init__(self, name, level):
        self.name = name
        self.level = level
