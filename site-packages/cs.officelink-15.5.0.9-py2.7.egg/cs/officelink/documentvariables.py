#!/usr/bin/env powerscript
# -*- python -*- coding: UTF-8 -*-
#
# Copyright (C) 2017 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

from __future__ import unicode_literals

from collections import OrderedDict
import json
import warnings

from lxml import objectify

from cdb import sqlapi, util
from cdb.objects.core import ClassRegistry, Object
from cdb.platform.mom.entities import Entity

__docformat__ = "restructuredtext en"
__revision__ = "$Id: documentvariables.py 178879 2018-06-13 09:56:15Z kbu $"


class DocumentVariable(object):

    def __init__(self, var_str):
        toks = var_str.split(".")
        self.access_mode = toks[1]
        self.relationship = toks[2]
        self.attribute = toks[3]
        self.cardinality = toks[4]
        self.parameter = "" if (len(toks) < 7) else toks[6]

    def get_values(self, obj_or_objs, verbose):
        objs = obj_or_objs if isinstance(obj_or_objs, list) else [obj_or_objs]
        values = []
        for obj in objs:
            if not obj:
                values.append("ERROR: No accessible object found" if verbose else "")

            elif self.attribute.startswith("_SML"):
                # TODO: Remove the SML feature in CDB 16.0!
                val = None
                _type = self.attribute[4]
                _id = self.attribute[5:]
                if _type == "_":
                    val = self.get_merkmal_value_by_kennung(obj, _id)
                elif _type == "N":
                    val = self.get_merkmal_kennung_by_row(obj, _id)
                elif _type == "V":
                    val = self.get_merkmal_value_by_row(obj, _id)
                values.append(val)

            elif not hasattr(obj, self.attribute):
                values.append(("ERROR: Attribute '%s' not found" % self.attribute)
                              if verbose else "")
            else:
                values.append("%s" % getattr(obj, self.attribute))
        return values[0] if (self.cardinality == "1") else values

    def get_sachmerkmal(self, part, sachgruppe):
        teilenummer = getattr(part, "teilenummer")
        t_index = getattr(part, "t_index")
        cls_def = Entity.ByKeys(sachgruppe).getClassDef()
        rs = sqlapi.RecordSet2(cls_def.getPrimaryTable(), "teilenummer='%s' AND t_index='%s'" %
                               (sqlapi.quote(teilenummer), sqlapi.quote(t_index)))
        return rs[0] if (len(rs) == 1) else None

    def get_merkmal_value_by_kennung(self, part, kennung):
        val = "ERROR: Relationship returned no or multiple referenced objects"
        sachgruppe = getattr(part, "sachgruppe")
        if not sachgruppe:
            val = "ERROR: Relationship object has no 'sachgruppe' value"
        else:
            sachmerkmal = self.get_sachmerkmal(part, sachgruppe)
            if sachmerkmal:
                merkmale = self.get_merkmal_kennungen(sachgruppe)
                if kennung in merkmale:
                    val = "%s" % getattr(sachmerkmal, merkmale[kennung])
                else:
                    val = "ERROR: Generic group property '%s' does not exist" % kennung
            else:
                val = "ERROR: Could not find SML object"
        return val

    def get_merkmal_kennung_by_row(self, part, row):
        row = int(row)
        val = "ERROR: Relationship returned no or multiple referenced objects"
        sachgruppe = getattr(part, "sachgruppe")
        if not sachgruppe:
            val = "ERROR: Relationship object has no 'sachgruppe' value"
        else:
            merkmale = self.get_merkmal_kennungen(sachgruppe)
            if row > len(merkmale.keys()):
                val = "ERROR: SML list contains less values"
            else:
                val = merkmale.keys()[row - 1]
        return val

    def get_merkmal_value_by_row(self, part, row):
        row = int(row)
        val = "ERROR: Relationship returned no or multiple referenced objects"
        sachgruppe = getattr(part, "sachgruppe")
        if not sachgruppe:
            val = "ERROR: Relationship object has no 'sachgruppe' value"
        else:
            sachmerkmal = self.get_sachmerkmal(part, sachgruppe)
            if sachmerkmal:
                merkmale = self.get_merkmal_kennungen(sachgruppe)
                if row > len(merkmale.keys()):
                    val = "ERROR: SML list contains less values"
                else:
                    attr = merkmale[merkmale.keys()[row - 1]]
                    val = "%s" % getattr(sachmerkmal, attr)
            else:
                val = "ERROR: Could not find SML object"
        return val

    def get_merkmal_kennungen(self, sachgruppe):
        merkmale = OrderedDict()
        res_tbl = sqlapi.SQLselect("a.field_name, b.prop_mk FROM cdbdd_field a, cdbsml_pset_prop b "
                                   "WHERE a.cdb_object_id=b.dd_attr_uuid AND classname='%s'"
                                   % sachgruppe)
        for row in range(0, sqlapi.SQLrows(res_tbl)):
            merkmale.setdefault(res_tbl.get_string("prop_mk", row),
                                res_tbl.get_string("field_name", row))
        return merkmale


class DocumentVariables(object):

    @classmethod
    def auto_fill(cls, ctx, check_access_user):
        """Retrieve values for all variables still containing None."""
        relationships = {}
        for var, value in ctx.document_variables.items():
            if value is not None:
                continue  # skip already handled variables
            _var = DocumentVariable(var)
            relationships.setdefault(_var.relationship, [])
            relationships[_var.relationship].append(var)

        if relationships:
            from cs.officelink.misc import get_conf_file_value
            verbose = get_conf_file_value("METADATA_SYNC_VERBOSE", False)
            ctx.log("METADATA_SYNC_VERBOSE=%s" % verbose)

            obj = cls.get_full_object(ctx.object)

            for relationship, doc_vars in relationships.items():

                if relationship == "this":
                    _obj = obj if cls.is_access_granted(
                        obj, check_access_user, relationship, ctx.log) else None
                    for var in doc_vars:
                        _var = DocumentVariable(var)
                        ctx.document_variables[var] = _var.get_values(_obj, verbose)

                elif relationship.startswith("BY_ZNUM_ZIDX_FROM_"):
                    # Step 1: For now only a warning
                    warnings.warn("Variables of type 'BY_ZNUM_ZIDX_FROM' will soon be deprecated!",
                                  DeprecationWarning)
                    # for var in doc_vars:
                    #     ctx.document_variables[var] = \
                    #         "ERROR: Variables of type 'BY_ZNUM_ZIDX_FROM' are deprecated!"
                    # Step 2: Get rid of the code below with CE 16.0
                    tbl_name = relationship.replace("BY_ZNUM_ZIDX_FROM_", "")
                    rs = sqlapi.RecordSet2(tbl_name, "z_nummer='%s' AND z_index='%s'" %
                                           (sqlapi.quote(getattr(obj, "z_nummer", "")),
                                            sqlapi.quote(getattr(obj, "z_index", ""))))
                    if len(rs) == 0:
                        error = "ERROR: Referenced object not found" if verbose else ""
                    elif len(rs) == 1:
                        error = None
                        obj = rs[0]
                        if not cls.is_access_granted(obj, check_access_user, tbl_name, ctx.log):
                            obj = None
                    else:
                        error = "ERROR: No unambiguous referenced object found" if verbose else ""
                    for var in doc_vars:
                        _var = DocumentVariable(var)
                        ctx.document_variables[var] = error or _var.get_values(obj, verbose)

                else:
                    tbl = obj.ToObjectHandle().navigate_relship_tableresult(relationship)
                    objs = []
                    for oh in [tbl.getObjectHandle(r) for r in range(0, tbl.getNumberOfRows())]:
                        _obj = cls.get_full_object(oh)
                        if cls.is_access_granted(_obj, check_access_user, relationship, ctx.log):
                            objs.append(_obj)
                        else:
                            objs.append(None)
                    for var in doc_vars:
                        _var = DocumentVariable(var)
                        ctx.document_variables[var] = _var.get_values(objs, verbose)
        else:
            ctx.log("No document variables found to be auto filled")

    @classmethod
    def get_full_object(cls, obj):
        if hasattr(obj, "getClassDef"):
            cls_def = obj.getClassDef()
            tbl_keys = {k: getattr(obj, k) for k in cls_def.getKeyNames()}
        elif "cdb_classname" in obj:
            entity = Entity.ByKeys(obj["cdb_classname"])
            cls_def = entity.getClassDef()
            tbl_keys = {k: obj[k] for k in cls_def.getKeyNames()}
        else:
            raise Exception("Can't receive full object for '%s'" % obj)
        tbl_name = cls_def.getPrimaryTable()
        _class = ClassRegistry().find(tbl_name)
        if _class:
            return _class.ByKeys(**tbl_keys)
        else:
            return sqlapi.RecordSet2(tbl_name, " AND ".join(["%s='%s'" % (k, sqlapi.quote(v))
                                                            for k, v in tbl_keys.items()]))[0]

    @classmethod
    def is_access_granted(cls, obj, user, relationship, log):
        granted = True
        if user:
            obj_desc = obj.GetDescription() if hasattr(obj, "GetDescription") else obj
            log("Checking access right (user=%s, relationship=%s, object=%s)" %
                (user, relationship, obj_desc))
            if isinstance(obj, Object):
                granted = obj.CheckAccess("read", user)
            elif isinstance(obj, sqlapi.Record):
                granted = util.check_access_record(obj, "read", user)
            else:
                raise Exception("Can't check access right for '%s'" % obj)
        if not granted:
            log("ERROR: Access check failed")
        return granted

    @classmethod
    def prepare_result(cls, ctx):
        """
        Converts lists to json strings before converting everything to a json string, since the
        OfficeLink Add-In can initially only handle strings as dictionary values.
        """
        for var in ctx.document_variables:
            value = ctx.document_variables[var]
            if not isinstance(value, basestring):
                ctx.document_variables[var] = json.dumps(value)

    @classmethod
    def write_metadata_xml(cls, ctx, filename):
        """
        Exports the document variable dictionary of the context into an XML file which is required
        for OfficeLink updating document variables in an Office file "offline".
        """
        msodocvarlist = objectify.Element("msodocvarlist")
        for var, value in ctx.document_variables.items():
            if value is None:
                ctx.log("Skipping non-value variable: %s" % var)
                continue
            ctx.log("Exporting variable: %s ==> %s" % (var, value))
            msodocvar = objectify.SubElement(msodocvarlist, "msodocvar")
            msodocvar.set("name", var)
            for val in (value if isinstance(value, list) else [value]):
                value_elem = objectify.SubElement(msodocvar, "value")
                value_elem._setText(val)

        objectify.deannotate(msodocvarlist, xsi_nil=True, cleanup_namespaces=True)
        msodocvarlist.getroottree().write(filename,
                                          encoding='UTF-8',
                                          pretty_print=True,
                                          xml_declaration=True)
        ctx.log("Successfully exported variables to: %s" % filename)
