#!/usr/bin/env powerscript
# -*- python -*- coding: UTF-8 -*-
#
# Copyright (C) 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Module nodes

This is the documentation for the nodes module.
"""

from __future__ import unicode_literals

from cdb import ddl, sqlapi
from cdb.platform import olc

from cs.pcs.msproject.misc import checkUUID, getClsObj, getLongtext, ParameterError


class Node:
    """Node is a base class used by all project representations.
       It gets specialized by Task, Project, DatabaseProject and XMLProject:

                                 Node
                      +-----------+---------------+
                      |                           |
                     Task                      Project
                      +                           +
           +------------------+          +------------------+
           |                  |          |                  |
        DBTask             XMLTask    DBProject        XMLProject

       Task -- used to represent tasks, that map to MSP tasks
       Project -- abstract base for projects
       DBProject -- used to represent a project stored in CDB database
       XMLProject -- used to represent a project read from an XML file


       self.children is a builtin-list of children.
    """

    def __init__(self, ctx, cdb_id):
        """Init a node (attributes)"""
        self.ctx = ctx
        self.children = []
        self.cdb_id = cdb_id
        self.parent = None
        self.attributes = {}

    def addChild(self, child):
        """Append a child."""
        self.children.append(child)
        child.parent = self
        return child

    def repr_helper(self, label):
        """return the printed representation as class-name, cdb_id"""
        return "%s('%s')" % (self.__class__.__name__.split(".")[-1], label)

    def __repr__(self):
        """return the printed representation"""
        return self.repr_helper(self.cdb_id)

    def hasAttribute(self, name):
        """Return true, if the attribute name is found"""
        return name in self.attributes

    def getAttribute(self, name):
        """return a node attribute"""
        if name in self.attributes:
            return self.attributes[name]
        else:
            raise ParameterError("%s.getAttribute: Attribute %s not found." %
                                 (self.__class__.__name__, name))

    def __getitem__(self, attr_name):
        """allow access to an attribute"""
        return self.getAttribute(attr_name)

    def __setitem__(self, attr_name, attr_value):
        """allow access to an attribute"""
        self.attributes[attr_name] = attr_value


class Task(Node):
    """A Task is a particular Node and is a base class for DBTask. It has a
       reference to the project object, and an attribute dictionary    """

    def __init__(self, ctx, project, cdb_id):
        """Init a task. Parameters: project - the project object reference, cdb_id - the Task id"""
        Node.__init__(self, ctx, cdb_id)
        self.project = project
        self.attributes = {}

    def __repr__(self):
        """Return a printable representation. Omit the project reference (circullar). """
        return self.repr_helper(self.cdb_id)

    def getAttribute(self, name):
        """return a task attribute or, if not found, return a project attribute with that name"""
        if name in self.attributes:
            return self.attributes[name]
        if name in self.project.attributes:
            return self.project.getAttribute(name)
        raise ParameterError("%s.getAttribute: Attribute %s not found." %
                             (self.__class__.__name__, name))

    def hasAttribute(self, name):
        """Return true, if the attribute name is found"""
        if name in self.attributes:
            return 1
        if name in self.project.attributes:
            return 1
        return 0

    def dump(self, depth=0):
        """Dump a task hierarchiy to the log file"""
        self.ctx.log("%s%s" % ("  " * depth, repr(self)))
        for task in self.children:
            task.dump(depth + 1)

    def dumpToXML(self, mspfields, xmlDumper, taskTag="Task"):
        """dump the task to XML"""
        if not xmlDumper:
            from cs.pcs.msproject.xml2 import XMLDumper
            xmlDumper = XMLDumper()
        xmlDumper.startTag(taskTag)
        for attr in self.attributes.keys():
            xmlDumper.tag("Attr",
                          attribs={"Changed": "False",
                                   "Name": attr,
                                   "Value": self.attributes[attr]})
        xmlDumper.endTag(taskTag)

        # dump children
        for task in self.children:
            task.dumpToXML(mspfields, xmlDumper, taskTag)


class Project(Node):
    """A Project is a particular Node and is a base class for DBProject. It also
       has a task list and a dictionary list"""

    def __init__(self, ctx, cdb_id):
        """Initialize a project and the task list / dictionary"""
        Node.__init__(self, ctx, cdb_id)
        self.tasks = []
        self.subprojects = []
        self.tasksById = {cdb_id: self}
        self.attributes = {}

    def addTask(self, task):
        """Add a task to the task list."""
        if task.cdb_id not in self.tasksById:
            self.tasks.append(task)
            self.tasksById[task.cdb_id] = task

    def addSubProject(self, subproject):
        """Add a subproject to the subproject list."""
        self.subprojects.append(subproject)

    def dump(self):
        """Dump the task list"""
        self.ctx.log("%s%s" % ("", repr(self)))
        for task in self.children:
            task.dump(1)

    def dumpToXML(self, mspfields, xmlDumper, projectTag="CDBProject"):
        """dump the project to XML"""
        if not xmlDumper:
            from cs.pcs.msproject.mspxml import XMLDumper
            xmlDumper = XMLDumper()
        xmlDumper.startTag(projectTag, attribs={"xmlns": "http://www.contact.de/cdb/pcs/msp"})

        for attr in self.attributes.keys():
            xmlDumper.tag("Attr",
                          attribs={"Changed": "False",
                                   "Name": attr,
                                   "Value": self.attributes[attr]})
        for task in self.children:
            task.dumpToXML(mspfields, xmlDumper)

        for subproject in self.subprojects:
            subproject.dumpToXMLAsTask(xmlDumper)

        xmlDumper.endTag(projectTag)

    def dumpToXMLAsTask(self, xmlDumper, taskTag="Task"):
        """dump the project to XML as task"""
        if not xmlDumper:
            from cs.pcs.msproject.xml2 import XMLDumper
            xmlDumper = XMLDumper()
        xmlDumper.startTag(taskTag)
        for attr in self.attributes.keys():
            mappedName = self.ctx.SUBPROJECT2TASK_MAP.get(attr, None)
            if mappedName:
                xmlDumper.tag("Attr",
                              attribs={"Changed": "False",
                                       "Name": mappedName,
                                       "Value": self.attributes[attr]})
        xmlDumper.tag("Attr",
                      attribs={"Changed": "False",
                               "Name": "isSubProject",
                               "Value": "True"})
        xmlDumper.endTag(taskTag)

    def recalcOutlineChildren(self, parent=None):
        """Recalculate the attribute OutlineChildren to reflect the current project structure.
           Parameter parent is used for internal recursion, call with empty attribute.
        """
        if parent is None:
            for task in self.children:
                self.recalcOutlineChildren(task)
        else:
            outlineChildrenList = []
            for task in parent.children:
                outlineChildrenList.append(task.cdb_id)
                self.recalcOutlineChildren(task)
            parent.attributes["OutlineChildren"] = ";".join(outlineChildrenList)

    def recalcParent(self, parent=None, x=0):
        """Recalculate the parent attribute to reflect the current project structure.
           Parameter parent is used for internal recursion, call with empty attribute.
        """
        self.ctx.log("%sParent = %s" % (">" * x, parent))
        if parent is None:
            for task in self.children:
                task.attributes["Parent"] = ""
                self.ctx.log("Parent for Task %s is [Empty]" % task)
                self.recalcParent(task, x + 1)
        else:
            for task in parent.children:
                task.attributes["Parent"] = parent.cdb_id
                self.ctx.log("Parent for Task %s is %s" % (task, parent.cdb_id))
                self.recalcParent(task, x + 1)


class DBTask(Task):
    """A DBTask is a Task representing a DB stored task. This task has child tasks and / or
       attributes loaded from the DB.
    """

    def __init__(self, ctx, project, dbRecord, syncRelations, mspFields, field_hooks):
        """Load a DB task from the DBRecord. The attributes are renamed
           by the syncRelations dictionary entries to valid MS Project names.
        """
        Task.__init__(self, ctx, project, dbRecord.tuid)
        relation = syncRelations.cdbpcs_task
        for key in relation["__std_msp"]:
            pcs_name = relation[key].pcs_field
            # ignore Project level attributes for task relations
            if mspFields.isTask(pcs_name):

                if pcs_name == "Deadline":  # use finishdate as deadline
                    key = "end_time_fcast"
                # ignore fixed date if no end date fcast set by user
                elif pcs_name == "Number19":
                    deadline = dbRecord["end_time_fcast"]
                    if not deadline or deadline == "":
                        self.attributes[pcs_name] = "0"
                        continue

                if key in self.ctx.LONGTEXTS:
                    t = getClsObj("cdbpcs_task", dbRecord)
                    # 1) 'Notes' is the only column in MSP which accepts multiline content
                    # 2) MSP converts '\n' to '\r' anyway, so we already prepare that in order to
                    #    avoid false detections of changes
                    sep = '\r' if pcs_name == "Notes" else ' '
                    value = getLongtext(t, key).replace('\n', sep)
                else:
                    value = dbRecord.get(key)

                hook = field_hooks.getHook("cdbpcs_task", key)
                value = hook.transform_from_db(value, dbRecord)
                value = syncRelations.prepare_msp_time_value("cdbpcs_task", dbRecord, key, value)

                if key == "cdb_status_txt":
                    taskstatus = dbRecord.get("status", None)
                    from cs.pcs.projects import tasks
                    taskcat = tasks.TaskCategory.ByKeys(dbRecord.get("category", None))
                    if taskstatus != "" and taskstatus is not None and taskcat is not None:
                        statedef = olc.StateDefinition.ByKeys(objektart=taskcat.workflow,
                                                              statusnummer=int(taskstatus))
                        if statedef:
                            value = statedef.StateText['']

                if not value or value == "":
                    default_val = syncRelations.default_values.default('cdbpcs_task', key)

                    if default_val and default_val[0] and default_val[0] != "":
                        value = default_val[0]
                        self.ctx.log("DBTask Using default %s for column %s" %
                                     (default_val[0], key))

                self.attributes[pcs_name] = value

    def ensureConstraints(self):
        """
        Recursively check if this task should be constrained and set the regarding MSP fields,
        if they aren't already set by previous synchronizations.
        [MSProject.PjConstraint.pjASAP = 0, pjALAP = 1, pjMSO = 2, pjMFO = 3, pjSNET = 4,
        pjSNLT = 5, pjFNET = 6, pjFNLT = 7]
        """
        starts_with_any_constrained_subtask = False
        for subtask in self.children:
            subtask.ensureConstraints()
            starts_with_any_constrained_subtask |= (subtask["Start"] == self["Start"]) \
                and (subtask["ConstraintDate"] != "")

        if ("ConstraintType" not in self.attributes) or not self["ConstraintType"]:
            has_subtasks = len(self.children) > 0
            is_manual = ("Manual" in self.attributes) and (self["Manual"] == "True")
            has_predecessors = ("Predecessors" in self.attributes) and self["Predecessors"]
            starts_on_project_start = (self["Start"] == self.project["Proj_ProjectStart"])
            is_partly_completed = ("PercentComplete" in self.attributes) and \
                (self["PercentComplete"] not in ["", "0"])

            if (has_subtasks and starts_with_any_constrained_subtask) \
               or is_manual or has_predecessors \
               or starts_on_project_start or is_partly_completed:
                self["ConstraintType"] = "0"  # As Soon As Possible
                self["ConstraintDate"] = ""
            else:
                self["ConstraintType"] = "4"  # Start Not Earlier Than
                self["ConstraintDate"] = self["Start"]


class DBProject(Project):
    """A DBProject represents the DB stored part of a project."""

    def __init__(self, ctx, cdb_id, syncRelations, mspFields, field_hooks, isSubProject):
        """Initialize a DB project: load the project and task structure from the database.
           Parameters: cdb_id - the ID of the project and the CBD project number
                       syncRelations - the object that stores synchronization relationships
                       mspFields - the object that stores the MSP name space
                       field_hooks - the hooks for transforming data
        """
        Project.__init__(self, ctx, cdb_id)
        self.cdb_project_id = cdb_id

        # load tasks
        self.dbtaskIdList = {}
        self.dbtaskUUIDList = {}

        # load project attributes
        dbProjects = sqlapi.RecordSet2("cdbpcs_project",
                                       "cdb_project_id='%s'" % cdb_id)
        if len(dbProjects) == 0:
            # error: No such project
            raise ParameterError("There is no project with ID %s" % cdb_id)
        for dbProject in dbProjects:
            checkUUID(self.ctx, dbProject, self.ctx.PROJECTS_UUIDS)
            self.ctx.PROJECTS_UUIDS.append(dbProject.puid)
            self.cdb_id = dbProject.puid
            relation = syncRelations.cdbpcs_project
            unitedColumns = set(dbProject.keys() + relation["__std_msp"])
            for dbattr in unitedColumns:
                if dbattr in relation:
                    pcs_name = relation[dbattr].pcs_field
                    value = dbProject.get(dbattr)

                    if dbattr in self.ctx.LONGTEXTS:
                        p = getClsObj("cdbpcs_project", dbProject)
                        # there is no project attribute in MSP which accepts multiline content
                        value = getLongtext(p, dbattr).replace('\n', ' ')

                    hook = field_hooks.getHook("cdbpcs_project", dbattr)
                    value = hook.transform_from_db(value, dbProject)
                    value = syncRelations.prepare_msp_time_value(
                        "cdbpcs_project", dbProject, dbattr, value)

                    if not value or value == "":
                        default_val = syncRelations.default_values.default('cdbpcs_project', dbattr)
                        if default_val and default_val[0] and default_val[0] != "":
                            value = default_val[0]
                            self.ctx.log("DBProject: Using default %s for column %s" %
                                         (default_val[0], dbattr))

                    self.attributes[pcs_name] = value

        # read subprojects
        # check if position column for subprojects is present
        cdbpcs_task = ddl.Table("cdbpcs_project")
        if cdbpcs_task.hasColumn("position"):
            dbToplevelSubProjects = sqlapi.RecordSet2("cdbpcs_project",
                                                      "parent_project='%s'" % cdb_id,
                                                      addtl="order by position")

            self.readDbSubProjects(dbToplevelSubProjects, syncRelations, mspFields, field_hooks)

        # dont read tasks and relation of subprojects
        if isSubProject:
            return

        dbToplevelTasks = sqlapi.RecordSet2("cdbpcs_task",
                                            "cdb_project_id='%s' AND parent_task=''" % cdb_id,
                                            addtl="order by position, task_name")

        self.readDbTasks(dbToplevelTasks, cdb_id, syncRelations, mspFields, field_hooks)

        # update task/child relationship
        for task in self.tasks:
            parentNode = self
            if task.db_parent_task is not None \
               and task.db_parent_task != "" \
               and task.db_parent_task != "-":
                parentNode = self.dbtaskIdList[task.db_parent_task]
            parentNode.addChild(task)

        # load additional attributes. We skip cdbpcs_task and cdbpcs_project, as it is already
        # processed
        for relationKey in syncRelations.keys():
            if relationKey != "cdbpcs_task" and relationKey != "cdbpcs_project":

                relationHook = field_hooks.getHookOrNone(relationKey)
                if relationHook:
                    # relation loading via the hook function
                    relationHook.load_relation_from_db(self, relationKey, cdb_id, syncRelations,
                                                       mspFields, field_hooks)
                else:

                    # standard relation loading
                    # task relations are loaded on a per task basis
                    relation = syncRelations[relationKey]
                    if relation["__is_task"]:

                        for task in self.tasks:
                            if len(relation["__std_msp"]) > 0:
                                keyCondition = []
                                for key in relation["__keys"]:
                                    pcs_name = relation[key].pcs_field
                                    val = task.getAttribute(pcs_name)
                                    keyCondition.append(key + "= '" + val + "'")
                                relRecords = sqlapi.RecordSet2(relationKey,
                                                               " AND ".join(keyCondition))
                                for relRecord in relRecords:
                                    for key in relation["__std_msp"]:
                                        pcs_name = relation[key].pcs_field
                                        # ignore Project level attributes for task relations
                                        if mspFields.isTask(pcs_name):
                                            hook = field_hooks.getHook(relationKey, key)
                                            value = hook.transform_from_db(relRecord[key],
                                                                           relRecord)
                                            value = syncRelations.prepare_msp_time_value(
                                                relationKey, relRecord, key, value)
                                            if not value or value == "":
                                                default_val = syncRelations.default_values.default(
                                                    relationKey, key)
                                                if default_val and \
                                                   default_val[0] and \
                                                   default_val[0] != "":
                                                    value = default_val[0]
                                                    self.ctx.log(
                                                        "DBTask: Using default %s for column %s/%s"
                                                        % (default_val[0], relationKey, key))
                                            task.attributes[pcs_name] = value
                                    break

                    # non-task relations are loaded per project (once)
                    else:
                        if len(relation["__std_msp"]) > 0:
                            keyCondition = []
                            for key in relation["__keys"]:
                                pcs_name = relation[key].pcs_field
                                val = self.attributes[pcs_name]
                                keyCondition.append(key + "= '" + val + "'")
                            relRecords = sqlapi.RecordSet2(relationKey, " AND ".join(keyCondition))
                            for relRecord in relRecords:
                                for key in relation["__std_msp"]:
                                    pcs_name = relation[key].pcs_field
                                    # we're save, there may be only project level attributes
                                    hook = field_hooks.getHook(relationKey, key)
                                    value = hook.transform_from_db(relRecord[key], relRecord)
                                    value = syncRelations.prepare_msp_time_value(
                                        relationKey, relRecord, key, value)
                                    if not value or value == "":
                                        default_val = syncRelations.default_values.default(
                                            relationKey, key)
                                        if default_val and default_val[0] and default_val[0] != "":
                                            value = default_val[0]
                                            self.ctx.log(
                                                "DBProject: Using default %s for column %s/%s" %
                                                (default_val[0], relationKey, key))
                                    self.attributes[pcs_name] = value
                                break

        self.recalcOutlineChildren()
        self.recalcParent()

        exported_task_fields = [syncRelations.cdbpcs_task[f].pcs_field
                                for f in syncRelations.cdbpcs_task["__std_msp"]]
        if ("ConstraintType" in exported_task_fields) \
           and ("ConstraintDate" in exported_task_fields):
            for task in self.children:
                task.ensureConstraints()

    # add all dbtasks to tasklist. add tasks recursive by their parent_task (to assure same sorting
    # as used in the client-view)
    def readDbTasks(self, dbtasks, cdb_id, syncRelations, mspFields, field_hooks):
        if len(dbtasks) < 1:
            return

        self.addDbTask(dbtasks[0], syncRelations, mspFields, field_hooks)

        dbchildtasks = sqlapi.RecordSet2("cdbpcs_task",
                                         "cdb_project_id='%s' AND parent_task='%s'" %
                                         (cdb_id, dbtasks[0].task_id),
                                         addtl="order by position, task_name")
        self.readDbTasks(dbchildtasks, cdb_id, syncRelations, mspFields, field_hooks)
        self.readDbTasks(dbtasks[1:len(dbtasks)], cdb_id, syncRelations, mspFields, field_hooks)

    # add all subprojects to subprojectslist.
    def readDbSubProjects(self, dbsubprojects, syncRelations, mspFields, field_hooks):
        if len(dbsubprojects) < 1:
            return

        firstSubproject = dbsubprojects[0]
        self.addDbSubproject(firstSubproject, syncRelations, mspFields, field_hooks)
        self.readDbSubProjects(dbsubprojects[1:], syncRelations, mspFields, field_hooks)

    # add single task from db to DBProject-tasklist
    def addDbTask(self, dbtask, syncRelations, mspFields, field_hooks):
        checkUUID(self.ctx, dbtask, self.dbtaskUUIDList)
        task = DBTask(self.ctx, self, dbtask, syncRelations, mspFields, field_hooks)
        self.addTask(task)
        self.dbtaskIdList[dbtask.task_id] = task
        self.dbtaskUUIDList[dbtask.tuid] = task
        task.db_parent_task = dbtask.parent_task

    # add single subproject from db to DBProject-tasklist
    def addDbSubproject(self, dbsubproject, syncRelations, mspFields, field_hooks):
        subproject = DBProject(self.ctx, dbsubproject['cdb_project_id'], syncRelations,
                               mspFields, field_hooks, 1)
        # add position
        subproject.attributes['position'] = dbsubproject['position']
        self.addSubProject(subproject)


if __name__ == "__main__":
    pass
