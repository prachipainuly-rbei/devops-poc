#!/usr/bin/env powerscript
# -*- python -*- coding: UTF-8 -*-
#
# Copyright (C) 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Module misc

This is the documentation for the misc module.
"""

from __future__ import unicode_literals

import datetime

from cdb import cdbuuid, sqlapi, ue, util
from cdb.objects import ClassRegistry

# default working times
DEFAULT_START_TIME = datetime.time(8)
DEFAULT_END_TIME = datetime.time(17)
DEFAULT_START_TIME_SUFFIX = " %s" % DEFAULT_START_TIME
DEFAULT_END_TIME_SUFFIX = " %s" % DEFAULT_END_TIME


def report(ctx, type_and_label, args=None, msg=None):
    """
    Adds a translated message for reporting to the interface. type_and_label must contain at least
    one character to represent the message type. If msg is None then type_and_label must also be an
    existing label.
    """
    # Also see language specific messages in db (meldungen):
    # Infos start with "officelink_pcs_i_", warnings with "officelink_pcs_w_"
    # and errors with "officelink_pcs_e_"
    label_type = type_and_label[0]
    if not msg:
        label_id = "officelink_pcs_%s" % type_and_label
        args = args or []
        msg = util.get_label(label_id) % tuple(args)
    ctx.add_result("%s:%s" % (label_type, msg))


def is_yes(yes_no):
    """Return true (1) if yes_no is a character on the set [YyJjTt1]"""
    if yes_no and ("%s" % yes_no) in 'YyJj1Tt':
        return 1
    else:
        return 0


def fit_value(ctx, relation, column, value):
    """Eventually truncate value to fit into column. ignore SQLITE because there are no length
    restrictions """
    if value and (column not in ctx.LONGTEXTS) and (not sqlapi.SQLdbms() == sqlapi.DBMS_SQLITE):
        ci = util.tables[relation].column(column)
        if ci.type() == sqlapi.SQL_CHAR:
            if len(value) > ci.length():
                ctx.log("Warning: value of %s.%s was shortened to length of %s due to column length"
                        " restriction (value='%s')" % (relation, column, ci.length(), value))
                report(ctx, "w_value_shortened_to_column_length",
                       [relation, column, ci.length(), value])
            return value[:ci.length()]
    return value


def date_only(datetime_string):
    """Truncate the time value if it exists"""
    return datetime_string.split(" ")[0]


def getClsObj(clsname, attrs):
    from cs.pcs import projects
    from cs.pcs.projects import tasks
    obj = None
    if clsname == "cdbpcs_project":
        obj = projects.Project.ByKeys(cdb_project_id=attrs['cdb_project_id'])
    elif clsname == "cdbpcs_task":
        obj = tasks.Task.ByKeys(cdb_project_id=attrs['cdb_project_id'], task_id=attrs['task_id'])
    else:
        cls = ClassRegistry().find(clsname)
        keys = {}
        for k in cls.KeyNames():
            keys[k] = attrs[k]
        obj = cls.ByKeys(**keys)
    return obj


def checkLongtext(obj, attr):
    if attr not in obj.GetTextFieldNames():
        raise Exception("Longtext relation '%s' does not exist" % attr)


def getLongtext(obj, attr):
    checkLongtext(obj, attr)
    return obj.GetText(attr)


def setLongtext(obj, attr, value):
    checkLongtext(obj, attr)
    obj.SetText(attr, value)


def checkUUID(ctx, record, uuidlist):
    """Check that 'record' has a UUID"""
    attr = ctx.UUID_MAP.get(record.thead.tname, None)
    # save new uuid if empty
    if (attr and not record[attr]) or (record[attr] and (record[attr] in uuidlist)):
        ctx.log("Generating new UUID for %s.%s %s" % (record.thead.tname, attr, record[attr]))
        uuid = cdbuuid.create_uuid()
        record.update(**{attr: uuid})
        record[attr] = uuid


class ParameterError(ue.Exception):
    """Exception that signals wrong use / values of parameters."""
    def __init__(self, reason):
        """Init of the exception"""
        ue.Exception.__init__(self, 9601, reason)
        self.reason = reason

    def __str__(self):
        """Return the reason string"""
        return self.reason

    def __repr__(self):
        """Return the reason string"""
        return self.reason


class DBError(ue.Exception):
    """Exception that signals wrong use / values of DB  entities."""
    def __init__(self, reason):
        """Init of the exception"""
        ue.Exception.__init__(self, 9603, reason)
        self.reason = reason

    def __str__(self):
        """Return the reason string"""
        return self.reason

    def __repr__(self):
        """Return the reason string"""
        return self.reason


if __name__ == "__main__":
    pass
