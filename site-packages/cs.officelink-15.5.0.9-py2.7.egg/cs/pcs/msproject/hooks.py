#!/usr/bin/env powerscript
# -*- python -*- coding: UTF-8 -*-
#
# Copyright (C) 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Module hooks

This is the documentation for the hooks module.
"""

from __future__ import unicode_literals

import re

from cdb import auth, cdbuuid, ddl, sqlapi

from cs.pcs.msproject.misc import is_yes, report


class ConstraintError(Exception):
    """Exception that signals wrong use / values of values."""
    def __init__(self, reason):
        """Init of the exception"""
        super(ConstraintError, self).__init__()
        self.reason = reason

    def __str__(self):
        """Return the reason string"""
        return self.reason

    def __repr__(self):
        """Return the reason string"""
        return self.reason


class DB_FieldHookSet:
    """This class stores active field hooks."""
    def __init__(self, ctx):
        """init the hook store, create an empty dictionary. The dictionary stores the hooks
           identified by a relation.field name string."""
        self.ctx = ctx
        self.field_hooks = {}
        self.default_hook = DB_FieldHook("*", "*")

    def addHook(self, hook):
        """add a hook"""
        hook.ctx = self.ctx
        self.field_hooks[hook.relation_name + "." + hook.field_name] = hook

    def getHook(self, relation_name, field_name="-"):
        """returns a specific hook for the relation/field or the default hook, if none"""
        # self.ctx.log("checking for hook on %s.%s" % (relation_name, field_name))
        return self.field_hooks.get(relation_name + "." + field_name, self.default_hook)

    def getHookOrNone(self, relation_name, field_name="-"):
        """returns a specific hook for the relation/field or None"""
        return self.field_hooks.get(relation_name + "." + field_name)

    def removeHook(self, relation_name, field_name):
        """remove a hook"""
        hook_key = relation_name + "." + field_name
        if hook_key in self.field_hooks:
            del self.field_hooks[hook_key]


class MSP_DB_FieldHookSet(DB_FieldHookSet):
    """Initialize the used hooks"""
    def __init__(self, ctx):
        """Add the used hooks to the hook set. parameters for defaulthook:<relation>,<attribute>,
        <default_msp_val>,<default_cdb_val>"""
        from cs.pcs.projects import kProjectManagerRole, Role

        DB_FieldHookSet.__init__(self, ctx)
        self.addHook(DB_FieldHookTaskNumgen("cdbpcs_task", "task_id",
                                            {"cdb_project_id": "$cdb_project_id"}, "T000000"))
        self.addHook(DB_FieldHookBoolean("cdbpcs_task", "milestone"))
        self.addHook(DB_FieldHookBoolean("cdbpcs_task", "auto_update_time", invert=True))
        self.addHook(DB_FieldHookDate("cdbpcs_task", "start_time_fcast"))
        self.addHook(DB_FieldHookDate("cdbpcs_task", "end_time_fcast"))
        self.addHook(DB_FieldHookDate("cdbpcs_task", "constraint_date"))
        self.addHook(DB_FieldHookUUID2TaskId("cdbpcs_task", "parent_task"))
        self.addHook(DB_FieldHookDuration("cdbpcs_task", "duration_fcast"))
        self.addHook(DB_FieldHookPercentComplete("cdbpcs_task", "percent_complet"))
        self.addHook(DB_FieldHookDate("cdbpcs_project", "start_time_fcast"))
        self.addHook(DB_FieldHookDate("cdbpcs_project", "end_time_fcast"))
        self.addHook(DB_FieldHookDefault("cdbpcs_task", "end_plan_fix", "0", ""))
        self.addHook(DB_FieldHookDefault("cdbpcs_task", "cdb_mpersno", "", auth.persno))
        self.addHook(DB_FieldHookDefault("cdbpcs_task", "priority", "500", ""))

        # check if subject_id is present, else use old style responsible and division
        cdbpcs_task = ddl.Table("cdbpcs_task")
        if cdbpcs_task.hasColumn("subject_id"):
            self.ctx.log("Adding Hook using field cdbpcs_task.subject_id")
            self.addHook(DB_FieldHookDefault("cdbpcs_task", "subject_id", "", kProjectManagerRole))
            self.addHook(DB_FieldHookDefault("cdbpcs_task", "subject_type", "",
                                             Role.__subject_type__))
        else:
            self.ctx.log("Adding Hook using field cdbpcs_task.responsible")
            self.addHook(DB_FieldHookDefault("cdbpcs_task", "responsible", "", auth.persno))
            self.addHook(DB_FieldHookDefault("cdbpcs_task", "division", "", auth.get_department()))

        # add relation hooks:
        self.addHook(DB_RelationHookTaskRel("cdbpcs_taskrel"))


def genno(start, trailing="1", prefixlength=0):
    """Generate a new number while retaining the prefix. Stolen from cdbnumgen.ue. """
    result = "0"
    # expression for matching a Number with prefix and running number
    __reNumMatch = re.compile("([^0-9]*)([0-9]*)$")
    matches = __reNumMatch.match(start)
    if matches:
        # In diesem Fall sind die letzten Zeichen nur noch Ziffern.
        segments = matches.groups()
        prefixlength = max(len(segments[0]), prefixlength)
        prefix = start[:prefixlength]
        suffix = start[prefixlength:]
        if not len(suffix):
            suffix = trailing
        else:
            suffix = "%0*d" % (len(suffix), int(suffix) + 1)
        result = "%s%s" % (prefix, suffix)
    else:
        # 'start' endet nicht mit Ziffern! Also einfach 'trailing'
        # anhaengen.
        result = "%s%s" % (start, trailing)
    return result


def get_conditions(cond_template, ctx):
    """Generate a condition set from a condition template using a given context.
       The template is a dict. (or similar) with col-name:col_value pairs.
       if a col_value starts with a "$", the value of the sucessing name is looked up in the attr
       dict.
       Returns a dict with column/value pairs.
    """
    result = {}
    for a in cond_template:
        if cond_template[a].startswith("$"):
            result[a] = ctx[cond_template[a][1:]]
        else:
            result[a] = cond_template[a]
    return result


def get_max_number(rel, attr, cond, start_number="X000000"):
    """Selects the max. ID (as defined by the SQL DB sort order) from the column attr in relation
       rel while observing the conditions in cond
       Used by numgen-hook, e.g. to retrieve the max. number of tasks within a project."""
    result = start_number
    stmt = "MAX(%s) AS mx FROM %s" % (attr, rel)
    th = sqlapi.TableHeader(None, rel)
    condList = []
    for a in cond:
        condList += ["%s=%s" % (a, th.quoted(a, cond[a]))]
    if condList:
        stmt += " WHERE %s" % " AND ".join(condList)
    result = sqlapi.SQLselect(stmt).get_string("mx", 0)
    if result == "":
        result = start_number
    return result


class DB_FieldHook:
    """Class for transforming field values. Operates on Database fields."""

    def __init__(self, relation_name, field_name):
        """Init: remember the relation and the field name """
        self.relation_name = relation_name
        self.field_name = field_name

    def transform_from_db(self, value, obj):
        """Transform a value that is read from the DB. This base implementation just returns the
        original value."""
        if value in [None, ""]:
            return ""
        else:
            return "%s" % value

    def transform_to_db(self, value, obj):
        """Transform a value that is written to the DB. This base implementation just returns the
        original value."""
        return value

    def compare(self, val1, val2):
        """Return true, if val1 is equal to val2"""
        return val1 == val2

    def check(self, value, obj):
        """After processing the value with transform_to_db(), this method gets the new value to
        check constraints. Errors may be indicated by returning a non-empty string (message) or by
        raising a ContraintError.
        """
        return ""


class DB_FieldHookBoolean(DB_FieldHook):
    """Class for transforming BOOLEAN values from True/False (XML) strings to 1/0 (DB)"""
    def __init__(self, relation_name, field_name, invert=False):
        DB_FieldHook.__init__(self, relation_name, field_name)
        self.invert = invert

    def transform_from_db(self, value, obj):
        """Transform a value that is read from the DB. transforms 0/1 to False/True."""
        if is_yes(value):
            return "True" if not self.invert else "False"
        else:
            return "False" if not self.invert else "True"

    def transform_to_db(self, value, obj):
        """Transform a value that is written to the DB. Transforms from True/False to 1/0"""
        if value.upper() == "TRUE":
            return '1' if not self.invert else '0'
        else:
            return '0' if not self.invert else '1'

    def compare(self, val1, val2):
        """Return true, if val1 is equal to val2 (boolean comparision)"""
        try:
            a = int(val1)
            b = int(val2)
            return ((not a) and (not b)) or (a and b)
        except Exception:
            return 0


class DB_FieldHookDate(DB_FieldHook):
    """Class for transforming Date values from empty or replacement strings to null (DB)"""

    def __init__(self, relation_name, field_name):
        DB_FieldHook.__init__(self, relation_name, field_name)

    def transform_from_db(self, value, obj):
        """Transform a value that is read from the DB."""
        if value in [None, ""]:
            return ""
        else:
            return value

    def transform_to_db(self, value, obj):
        """Transform a value that is written to the DB. Transforms from replacements like NV or NA
        to empty string"""
        if len(value) <= 2:
            return ""
        else:
            return value


class DB_FieldHookPercentComplete(DB_FieldHook):
    """Class for transforming percentagevalues.values can be 0-100 in msp and -99-999 in cdb."""
    def __init__(self, relation_name, field_name):
        DB_FieldHook.__init__(self, relation_name, field_name)

    def transform_from_db(self, value, obj):
        """Transform a value that is read from the DB. ignore values <> 0"""
        if value in [None, ""]:
            return "0"
        elif int(value) < 0:
            return "0"
        elif int(value) > 100:
            return "100"
        else:
            return "%s" % value

    def transform_to_db(self, value, obj):
        """Transform a value that is written to the DB. no transformation needed"""
        if value in [None, ""]:
            return "0"
        else:
            return value


class DB_FieldHookNumgen(DB_FieldHook):
    """Class for transforming an empty id to a new value using a number generating function."""
    def __init__(self, relation_name, field_name, attr, start_number):
        DB_FieldHook.__init__(self, relation_name, field_name)
        self.attr = attr
        self.start_number = start_number

    def transform_from_db(self, value, obj):
        """Transform a value that is read from the DB. returns the original value"""
        return "%s" % value

    def transform_to_db(self, value, obj):
        """Transform a value that is written to the DB. if value is an empty string, generate a new
        number"""
        from cs.pcs.projects import tasks
        if value not in [None, ""]:
            return value
        if self.relation_name == "cdbpcs_task":
            return tasks.Task.makeTaskID(obj["cdb_project_id"])
        else:
            max_id = get_max_number(self.relation_name, self.field_name,
                                    get_conditions(self.attr, obj), self.start_number)
            return genno(max_id)


class DB_FieldHookTaskNumgen(DB_FieldHookNumgen):
    """Class for handling of task id."""
    def __init__(self, relation_name, field_name, attr, start_number):
        DB_FieldHookNumgen.__init__(self, relation_name, field_name, attr, start_number)

    def transform_to_db(self, value, obj):
        """Transform a value that is written to the DB. if value is an empty string, generate a new
        number"""
        value = DB_FieldHookNumgen.transform_to_db(self, value, obj)
        obj.fixed_cdb_taskkey = value
        return value


class DB_FieldHookDuration(DB_FieldHook):
    """
    Class for transforming an MSP duration entry (in minutes for a 8h working day) to a CIM
    DATABASE duration (in days).
    """

    # global MSP duration factor (from minutes to hours)
    MSP_Duration_Factor = 60

    def __init__(self, relation_name, field_name):
        DB_FieldHook.__init__(self, relation_name, field_name)

    def transform_from_db(self, value, obj):
        """Transform a value that is read from the DB. returns the transformed value as INT"""
        start_value_exported = \
            self.ctx.is_attribute_synchronized(self.relation_name, "start_time_fcast", to_msp=True)\
            and (obj.start_time_fcast not in [None, ""])
        finish_value_exported = \
            self.ctx.is_attribute_synchronized(self.relation_name, "end_time_fcast", to_msp=True)\
            and (obj.end_time_fcast not in [None, ""])
        if start_value_exported and finish_value_exported:
            # Workaround for PCS currently not being able to interrupt tasks like MSP can do:
            # Returning "" results in the "Duration" field not being touched in MSP at all
            return ""

        if value in [None, ""]:
            return "0"
        return "%.0f" % (float(value) * self.MSP_Duration_Factor)

    def transform_to_db(self, value, obj):
        """Transform a value that is written to the DB. returns the transformed value as INT"""
        if value in [None, ""]:
            return "0"
        return "%.0f" % (float(value) / self.MSP_Duration_Factor)

    def compare(self, val1, val2):
        """Return true, if val1 is equal to val2 (float comparison)"""
        if val1 in [None, ""]:
            val1 = "0"
        if val2 in [None, ""]:
            val2 = "0"
        return float(val1) == float(val2)


class DB_FieldHookUUID2TaskId(DB_FieldHook):
    """
    Class for transforming an UUID into a cdb task id. This is done by using the project member
    of a task node. The transformation is only defined for the writing part.
    """
    def __init__(self, relation_name, field_name):
        DB_FieldHook.__init__(self, relation_name, field_name)

    def transform_to_db(self, value, obj):
        """Transform a UUID to a task id"""
        if value in [None, "", "-"]:
            return ''
        project = obj.project
        task = project.tasksById.get(value, None)
        if task:
            return task.fixed_cdb_taskkey
        else:
            return ''


class DB_FieldHookDefault(DB_FieldHook):
    """Class for applying default values to fields"""
    def __init__(self, relation_name, field_name, defaultWin, defaultCDB):
        DB_FieldHook.__init__(self, relation_name, field_name)
        self.defaultWin = defaultWin
        self.defaultCDB = defaultCDB

    def transform_from_db(self, value, obj):
        """Transform a value that is read from the DB. Applies defaultWin."""
        if value in [None, ""]:
            return self.defaultWin
        else:
            return "%s" % value

    def transform_to_db(self, value, obj):
        """Transform a value that is written to the DB. Apply defaultCDB"""
        if value in [None, ""]:
            return self.defaultCDB
        else:
            return value


class DB_RelationHook:
    """
    Class for loading a relation from the database to a project (which is a DB project by
    semantics). This base class for relation hooks defines the function load_relation_from_db()
    which is used to perform the complete loading of a relation.
    """

    def __init__(self, relation_name):
        """Init: remember the relation and the field name """
        self.relation_name = relation_name
        self.field_name = "-"

    def load_relation_from_db(self, project, relation_name, cdb_id, syncRelations, mspFields,
                              field_hooks):
        """Load a relation from the database, this is a method for DB relation hooks"""
        pass

    def store_relation_in_db(self, project, relation_name, cdb_id, syncRelations, mspFields,
                             field_hooks, default_values):
        """store a relation in the database."""
        pass


class DB_RelationHookTaskRel(DB_RelationHook):
    """
    This hook loads the sync rel. table and transforms the values for the Predecessors and
    UniquePredecessorID fields.
    """

    def __init__(self, relation_name):
        DB_RelationHook.__init__(self, relation_name)

    def load_relation_from_db(self, project, relation_name, cdb_id, syncRelations, mspFields,
                              field_hooks):
        """Load the cdbpcs_taskrel relation from the database."""
        cdbpcs_taskrel = ddl.Table("cdbpcs_taskrel")
        # cs.pcs 15.3.1 adds a "minimal_gap" besides the old "gap"
        has_minimal_gap = cdbpcs_taskrel.hasColumn("minimal_gap")
        gap_attr_name = "minimal_gap" if has_minimal_gap else "gap"

        th = sqlapi.TableHeader(None, "cdbpcs_taskrel")
        # only consider links for tasks from the same project
        relRecords = sqlapi.RecordSet2("cdbpcs_taskrel", "cdb_project_id=%s AND "
                                       "cdb_project_id=cdb_project_id2" %
                                       th.quoted("cdb_project_id", cdb_id))
        for relRecord in relRecords:
            task = project.dbtaskIdList.get(relRecord["task_id"])

            if task:

                predTask = project.dbtaskIdList.get(relRecord["task_id2"])

                if predTask:
                    # add to task predecessor list
                    predUUID = predTask["UUID"]

                    # get relationtype
                    taskType = relRecord["rel_type"]

                    if taskType not in ["EE", "EA", "AE", "AA"]:
                        taskType = ""

                    # link gap
                    gap = "0"
                    if relRecord[gap_attr_name] != sqlapi.NULL:
                        gap = "%s" % relRecord[gap_attr_name]

                    entry = ",".join([predUUID, taskType, gap])
                    if task.hasAttribute("Predecessors"):
                        task["Predecessors"] = ";".join(task["Predecessors"].split(";") + [entry])
                    else:
                        task["Predecessors"] = entry

                    # also always export the Successors field to be able to "fully" restore tasks in
                    # MSP (e.g. after deletion of completed tasks)
                    entry = ",".join([task["UUID"], taskType, gap])
                    if predTask.hasAttribute("Successors"):
                        predTask["Successors"] = \
                            ";".join(predTask["Successors"].split(";") + [entry])
                    else:
                        predTask["Successors"] = entry
                else:
                    self.ctx.log("Project %s / TaskRel %s->%s: Task with ID %s does not exist in "
                                 "project." % (cdb_id, relRecord["task_id2"],
                                               relRecord["task_id"],
                                               relRecord["task_id2"]))
                    report(self.ctx, "w_task_with_id_x_does_not_exist",
                           [cdb_id, relRecord["task_id2"],
                            relRecord["task_id"], relRecord["task_id2"]])
            else:
                self.ctx.log(
                    "Project %s / TaskRel %s->%s: Task with ID %s does not exist in project." %
                    (cdb_id, relRecord["task_id2"], relRecord["task_id"], relRecord["task_id"]))
                report(self.ctx, "w_task_with_id_x_does_not_exist",
                       [cdb_id, relRecord["task_id2"], relRecord["task_id"], relRecord["task_id"]])

    def store_relation_in_db(self, project, relation_name, cdb_id, syncRelations, mspFields,
                             field_hooks, default_values):
        """store the cdbpcs_taskrel relation in the database."""
        # cs.mobile_pcs adds a not-null "cdb_object_id" to "cdbpcs_taskrel"
        cdbpcs_taskrel = ddl.Table("cdbpcs_taskrel")
        has_oid = cdbpcs_taskrel.hasColumn("cdb_object_id")
        # cs.pcs 15.3.1 adds a "minimal_gap" besides the old "gap"
        has_minimal_gap = cdbpcs_taskrel.hasColumn("minimal_gap")
        gap_attr_name = "minimal_gap" if has_minimal_gap else "gap"

        th = sqlapi.TableHeader(None, "cdbpcs_taskrel")
        # do not delete links between tasks of different projects
        sqlapi.SQLdelete("FROM cdbpcs_taskrel "
                         "WHERE cdb_project_id=%s AND cdb_project_id=cdb_project_id2" %
                         th.quoted("cdb_project_id", cdb_id))
        self.ctx.log("Deleting from CDBPCS_TASKREL for project %s" % cdb_id)
        for task in project.tasks:
            self.ctx.log("Task %s: check for predecessors" % (task))
            if task.hasAttribute("Predecessors") and task["Predecessors"] != "":
                self.ctx.log("Task %s has predecessors: '%s'" % (task, task["Predecessors"]))
                for predUUIDStr in task["Predecessors"].split(";"):
                    predUUIDElem = predUUIDStr.split(",")
                    predTask = project.tasksById.get(predUUIDElem[0], None)
                    self.ctx.log("Task %s has predtask: '%s'->'%s'" %
                                 (task, predUUIDElem[0], predTask))
                    if predTask:
                        taskType = 1
                        if len(predUUIDElem) > 1:
                            taskType = predUUIDElem[1]
                            if taskType not in ["EE", "EA", "AE", "AA"]:
                                taskType = "EA"

                        self.ctx.log("Task %s has GAP: '%s'" % (task, predUUIDElem[2]))
                        gap = predUUIDElem[2]
                        if not gap:
                            gap = 0

                        if task.fixed_cdb_taskkey and predTask.fixed_cdb_taskkey:
                            self.ctx.log(
                                "Taskrel: inserting (%s, %s, %s, %s, %s, %s)" %
                                (cdb_id, task.fixed_cdb_taskkey, predTask.fixed_cdb_taskkey,
                                 taskType, "", gap))
                            attrs = ["cdb_project_id",
                                     "cdb_project_id2",
                                     "task_id",
                                     "task_id2",
                                     "rel_type",
                                     "name",
                                     gap_attr_name,
                                     "violation"]
                            values = [th.quoted("cdb_project_id", cdb_id),
                                      th.quoted("cdb_project_id2", cdb_id),
                                      th.quoted("task_id", task.fixed_cdb_taskkey),
                                      th.quoted("task_id2", predTask.fixed_cdb_taskkey),
                                      th.quoted("rel_type", taskType),
                                      th.quoted("name", ""),
                                      th.quoted(gap_attr_name, gap),
                                      th.quoted("violation", int(gap < 0))]
                            if has_oid:
                                attrs.append("cdb_object_id")
                                values.append(th.quoted("cdb_object_id", cdbuuid.create_uuid()))
                            sqlapi.SQLinsert("INTO cdbpcs_taskrel (%s) VALUES (%s)" %
                                             (",".join(attrs), ",".join(values)))
                        else:
                            self.ctx.log("Taskrel: inserting skipped due to empty taskids "
                                         "(%s, %s, %s, %s, %s, %s)" %
                                         (cdb_id, task.fixed_cdb_taskkey,
                                          predTask.fixed_cdb_taskkey, taskType, "", gap))


class MSP_ConstraintHookSet:
    """This class stores active constraint hooks."""

    def __init__(self, ctx):
        self.ctx = ctx
        self.constraint_hooks = []
        # following hook isn't required any longer due to task deletions called via deep delete
        # method in cs.pcs, but the hook is left since currently there aren't any other example
        # hooks:
        # self.addHook(ConstraintHookDeletionContraints())

    def addHook(self, hook):
        hook.ctx = self.ctx
        self.constraint_hooks.append(hook)

    def getHooks(self):
        return self.constraint_hooks


class ConstraintHook:
    """This class defines the class layout for a constraint hook set"""

    def checkConstraint(self, xmlProj, dbProj):
        """
        This method is called with an XML hook and checks the constraint for which it is
        implemented. If the constraint is violated, then:
        a) a descriptive 'warning' or 'error' can be shown by calling 'report()'. The return
           value mustn't be None.
        b) a descriptive exception can be raised which results in skipping all remaining constraint
           hooks.
        Both cases result in the project not being imported in the system but it finally still gets
        exported into msp again (which e.g. reverts deleted tasks).
        """
        return None


class ConstraintHookDeletionContraints(ConstraintHook):

    def checkConstraint(self, xmlProj, dbProj):
        """
        This constraint checks for deleted tasks in MS Project.
        CIM DATABASE Import is canceled if deleted tasks have Checklisten, Offene Punkte or
        Aufwaende
        """
        errors = 0
        for dbtask in dbProj.tasks:
            bTaskDeleted = True
            dbtaskid = dbtask.attributes['UUID']
            for xmltask in xmlProj.tasks:
                if xmltask.attributes['UUID'] == dbtaskid:
                    bTaskDeleted = False
                    break
            if bTaskDeleted:
                violatedConstraints = self.hasDeletionConstraints(dbProj.attributes['Proj_Text10'],
                                                                  dbtask.attributes['Text30'])
                if violatedConstraints:
                    args = (dbtask.attributes['Name'], violatedConstraints)
                    report(self.ctx, "w_task_delete_not_possible", args)
                    errors += 1
        return errors

    def hasDeletionConstraints(self, project_id, task_id):
        # cancels deletion if task owns TimeSheets, Checklists or Issues

        violatedConstraints = []
        if (not project_id or project_id == '') or (not task_id or task_id == ''):
            return None

        sqlkey = "cdb_project_id='%s' and task_id='%s'" % (project_id, task_id)

        timeSheets = sqlapi.RecordSet2('cdbpcs_time_sheet', sqlkey)
        if (timeSheets and timeSheets.__len__() > 0):
            violatedConstraints.append('Efforts(Aufwände)')
        checklists = sqlapi.RecordSet2('cdbpcs_checklst', sqlkey)
        if (checklists and checklists.__len__() > 0):
            violatedConstraints.append('Checklists')
        issues = sqlapi.RecordSet2('cdbpcs_issue', sqlkey)
        if (issues and issues.__len__() > 0):
            violatedConstraints.append('Issues(Offene Punkte)')

        return "/".join(violatedConstraints)


if __name__ == "__main__":
    pass
