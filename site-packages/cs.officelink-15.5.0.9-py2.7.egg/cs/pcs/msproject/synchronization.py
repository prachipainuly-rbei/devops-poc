#!/usr/bin/env powerscript
# -*- python -*- coding: UTF-8 -*-
#
# Copyright (C) 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Module synchronization

This is the documentation for the synchronization module.
"""

from __future__ import unicode_literals

import datetime
import io
import math
import os
from xml.sax import make_parser

from cdb import auth, CADDOK, cdbtime, ddl, sqlapi, transaction, util
from cdb.fls import allocate_license
from cdb.objects import Object
from cdb.objects.org import Person
from cdb.platform import olc

from cs.officelink.context import SoftException
from cs.pcs.msproject.hooks import ConstraintError, MSP_ConstraintHookSet, MSP_DB_FieldHookSet
from cs.pcs.msproject.misc import date_only, DBError, DEFAULT_END_TIME_SUFFIX, \
    DEFAULT_START_TIME, DEFAULT_START_TIME_SUFFIX, fit_value, getClsObj, getLongtext, is_yes, \
    ParameterError, report, setLongtext
from cs.pcs.msproject.nodes import DBProject
from cs.pcs.msproject.mspxml import checkin_xml_file, export_project_to_xml_file, MSPXML_FILE_EXT, \
    XMLContentHandler


# when cad konf "COMAddIn CDB Aufgabenschutz" is activated,
# then only write following attributes to cdb when synchronizing:
RESTRICTED_SYNC_FIELDS = ['end_time_fcast',
                          'start_time_fcast',
                          'duration_fcast',
                          'psp_code',
                          'parent_task']


class MSPField(Object):

    __maps_to__ = "cdbpcs_msp_fields"
    __classname__ = "cdbpcs_msp_fields"


class MSPFields:
    """Store MS Project field names and descriptions"""

    def __init__(self):
        """Load the MSP Fields from the table CDBPCS_MSP_FIELD"""
        self.fields = {}
        self.groupFields = {}
        for field in MSPField.KeywordQuery(field_enabled="1"):
            self.fields[field.pcs_field] = field
            if field.gruppe not in self.groupFields:
                self.groupFields[field.gruppe] = {}
            self.groupFields[field.gruppe][field.pcs_field] = 1

    def isTask(self, name):
        """Return true if the field name describes a task item"""
        return (name in self.groupFields['TASK'])


class RelationKeys:
    """
    This class requests key colums from sqlapi and holds a cache for relation / key data.
    The cache is maintained statically.
    """

    cache = {}

    def isKeyColum(self, relation, columnName):
        """Return true, if the column 'columnName' is part of the relation primary keys"""
        relationKeys = RelationKeys.cache.get(relation, None)
        if relationKeys is None:
            # get the relation
            recordSet = sqlapi.RecordSet2(relation, "0=1")
            relationKeys = recordSet.thead.dbkeys()
            RelationKeys.cache[relation] = relationKeys
        return columnName in relationKeys


class DefaultValue(Object):

    __maps_to__ = "cdbpcs_msp_default"
    __classname__ = "cdbpcs_msp_default"


class DefaultValues:
    """
    DefaultValues is a class that stores default values for CIM DATABASE relation columns.
    It is loaded from cdbpcs_msp_default table.
    """

    def __init__(self, ctx):
        """Load the default map from CIM DATABASE."""
        from cs.pcs.projects import tasks
        self.ctx = ctx
        taskcat = None
        taskstatus = None
        self.defaultMap = {}
        for default in DefaultValue.Query():
            self.ctx.log("Default %s/%s = (%s, %s) read." %
                         (default.cdb_relation, default.cdb_column,
                          default.default_read, default.default_write))
            serverKey = "%s/%s" % (default.cdb_relation, default.cdb_column)
            self.defaultMap[serverKey] = {'cdb_relation': default.cdb_relation,
                                          'cdb_column': default.cdb_column,
                                          'default_read': default.default_read,
                                          'default_write': default.default_write}

            # remember values for calculation of cdb_status_txt
            if default.cdb_column == 'category':
                taskcat = tasks.TaskCategory.ByKeys(default.default_write)
            if default.cdb_column == 'status':
                taskstatus = int(default.default_write)

        workflow = u"cdbpcs_task"
        if taskcat:
            workflow = taskcat.workflow

        if taskstatus is not None:
            # specialcase cdb_status_txt: derive from category and status
            statedef = olc.StateDefinition.ByKeys(objektart=workflow,
                                                  statusnummer=taskstatus)
            if statedef:
                serverKey = "cdbpcs_task/cdb_status_txt"
                self.defaultMap[serverKey] = {'cdb_relation': 'cdbpcs_task',
                                              'cdb_column': 'cdb_status_txt',
                                              'default_read': '',
                                              'default_write': statedef.StateText['']}
            else:
                self.ctx.log("DefaultValues: taskstatus set but could not retrieve StateText.")

        # specialcase cdb_objektart: equal category.workflow
        serverKey = "cdbpcs_task/cdb_objektart"
        self.defaultMap[serverKey] = {'cdb_relation': 'cdbpcs_task',
                                      'cdb_column': 'cdb_objektart',
                                      'default_read': '',
                                      'default_write': workflow}

        self.ctx.log("%d defaults loaded" % len(self.defaultMap))

    def default(self, cdb_rel, cdb_col):
        """Return none, if there is no default for this column. If there is a default,
           return a tupel of (read, write) default.
        """
        server_key = "%s/%s" % (cdb_rel, cdb_col)
        if server_key not in self.defaultMap:
            return None
        else:
            result = self.defaultMap[server_key]
            return (result['default_read'], result['default_write'])


class MSPSyncRelation(Object):

    __maps_to__ = "cdbpcs_msp_syncrel"
    __classname__ = "cdbpcs_msp_syncrel"


class MSPSyncRelations:
    """This class stores the defined sync relations"""

    def __init__(self, ctx, msp_fields):
        """
        Load the CDBPCS_MSP_SYNCREL table and store the sync. descriptions.
        Parameter msp_fields: The MSP_FIELDS object for integrity checking.
        The default values are also loaded.
        """
        self.ctx = ctx
        self.relations = {}
        relationKeys = RelationKeys()
        self.default_values = DefaultValues(ctx)
        for field in MSPSyncRelation.Query():
            if field.pcs_field not in msp_fields.fields.keys():
                continue  # cdbpcs_msp_fields.field_enabled=0
            relationName = field.cdb_relation.lower()
            if relationName not in self.relations:
                self.relations[relationName] = {'__is_task': 0,
                                                '__keys': [],
                                                '__del_keys': [],
                                                '__std_msp': [],
                                                '__from_msp': []}
            columnName = field.cdb_column.lower()
            relation = self.relations[relationName]
            relation[columnName] = field
            if relationKeys.isKeyColum(relationName, columnName):
                relation["__keys"].append(columnName)
            if is_yes(field.del_key):
                if msp_fields.isTask(field.pcs_field):
                    ctx.log("Task field %s.%s is configured to be used as del key, this is invalid"
                            % (relationName, columnName))
                else:
                    relation["__del_keys"].append(columnName)
            if is_yes(field.cdb_std_msp):
                relation["__std_msp"].append(columnName)
            if is_yes(field.cdb_from_msp):
                relation["__from_msp"].append(columnName)
            if msp_fields.isTask(field.pcs_field):
                relation['__is_task'] = 1
            self.msp_fields = msp_fields

    def __getattr__(self, relationName):
        """Return the relation info with the name relation or None, if no relation exists"""
        if relationName in self.relations:
            return self.relations[relationName]
        else:
            self.ctx.log("There is no relation named %s in configuration (CBDPCS_MSP_SYNCREL)." %
                         relationName)
            raise ParameterError("There is no relation named %s in configuration "
                                 "(CBDPCS_MSP_SYNCREL)." % relationName)

    def __getitem__(self, relationName):
        """Return the relation info with the name relation or None, if no relation exists"""
        if relationName in self.relations:
            return self.relations[relationName]
        else:
            self.ctx.log("There is no relation named %s in configuration "
                         "(CBDPCS_MSP_SYNCREL)." % relationName)
            raise ParameterError("There is no relation named %s in configuration "
                                 "(CBDPCS_MSP_SYNCREL)." % relationName)

    def keys(self):
        """return a list of keys"""
        return self.relations.keys()

    def values(self):
        """return a list of valued"""
        return self.relations.values()

    def has_key(self, key):
        """return true (1) if the key exists"""
        return key in self.relations

    def getDBKeyExpression(self, relationName, node, keySet="__keys"):
        """return an SQL expression for the primary keys of a relation filled with parameters from
        node attributes"""
        keyCondition = []
        relation = self.relations[relationName]
        for key in relation[keySet]:
            pcs_name = relation[key].pcs_field
            val = node.getAttribute(pcs_name)
            keyCondition.append(key + "= '" + val + "'")
        return " AND ".join(keyCondition)

    def prepare_msp_time_value(self, relation, obj, column, value):
        # 1) MSP sets time values of date fields to 00:00:00, when they are set with date-only
        #    values, which results in tasks always starting and ending at 00:00:00, which therefore
        #    e.g. results in tasks with a duration of 1 day being displayed with a duration of 0
        #    days.
        # 2) Milestones are specially handled in that the cdb attribute "early_position" determines
        #    the start and end time of the MSP task. If "early_position" is not synchronized to msp
        #    then set DEFAULT_START_TIME for start and end since MSP itself defaults to "early"
        #    milestones.
        time_suffix = ""

        if isinstance(value, datetime.date):
            value = value.strftime("%d.%m.%Y")
        elif isinstance(value, datetime.datetime):
            value = value.strftime("%d.%m.%Y %H:%M:%S")

        if value and (column in self.ctx.DATEONLYATTRS) and (":" not in value):

            if "start" in column:
                time_suffix = DEFAULT_START_TIME_SUFFIX
                if obj.get("milestone") and not obj["early_position"] and\
                   self.ctx.is_attribute_synchronized(relation, "early_position", to_msp=True):
                    time_suffix = DEFAULT_END_TIME_SUFFIX

            elif "end" in column:
                time_suffix = DEFAULT_END_TIME_SUFFIX
                if obj.get("milestone"):
                    if obj["early_position"] or\
                       not self.ctx.is_attribute_synchronized(
                           relation, "early_position", to_msp=True):
                        time_suffix = DEFAULT_START_TIME_SUFFIX

        return "%s%s" % (value, time_suffix)

    def evaluate_msp_time_value(self, relation, obj, column, value, updates):
        # 1) PCS date attributes must not contain time values, thus by default truncate it for all
        #    attributes like cdbpcs_project.start_time_fcast, cdbpcs_task.start_time_fcast, ..
        # 2) Milestones are specially handled in that the cdb attribute "early_position" gets
        #    adjusted here according to the start and end time of the MSP task
        if (column in self.ctx.DATEONLYATTRS) and (":" in value):

            dt = cdbtime.Time(value)
            task_time = dt.datetime()
            early_time = task_time.replace(
                hour=DEFAULT_START_TIME.hour,
                minute=DEFAULT_START_TIME.minute,
                second=DEFAULT_START_TIME.second)
            if "start" in column:
                if obj.attributes.get("Milestone") == "True":
                    early_position_synced = self.ctx.is_attribute_synchronized(
                        relation, "early_position", to_cdb=True)
                    if early_position_synced:
                        # if in MSP later than 08:00:00 then in CDB early_position=0
                        updates["early_position"] = "0" if (task_time > early_time) else "1"
            value = date_only(dt.datestr)
        return value

    def updateSubProjectRelationEntry(self, relationName, subproject, field_hooks):
        """Update project relation with attributes from the subproject (a task node)"""
        relation = self.relations[relationName]
        updates = {}
        DBPrimaryKey = ''

        for attr in subproject.attributes.keys():

            # subproject are covered as taskobject. now convert taskobjectattributes back to
            # projectattributes
            mappedName = self.ctx.TASK2SUBPROJECT_MAP.get(attr, None)
            if mappedName:
                attrvalue = subproject.attributes[attr]
                colname = ''
                # get fitting mapping from msp_syncrel for cdbpcs_project
                for rel in relation:
                    if mappedName == 'position':
                        colname = mappedName
                        break
                    if isinstance(relation[rel], MSPSyncRelation) \
                       and 'pcs_field' in relation[rel] \
                       and relation[rel].pcs_field == mappedName:
                        if rel == 'cdb_project_id':
                            DBPrimaryKey = attrvalue
                            break
                        else:
                            colname = rel
                            break
                if colname == '':
                    continue
                # use hooks and fitvalue to db
                attrvalueTransformed = self.evaluate_msp_time_value(
                    relationName, subproject, colname, attrvalue, updates)
                hook = field_hooks.getHook(relationName, colname)
                attrvalueTransformed = hook.transform_to_db(attrvalueTransformed, subproject)
                constraint_error = hook.check(attrvalueTransformed, subproject)
                if constraint_error:
                    self.ctx.log("Constraint violated in field %s.%s: %s" %
                                 (relationName, colname, constraint_error))
                    report(self.ctx, "e_constraint_violated_in_field",
                           [relationName, colname, constraint_error])
                    raise ConstraintError(constraint_error)
                attrvalueTransformed = fit_value(self.ctx, relationName, colname,
                                                 attrvalueTransformed)
                updates[colname] = attrvalueTransformed
        if DBPrimaryKey == '':
            self.ctx.log("Cannot update subproject due to missing database key (%s)" % updates)
            report(self.ctx, "w_no_subproject_update_due_to_missing_db_key", [updates])
            return
        RecordSet = sqlapi.RecordSet2(relationName, 'cdb_project_id=\'%s\'' % DBPrimaryKey,
                                      updatable=1)
        if len(RecordSet) != 1:
            self.ctx.log("SubProject Record not found in DB: %s" % DBPrimaryKey)
            return
        dbrecord = RecordSet[0]
        self.ctx.log("updating %s:%s with %s" % (relationName, DBPrimaryKey, updates))
        # always set fixed enddates for subprojects
        updates['end_plan_fix'] = 1

        # set modified by date/person information
        updates["cdb_mdate"] = cdbtime.now('%d.%m.%Y %H:%M:%S')
        updates["cdb_mpersno"] = auth.persno
        dbrecord.update(**updates)

    def updateRelationEntry(self, relationName, node, delrecordset, foundKeys, field_hooks,
                            onlyDates=False):
        """Update a relation element with attributes from the node"""
        relation = self.relations[relationName]
        keys = relation["__keys"]

        # if we have a delrecordset, look for the record in it
        delrecord = None
        identitycheck = 1
        if delrecordset:
            for delrecord in delrecordset:
                identitycheck = 1
                for keyColumn in keys:
                    if delrecord[keyColumn] != node.getAttribute(relation[keyColumn].pcs_field):
                        identitycheck = 0
                        break
                if not identitycheck:
                    continue
                # if we reach this, we found the delrecord
                foundKeys[delrecord.sqlkey()] = 1
                break
            # if we iterated through all records and did not found any equivalence, reset the
            # delrecord
            if not identitycheck:
                delrecord = None

            if delrecord:
                self.ctx.log("Record identified")
                for keyColumn in keys:
                    self.ctx.log("     %s:%s/%s:%s" %
                                 (keyColumn, delrecord[keyColumn],
                                  relation[keyColumn].pcs_field,
                                  node.getAttribute(relation[keyColumn].pcs_field)))
            else:
                self.ctx.log("Record NOT identified:")
                for record in delrecordset:
                    for keyColumn in keys:
                        self.ctx.log("     %s:%s/%s:%s" %
                                     (keyColumn, record[keyColumn],
                                      relation[keyColumn].pcs_field,
                                      node.getAttribute(relation[keyColumn].pcs_field)))
                    self.ctx.log("     --")

        # if delrecord is still empty (because there is no delrecordset), try to get it from the DB
        if not delrecordset:
            loadRecordSet = sqlapi.RecordSet2(relationName,
                                              self.getDBKeyExpression(relationName, node))
            if len(loadRecordSet) == 1:
                delrecord = loadRecordSet[0]
            elif len(loadRecordSet) > 0:
                msg = "Error: Primary key retrieval on relation %s with key %s yielded %d rows!" % \
                    (relationName, self.getDBKeyExpression(relationName, node), len(loadRecordSet))
                self.ctx.log(msg)
                report(self.ctx, "e_error_on_primary_key_retrieval",
                       [relationName,
                        self.getDBKeyExpression(relationName, node),
                        len(loadRecordSet)])
                raise DBError(msg)
            else:
                self.ctx.log("Record not found in DB: %s" % self.getDBKeyExpression(relationName,
                                                                                    node))

        relObj = None

        if delrecord:
            # UPDATE! check all fields: do we need an update
            updates = {}
            for updateColumn in relation["__from_msp"]:
                pcs_name = relation[updateColumn].pcs_field

                # dont change fixed enddates of tasks
                if updateColumn == 'end_time_fcast' and relationName == "cdbpcs_task" \
                   and 'Number19' in node.attributes and node.attributes['Number19'] == '1':
                    self.ctx.log("Ignoring changed task value for %s because date is fixed" %
                                 updateColumn)
                    continue

                # if cad konv switch 'only sync dates from cdb tasks' set only sync this task
                # attributes
                if onlyDates and updateColumn not in RESTRICTED_SYNC_FIELDS:
                    self.ctx.log("Ignoring changed task value for %s because onlyDates set" %
                                 updateColumn)
                    continue

                hook = field_hooks.getHook(relationName, updateColumn)
                if node.hasAttribute(pcs_name):
                    attrvalue = node.getAttribute(pcs_name)
                    attrvalue = self.evaluate_msp_time_value(
                        relationName, node, updateColumn, attrvalue, updates)
                    nodeValue = hook.transform_to_db(attrvalue, node)
                else:
                    nodeValue = hook.transform_to_db("", node)
                    self.ctx.log("Warning: Empty default value used for %s.%s (%s)." %
                                 (relationName, updateColumn, pcs_name))
                    report(self.ctx, "w_empty_default_value",
                           [relationName, updateColumn, pcs_name])

                constraint_error = hook.check(nodeValue, node)
                if constraint_error:
                    self.ctx.log("Constraint violated in field %s.%s: %s" %
                                 (relationName, updateColumn, constraint_error))
                    report(self.ctx, "e_constraint_violated_in_field",
                           [relationName, updateColumn, constraint_error])
                    raise ConstraintError(constraint_error)

                oldValue = delrecord.get(updateColumn)
                if updateColumn in self.ctx.LONGTEXTS:
                    relObj = getClsObj(relationName, delrecord)
                    if relObj is not None:
                        sep = '\r' if pcs_name == "Notes" else ' '
                        oldValue = getLongtext(relObj, updateColumn).replace('\n', sep)
                        nodeValue = nodeValue.replace('\r', '\n')

                if not hook.compare(oldValue, nodeValue):
                    if updateColumn not in relation["__keys"]:
                        self.ctx.log("delrecord[%s] '%s' != nodeValue '%s'" %
                                     (updateColumn, oldValue, nodeValue))
                        nodeValue = fit_value(self.ctx, relationName, updateColumn, nodeValue)
                        updates[updateColumn] = nodeValue
                    else:
                        self.ctx.log("Warning: Skipping update on key column %s.%s ('%s'->'%s')" %
                                     (relationName, updateColumn, oldValue, nodeValue))
                        report(self.ctx, "w_skipping_update_on_key_value",
                               [relationName, updateColumn, oldValue, nodeValue])
            # default checking for update
            unitedColumns = set(delrecord.keys() + relation["__std_msp"])
            for column in unitedColumns:
                result = None
                if column in relation:
                    if column in self.ctx.LONGTEXTS:
                        if relObj is not None:
                            pcs_name = relation[column].pcs_field
                            sep = '\r' if pcs_name == "Notes" else ' '
                            result = getLongtext(relObj, column).replace('\n', sep)
                    elif column in delrecord:
                        result = delrecord[column]
                else:
                    result = delrecord[column]
                if column in updates:
                    result = updates[column]
                if not result or result == "":
                    default_val = self.default_values.default(relationName, column)
                    if default_val and default_val[1] and default_val[1] != "":
                        updates[column] = default_val[1]
                        self.ctx.log("update %s: Using default %s for column %s" %
                                     (relationName, default_val[1], column))

            if len(updates) > 0:
                self.ctx.log("updating %s: %s with %s" % (relationName, delrecord.sqlkey(),
                                                          updates))
                # set modified by date/person information
                updates["cdb_mdate"] = cdbtime.now('%d.%m.%Y %H:%M:%S')
                updates["cdb_mpersno"] = auth.persno

                # hack: since cs.pcs 15.4.0 "auto_update_time" and "automatic" must always be the
                # same, but the hooks don't allow to map one MSP field with two PCS fields
                if ("auto_update_time" in updates) and ("__has_automatic" in relation):
                    updates["automatic"] = updates["auto_update_time"]
                # hack: since cs.pcs 15.4.0 "days_fcast" must always be set when "duration_fcast" is
                # set
                if ("duration_fcast" in updates) and updates["duration_fcast"]:
                    updates["days_fcast"] = int(math.ceil(float(updates["duration_fcast"]) / 8.0))

                for longtext in self.ctx.LONGTEXTS:
                    if longtext in updates:
                        setLongtext(relObj, longtext, updates[longtext])
                        del updates[longtext]

                delrecord.update(**updates)

                # set is_group attribute for parent summary task if pcs scheme version = 2 and
                # parent task changed
                if relationName == "cdbpcs_task":
                    parent_task_id = updates.get("parent_task", "")
                    if parent_task_id and parent_task_id != "-":
                        project_id = delrecord.cdb_project_id
                        parent_task = sqlapi.RecordSet2(relationName,
                                                        "cdb_project_id='%s' AND task_id='%s'" %
                                                        (project_id, parent_task_id), updatable=1)

                        if len(parent_task) == 1 and parent_task[0].is_group != '1':
                            parent_task[0].update(is_group='1')
                            self.ctx.log("Summary task attribute 'is_group' set for task %s (%s)" %
                                         (parent_task_id, project_id))

            else:
                self.ctx.log("updating %s[%s]: %s has no changes" %
                             (relationName, delrecord.sqlkey(), updates))
        else:
            if onlyDates and relationName == "cdbpcs_task":
                return
            constraint_error = None
            # Insert
            cols = {}
            tableHeader = sqlapi.TableHeader(
                sqlapi.SQLdescribe("select * from %s where 0=1" % relationName), relationName)
            for updateColumn in relation["__from_msp"]:
                pcs_name = relation[updateColumn].pcs_field
                hook = field_hooks.getHook(relationName, updateColumn)
                if node.hasAttribute(pcs_name):
                    attrvalue = node.getAttribute(pcs_name)
                    attrvalue = self.evaluate_msp_time_value(
                        relationName, node, updateColumn, attrvalue, cols)
                    nodeValue = hook.transform_to_db(attrvalue, node)
                else:
                    nodeValue = hook.transform_to_db("", node)
                constraint_error = hook.check(nodeValue, node)
                nodeValue = fit_value(self.ctx, relationName, updateColumn, nodeValue)
                cols[updateColumn] = nodeValue

                if constraint_error:
                    self.ctx.log("Constraint violated in field %s.%s: %s" %
                                 (relationName, updateColumn, constraint_error))
                    report(self.ctx, "e_constraint_violated_in_field",
                           [relationName, updateColumn, constraint_error])
                    raise ConstraintError(constraint_error)

            for keyColumn in relation["__keys"]:
                attrvalue = node.getAttribute(relation[keyColumn].pcs_field)
                attrvalue = self.evaluate_msp_time_value(
                    relationName, node, keyColumn, attrvalue, cols)
                hook = field_hooks.getHook(relationName, keyColumn)
                nodeValue = hook.transform_to_db(attrvalue, node)
                constraint_error = hook.check(nodeValue, node)
                nodeValue = fit_value(self.ctx, relationName, keyColumn, nodeValue)
                cols[keyColumn] = nodeValue

                if constraint_error:
                    self.ctx.log("Constraint violated in field %s.%s: %s" %
                                 (relationName, keyColumn, constraint_error))
                    report(self.ctx, "e_constraint_violated_in_field",
                           [relationName, keyColumn, constraint_error])
                    raise ConstraintError(constraint_error)

            # default checking for update
            for column in tableHeader.keys():
                result = ""
                if column in cols:
                    result = cols[column]
                if not result or result == "":
                    default_val = self.default_values.default(relationName, column)
                    if default_val and default_val[1] and default_val[1] != "":
                        cols[column] = default_val[1]
                        self.ctx.log("insert %s: Using default %s for column %s" %
                                     (relationName, default_val[1], column))

            # set is_group value to 0 by default
            if relationName == "cdbpcs_task":
                cols['is_group'] = '0'

            # set created and modified by date/person information
            # TODO: see tasks.Task.MakeChangeControlAttributes()
            cols["cdb_cdate"] = cdbtime.now('%d.%m.%Y %H:%M:%S')
            cols["cdb_mdate"] = cdbtime.now('%d.%m.%Y %H:%M:%S')
            cols["cdb_cpersno"] = auth.persno
            cols["cdb_mpersno"] = auth.persno

            # hack: since cs.pcs 15.4.0 "auto_update_time" and "automatic" must always be the
            # same, but the hooks don't allow to map one MSP field with two PCS fields
            if "auto_update_time" in cols and ("__has_automatic" in relation):
                cols["automatic"] = cols["auto_update_time"]
            # hack: since cs.pcs 15.4.0 "days_fcast" must always be set when "duration_fcast" is set
            if ("duration_fcast" in cols) and cols["duration_fcast"]:
                cols["days_fcast"] = int(math.ceil(float(cols["duration_fcast"]) / 8.0))

            # skip longtexts and set them later
            longtext_cols = {}
            for longtext in self.ctx.LONGTEXTS:
                if longtext in cols:
                    longtext_cols[longtext] = cols[longtext]
                    del cols[longtext]

            self.ctx.log("creating new entry in %s" % relationName)

            dbi = util.DBInserter(relationName)
            for k, v in cols.iteritems():
                dbi.add(k, v)
            dbi.insert()

            relObj = None
            for longtext in longtext_cols:
                if relObj is None:
                    relObj = getClsObj(relationName, cols)
                setLongtext(relObj, longtext, longtext_cols[longtext])

            # set is_group attribute for parent summary task if pcs scheme version = 2
            # TODO: see tasks.Task.updateParentTask()
            if relationName == "cdbpcs_task":
                parent_task_id = cols["parent_task"]
                if parent_task_id and parent_task_id != "-":
                    project_id = cols["cdb_project_id"]
                    parent_task = sqlapi.RecordSet2(relationName,
                                                    "cdb_project_id='%s' AND task_id='%s'" %
                                                    (project_id, parent_task_id), updatable=1)

                    if len(parent_task) == 1 and parent_task[0].is_group != '1':
                        parent_task[0].update(is_group='1')
                        self.ctx.log("Summary task attribute 'is_group' set for task '%s' (%s)" %
                                     (parent_task_id, project_id))

    def updateRelation(self, relationName, project, syncrel, field_hooks, onlyDates=False):
        """Updates a relation to the database based on the relation config"""
        from cs.pcs.projects import tasks
        self.ctx.log("Updating relation %s with project %s" % (relationName,
                                                               project["cdb_project_id"]))
        # load all records for the deletion set
        relation = self.relations[relationName]
        relationHook = field_hooks.getHookOrNone(relationName)
        if relationHook:
            # relation storing via the hook function
            relationHook.store_relation_in_db(project, relationName, project["cdb_project_id"],
                                              syncrel, self.msp_fields, field_hooks,
                                              self.default_values)
        else:
            # get the deletion key expression
            delKeyExpression = self.getDBKeyExpression(relationName, project, "__del_keys")
            delRecordSet = None
            foundKeys = {}
            if delKeyExpression != "":
                # load the deletion recordset
                self.ctx.log("Loading deletion set where %s" % delKeyExpression)
                delRecordSet = sqlapi.RecordSet2(relationName, delKeyExpression, updatable=1)
                self.ctx.log("Deletion set: %d entries" % len(delRecordSet))
            if relation['__is_task']:
                # perform updates / insertions for each task
                if ddl.Table("cdbpcs_task").hasColumn("automatic"):
                    # for compatibility with newer cs.pcs versions
                    relation['__has_automatic'] = True
                for task in project.tasks:
                    self.updateRelationEntry(relationName, task, delRecordSet, foundKeys,
                                             field_hooks, onlyDates)
                for subproject in project.subprojects:
                    self.updateSubProjectRelationEntry("cdbpcs_project", subproject, field_hooks)

            else:
                # perform update for project object
                if onlyDates:
                    self.ctx.log("Import of project attributes skipped because onlyDates set")
                else:
                    self.updateRelationEntry(relationName, project, delRecordSet, foundKeys,
                                             field_hooks, onlyDates)
            # if there are any delete keys left, delete them.
            if delRecordSet:
                for delrecord in delRecordSet:
                    if not delrecord.sqlkey() in foundKeys.keys():
                        # skip deletion of tasks if onlyDates is set to True.
                        if onlyDates:
                            self.ctx.log("DELETE skipped of task %s where %s because onlyDates set"
                                         % (relationName, delrecord.sqlkey()))
                        else:
                            self.ctx.log("DELETE %s where %s" % (relationName, delrecord.sqlkey()))
                            self.ctx.log("deleting entry in %s with key (%s)" %
                                         (relationName, delrecord.sqlkey()))
                            if relation['__is_task']:
                                tskObj = tasks.Task.ByKeys(
                                    cdb_project_id=delrecord["cdb_project_id"],
                                    task_id=delrecord["task_id"])
                                if tskObj:
                                    try:
                                        tskObj.msp_delete()
                                    except Exception as ex:
                                        self.ctx.rollback = True
                                        self.ctx.log(ex.message, trace=True)
                                        args = (tskObj['task_name'], ex.message)
                                        report(self.ctx, "w_task_delete_not_possible", args)
                            else:
                                delrecord.delete()


class Synchronization(object):
    """Exporting and importing PCS projects via xml"""

    def __init__(self, ctx, field_hooks=None, constraint_hooks=None):
        """
        Initialize an upcoming project export and/or import.
        Constraint hooks are currently only used for imports.
        """
        self.ctx = ctx

        self.field_hooks = field_hooks or MSP_DB_FieldHookSet(self.ctx)
        self.constraint_hooks = constraint_hooks or MSP_ConstraintHookSet(self.ctx)

        self.msp_fields = MSPFields()
        self.msp_sync_rels = MSPSyncRelations(self.ctx, self.msp_fields)

        # expose MSPSyncRelations queries to the hooks via ctx method
        self.ctx.is_attribute_synchronized = self.is_attribute_synchronized

        if not hasattr(ctx, "LONGTEXTS"):
            # default longtext fields
            self.ctx.LONGTEXTS = ['cdbpcs_task_txt', 'cdbpcs_proj_txt']

        if not hasattr(ctx, "TASK2SUBPROJECT_MAP"):
            self.ctx.TASK2SUBPROJECT_MAP = {"Start": "Proj_ProjectStart",
                                            "Finish": "Proj_ProjectFinish",
                                            "Text30": "Proj_Text10",
                                            "Name": "Proj_Title",
                                            "ID": "position"}
        if not hasattr(ctx, "SUBPROJECT2TASK_MAP"):
            self.ctx.SUBPROJECT2TASK_MAP = {"Proj_ProjectStart": "Start",
                                            "Proj_ProjectFinish": "Finish",
                                            "Proj_Text10": "Text30",
                                            "Proj_Number4": "Number18",
                                            "Proj_Text9": "UUID",
                                            "Proj_Title": "Name",
                                            "position": "position"}

        if not hasattr(ctx, "DATEONLYATTRS"):
            self.ctx.DATEONLYATTRS = ["end_time_fcast",
                                      "end_time_plan",
                                      "start_time_fcast",
                                      "start_time_plan"]

        self.ctx.UUID_MAP = {"cdbpcs_task": "tuid",
                             "cdbpcs_project": "puid"}

        # global UUID list of (sub)projects
        self.ctx.PROJECTS_UUIDS = []

    def is_attribute_synchronized(self, relation, attr, to_cdb=False, to_msp=False):
        """Check if an attribute is synchronized in one or the other or both directions"""
        ret = False
        if attr in self.msp_sync_rels[relation]:
            if to_cdb:
                ret = is_yes(self.msp_sync_rels[relation][attr]["cdb_from_msp"])
                if to_msp:
                    ret &= is_yes(self.msp_sync_rels[relation][attr]["cdb_std_msp"])
            elif to_msp:
                ret = is_yes(self.msp_sync_rels[relation][attr]["cdb_std_msp"])
        return ret

    def export_project(self):
        """Exports a PCS project to an XML file."""
        from cs.documents import Document
        from cs.pcs import projects
        self.ctx.log("Synchronization.export_project: -start-")

        allocate_license("TASKS_001")

        self.ctx.doc = Document.ByKeys(self.ctx.object["z_nummer"], self.ctx.object["z_index"])
        self.ctx.proj = projects.Project.ByKeys(cdb_project_id=self.ctx.doc.cdb_project_id)

        # get xml filename
        self.ctx.log("doc: z_nummer=%s, z_index=%s, cdb_project_id=%s" %
                     (self.ctx.doc.z_nummer, self.ctx.doc.z_index, self.ctx.doc.cdb_project_id))
        xml_fname = self.ctx.doc.getExternalFilename(MSPXML_FILE_EXT)
        self.ctx.log("xml_fname: %s" % xml_fname)

        # read project from db
        proj = DBProject(self.ctx, self.ctx.doc.cdb_project_id, self.msp_sync_rels, self.msp_fields,
                         self.field_hooks, isSubProject=False)

        # export project to xml file and save to vault
        xml_fname = "%s" % os.path.join(CADDOK.TMPDIR, os.path.basename(xml_fname))
        export_project_to_xml_file(self.ctx, self.msp_fields, proj, xml_fname)
        checkin_xml_file(self.ctx, self.ctx.doc, xml_fname)

        self.ctx.log("Synchronization.export_project: -stop-")

    def import_project_pre(self, proj, doc):
        """
        Method for running checks on project or document level.
        If False is returned then the project doesn't get exported.
        """
        # check if the project is enabled to be edited in MSP
        if ("msp_active" in proj) and not proj.msp_active:
            report(self.ctx, "e_project_must_not_be_modified_via_msp")
            self.ctx.log("Synchronization.import_project_pre: "
                         "canceled because this project mustn't be edited in MSP")
            return False

        # check if the document is the primary plan of the project
        if ("msp_z_nummer" in proj) and (proj.getLastPrimaryMSPDocument() != doc):
            report(self.ctx, "e_document_not_set_as_primary_plan")
            self.ctx.log("Synchronization.import_project_pre: "
                         "canceled because this document isn't the primary project plan")
            return False

        # check if the project is locked by another person
        if proj.locked_by and (proj.locked_by != auth.persno):
            pers = Person.ByKeys(personalnummer=proj.locked_by)
            if pers:
                pers = pers.GetDescription()
                report(self.ctx, "e_locked_by_someone", [pers])
                self.ctx.log("Synchronization.import_project_pre: "
                             "canceled because of being locked by '%s'" % pers)
                return False
            else:
                self.ctx.log("Synchronization.import_project_pre: "
                             "the project is locked by '%s', but the sync was not canceled "
                             "because the persno could not be resolved" % proj.locked_by, 0)

        return True

    def import_project(self):
        """Imports a PCS project from an XML file."""
        from cs.documents import Document
        from cs.pcs import projects
        self.ctx.log("Synchronization.import_project: -start-")

        allocate_license("TASKS_002")

        self.ctx.doc = Document.ByKeys(self.ctx.object["z_nummer"], self.ctx.object["z_index"])
        self.ctx.proj = projects.Project.ByKeys(cdb_project_id=self.ctx.doc.cdb_project_id)

        if not self.import_project_pre(self.ctx.proj, self.ctx.doc):
            return

        # get xml filename
        self.ctx.log("doc: z_nummer=%s, z_index=%s, cdb_project_id=%s" %
                     (self.ctx.doc.z_nummer, self.ctx.doc.z_index, self.ctx.doc.cdb_project_id))
        xml_fname = self.ctx.doc.getExternalFilename(MSPXML_FILE_EXT)
        self.ctx.log("xml_fname: %s" % xml_fname)

        # init xml parser
        parser = make_parser()
        contentHandler = XMLContentHandler(self.ctx, self.msp_fields, self.msp_sync_rels)
        parser.setContentHandler(contentHandler)

        # check out xml file
        xml_fname = "%s" % os.path.join(CADDOK.TMPDIR, os.path.basename(xml_fname))
        self.ctx.log("Trying to check out to %s" % (xml_fname))
        assert isinstance(xml_fname, unicode)
        self.ctx.doc.checkoutFile(xml_fname, suffix=MSPXML_FILE_EXT)

        # load and parse xml file
        xml_file = io.open(xml_fname, "r", encoding="utf-8")
        parser.parse(xml_file)
        xml_file.close()
        os.remove(xml_fname)
        xmlProj = contentHandler.project
        xmlProj.attributes["Proj_Text10"] = self.ctx.doc.cdb_project_id
        xmlProj.attributes["cdb_project_id"] = self.ctx.doc.cdb_project_id

        # read project from db
        dbProj = DBProject(self.ctx, self.ctx.doc.cdb_project_id, self.msp_sync_rels,
                           self.msp_fields, self.field_hooks, isSubProject=False)

        self.ctx.log("Fixing keys")
        # Compatibility to old/misconfigured configs that do not transfer the CDB task key in the
        # XML file: use the UUID for looking up the related task id and write it to the XML
        # attribute
        field_name = "task_id"
        if "task_id" in self.msp_sync_rels["cdbpcs_task"]:
            field_name = self.msp_sync_rels["cdbpcs_task"]["task_id"].pcs_field
        for task in xmlProj.tasks:
            if task["UUID"] in dbProj.dbtaskUUIDList:
                taskkey = dbProj.dbtaskUUIDList[task["UUID"]][field_name]
                if not task.hasAttribute(field_name) or task[field_name] == "":
                    task[field_name] = taskkey
                task.fixed_cdb_taskkey = taskkey
            else:
                task[field_name] = ""
                task.fixed_cdb_taskkey = ""

        try:
            self.ctx.log("Checking constraints")
            constraint_violations = 0
            for hook in self.constraint_hooks.getHooks():
                _errors = hook.checkConstraint(xmlProj, dbProj)
                if _errors:
                    constraint_violations += 1

            self.ctx.log("Updating project in db")

            # check if project has fixed start and end dates. don't overwrite these values
            if 'Proj_Number4' in dbProj.attributes and dbProj.attributes['Proj_Number4'] == '1':
                xmlProj.attributes['Proj_ProjectStart'] = dbProj.attributes['Proj_ProjectStart']
                xmlProj.attributes['Proj_ProjectFinish'] = dbProj.attributes['Proj_ProjectFinish']

            # remember if dbproject has fixed end dates
            for dbSubproject in dbProj.subprojects:
                if 'Proj_Number4' in dbSubproject.attributes and \
                   dbSubproject.attributes['Proj_Number4'] == '1':
                    for xmlSubproject in xmlProj.subprojects:
                        if xmlSubproject.cdb_id == dbSubproject.cdb_id:
                            xmlSubproject['Proj_Number4'] = 1

            # check if to import while not creating new tasks or removing existing ones in db
            import_restrictively = not bool(self.ctx.import_restrictively)

            # warn user if project start or finish has changed
            try:
                if not import_restrictively:
                    xml_proj_start = date_only(xmlProj.attributes["Proj_ProjectStart"])
                    db_proj_start = date_only(dbProj.attributes["Proj_ProjectStart"])
                    if xml_proj_start != db_proj_start:
                        self.ctx.log("Start date of cdb project changed from \'%s\' to \'%s\'" %
                                     (db_proj_start, xml_proj_start))
                        report(self.ctx, "i_cdb_project_start_date_changed",
                               [db_proj_start, xml_proj_start])

                    xml_proj_finish = date_only(xmlProj.attributes["Proj_ProjectFinish"])
                    db_proj_finish = date_only(dbProj.attributes["Proj_ProjectFinish"])
                    if xml_proj_finish != db_proj_finish:
                        self.ctx.log("Finish date of cdb project changed from \'%s\' to \'%s\'"
                                     % (db_proj_finish, xml_proj_finish))
                        report(self.ctx, "i_cdb_project_finish_date_changed",
                               [db_proj_finish, xml_proj_finish])
            except Exception as ex:
                error_msg = "Exception while checking for changed project " \
                    "start or end: %s" % ex.message
                self.ctx.log(error_msg, trace=True)
                report(self.ctx, "e", msg=error_msg)

            if not constraint_violations:
                with transaction.Transaction():
                    self.ctx.rollback = False

                    for rel_name in list(set(["cdbpcs_project", "cdbpcs_task"]
                                             + self.msp_sync_rels.relations.keys())):
                        self.msp_sync_rels.updateRelation(rel_name, xmlProj, self.msp_sync_rels,
                                                          self.field_hooks, import_restrictively)

                    try:
                        self.ctx.log("Adjust pcs values")
                        myProject = projects.Project.ByKeys(self.ctx.doc.cdb_project_id)
                        myProject.MSPtoDB()
                    except Exception as ex:
                        # TODO: try/catch/report/enable-rollback inside of MSPtoDB in order to
                        #       report about all problems, not only the first one
                        self.ctx.log("%s" % ex, trace=True)
                        report(self.ctx, "e", msg="%s" % ex)
                        self.ctx.rollback = True

                    if self.ctx.rollback:
                        raise Exception(util.get_label("officelink_pcs_e_server_side_rollback"))

        except Exception as ex:
            self.ctx.log("%s" % ex, trace=True)
            report(self.ctx, "e", msg="%s" % ex)
            # using 'SoftException' is a workaround which ensures that the client side operation
            # fully completes, which is necessary e.g. for reverting deleted tasks
            raise SoftException(ex)

        finally:
            self.ctx.log("Reloading project from db after update")
            self.ctx.PROJECTS_UUIDS = []  # reset global UUID list of (sub)projects
            dbProjAfterUpdate = DBProject(self.ctx, self.ctx.doc.cdb_project_id, self.msp_sync_rels,
                                          self.msp_fields, self.field_hooks, isSubProject=False)

            # export project to xml file and save to vault
            export_project_to_xml_file(self.ctx, self.msp_fields, dbProjAfterUpdate, xml_fname)
            checkin_xml_file(self.ctx, self.ctx.doc, xml_fname)

        self.ctx.log("Synchronization.import_project: -stop-")


if __name__ == "__main__":
    pass
