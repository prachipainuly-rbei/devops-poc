# !/usr/bin/env powerscript
# -*- python -*- coding: UTF-8 -*-
#
# Copyright (C) 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

from __future__ import unicode_literals

import json
import os
import sys
import re
from threading import Timer
import time
import traceback

import win32com.client as win32

from cdb.objects.cdb_file import CDB_File
from cdb.plattools import killableprocess
from cdb.validationkit import operation
from cs.documents import Document

__docformat__ = "restructuredtext en"
__revision__ = "$Id: common.py 179157 2018-06-18 14:09:40Z kbu $"

OFFICE_APPLICATION = {
    "excel": {
        "com_name": "Excel.Application",
        "proc_name": "excel.exe",
        "erzeug_system": "MS-Excel",
        },
    "outlook": {
        "com_name": "Outlook.Application",
        "proc_name": "outlook.exe",
        "erzeug_system": "MS-Outlook",
        },
    "powerpoint": {
        "com_name": "PowerPoint.Application",
        "proc_name": "powerpnt.exe",
        "erzeug_system": "MS-PowerPoint",
        },
    "project": {
        "com_name": "MSProject.Application",
        "proc_name": "winproj.exe",
        "erzeug_system": "MS-Project",
        },
    "visio": {
        "com_name": "Visio.Application",
        "proc_name": "visio.exe",
        "erzeug_system": "MS-Visio",
        },
    "word": {
        "com_name": "Word.Application",
        "proc_name": "winword.exe",
        "erzeug_system": "MS-Word",
        },
    }


def watchedmethod(func):
    """
    Methods tagged with this property trigger a screenshot when ever an
    exception or a specified timeout occurs while executing the method.
    """
    def wrapper(context, *args, **kwargs):

        def save_screenshot():
            from mss import mss
            scr = mss()
            scr_dir = r"C:\buildbot_screenshots"
            scr_fname = "%s_%s_%s.png" % (re.sub("[^\w\-_\. ]", "_", os.getcwd()),
                                          os.environ.get("BUILDNUMBER", ""),
                                          "{date:%Y-%m-%d_%H-%M-%S}")
            if not os.path.exists(scr_dir):
                os.makedirs(scr_dir)
            next(scr.save(output=os.path.join(scr_dir, scr_fname)))

        def timeout_callback():
            save_screenshot()
            proc_name = OFFICE_APPLICATION[context.application_name]["proc_name"]
            killableprocess.call(['taskkill', '/f', '/t', '/im', proc_name])

        tm = None
        try:
            tm = Timer(180, timeout_callback)
            tm.start()
            return func(context, *args, **kwargs)
        except:
            if tm:
                tm.cancel()
            traceback.print_exc()
            # save_screenshot()
            raise
        finally:
            if tm:
                tm.cancel()

    return wrapper


@watchedmethod
def open_office_app(context):
    context.application = win32.gencache.EnsureDispatch(
        OFFICE_APPLICATION[context.application_name]["com_name"])
    assert context.application is not None
    if context.application_name != "outlook":
        context.application.Visible = True


@watchedmethod
def open_office_indirectly(context):
    os.startfile(OFFICE_APPLICATION[context.application_name]["proc_name"])
    return get_office_app(context)


def get_office_app(context):
    ret = None
    tries = 10
    while not ret:
        tries -= 1
        time.sleep(0.3)
        try:
            ret = win32.GetActiveObject(OFFICE_APPLICATION[context.application_name]["com_name"])
        except:
            if not tries:
                raise
    return ret


@watchedmethod
def close_office_app(context, kill_all=True):
    time.sleep(5)
    if hasattr(context, "application") and context.application:
        tries = 10
        while True:
            tries -= 1
            time.sleep(0.3)
            try:
                cdbinfo_fname = "%s.cdbinfo" % \
                    call_officelink_method(context, "IOfficeLink", "GetDocPath")[1]
                if os.path.exists(cdbinfo_fname):
                    os.remove(cdbinfo_fname)
                if context.application_name == "project":
                    context.application.Quit(0)  # PjSaveType.pjDoNotSave
                elif context.application_name == "visio":
                    if context.application.ActiveDocument:
                        context.application.ActiveDocument.Saved = True
                    context.application.Quit()
                elif context.application_name == "word":
                    context.application.Quit(0)  # wdDoNotSaveChanges
                else:
                    context.application.Quit()
                break
            except:
                if not tries:
                    if context.application_name == "project":
                        kill_all = True
                        break
                    else:
                        raise
        context.application = None
    if kill_all:
        time.sleep(3)
        proc_name = OFFICE_APPLICATION[context.application_name]["proc_name"]
        output = killableprocess.check_output(['tasklist', '/fi', 'IMAGENAME eq %s' % proc_name])
        output = output.decode(sys.getfilesystemencoding())
        if output.lower().find(proc_name.lower()) >= 0:
            killableprocess.call(['taskkill', '/f', '/t', '/im', proc_name])


@watchedmethod
def open_office_file(context, file_path):
    if context.application_name == "excel":
        context.application_document = context.application.Workbooks.Open(file_path)
    elif context.application_name == "outlook":
        context.application_document = open_office_file_indirectly(
            context, file_path, "context.application.ActiveInspector().CurrentItem")
    elif context.application_name == "powerpoint":
        context.application_document = context.application.Presentations.Open(file_path)
    elif context.application_name == "project":
        context.application.FileOpen(file_path)
        context.application_document = context.application.ActiveProject
    elif context.application_name == "visio":
        context.application_document = context.application.Documents.Open(file_path)
    elif context.application_name == "word":
        context.application_document = context.application.Documents.Open(file_path)
    assert context.application_document is not None


def open_office_file_indirectly(context, file_path, ret_com_object):
    os.startfile('"%s"' % os.path.normpath(file_path))
    ret = None
    tries = 10
    while not ret:
        tries -= 1
        time.sleep(0.3)
        try:
            ret = eval(ret_com_object)
        except:
            if not tries:
                raise
    return ret


def create_cdb_document(context):
    return operation("CDB_Create", Document,
                     user_input={"titel": "%s_test" % context.application_name},
                     preset={"cdb_obsolete": "0",
                             "z_categ1": "142",  # Allgemeines
                             "z_categ2": "153",  # Besuchsbericht
                             "z_art": "doc_standard",
                             "vorlagen_kz": "1",
                             "keywords": "my_keyword",
                             "z_bemerkung": "my_comment",
                             })


def create_cdb_file(doc, file_path, primary=True):
    fobj = CDB_File.NewFromFile(doc.cdb_object_id, file_path, primary)
    if primary:
        # emulate some talkapi behavior
        fobj.cdbf_name = "%s-%s%s" % (doc.z_nummer, doc.z_index,
                                      os.path.splitext(fobj.cdbf_name)[1])
    return fobj


@watchedmethod
def get_active_office_file(context):
    found = False
    tries = 10
    while not found:
        try:
            if not hasattr(context, "application") or not context.application:
                context.application = get_office_app(context)
            if context.application_name == "excel":
                context.application_document = context.application.ActiveWorkbook
            elif context.application_name == "powerpoint":
                context.application_document = context.application.ActivePresentation
            elif context.application_name == "project":
                context.application_document = context.application.ActiveProject
            elif context.application_name == "visio":
                context.application_document = context.application.ActiveDocument
            elif context.application_name == "word":
                context.application_document = context.application.ActiveDocument
            assert context.application_document is not None
            assert context.application_document.Name is not None
            found = True
        except:
            if not tries:
                raise
            time.sleep(1)
            tries -= 1


@watchedmethod
def modify_office_file(context):
    if context.application_name == "excel":
        context.application.Range("A1").Formula = "Test"
        assert context.application_document.Saved is False
    elif context.application_name == "powerpoint":
        context.application_document.Slides.AddSlide(
            1, context.application.ActivePresentation.Slides(1).CustomLayout)
        # TODO: assert Saved == False
    elif context.application_name == "project":
        context.application.RowInsert()
        # TODO: assert Saved == False
    elif context.application_name == "visio":
        context.application.ActiveWindow.Page.DrawLine(1, 5, 5, 5)
        # TODO: assert Saved == False
    elif context.application_name == "word":
        context.application_document.Content.InsertAfter("Test")
        # TODO: assert Saved == False


@watchedmethod
def call_officelink_method(context, interface_name, method_name, method_parameters=None, **kwargs):
    ret = context.application.COMAddIns.Item("OfficeLink.Connect").Object.CallMethodEx(
        interface_name, method_name, method_parameters or [], True, json.dumps(kwargs))
    if not ret or (ret[0] != "OK"):
        raise Exception("OfficeLink.Connect.CallMethod didn't return 'OK'%s" %
                        "" if not ret else (":\n%s" % "\n".join(ret[1:])))
    return ret
