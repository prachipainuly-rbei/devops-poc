#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbHfor behave
# All rights reserved.
# http://www.contact.de/
#

import _winreg
import datetime
import os
import platform
import sys
import time
import traceback

from cdb import fsutil, util, dberrors
from cdb.objects import org
from cdb.objects.cdb_file import CDB_File
from cdb.objects.org import CommonRoleSubject
from cdb.platform.favourite import Favourite
from cdb.platform.uberserver import Services
from cdb.plattools import killableprocess
from cdb.uberserver import usutil
from cdb.uberserver.management import Management
from cdb.validationkit import generateUser
import cdbwrapc

from cs.documents import Document
try:
    from cs.pcs import projects, timeschedule
    from cs.workflow import processes
except ImportError:
    pass

__docformat__ = "restructuredtext en"
__revision__ = "$Id: environment.py 176367 2018-04-20 16:38:59Z kbu $"


def ensure_running_service_daemon(context):
    """If a service daemon isn't already running, then a temporary one gets started"""
    svc = Management()
    if svc._check_if_its_up(usutil.UBERSERVER):
        context.temp_service_daemon = None
    else:
        svc.start()
        context.temp_service_daemon = svc
    tries = 60
    while True:
        tries -= 1
        time.sleep(1)
        context.apache = Services.get_services(
            "cdb.uberserver.services.apache.Apache", site="default")[0]
        if context.apache and context.apache.port:
            break
        elif not tries:
            raise Exception("Waiting time for Apache service has exceeded (1 min)")


def ensure_running_cdb_win(context):
    """Starts a temporary CDB/Win client"""
    # prevent some slow downs when logging in
    for fav in Favourite.Query():
        fav.autostart = 0
    # open CDB/Win
    cdbpc_cmd = os.path.join(os.environ["CADDOK_INSTALLDIR"], "cdbpc.exe")
    args = "%s --user behave_test --autologon --url http://%s:%s" % \
        (cdbpc_cmd, context.apache.hostname, context.apache.port)
    context.cdbpc = killableprocess.Popen(args)
    # preset interface settings which results in setting CADDOK_TALK_PCCLIENT
    with _winreg.CreateKey(_winreg.HKEY_CURRENT_USER, r"Software\CONTACT\OfficeLink") as key:
        try:
            context.old_cdb_win_path = _winreg.QueryValueEx(key, 'CdbWinPath')[0]
        except WindowsError:
            context.old_cdb_win_path = ""
        _winreg.SetValueEx(key, 'CdbWinPath', 0, _winreg.REG_SZ, cdbpc_cmd)


def terminate_proc(proc_name=None, proc_id=None, force=False, timeout=90, interval=15):
    """
    Repeatedly kill a process by 'name' or 'id' after checking if it is running and waiting for a
    specified 'interval'. Stop trying after specified 'timeout'.
    """
    assert proc_name or proc_id, "Neither 'proc_name' nor 'proc_id' are passed."
    killed_procs = 0
    start_time = datetime.datetime.now()
    while True:
        if sys.platform == "win32":
            if proc_name:
                query = ['/fi', 'IMAGENAME eq %s' % proc_name]
            elif proc_id:
                query = ['/fi', 'PID eq %s' % proc_id]
            output = killableprocess.check_output(
                ['tasklist',
                 '/nh',  # don't display column headers
                 '/fo', 'CSV']  # --> "MyApp.exe","4380","Console","1","395.604 K"
                + query)
            output = output.decode(sys.getfilesystemencoding())
            proc_ids = []
            for line in output.decode(sys.getfilesystemencoding()).split("\n"):
                line = line.replace("\r", "")
                if '"' in line:
                    proc_ids.append(eval('[%s]' % line)[1])
            if proc_ids:
                for id in proc_ids:
                    try:
                        args = ['taskkill', '/t', '/pid', id]
                        if force:
                            args.append('/f')
                        killableprocess.check_call(args)
                        killed_procs += 1
                    except Exception as ex:
                        print ex
            else:
                timeout = 0
        else:
            pass  # necessary ?
        if start_time >= (start_time + datetime.timedelta(0, timeout)):
            break
        time.sleep(interval)
    return killed_procs


def terminate_temp_service_daemon(context):
    if context.temp_service_daemon:
        cdbsvcd_pid = context.temp_service_daemon.cdbsvcd.pid
        try:
            context.temp_service_daemon.shutdown()
        except Exception as ex:
            print ex
            if sys.platform == "win32":
                # workaround for shutdown method not functioning properly (on windows)
                terminate_proc(proc_id=cdbsvcd_pid, timeout=120, interval=50)


def terminate_temp_cdb_win(context):
    if hasattr(context, "cdbpc") and context.cdbpc:
        # restore interface settings
        with _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, r"Software\CONTACT\OfficeLink",
                             0, _winreg.KEY_SET_VALUE) as key:
            _winreg.SetValueEx(key, 'CdbWinPath', 0, _winreg.REG_SZ, context.old_cdb_win_path)
        # clean up CDB/Win's working directory again to avoid
        # CDB/Win's warning dialog about modified files
        clean_up_workspace()
        if sys.platform == "win32":
            # -workaround for terminate method not functioning properly (on windows)
            # -also in order to prevent orphaned cdbsrv processes
            # -don't force killing it since then the regarding cdbsrv process wouldn't be terminated
            terminate_proc(proc_id=context.cdbpc.pid, timeout=90, interval=15)
            # on buildbot additionally kill
            # -cdbsrv.exe since it stays orphaned most of the times
            # -all office apps started via COM to prevent failing follow up builds
            if platform.node().lower().startswith(("con-wks03", "de-bre-bbc")):
                terminate_proc(proc_name="cdbsrv.exe", force=True, timeout=20, interval=5)
                terminate_proc(proc_name="excel.exe", force=True, timeout=20, interval=5)
                terminate_proc(proc_name="outlook.exe", force=True, timeout=20, interval=5)
                terminate_proc(proc_name="powerpnt.exe", force=True, timeout=20, interval=5)
                terminate_proc(proc_name="visio.exe", force=True, timeout=20, interval=5)
                terminate_proc(proc_name="winproj.exe", force=True, timeout=20, interval=5)
                terminate_proc(proc_name="winword.exe", force=True, timeout=20, interval=5)
        else:
            context.cdbpc.terminate()


def check_for_werfaults():
    num_werfaults = terminate_proc(proc_name="werfault.exe", timeout=20, interval=5)
    if num_werfaults:
        raise Exception("Number of killed 'WerFault' dialogs: %s "
                        "(check Windows event log)" % num_werfaults)


def clean_up_db():
    # delete all objects created via officelink
    Document.KeywordQuery(cdb_cpersno="behave_test").Delete()
    CDB_File.KeywordQuery(cdb_cpersno="behave_test").Delete()
    if "cs.pcs" in sys.modules:
        try:
            for prj in projects.Project.KeywordQuery(cdb_cpersno="behave_test"):
                prj.Tasks.Delete()
                prj.TaskRelations.Delete()
                prj.Checklists.Delete()
                timeschedule.Project2TimeSchedule.KeywordQuery(
                    cdb_project_id=prj.cdb_project_id).Delete()
                prj.Delete()
        except:
            traceback.print_exc()
    if "cs.workflow" in sys.modules:
        try:
            for proc in processes.Process.KeywordQuery(cdb_cpersno="behave_test"):
                proc.AllComponents.Delete()
                proc.AllBriefcases.Delete()
                proc.AllBriefcaseLinks.Delete()
                proc.Delete()
        except:
            traceback.print_exc()


def clean_up_workspace():
    try:
        fsutil.wipedir(os.path.expandvars("%USERPROFILE%\Documents\cdb\edit"))
    except Exception as ex:
        print ex


def before_feature(context, feature):
    # skip cs.pcs tests if cs.pcs is not installed
    if ("project" in feature.name.lower()) and ("projects" not in globals()):
        feature.mark_skipped()


def before_scenario(context, scenario):
    # clean up CDB/Win's working directory
    clean_up_workspace()


def after_scenario(context, scenario):
    clean_up_db()


def before_all(context):
    # Create a new User to use for testing and login as this one
    users = org.User.KeywordQuery(personalnummer="behave_test")
    if len(users) > 0:
        context.user = users[0]
    else:
        context.user = generateUser("behave_test")
        # Assign the user to some common roles
        context.role_assignments = []
        for role_id in ["Administrator", "Administrator: Master Data",
                        "Documentation", "cdbwf: Process Administrator"]:
            try:
                role = CommonRoleSubject.Create(
                    role_id=role_id,
                    subject_id=context.user.personalnummer,
                    subject_type="Person",
                    exception_id="",
                    cdb_classname="cdb_global_subject")
                context.role_assignments.append(role)
            except dberrors.DBConstraintViolation:
                pass  # the role apparently exists. which is fine.
    assert cdbwrapc.set_user(context.user.personalnummer), "Couldn't log in as 'behave_test'"
    # run CDB server and open CDB/Win
    ensure_running_service_daemon(context)  # require_uberserver()
    ensure_running_cdb_win(context)
    # delete orphaned objects from failed tests
    clean_up_db()
    # workaround for weird document.z_nummer/util.next behavior (on fresh DBs)
    util.set_min_counter_value("DOK_NR_SEQ", 0)


def after_all(context):
    # Delete the common role assignments
    if hasattr(context, "role_assignments"):
        for role_assignment in context.role_assignments:
            role_assignment.Delete()

    # shutdown CDB/Win and CDB server
    terminate_temp_cdb_win(context)
    terminate_temp_service_daemon(context)

    # Delete the created user
    if hasattr(context, "user"):
        context.user.Delete()

    check_for_werfaults()
