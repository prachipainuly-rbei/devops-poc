

var scriptPath = $.fileName; // TODO: alternatively try app.activeScript
var scriptFolder = (new File(scriptPath)).parent;

var baseFolder = new Folder(scriptFolder.path);
baseFolder.changePath('../../../../');


var toAbsoluteURI = function (string) {
    return baseFolder.absoluteURI + '/' + string;
};


var toFolderPath = function(string) {
    if (string.slice(-1) == '/') {
        return string;
    }
    return string + '/';
};


var getPath = function(string) {
    if (string.slice(-1) == '/') {
        return string;
    }
    return string.substring(0, string.lastIndexOf('/') + 1);
};


var getRelativePath = function(sourcePath, targetPath) {

    var sourceFolder = new Folder(getPath(sourcePath));
    var targetFolder = new Folder(getPath(targetPath));

    Folder.current = sourceFolder;

    return targetFolder.relativeURI;
};


var exportPreset = {
    target: 'cs/designsystem/resources/icons/svg'
};


var docHtmlPreset = {
    name: 'Overview (HTML)',
    assets: 'cs/designsystem/resources/icons/svg',
    template: 'cs/designsystem/resources/icons/src/contact-icon-set-doctemplate.html',
    target: 'cs/designsystem/resources/icons/contact-icon-set.html',
};

var docRstPreset = {
    name: 'Overview for Documentation Portal (RST)',
    assets: 'doc/design_system/en/src/images',
    template: 'doc/design_system/en/src/design_system_icons_assets.rst',
    target: 'doc/design_system/en/src/design_system_icons_assets.rst',
};

var iconStyles = {
    "width": "64px",
    "height": "64px",
    "display": "inline-flex",
    "justify-content": "center",
    "flex-direction": "column",
    "align-items": "center"
};

var labelStyles = {
    "font-size": "10px",
    "text-align": "center",
    "margin-top": "4px",
    "color": "gray"
};


var jsonToStyles = function(styleJson) {
    var styleString = '';
    for (var key in styleJson) {
        styleString += key + ': ' + styleJson[key] + ';';
    }
    return styleString;
}


var iconStyleString = jsonToStyles(iconStyles);
var labelStyleString = jsonToStyles(labelStyles);


var createColor = function(r, g, b) {
	var col = new RGBColor();
	col.red = r;
	col.green = g;
	col.blue = b;
	return col;
}


var colors = [];
colors.push({name: '', value: createColor(153, 153, 153), hex: '999999'});
colors.push({name: 'primary', value: createColor(0, 128, 197), hex: '0080C5'});
colors.push({name: 'info', value: createColor(252, 185, 0), hex: 'FCB900'});
colors.push({name: 'success', value: createColor(173, 201, 2), hex: 'ADC902'});
colors.push({name: 'warning', value: createColor(247, 92, 3), hex: 'F75C03'});
colors.push({name: 'danger', value: createColor(208, 0, 0), hex: 'D00000'});


var colorToSemantic = function(colorToMatch) {

    var r = null;
    var g = null;
    var b = null;
    
    if (colorToMatch.typename == 'SpotColor') {
        r = Math.floor(colorToMatch.spot.getInternalColor()[0]);
        g = Math.floor(colorToMatch.spot.getInternalColor()[1]);
        b = Math.floor(colorToMatch.spot.getInternalColor()[2]);
    }
    
    if (colorToMatch.typename == 'RGBColor') {
        r = colorToMatch.red;
        g = colorToMatch.green;
        b = colorToMatch.blue;
    }
    
    var result = '';
    for (var i=0; i<colors.length; i++) {
        col = colors[i].value;
        if (r == col.red && g == col.green && b == col.blue) {
            result = colors[i].name;
            break
        }
    }
	return result;
}

var semanticToHex = function(semantic) {
	for (var i=0; i<colors.length; i++) {
		if (colors[i].name == semantic) {
			return colors[i].hex;
		}
	}
    return colors[0].hex;
}


var docRef = app.activeDocument;

var newDoc;

var logFile;

var docLines;

getSvgOptions = function ( transparency, scaling, embedImage, embedFont, trimEdges ) {
	options = new ExportOptionsSVG();
	options.includeVariablesAndDatasets = false;
	options.includeUnusedStyles = false;
	options.preserveEditability = false;
	options.includeFileInfo = false;
	options.coordinatePrecision = 2;
	options.cssProperties = SVGCSSPropertyLocation.PRESENTATIONATTRIBUTES;
	return options;
}


saveSvg = function (doc, filePath) {
	var destFile = new File( filePath + '.svg' );
	doc.exportFile(destFile, ExportType.SVG, getSvgOptions());
}


// searches object's page items for a 16 x 16 PathItem and removes it
var removeBackground = function(object) {
	if (object.typename == 'PathItem' && 
		object.width > 15.9 &&
		object.height > 15.9) {
		object.remove();
		return;
	}
	else if (object.typename == 'CompoundPathItem') {
		var pathItems = copyArray(object.pathItems);
		while (pathItems.length > 0) {
			removeBackground(pathItems.pop());
		}
	}
	else if (object.typename == 'GroupItem' || object.typename == 'Layer') {
		var pageItems = copyArray(object.pageItems);
		while (pageItems.length > 0) {
			removeBackground(pageItems.pop());
		}
	}
	
	if (object.typename == 'Layer') {
		var layers = copyArray(object.layers);
		while (layers.length > 0) {
			removeBackground(layers.pop());
		}
	}
}


// takes all (Compound)PathItems contained in Layers and GroupItems
// and inserts them in root. Empty layers and groups are removed implicitly
var flatten = function(root, object) {
	if (object.typename == 'PathItem' || object.typename == 'CompoundPathItem') {
		object.move(root, ElementPlacement.INSIDE);
		return;
	}
	
	if (object.typename == 'GroupItem' || object.typename == 'Layer') {
		var pageItems = copyArray(object.pageItems);
		while (pageItems.length > 0) {
			flatten(root, pageItems.pop());			
		}
	}
	if (object.typename == 'Layer') {
		var layers = copyArray(object.layers);
		while (layers.length > 0) {
			flatten(root, layers.pop());
		}
	}
}


// helper function for conflict-free operations on arrays
var copyArray = function(sourceArray) {
	var targetArray = [];
	for (var i=0; i<sourceArray.length; i++) {
		targetArray.push(sourceArray[i]);
	}
	return targetArray;
}


// returns the fill color of the first contained PathItem
var getColor = function(container) {
		
	if (container.typename == 'CompoundPathItem' ||
		container.typename == 'GroupItem' ||
		container.typename == 'Layer') {
		
		for (var i=0; i<container.pathItems.length; i++) {
			return container.pathItems[i].fillColor;
		}
	}

	if (container.typename == 'GroupItem' ||
		container.typename == 'Layer') {
		for (var j=0; j<container.compoundPathItems.length; j++) {
			return getColor(container.compoundPathItems[j]);
		}
		
		for (var k=0; k<container.groupItems.length; k++) {
			return getColor(container.groupItems[k]);
		}
	}
	
	return new RGBColor();
}


// sets the fillColor for all PathItems to targetColor
var setColor = function(container, targetColor) {
	
    if (container.typename == 'CompoundPathItem' ||
		container.typename == 'GroupItem' ||
		container.typename == 'Layer') {
		for (var i=0; i<container.pathItems.length; i++) {
			container.pathItems[i].fillColor = targetColor;
		}
	}

	if (container.typename == 'GroupItem' ||
		container.typename == 'Layer') {
		for (var j=0; j<container.compoundPathItems.length; j++) {
			setColor(container.compoundPathItems[j], targetColor);
		}
		for (var k=0; k<container.groupItems.length; k++) {
			setColor(container.groupItems[k], targetColor);
		}
	}    
}


var hasTagBegin = function(string, tag) {
    return string.indexOf('<' + tag) > -1;
}


var hasTagClose = function(string, tag) {
    return string.indexOf('</' + tag) > -1;
}


var cleanSVGFile = function(fsrc, ftgt, name, semantic) {
    
    if (fsrc.indexOf('.svg') < 0) {
        fsrc = fsrc + '.svg';
    }
    fsrc = new File(fsrc);
    
    if (ftgt.indexOf('.svg') < 0) {
        ftgt = ftgt + '.svg';
    }
    ftgt = new File(ftgt);
        
    fsrc.open('r');
    var lines = [];
    var startReading = false;
    while(!fsrc.eof) {
        line = fsrc.readln();
        if (startReading && hasTagClose(line, '')) {
            break;
        }
        if (hasTagBegin(line, 'path') || 
            hasTagBegin(line, 'circle') || 
            hasTagBegin(line, 'rect') ||
            hasTagBegin(line, 'polygon')) {
            startReading = true;
        }
        if (startReading) {
            lines.push(line);
        }
    }
    fsrc.close()
    
    ftgt.open('w');
    ftgt.writeln('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">')
    ftgt.writeln('<cis-name>' + name + '</cis-name>');
    if (semantic != '') {
        ftgt.writeln('<cis-semantic>' + semantic + '</cis-semantic>');
    }
    
    for (var i=0; i<lines.length; i++) {
        var fillAttIdx = lines[i].indexOf('fill=');
        if (fillAttIdx > -1) {
            ftgt.writeln(lines[i].substr(0, fillAttIdx + 7) + semanticToHex(semantic) + lines[i].substr(fillAttIdx + 13));
        } else {
            ftgt.writeln(lines[i]);
        }
    }
    
    ftgt.writeln('</svg>');
    ftgt.close();
}


var writeDocSectionHtml = function(docFile, assetPrefix) {
    docFile.writeln('    <p id="icon-doc-export-placeholder">');
    for (var j=0; j<docLines.length; j++) {
        docFile.writeln('        <div style="' + iconStyleString + '">');
        docFile.writeln('            <img src="' + assetPrefix + docLines[j].identifier + '.svg"/>');
        docFile.writeln('            <span style="' + labelStyleString + '">' + docLines[j].name + '</span>');
        docFile.writeln('        </div>');
    }
    docFile.writeln('    </p>');
}


var writeDocSectionRst = function(docFile, assetPrefix) {
    var counter = 1;
    docFile.writeln('');
    for (var j=0; j<docLines.length; j++) {
        docFile.writeln('.. |' + counter.toString() + '_' + docLines[j].name + '| image:: ' + assetPrefix + docLines[j].identifier + '.svg');
        docFile.writeln('');
        counter++;
    }
}


var writeDocFile = function(docFileSrc, docFileTgt, assetTgt, writeDocSection, placeHolder, replaceRule) {

    // open template doc file in read mode
    var docFile = new File(docFileSrc);
    docFile.open('r');
    var lines = [];
    var lineIndexCounter = 0

    // buffer lines until <div id="icon-doc-export-placeholder">
    // buffer lines onwards from corresponding closing </div>
    // note index
    var placeholderBegin = -1;
    var placeholderClose = -1;
    while (!docFile.eof) {
        line = docFile.readln();
        if (placeholderBegin < 0 && line.indexOf(placeHolder + 'begin') > -1) {
            placeholderBegin = lineIndexCounter;
        }
        if (placeholderBegin > -1 && placeholderClose < 0 && line.indexOf(placeHolder + 'end') > -1) {
            placeholderClose = lineIndexCounter;
        }
        lines.push(line);
        lineIndexCounter++;
    }
    // close template doc file
    docFile.close();
    
    // open target doc file in write mode
    var docFile = new File(docFileTgt);
    docFile.open('w');
    // write first part of lines
    for (var i=0; i<=placeholderBegin; i++) {
        docFile.writeln(lines[i]);
    }

    // write docLines
    writeDocSection(
        docFile,
        replaceRule(toFolderPath(getRelativePath(docFileTgt, toFolderPath(assetTgt))))
    );

    // write second part of lines
    for (var i=placeholderClose; i<lines.length; i++) {
        docFile.writeln(lines[i]);
    }
    // close target doc file
    docFile.close();
}


var createIdentifier = function(prefix, item, semantic, override) {
    if (item.name[0] == '#' && override) {
        return item.name.substring(1);
    }
    return prefix + item.symbol.name + (semantic != '' ? '_' : '') + semantic;
}


// exports all items on layer
var exportLayerByItem = function(layer, path, prefix, writeAllVariants, log) {
    
    // go through the layer's symbol items
    for (var j=0; j < layer.symbolItems.length; j++ ) {
        
        var item = layer.symbolItems[j];
                
        //logFile.writeln("exporting item \"" + item.name + "\" symbol \"" + item.symbol.name + "\"");
        
        newDoc.layers.removeAll();
        
        // copy and position item
        item.duplicate(newDoc, ElementPlacement.PLACEATEND);
        newDoc.layers[0].symbolItems[0].position = [0, 16];
        
        // break link to symbol
        newDoc.symbols.removeAll();
        
        // remove all groups and sub-layers
        flatten(newDoc.layers[0], newDoc.layers[0]);
        
        // remove background path object
        removeBackground(newDoc.layers[0]);
        
        // default semantic
        var color = getColor(newDoc.layers[0]);
        var semantic = colorToSemantic(color);
        
        // write file
        if (writeAllVariants) {
            var baseFile = toFolderPath(path) + createIdentifier(prefix, item, semantic, false);
            saveSvg(newDoc, baseFile);
            for (var i=0; i<colors.length; i++) {
                cleanSVGFile(baseFile, toFolderPath(path) + createIdentifier(prefix, item, colors[i].name, false), item.symbol.name, colors[i].name);
            }
        } else {
            var file = toFolderPath(path) + createIdentifier(prefix, item, semantic, true);
            saveSvg(newDoc, file);
            cleanSVGFile(file, file, item.symbol.name, semantic);
        }
        
        docLines.push({
            identifier: createIdentifier(prefix, item, semantic, true), 
            name: item.symbol.name
        });
    }
}


var exportIcons = function () {

    // create new document
    var preset = new DocumentPreset();
    preset.units = RulerUnits.Pixels;
    preset.width = 16;
    preset.height = 16;
    newDoc = documents.addDocument(DocumentColorSpace.RGB, preset);

    // clear documentation buffer
    docLines = [];

    for (var i = 0; i < docRef.layers.length; i++) {
        if (docRef.layers[i].name == multi_exporter.iconSetSelector.selection.text) {
            try {
                //logFile.writeln("exporting layer " + docRef.layers[i].name);
                exportLayerByItem(
                    docRef.layers[i],
                    multi_exporter.dirEt.text,
                    multi_exporter.prefixText.text,
                    multi_exporter.exportAll.value);
            } catch (e) {
                alert(e);
            }
        }
    }

    // close document
    newDoc.close(SaveOptions.DONOTSAVECHANGES);
}


var copyAssets = function (sourceFolderPath, targetFolderPath) {

    // set up folders
    var sourceFolder = new Folder(sourceFolderPath);
    var targetFolder = new Folder(targetFolderPath);
    if (!targetFolder.exists) {
        targetFolder.create();
    }

    // copy files
    for (var j=0; j<docLines.length; j++) {
        var assetFile = new File(sourceFolder.absoluteURI + '/' + docLines[j].identifier + '.svg')

        if (assetFile.exists) {
            assetFile.copy(targetFolder.absoluteURI + '/' + docLines[j].identifier + '.svg');
        }
    }
}


var generateDocsHtml = function (docSettings) {

    writeDocFile(
        docSettings.docTemplate.text,
        docSettings.docTarget.text,
        docSettings.assetDir.text,
        writeDocSectionHtml,
        'icon-doc-html-',
        function (str) { return str }
    );

    if (getRelativePath(multi_exporter.dirEt.text, docSettings.assetDir.text) != '.') {
        copyAssets(
            multi_exporter.dirEt.text,
            docSettings.assetDir.text);
    }
}


var generateDocsRst = function (docSettings) {

    // write rst for securing image sources
    writeDocFile(
        docSettings.docTemplate.text,
        docSettings.docTarget.text,
        docSettings.assetDir.text,
        writeDocSectionRst,
        'icon-doc-rst-',
        function (str) { return str }
    );

    // write raw:: html for actual rendering
    writeDocFile(
        docSettings.docTemplate.text,
        docSettings.docTarget.text,
        docSettings.assetDir.text,
        writeDocSectionHtml,
        'icon-doc-html-',
        function (str) { return str.replace('images', '_images') }
    );

    if (getRelativePath(multi_exporter.dirEt.text, docSettings.assetDir.text) != '.') {
        copyAssets(
            multi_exporter.dirEt.text,
            docSettings.assetDir.text
        );
    }
}


var multi_exporter = {

    render_export_panel: function() {

        var panel = this.dlg.add('panel', undefined, 'Icon Export Settings');

        // settings
        row = panel.add('group', undefined, '');
        var prefixLabel = row.add('statictext', undefined, 'Prefix for exported files:');
        prefixLabel.size = [ 140, 20 ];
        this.prefixText = row.add('edittext', undefined, "");
        this.prefixText.size = [ 100, 20 ];
        this.prefixText.text = "cis_";

        row = panel.add('group', undefined, '');
        this.exportAll = row.add('checkbox', undefined, 'Export all semantic variants (overrides SymbolItem name)');
        this.exportAll.value = true;

        // output directory
        var row = panel.add('group', undefined, '');
        row.add('statictext', undefined, 'Assets:');
        this.dirEt = row.add('edittext', undefined, toAbsoluteURI(exportPreset.target));
        this.dirEt.size = [600, 20];
        var chooseBtn = row.add('button', undefined, 'Folder...' );
        chooseBtn.active = this.dirEt != undefined;
        chooseBtn.onClick = function() {
            multi_exporter.dirEt.text = Folder.selectDialog();
        };

        return panel;
    },

    render_doc_panel: function(preset) {

        var panel = this.dlg.add('panel', undefined, preset.name + ' Settings');

        // documentation template
        var row = panel.add('group', undefined, '');
        row.add('statictext', undefined, 'Template:');
        panel.docTemplate = row.add('edittext', undefined, toAbsoluteURI(preset.template));
        panel.docTemplate.size = [600, 20];
        var chooseBtn = row.add('button', undefined, 'File...');
        chooseBtn.active = panel.docTemplate != undefined;
        chooseBtn.onClick = function () {
            panel.docTemplate.text = File.openDialog();
        };

        // documentation target
        var row = panel.add('group', undefined, '');
        row.add('statictext', undefined, 'Target:');
        panel.docTarget = row.add('edittext', undefined, toAbsoluteURI(preset.target));
        panel.docTarget.size = [600, 20];
        var chooseBtn = row.add('button', undefined, 'File...');
        chooseBtn.active = panel.docTarget != undefined;
        chooseBtn.onClick = function () {
            panel.docTarget.text = File.openDialog();
        };

        // asset directory
        var row = panel.add('group', undefined, '');
        row.add('statictext', undefined, 'Assets:');
        panel.assetDir = row.add('edittext', undefined, toAbsoluteURI(preset.assets));
        panel.assetDir.size = [600, 20];
        var chooseBtn = row.add('button', undefined, 'Folder...');
        chooseBtn.onClick = function () {
            panel.assetDir.text = Folder.selectDialog();
        };

        return panel;
    },

    // dialog display
    show_dialog: function() {

        this.dlg = new Window('dialog', 'Multi Exporter');
        
        // icon sets
        var iconSets = [];
        var iconSetCounter = 0;
        var iconSetDefault = 0;
        row = this.dlg.add('group', undefined, '');
        for (var i=0; i<docRef.layers.length; i++)
        {
            var layer = docRef.layers[i];
            if (layer.name.search('cs.') > -1)
            {
                iconSets.push(layer.name);
                if (layer.name == 'cs.designsystem') {
                    iconSetDefault = iconSetCounter;
                }
                iconSetCounter++;
            }
        }
        row.add('statictext', undefined, 'Icon Set:');
        this.iconSetSelector = row.add("dropdownlist", undefined, iconSets);
        this.iconSetSelector.items[iconSetDefault].selected = true;

        // icon export
        this.iconExportPanel = this.render_export_panel();

        // doc: html
        row = this.dlg.add('group', undefined, '');
        this.docHtmlCheckbox = row.add('checkbox', undefined, 'Generate ' + docHtmlPreset.name);
        this.docHtmlCheckbox.value = true;
        this.docHtmlPanel = this.render_doc_panel(docHtmlPreset);
        this.docHtmlCheckbox.onClick = function() {
            multi_exporter.docHtmlPanel.enabled = multi_exporter.docHtmlCheckbox.value;
        };

        // doc: rst
        row = this.dlg.add('group', undefined, '');
        this.docRstCheckbox = row.add('checkbox', undefined, 'Generate ' + docRstPreset.name);
        this.docRstCheckbox.value = true;
        this.docRstPanel = this.render_doc_panel(docRstPreset);
        this.docRstCheckbox.onClick = function() {
            multi_exporter.docRstPanel.enabled = multi_exporter.docRstCheckbox.value;
        };

        // buttons
        row = this.dlg.add('group', undefined, ''); 
        row.orientation = 'row'		
        var okBtn = row.add('button', undefined, 'Execute', {name:'ok'});
        okBtn.onClick = function() {
            
            // create log file
            //logFile = new File(multi_exporter.dirEt.text + "/log.txt");
            //logFile.open('w');

            exportIcons();

            if (multi_exporter.docHtmlCheckbox.value) {
                generateDocsHtml(multi_exporter.docHtmlPanel);
            }

            if (multi_exporter.docRstCheckbox.value) {
                generateDocsRst(multi_exporter.docRstPanel);
            }

            // close log file
            //logFile.close();
        };
        
        this.dlg.show();
    }
};


multi_exporter.show_dialog();

// TODO: button reset to preset
// TODO: revise variable names
// TODO: internal variable for switching logging on/off
// TODO: true sync, obsolete elements are deleted
// TODO: make icon export optional (further decouple docs and export)
// TODO: use class instead of inline styles
// TODO: make doc overview sortable (by name, semantic, ..)
// TODO: write doc assets as svg
// TODO: make icon size configurable in docs
// TODO: test doc generation in MacOS
// TODO: clean up script configuration gui
// TODO: deal with different newlines
// TODO: add progress indication
// TODO: generate react storyboard files
// TODO: generate icondefs
// TODO: batch export of multiple sets, with individual directories
// TODO: group items with same symbol for more efficient export (but: how to get instance colors?)
// TODO: add ability to export manually defined subset (e.g. via selection, visibility, coordinates ...)
// TODO: option to colorize with specific semantic color: default/all/primary/success/info/danger/warning/unbranded
// TODO: add png export
// TODO: set semantic color names and values via GUI
// TODO: write log with errors/failures (e.g. could not find semantic) for crash tracking
// TODO: add info text in the panel that relates limitations of script
// TODO: alert when assigned color is not in palette
// TODO: fix different newlines between operating systems (Mac/Win) resulting in unneccesary changes 
