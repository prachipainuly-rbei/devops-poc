#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
# $Id: workday.py 127742 2015-07-10 15:02:33Z heg $
#
# Copyright (C) 1990 - 2009 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
# File:     workday.py
# Author:   ch
# Creation: 05.03.09

"""
Workdays counter
"""

import math
import datetime
from cdb import holiday
from cdb import util
from cs import calendar as cdbcalendar


# Soll Kalenderlogik (Property: fxcl) verwendet werden?
def _fxcl():
    fxcl = util.get_prop("fxcl")
    if fxcl and fxcl.lower() == "true":
        return True
    return False

WORKDAYS = (
    0,  # Monday
    1,  # Tuesday
    2,  # Wednesday
    3,  # Thursday
    4,  # Friday
)

HOLIDAYS = {
    "de": holiday.GermanHoliday,
}

HOURS = 8.0


def workdays(begin_date, end_date, country=None, region=None):
    """
    returns the date of all workdays (including start and end)
    """

    diff = end_date - begin_date
    the_workdays = []

    for i in range(diff.days + 1):
        actual_day = begin_date + datetime.timedelta(days=i)
        if actual_day.weekday() in WORKDAYS:
            the_workdays.append(actual_day)

    # holidays?
    holidays = []
    hd = HOLIDAYS.get(country, None)
    if hd:
        holidays = hd(begin_date, end_date, region).get()

    the_workdays = filter(lambda x: x not in holidays, the_workdays)

    return the_workdays


def personal_workdays(persno, start_date=None, end_date=None):
    if _fxcl() and persno:
        cal = cdbcalendar.getPersonalWorkdays(list_of_persno=[persno],
                                              start_date=start_date,
                                              end_date=end_date)
        if not cal.has_key(persno):
            return []
        return map(lambda x: x[0], cal[persno])
    return workdays(start_date, end_date)


def is_workday(myDate, country=None, region=None):
    if myDate.weekday() not in WORKDAYS:
        return False
    holidays = []
    hd = HOLIDAYS.get(country, None)
    if hd:
        holidays = hd(myDate, myDate, region).get()
    return myDate not in holidays


def days_to_hours(myDays):
    return int(myDays * HOURS)


def hours_to_days(myHours):
    return int(math.ceil(myHours / HOURS))


def next_day(myDate, span=0):
    return myDate + datetime.timedelta(days=span)


def next_workday(myDate, span=0, country=None, region=None):
    total_workdays = 0
    actual_day = myDate
    if span > 0:
        if is_workday(actual_day, country, region):
            total_workdays += 1
        while span > total_workdays:
            actual_day = actual_day + datetime.timedelta(days=1)
            if is_workday(actual_day, country, region):
                total_workdays += 1
    elif span < 0:
        if is_workday(actual_day, country, region):
            total_workdays -= 1
        while span < total_workdays:
            actual_day = actual_day - datetime.timedelta(days=1)
            if is_workday(actual_day, country, region):
                total_workdays -= 1
    return actual_day


def next_personal_workday(persno, myDate, span=0):
    if not _fxcl() or not persno:
        return next_workday(myDate=myDate, span=span)
    if not span:
        return myDate
    days = personal_workdays(persno)
    tolerance = span / int(math.fabs(span))
    i = get_index_of_day(myDate, days, tolerance)
    try:
        return days[i + span - tolerance]
    except Exception:
        return None


def get_index_of_day(myDay, all_days, next=0):
    """
    The function searches in `all_days` for `myDay`.
    `all_days` has to be sorted ascending and has to
    provide an index operator.

    The function returns the index of `myDay` in the list.
    If `next` is ``0`` and `myDay` is not part of the list,
    the function returns ``-1``.

    If `myDay` is not part of `all_days` and `next` is ``1``
    the function returns the index of the first day of `all_days`
    with a date after `myDay`. If there is no such day the
    function returns the index of the last day in `all_days`.

    If `myDay` is not part of `all_days` and `next` is ``-1``
    the function returns the index of the first day of `all_days`
    with a date before `myDay`. If there is no such day the
    function returns ``0``.
    """
    import bisect
    if not all_days:
        return -1

    if next >= 0:
        result = bisect.bisect_left(all_days, myDay)
        if result == len(all_days):
            result -= 1
        if next > 0 or all_days[result] == myDay:
            return result
        else:
            return -1
    else:
        result = bisect.bisect_right(all_days, myDay)
        if result:
            result -= 1
        return result


def getDays(start_date, end_date):
    # Liste mit allen Tagen erstellen
    return map(lambda x: start_date + datetime.timedelta(days=x),
               range((end_date - start_date).days + 1))
