/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Provider.jsx 181644 2018-08-03 12:02:09Z ssa $"
 */

import React from 'react';
import {PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import Immutable from 'immutable';
import {Table} from 'cs-web-components-base';

import {setSingleSelectionMode, selectRow} from './actions';
import {formatStr} from '../../i18n';
import Selector from './Selector';

const SELECTORID = 'cs-web-components-base-table-selector-column';

const {setSelectedRows, setOrderedColumns,
    setColumns, setRowClassName
} = Table.actions;

const {connect} = Table;
const toggleTreeView = Table.treeview.actions.toggleTreeView;

export default function(WrappedTable) {
    class Select extends React.Component {
        constructor(props) {
            super(props);
            this.onSelect = this.onSelect.bind(this);
            this.markRows = this.markRows.bind(this);
            this.selectorColumn = Immutable.Map({
                id: SELECTORID,
                label: '',
                width: '1em',
                contentRenderer: Selector,
                tooltip: formatStr('tabcatalog_select_header')  // TODO: i18n own label/tooltip
            });

        }

        componentWillMount() {
            if (this.props.initSelected !== undefined) {
                this.selectRows(this.props.initSelected, this.props);
            }
            this.props.setSingleSelectionMode(this.props.singleSelection);
            this.createSelector(this.props);
        }

        createSelector(props) {
            const {
                setColumns, setOrderedColumns,
                columns, orderedColumns, withSelector
            } = props;
            if (!withSelector) {
                return;
            }
            const added = columns.findIndex(
                col => col.get('id') === SELECTORID);
            if (added < 0) {
                const newColumns = columns.push(this.selectorColumn);
                setColumns(newColumns);
                setOrderedColumns(
                    Immutable.OrderedSet([SELECTORID]).union(orderedColumns));
            } else if (orderedColumns.first() !== SELECTORID) {
                setOrderedColumns(
                    Immutable.OrderedSet([SELECTORID]).union(orderedColumns));
            }
        }

        getValidSelection(selected, props) {
            const {rows} = props;
            return selected.filter(
                i => rows.findIndex(row => row.get('id') === i) > -1);
        }

        selectRows(selected, props) {
            const {setSelectedRows} = props;
            const valid = this.getValidSelection(selected, props);
            // only select valid rows or empty selection
            if (setSelectedRows && (selected.count() === 0 || valid.count() > 0)) {
                setSelectedRows(valid);
            }
        }

        // TODO: shouldComponentUpdate
        componentWillReceiveProps(nextProps) {
            if (nextProps.singleSelection !== this.props.singleSelection) {
                nextProps.setSingleSelectionMode(nextProps.singleSelection);
            }
            if (nextProps.columns !== this.props.columns ||
                nextProps.orderedColumns !== this.props.orderedColumns) {
                this.createSelector(nextProps);
                if (nextProps.rows.size === 0) {
                    nextProps.toggleTreeView();
                }
                else if (nextProps.rows.every(v => v.get("columns").get(4) === "Status")) {
                    nextProps.toggleTreeView();
                }
            }
            if (!Immutable.is(nextProps.initSelected, this.props.initSelected)) {
                this.selectRows(nextProps.initSelected || Immutable.OrderedSet(), nextProps);
            } else if (nextProps.selectedRows !== this.props.selectedRows) {
                this.markRows(nextProps);
                if (nextProps.onSelectRows) {
                    nextProps.onSelectRows(nextProps.selectedRows);
                }
            } else if (nextProps.rows !== this.props.rows) {
                this.markRows(nextProps, true);
                if (nextProps.rows.size === 0) {
                    toggleTreeView();
                }
            }
        }

        markRows(props, checkSelection = false) {
            const rowIDs = props.rows.map(row => row.get('id'));
            const selected = props.selectedRows === undefined ?
                Immutable.OrderedSet() :
                props.selectedRows.intersect(rowIDs);

            // If rows have changed we remove selection for missing rows
            if (checkSelection && !Immutable.is(selected, props.selectedRows)) {
                props.setSelectedRows(selected);
            } else {
                props.setRowClassName('selected', selected);
            }
        }

        onSelect(row) {
            const {selectRow} = this.props;
            const rowdetail = row.split("\\at");
            if (rowdetail[7] === " nil " || rowdetail[7] === "Status") {
                return;
            }
            if (this.getValidSelection(Immutable.OrderedSet([row]), this.props).count() > 0) {
                selectRow(row, true);
            }
        }

        render() {
            const {...props} = this.props;
            delete props.singleSelection;
            delete props.withSelector;
            delete props.initSelected;
            delete props.setSingleSelectionMode;
            delete props.setColumns;
            delete props.setOrderedColumns;
            delete props.setSelectedRows;
            delete props.selectRow;
            delete props.setRowClassName;
            delete props.columns;
            delete props.orderedColumns;
            delete props.selectedRows;
            delete props.onSelectRows;
            delete props.toggleTreeView;
            return (
                <WrappedTable
                    {...props}
                    onSelectRow={this.onSelect}/>
            );
        }
    }

    Select.propTypes = {
        singleSelection: PropTypes.bool,
        withSelector: PropTypes.bool,
        initSelected: ImmutablePropTypes.orderedSet,
        setSingleSelectionMode: PropTypes.func,
        setColumns: PropTypes.func,
        setOrderedColumns: PropTypes.func,
        setSelectedRows: PropTypes.func,
        selectRow: PropTypes.func,
        setRowClassName: PropTypes.func,
        rows: ImmutablePropTypes.list,
        columns: ImmutablePropTypes.list,
        orderedColumns: ImmutablePropTypes.orderedSet,
        selectedRows: ImmutablePropTypes.orderedSet,
        onSelectRows: PropTypes.func,
        toggleTreeView: PropTypes.func
    };

    Select.defaultProps = {
        singleSelection: true,
        withSelector: false
    };

    const mapStateToProps = (state) => ({
        selectedRows: state.selectedRows,
        columns: state.columns,
        orderedColumns: state.orderedColumns
    });

    return connect(mapStateToProps,
        {setSelectedRows, setSingleSelectionMode, selectRow,
            setOrderedColumns, setColumns, setRowClassName, toggleTreeView})(Select);
}
