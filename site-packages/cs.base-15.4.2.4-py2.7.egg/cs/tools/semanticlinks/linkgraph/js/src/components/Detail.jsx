/*
 * Copyright (C) 2017 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: Detail.jsx 174201 2018-03-08 09:01:14Z vov $"
 */

import React, {Component} from 'react';
import {PropTypes, ImmutablePropTypes, connect} from 'cs-web-components-externals';
import {getJSON, postJSON, fetchUserSetting, storeUserSetting, resetUserSetting,
        ContentBlock, Button, addNotification, Dialog, Icon, ButtonToolbar,
        Organizer, ContentOperationToolbar, isCEDesktop} from 'cs-web-components-base';
import Immutable from 'immutable';
import {prefixNS, getIcon, getAppSetup, timeToDisplayFormat} from '../helpers';
import {formatStr} from '../i18n';


const USER_SETTING_ID = prefixNS('Attributes');

function userSettingKey({contextObject, dialog}) {
    return `${contextObject.get('system:classname')}.${dialog}`;
}

const sortItems = (items) => items.sortBy(item => item.get('label'));

/**
 * This component displays the base data of a given contextObject in a
 * list. It retrieves its data by executing a CDB_ShowObject operation
 * for the contextObject so this operation needs to be active in your
 * Web-UI configuration.
 *
 * The component retrieves the operation information from the backend,
 * and requires the operation link to be retrieved via
 * ``app_setup['links', 'detail_view', 'info_form_url']``.
 *
 * React Properties
 * ----------------
 *
 * - contextObject: The object whose base data should be displayed
 * - dialog: An alternative dialog configuration, from which to retrieve
 *   the base data configuration to be displayed
 * - onStartEditing: An optional callback which is invoked if the user
 *   presses the widgets Edit button.
 * - editingLabel: The label to be displayed as the buttons tooltip.
 */
class Attributes extends Component {

    constructor(props) {
        super(props);
        const visibleAttributes = Immutable.List();
        const availableAttributes = Immutable.List();
        const allAttributes = Immutable.List();
        this.state = {
            attributes: this.createItemList(allAttributes, visibleAttributes),
            operationState: undefined,
            values: undefined,
            visibleAttributes,
            availableAttributes,
            allAttributes,
            showAttributeSettings: false
        };
        this.openSettings = this.toggleSettings.bind(this, true);
        this.closeSettings = this.toggleSettings.bind(this, false);
        this.cancelChanges = this.cancelChanges.bind(this);
        this.saveAttributes = this.saveAttributes.bind(this);
        this.resetToDefault = this.resetToDefault.bind(this);
        this.transferAttribute = this.transferAttribute.bind(this);
        this.settingButtons = [
            {
                text: formatStr('save'),
                isPrimary: true,
                callback: this.saveAttributes
            },
            {
                text: formatStr('attributes_reset'),
                isPrimary: false,
                callback: this.resetToDefault
            }
        ];
    }

    componentDidMount() {
        const {contextObject, dialog, formLink} = this.props;

        // Update userSettingKey
        this.userSettingKey = userSettingKey(this.props);

        // Fetch dialog definition
        const request_params = {};
        request_params['object_navigation_id'] = contextObject.get('system:navigation_id');
        if (dialog) {
            request_params['dialog_name'] = dialog;
        }
        if (formLink === undefined) {
            this.props.addNotification(
                formLink,
                formatStr('config_error'),
                formatStr('attr_mask_loading_failed'),
                'danger',
                2,
                null,
                5000);
        }
        getJSON(
            formLink, request_params
        ).then(
            result => {
                this.initializeAttributesFromResult(result);
                this.props.fetchUserSetting(USER_SETTING_ID, this.userSettingKey);
            },
            () => {
                this.props.addNotification(
                    formLink,
                    formatStr('config_error'),
                    formatStr('attr_mask_loading_failed'),
                    'danger',
                    2,
                    null,
                    5000);
            }
        );
    }

    componentWillReceiveProps(nextProps) {
        if (this.props.contextObject !== nextProps.contextObject) {
            const {contextObject, dialog, formLink} = nextProps;

            // Update userSettingKey
            this.userSettingKey = userSettingKey(nextProps);

            // Fetch dialog definition
            const request_params = {};
            request_params['object_navigation_id'] = contextObject.get('system:navigation_id');
            if (dialog) {
                request_params['dialog_name'] = dialog;
            }
            if (formLink === undefined) {
                this.props.addNotification(
                    formLink,
                    formatStr('config_error'),
                    formatStr('attr_mask_loading_failed'),
                    'danger',
                    2,
                    null,
                    5000);
            }
            getJSON(
                formLink, request_params
            ).then(
                result => {
                    this.initializeAttributesFromResult(result);
                    nextProps.fetchUserSetting(USER_SETTING_ID, this.userSettingKey);
                },
                () => {
                    this.props.addNotification(
                        formLink,
                        formatStr('config_error'),
                        formatStr('attr_mask_loading_failed'),
                        'danger',
                        2,
                        null,
                        5000);
                }
            );
        }
    }

    toggleSettings(flag) {
        this.setState({
            showAttributeSettings: flag
        });
    }

    saveAttributes() {
        this.props.storeUserSetting(
            USER_SETTING_ID, this.userSettingKey,
            this.state.visibleAttributes.map(field => field.get('id'))
        );
        this.closeSettings();
    }

    resetToDefault() {
        this.props.resetUserSetting(USER_SETTING_ID, this.userSettingKey);
    }

    cancelChanges() {
        this.initializeAttributes(this.state.allAttributes, this.props.userSetting);
        this.closeSettings();
    }

    initializeAttributesFromResult(result) {
        // Merge registers to easily handle all fields in mask
        const mergedFieldArray = [];
        result['registers'].forEach(register => {
            register['fields'].forEach(field => {
                mergedFieldArray.push(field);
            });
        });

        // Create attribute lists
        this.initializeAttributes(
            Immutable.fromJS(mergedFieldArray.map(
                field => ({
                    id: field['attribute'],
                    label: field['attribute_label'],
                    value: field['fieldtype'] === "calendar" ?
                            timeToDisplayFormat(result['values'][field['attribute']]) :
                            field['config']['display_mapping'] ?
                            field['config']['display_mapping']['mappings'][0][1] :
                            result['values'][field['attribute']],
                    visible: !field['hidden'],
                    link: field['config']['link_target_url']
                })
            )),
            this.props.userSetting
        );
        this.setState({
            values: result['values'],
            operationState: result['operation_state']
        });
    }

    initializeAttributes(allAttributes, userSetting) {
        let availableAttributes = undefined;
        let visibleAttributes = undefined;
        if (userSetting) {
            const attributeMap = Immutable.Map(
                allAttributes.map(attr => [attr.get('id'), attr]).toJS()
            );
            availableAttributes = allAttributes.filter(
                attr => !userSetting.find(id => id === attr.get('id'))
            );
            visibleAttributes = Immutable.fromJS(
                userSetting.map(id => attributeMap.get(id))
            );
        } else {
            availableAttributes = sortItems(
                allAttributes.filter(field => !field.get('visible'))
            );
            visibleAttributes = allAttributes.filter(field => field.get('visible'));
        }

        this.setState({
            allAttributes, visibleAttributes, availableAttributes,
            attributes: this.createItemList(availableAttributes, visibleAttributes)
        });
    }

    createItemList(availableAttributes, visibleAttributes) {
        return Immutable.List([
            Immutable.Map({
                label: formatStr('attributes_available_title'),
                items: availableAttributes,
                unsortable: true
            }),
            Immutable.Map({
                label: formatStr('attributes_visible_title'),
                items: visibleAttributes
            })
        ]);
    }

    transferAttribute(changedLists) {
        const sorted = sortItems(changedLists.get(0).get('items'));
        this.setState({
            availableAttributes: sorted,
            visibleAttributes: changedLists.get(1).get('items'),
            attributes: changedLists.set(
                0, changedLists.get(0).set('items', sorted)
            )
        });
    }

    navigateLink(url) {
        postJSON(url, {values: this.state.values, operation_state: this.state.operationState})
            .then(result => {
                if (result.ui_link) {
                    window.open(result.ui_link);
                } else if (result.error_message) {
                    // We want a feedback - error might be something like
                    // No object assigned
                    this.props.addNotification(
                        url,
                        formatStr('form_name'),
                        result.error_message,
                        'danger',
                        2,
                        null,
                        5000);
                }
            });
    }

    renderAttributes() {
        return this.state.visibleAttributes.map(attr => {
            return ([
                <dt className="text-muted" key={attr.get('id')}>
                    {attr.get('label')}
                </dt>,
                <dd key={`${attr.get('id')}#value`}>
                    {attr.get('value')}
                    {attr.get('link') ?
                     (
                         <Icon src={getIcon('csweb_link')}
                               className={prefixNS('attribute-list-button')}
                               title={formatStr('attributes_panel_link')}
                               onClick={() => this.navigateLink(attr.get('link'))}
                               size="sm"/>
                     )
                     : undefined}
                </dd>
            ]);
        });
    }

    render() {
        const {onStartEditing, editingLabel, contextObject} = this.props;
        return (
            <div className={prefixNS('attributes')}>
                <ContentBlock collapsible={true}
                              expanded={true}
                              title={formatStr('attributes_panel_title')}>
                    <ContentBlock.Header>
                        <ButtonToolbar>
                            {onStartEditing ?
                             <Button.IconButton
                                 onClick={onStartEditing}
                                 disabled={onStartEditing === undefined}
                                 title={editingLabel}
                                 buttonStyle="success"
                                 iconName="csweb_edit"/> : null}
                             <Button.IconButton
                             onClick={this.openSettings}
                             title={formatStr('attributes_dialog_title')}
                             buttonStyle="info"
                             iconName="csweb_settings"/>
                             {isCEDesktop() ?
                             <Button.IconButton
                               onClick={() => window.open(contextObject.get('system:ui_link'))}
                               title={formatStr('attributes_panel_link')}
                               buttonStyle="info"
                               iconName="csweb_link"/> :
                             <ContentOperationToolbar
                             contextObject={contextObject}/>}
                        </ButtonToolbar>
                    </ContentBlock.Header>
                    <ContentBlock.Body>
                        <div className={prefixNS('attribute-list')}>
                            <div className={prefixNS('attribute-block')}>
                                <dl className="dl-horizontal">
                                    {this.renderAttributes()}
                                </dl>
                            </div>
                        </div>
                    </ContentBlock.Body>
                </ContentBlock>
                <Dialog.Dialog title={formatStr('attributes_dialog_title')}
                               buttons={[<Dialog.Buttons.Save
                                             key="save"
                                             onClick={this.saveAttributes}/>,
                                         <Dialog.Buttons.Reset
                                             key="reset"
                                             onClick={this.resetToDefault}/>,
                                         <Dialog.Buttons.Cancel
                                             key="cancel"
                                             onClick={this.cancelChanges}/>]}
                               size={Dialog.Dialog.SIZE_SMALL}
                               show={this.state.showAttributeSettings}>
                    <p>{formatStr('attributes_dialog_text1')}</p>
                    <p>{formatStr('attributes_dialog_text2')}</p>
                    <Organizer itemLists={this.state.attributes}
                               onItemListsChange={this.transferAttribute}
                               placeholder={formatStr("attributes_no_items")} />
                </Dialog.Dialog>
            </div>
        );
    }
}

Attributes.propTypes = {
    contextObject: PropTypes.object.isRequired,
    dialog: PropTypes.string,
    onStartEditing: PropTypes.func,
    editingLabel: PropTypes.string,
    userSetting: ImmutablePropTypes.list,
    fetchUserSetting: PropTypes.func,
    storeUserSetting: PropTypes.func,
    resetUserSetting: PropTypes.func,
    addNotification: PropTypes.func,
    formLink: PropTypes.string
};

Attributes.defaultProps = {
    formLink: getAppSetup().getIn(["links", "detail_view", "info_form_url"])
};

function mapStateToProps(state, ownProps) {
    const userSettingRaw = state.userSettings.getIn([USER_SETTING_ID, userSettingKey(ownProps)]);
    const userSetting = userSettingRaw === undefined || userSettingRaw === '' ?
                        undefined :
                        userSettingRaw;
    return {userSetting: userSetting};
}

export default connect(
    mapStateToProps,
    {
        storeUserSetting,
        fetchUserSetting,
        resetUserSetting,
        addNotification
    }
)(Attributes);
