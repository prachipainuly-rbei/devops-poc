import React from 'react';
import Immutable from 'immutable';
import {FormGroup, ControlLabel} from 'react-bootstrap';
import {Component} from 'react';
import {PropTypes, connect, ImmutablePropTypes, classNames} from 'cs-web-components-externals';
import {fetchObject, createObject, fetchCollection, FormControl, ObjectWidgets,
  addNotification, removeNotificationNow, isCEDesktop, parseQuery} from 'cs-web-components-base';
import {formatStr} from '../i18n.js';
import {prefixNS} from '../helpers';

export class CreateLink extends Component {
    constructor(props) {
        super(props);
        this.state = {
            obj_link: '',
            obj_desc: '',
            obj_classname: '',
            subj_classname: '',
            link_desc: '',
            subj_desc: '',
            classes: [],
            formData: Immutable.fromJS({
                "subject_object_id": "",
                "link_type_object_id": "",
                "object_object_id": ""
            }),
            multi: false,
            subjects: []
        };
        this.fields =
        {
            "subject_object_id": formatStr("subject"),
            "object_object_id": formatStr("object"),
            "link_type_object_id": formatStr("verb")
        };
        this.onSelectItem = this.onSelectItem.bind(this);
        this.onCatalogChange = this.onCatalogChange.bind(this);
        this.onCatalogValueChange = this.onCatalogValueChange.bind(this);
        this.getObject = this.getObject.bind(this);
        this.submitForm = this.submitForm.bind(this);
        this.closeForm = this.closeForm.bind(this);
        this.buttons = this.buttons.bind(this);
        this.mandatory_fields_not_filled = this.mandatory_fields_not_filled.bind(this);
    }

    buttons() {
        return Immutable.fromJS([
            {
                onClick: this.submitForm,
                button_type: 0,
                label: formatStr("save")},
            {
                onClick: this.closeForm,
                button_type: 1,
                label: formatStr("cancel")
            }]);
    }

    componentDidMount() {
        const {fetchCollection, location, contextObject} = this.props;
        if (!contextObject) {
            const collection_url = "/api/v1/collection/" + parseQuery(location).restname;
            const cdb_object_ids = parseQuery(location).cdb_object_ids;
            if (cdb_object_ids) {
                const filter = cdb_object_ids.split(";").map(obj_id => {
                    return "cdb_object_id eq '" + obj_id + "'";
                }).join(" or ");
                fetchCollection(collection_url, {"$filter": filter}).then((data) => {
                    const subject_obj = data.objects[0];
                    fetchCollection("/api/v1/collection/semantic_link_type").then((data2) => {
                        const pclasses = [];
                        for (const key of Object.keys(data2.objects)) {
                            const pclass = data2.objects[key];
                            if (pclasses.indexOf(pclass.object_object_classname) === -1 &&
                             subject_obj["system:classname"] === pclass.subject_object_classname) {
                                pclasses.push(pclass.object_object_classname);
                            }
                        }
                        const subj_descs = [];
                        const subjects = [];
                        data.objects.forEach(subject_obj => {
                            subj_descs.push(subject_obj["system:description"]);
                            subjects.push(subject_obj["cdb_object_id"]);
                        });
                        this.setState({subj_desc: subj_descs.join(" / "),
                                       subj_classname: subject_obj["system:classname"],
                                       formData: this.state.formData.set("subject_object_id",
                                        subject_obj.cdb_object_id),
                                       classes: pclasses,
                                       multi: true,
                                       subjects: subjects});
                    });
                });
            }
            else {
                fetchCollection(collection_url,
                 {"$filter": "cdb_object_id eq '" + parseQuery(location).cdb_object_id + "'"})
                 .then((data) => {
                     const subject_obj = data.objects[0];
                     fetchCollection("/api/v1/collection/semantic_link_type").then((data2) => {
                         const pclasses = [];
                         for (const key of Object.keys(data2.objects)) {
                             const pclass = data2.objects[key];
                             if (pclasses.indexOf(pclass.object_object_classname) === -1 &&
                              subject_obj["system:classname"] === pclass.subject_object_classname) {
                                 pclasses.push(pclass.object_object_classname);
                             }
                         }
                         this.setState({subj_desc: subject_obj["system:description"],
                                        subj_classname: subject_obj["system:classname"],
                                        formData: this.state.formData.set("subject_object_id",
                                        subject_obj.cdb_object_id),
                                        classes: pclasses});
                     });
                 });
            }
        }
        else {
            fetchCollection("/api/v1/collection/semantic_link_type").then((data2) => {
                const pclasses = [];
                for (const key of Object.keys(data2.objects)) {
                    const pclass = data2.objects[key];
                    if (pclasses.indexOf(pclass.object_object_classname) === -1 &&
                     contextObject.get("system:classname") === pclass.subject_object_classname) {
                        pclasses.push(pclass.object_object_classname);
                    }
                }
                this.setState({subj_desc: contextObject.get("system:description"),
                               subj_classname: contextObject.get("system:classname"),
                               formData: this.state.formData.set("subject_object_id",
                               contextObject.get('cdb_object_id')),
                               classes: pclasses});
            });
        }

    }

    mandatory_fields_not_filled() {
        const emptyField = [];
        this.state.formData.entrySeq().forEach(x => {
            if (x[1] === "") {
                emptyField.push(this.fields[x[0]]);
            }
        });
        if (emptyField.length > 0) {
            const missing_fields = (<p>{emptyField.map((field) => (
                <div key={field}>{field}</div>
            ))}</p>);
            const msg = (
                <div>
                    <p>{formatStr("mandatory_fields_not_filled")}</p>
                    {missing_fields}
                </div>
            );
            this.props.addNotification(
                null,
                formatStr("mandatory_fields"),
                msg,
                'danger',
                2,
                null,
                5000);
            return false;
        }
        return true;
    }

    submitForm() {
        const mandatory_fields_filled = this.mandatory_fields_not_filled();
        if (mandatory_fields_filled) {
            if (this.state.multi) {
                this.state.subjects.forEach(subject_id => {
                    const formData = this.state.formData.set("subject_object_id", subject_id);
                    this.props.createObject("/api/v1/collection/semantic_link", formData.toJS())
                    .then(() => {this.closeForm()})
                    .catch((error) => {
                        error.response.text().then((text) => {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(text, "text/html");
                            const txt = doc.querySelectorAll('div.error-text')[0].innerText;
                            this.props.addNotification(
                              null,
                              formatStr("semantic_link_not_created"),
                               txt,
                              'danger',
                              2,
                              null,
                              5000);
                        });
                    });
                });
            }
            else {
                this.props.createObject("/api/v1/collection/semantic_link",
                                        this.state.formData.toJS())
                .then(() => {this.closeForm()})
                .catch((error) => {
                    error.response.text().then((text) => {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, "text/html");
                        const txt = doc.querySelectorAll('div.error-text')[0].innerText;
                        this.props.addNotification(
                          null,
                          formatStr("semantic_link_not_created"),
                           txt,
                          'danger',
                          2,
                          null,
                          5000);
                    });
                });
            }
        }
    }

    closeForm() {
        if (this.props.onClose) {
            this.props.onClose();
        }
        else {
            if (isCEDesktop()) {
                window.external.cdbEFClose();
            }
            else {
                window.close();
            }
        }
    }


    getObject(object_link) {
        const obj = this.props.getObjectById(object_link);
        if (obj === undefined) {
            this.props.fetchObject(object_link).then((data) => {
                this.setState({obj_desc: data["system:description"],
                               obj_classname: data["system:classname"],
                               formData: this.state.formData.set("object_object_id",
                                                                 data.cdb_object_id)});
            });
        }
        else {
            this.setState({obj_desc: obj.get("system:description"),
                           obj_classname: obj.get("system:classname"),
                           formData: this.state.formData.set("object_object_id",
                                                             obj.get("cdb_object_id"))});
        }
    }

    onSelectItem(item) {
        this.getObject(item.get("rest_url"));
    }

    onCatalogChange(item) {
        const link_oid = item["link_type_object_id"];
        let link_desc = "";
        this.props.ObjectStore.valueSeq().forEach(x => {
            if (x.get("cdb_object_id") === link_oid) {
                link_desc = x.get("name");
            }
        });
        this.setState({formData: this.state.formData.set("link_type_object_id", link_oid),
                       link_desc: link_desc});
    }

    onCatalogValueChange(value) {
        this.setState({link_desc: value});
    }

    render() {
        if (this.state.classes.length === 0) {
            return <div />;
        }
        const catalogURL = "/internal/uisupport/catalog/cdb_sem_link_type_brows_web/";
        const groupClass = classNames(
            'cs-web-components-base-formcontrols-formcontrol',
            {
                ['cs-web-components-base-formcontrols-formcontrol-readonly']: false,
                ['cs-web-components-base-formcontrols-formcontrol-focused']: false,
                ['cs-web-components-base-formcontrols-textinput-compact']: false
            }
        );
        return (
            <div className={prefixNS("modal-content")}>
                <FormControl.TextInput name="subject"
                                       label={formatStr("subject")}
                                       value = {this.state.subj_desc}
                                       mandatory
                                       readOnly />
                <FormGroup className={groupClass}
                           validationState={this.state.obj_desc ? "" : "error"}
                           data-mandatory={true}>
                    <ControlLabel>{formatStr("object")}</ControlLabel>
                    <div className={prefixNS("object-search-wrapper")} id="object-search-wrapper">
                        <ObjectWidgets.ObjectSearch onSelectItem = {this.onSelectItem}
                                                    hideDefaultTags = {true}
                                                    searchClasses = {this.state.classes}
                                                    searchPlaceholder = {formatStr(
                                                                            "search_for_objects")}
                                                    value = {this.state.obj_desc}/>
                    </div>
                </FormGroup>
                <FormControl.ComboBoxCatalog name="name"
                                             label={formatStr("verb")}
                                             selectURL = {catalogURL + "selected_values"}
                                             itemsURL = {catalogURL + "items?as_strings=''"}
                                             formData = {Immutable.fromJS(
                                              {subject_object_classname: this.state.subj_classname,
                                               object_object_classname: this.state.obj_classname,
                                               link_type_object_id: ''})}
                                             onCatalogChange = {this.onCatalogChange}
                                             value = {this.state.link_desc}
                                             mandatory
                                             readOnly = {!this.state.obj_desc}
                                             textReadOnly = {!this.state.obj_desc}
                                             validationState = {this.state.link_desc ? "" : "error"}
                                             />
                {!this.props.onClose &&
                    <FormControl.FormActions buttons={this.buttons()}/>}
            </div>
      );
    }
}

CreateLink.propTypes = {
    fetchObject: PropTypes.func.isRequired,
    fetchCollection: PropTypes.func.isRequired,
    createObject: PropTypes.func.isRequired,
    addNotification: PropTypes.func.isRequired,
    removeNotificationNow: PropTypes.func.isRequired,
    getObjectById: ImmutablePropTypes.map,
    ObjectStore: ImmutablePropTypes.map,
    location: PropTypes.object,
    contextObject: ImmutablePropTypes.map,
    onClose: PropTypes.func
};

function mapStateToProps(state) {
    return {
        getObjectById: object_link => state.objectsById.get(object_link),
        ObjectStore: state.objectsById
    };
}


const actions = {addNotification, removeNotificationNow,
                 fetchObject, fetchCollection, createObject};
export default connect(mapStateToProps, actions, null, {withRef: true})(CreateLink);

