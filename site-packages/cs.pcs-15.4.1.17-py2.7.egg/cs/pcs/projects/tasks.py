#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
# CDB:Browse
# pylint: disable-msg=E0213,E1103,E0102,E0203,W0212,W0621,W0201,W0142

__docformat__ = "restructuredtext en"
__revision__ = "$Id: tasks.py 185036 2018-10-12 14:04:08Z heg $"

import datetime
from collections import defaultdict

from cdb import CADDOK
from cdb import sig
from cdb import transactions
from cdb.classbody import classbody
from cdb import auth
from cdb import sqlapi
from cdb import ue
from cdb import misc
from cdb import ddl
from cdb import cdbuuid
from cdb import cdbtime
from cdb import util
from cdb import cmsg
from cdb import i18n
from cdb import typeconversion

from cdb.constants import kOperationDelete
from cdb.constants import kOperationNew
from cdb.constants import kOperationCopy

from cdb.platform import mom

from cdb.objects import Reference, N, Forward, Object, Reference_Methods, State, Transition, Rule
from cdb.objects import unique
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects.org import WithSubject
from cdb.objects.operations import operation, system_args

from cdb.typeconversion import to_user_repr_date_format
from cdb.typeconversion import to_legacy_date_format_auto
from cdb.typeconversion import to_python_rep

from cs.calendar import workday
from cs.pcs.projects import calendar as Calendar
from cs.pcs.efforts import WithEffortReport
from cs.pcs.issues import WithFrozen
from cs.pcs.issues import WithIssueReport
from cs.pcs.projects import Project
from cs.pcs.projects import Role
from cs.pcs.projects.tasks_plugin import TaskWithCsTasks
from cdb.objects.common import WithStateChangeNotification
from cs.tools.powerreports import WithPowerReports
from cs.metrics.qcclasses import WithQualityCharacteristic
from cs.workflow.briefcases import BriefcaseContent

from cs.actions import Action
from cs.sharing.share_objects import WithSharing

from cdb.platform import gui
from cdb.platform import olc

__all__ = ['Task', 'TaskRelation', 'TaskRelationType',
           'TaskCategory', 'CatalogPCSResponsibleData', 'CatalogPCSResponsible']

# Forward declarations
Task = Forward("cs.pcs.projects.tasks.Task")
TaskRelation = Forward("cs.pcs.projects.tasks.TaskRelation")
TaskRelationType = Forward("cs.pcs.projects.tasks.TaskRelationType")
Issue = Forward("cs.pcs.issues.Issue")
TimeSheet = Forward("cs.pcs.efforts.TimeSheet")
Checklist = Forward("cs.pcs.checklists.Checklist")
fOrganization = Forward("cdb.objects.org.Organization")
fPerson = Forward("cdb.objects.org.Person")

kTaskDependencyEA = 'EA'  # Normalfolge
kTaskDependencyAA = 'AA'  # Anfangsfolge
kTaskDependencyAE = 'AE'  # Sprungfolge
kTaskDependencyEE = 'EE'  # Endfolge

ALLOWED_TASK_GROUP_DEPENDECIES = [kTaskDependencyEA, kTaskDependencyAA]

MODE_MOVE_SINGLE_TASK = 0
# MODE_MOVE_RELATED = 1
MODE_MOVE_DROP_GAPS = 2
MODE_MOVE_HOLD_GAPS = 3

FCAST_MOVEMENT_NONE = "no movement"
FCAST_MOVEMENT_ADJUST = "adjust dates"
FCAST_MOVEMENT_RELATIVE = "move relative"

BASE_ATTRIBUTES = [u"start_time_act", u"start_time_fcast", u"start_time_plan",
                   u"end_time_act", u"end_time_fcast", u"end_time_plan",
                   u"days", u"days_fcast", u"duration", u"duration_fcast",
                   u"early_finish", u"early_start", u"late_finish", u"late_start",
                   u"free_float", u"total_float", u"status",
                   u"effort_act", u"effort_fcast", u"effort_fcast_a", u"effort_fcast_d", u"effort_plan",
                   u"status_effort_fcast", u"status_time_fcast", u"work_uncovered", u"percent_complet"]


def __log__(txt, lvl=7):
    misc.cdblogv(misc.kLogMsg, lvl, unicode(txt))


class Task(WithSubject, WithEffortReport, WithIssueReport, WithPowerReports, WithStateChangeNotification,
           WithQualityCharacteristic, BriefcaseContent, Calendar.WithCalendarIndex, WithSharing, WithFrozen, TaskWithCsTasks):
    __maps_to__ = "cdbpcs_task"
    __classname__ = "cdbpcs_task"
    __wf_step_reject_msg__ = "pcstask_wfstep_rej"

    position_initial = 10
    position_increment = 10

    def _allParentTasks(self):
        result = []
        if self.ParentTask:
            result.append(self.ParentTask)
            result += self.ParentTask._allParentTasks()
        return result

    def _allSubtasks(self, by_order=True):
        result = []
        for task in self.SubTasks:
            result.append(task)
            result += task._allSubtasks(by_order=by_order)
        return result

    Project = Reference(1, Project, Task.cdb_project_id)
    SubTasks = Reference(N, Task, Task.cdb_project_id == Task.cdb_project_id, Task.parent_task == Task.task_id, order_by='position')
    AllSubTasks = Reference_Methods(Task, lambda self: self._allSubtasks())
    ParentTask = Reference(1, Task, Task.cdb_project_id, Task.parent_task)
    AllParentTasks = Reference_Methods(Task, lambda self: self._allParentTasks())
    Issues = Reference(N, Issue, Issue.cdb_project_id == Task.cdb_project_id, Issue.task_id == Task.task_id)
    Checklists = Reference(N, Checklist, Checklist.cdb_project_id == Task.cdb_project_id, Checklist.task_id == Task.task_id)
    TimeSheets = Reference(N, TimeSheet, TimeSheet.cdb_project_id == Task.cdb_project_id, TimeSheet.task_id == Task.task_id)

    PredecessorTaskRelations = Reference(N, TaskRelation,
                                         TaskRelation.cdb_project_id == Task.cdb_project_id,
                                         TaskRelation.task_id == Task.task_id)
    SuccessorTaskRelations = Reference(N, TaskRelation,
                                       TaskRelation.cdb_project_id2 == Task.cdb_project_id,
                                       TaskRelation.task_id2 == Task.task_id)
    PredecessorTaskRelationsByType = Reference(N, TaskRelation,
                                               TaskRelation.cdb_project_id == Task.cdb_project_id,
                                               TaskRelation.task_id == Task.task_id,
                                               indexed_by=TaskRelation.rel_type)
    SuccessorTaskRelationsByType = Reference(N, TaskRelation,
                                             TaskRelation.cdb_project_id2 == Task.cdb_project_id,
                                             TaskRelation.task_id2 == Task.task_id,
                                             indexed_by=TaskRelation.rel_type)

    def _allSupertasks(self):
        u'''
        Method to get all top level tasks

        :return: returns a list of task objects (1, n, none)
        '''
        result = [self]
        if self.Supertask:
            result += self.Supertask._allSupertasks()
        return result

    AllSuperTasks = Reference_Methods(Task, lambda self: self._allSupertasks())
    Supertask = Reference_1(Task, Task.cdb_project_id, Task.parent_task)
    Subtasks = Reference_N(Task, Task.cdb_project_id == Task.cdb_project_id, Task.parent_task == Task.task_id)

    def _allSupertasksPredRelations(self):
        """
        Method to get all predecessor taskrelations on self and top level tasks

        :return: returns a list of taskrelation objects (1, n, none)
        """
        result = []
        for t in self.AllSuperTasks:
            result += t.PredecessorTaskRelations
        return result
    AllPredecessorTaskRelations = Reference_Methods(TaskRelation, lambda self: self._allSupertasksPredRelations())

    def _allSupertasksSuccRelations(self):
        """
        Method to get all successor taskrelations on self and top level tasks

        :return: returns a list of taskrelation objects (1, n, none)
        """
        result = []
        for t in self.AllSuperTasks:
            result += t.SuccessorTaskRelations
        return result
    AllSuccessorTaskRelations = Reference_Methods(TaskRelation, lambda self: self._allSupertasksSuccRelations())

    def getCompleteStructure(self):
        relationships = [self.AllSubTasks, self.Issues, self.Checklists]
        for subtask in self.AllSubTasks:
            relationships.append(subtask.Issues)
            relationships.append(subtask.Checklists)
        return relationships
    # Toleranzwert fuer Berechnungen
    Tolerance = 0.01

    def setDone(self, comment=""):
        sc = self.GetStateChange()
        if self.status == 20:
            sc.step(50)
        if self.status == 50:
            sc.step(200)

    def Reset(self):
        self.Update(status=Task.NEW.status,
                    cdb_status_txt=olc.StateDefinition.ByKeys(Task.NEW.status, self.cdb_objektart).StateText[''],
                    start_time_act="", end_time_act="", effort_act=0, percent_complet=0, effort_fcast_a=0)

    @classmethod
    def makeTaskID(cls, cdb_project_id):
        return "T%09d" % (util.nextval("cdbpcs_task"))

    def setTaskID(self, ctx):
        tasks = Task.Query("task_id = '%s'" % self.task_id)
        if not self.task_id or self.task_id in ['#', ''] or len(tasks):
            self.task_id = self.makeTaskID(self.cdb_project_id)

    def makePosition(self, ctx=None):
        """
        Returns following position of a task.
        If the maximum position of all tasks at the same level is 0, the initial value will be used
        :return: int
        """
        position = self.position_initial
        mymax = sqlapi.RecordSet2("cdbpcs_task",
                                  (Task.cdb_project_id == self.cdb_project_id)
                                  & (Task.parent_task == self.parent_task),
                                  columns=["MAX(position) p"])
        if mymax and mymax[0].p:
            position = int(mymax[0].p) + 10
        return position

    def setPosition(self, ctx=None):
        """
        If task id exists and position does not exists, sets the position of a task using makePosition
        """
        if self.task_id and self.position is None:
            self.position = self.makePosition()

    def on_cdbpcs_reinit_position_now(self, ctx):
        """
        Event handler for initializing positions of tasks
        :param ctx:
        :return:
        """
        self.reinitPosition()

    def on_activate_automatic_now(self, ctx):
        """
        Event handler for activating automatic flag for tasks
        :param ctx:
        :return:
        """
        if self.Project and not self.Project.CheckAccess("save"):
            raise ue.Exception("cdbpcs_no_project_right")
        cca = self.MakeChangeControlAttributes()
        if not self.automatic:
            self.Update(automatic=1, auto_update_time=1,
                        cdb_mdate=cca[u"cdb_mdate"], cdb_mpersno=cca[u"cdb_mpersno"])
        if self._lastObjectOfMultiSelect(ctx=ctx):
            ids = set()
            for obj in ctx.objects:
                ids.add(obj.cdb_project_id)
            for p in Project.KeywordQuery(cdb_project_id=ids):
                p.recalculate()

    def _lastObjectOfMultiSelect(self, ctx):
        object_count = 0
        if "object_count" in ctx.ue_args.get_attribute_names():
            object_count = int(ctx.ue_args["object_count"])
        object_count += 1
        ctx.keep("object_count", object_count)
        return object_count == len(ctx.objects)

    def on_deactivate_automatic_now(self, ctx):
        """
        Event handler for deactivating automatic flag for tasks
        :param ctx:
        :return:
        """
        if self.Project and not self.Project.CheckAccess("save"):
            raise ue.Exception("cdbpcs_no_project_right")
        cca = self.MakeChangeControlAttributes()
        if self.automatic:
            self.Update(automatic=0, auto_update_time=0,
                        cdb_mdate=cca[u"cdb_mdate"], cdb_mpersno=cca[u"cdb_mpersno"])

    def on_deactivate_automatic_clean_now(self, ctx):
        """
        Event handler for deactivating automatic flag for tasks and removing date values
        :param ctx:
        :return:
        """
        if not "remove_date_values" in ctx.dialog.get_attribute_names():
            self.ask_remove_date_values(ctx)
        elif ctx.dialog.remove_date_values == "1":
            self.removeDateValues(ctx=ctx)
            if self._lastObjectOfMultiSelect(ctx=ctx):
                self.recalculate()

    def removeDateValues(self, ctx):
        cca = self.MakeChangeControlAttributes()
        changes = {}
        changes[u"cdb_mdate"] = cca[u"cdb_mdate"]
        changes[u"cdb_mpersno"] = cca[u"cdb_mpersno"]
        if self.automatic:
            changes[u"automatic"] = 0
            changes[u"auto_update_time"] = 0
        if self.start_time_fcast or self.end_time_fcast:
            changes[u"start_time_fcast"] = u""
            changes[u"end_time_fcast"] = u""
        if self.constraint_type not in [u"0", u"1"]:
            changes[u"constraint_type"] = u"0"
            changes[u"constraint_date"] = u""
        if self.constraint_type not in [u"0", u"1"]:
            changes[u"constraint_type"] = u"0"
            changes[u"constraint_date"] = u""
        self.Update(**changes)

    def reinitPosition(self, ctx=None, position_initial=None, position_increment=None, next_position=10):
        """
        Initializes the positions of the task structure below the selected node
        Note: Position of the selected task is not initialized
        :param ctx: deprecated
        :param position_initial: initial value (Default: cs.pcs.tasks.Task.position_initial)
        :param position_increment: increment (Default: cs.pcs.tasks.Task.position_increment)
        :param next_position: deprecated
        :return:
        """
        self.current_position = self.position_initial if not position_initial else position_initial
        position_increment = self.position_increment if not position_increment else position_increment
        with transactions.Transaction():
            for task in self.SubTasks:
                task.position = self.current_position
                self.current_position += position_increment
                task.reinitPosition()

    def checkTaskId(self, ctx):
        if ctx.get_current_mask() == "initial":
            if self.task_id not in ['#', ''] and Task.ByKeys(self.cdb_project_id, self.task_id):
                raise ue.Exception("pcs_err_task_id_exists", self.task_id)

    def MSPtoDB(self):
        for t in self.SubTasks:
            t.MSPtoDB()
        self.is_group = len(self.Subtasks) > 0
        self.adjust_values(time_plan=True)

        # Ressourcenbedarfe und -zuweisungen anpassen
        sig.emit(Task, "adjustDependingObjects")(self)

        # Testen ob die Aufgabe nicht durchführbar ist
        self.validateSchedule()

    def setDefaults(self, ctx):
        if ctx.get_current_mask() == "initial":
            self.task_id = "#"
        if ctx.action in ['create', 'copy']:
            if self.Project:
                ctx.set("project_name", self.Project.project_name)
            if self.ParentTask:
                ctx.set("parent_task_name", self.ParentTask.task_name)

    def checkSchedule(self, ctx):
        if self.Project:
            self.Project.checkScheduleLock()

    def checkProjectID(self, ctx):
        if not Project.ByKeys(self.cdb_project_id):
            raise ue.Exception("pcs_err_prj_id", self.cdb_project_id)

    def checkForSubProjects(self, ctx):
        u''' SampleCode below can be used in subclasses to implement
        restrictions for the project hierachie.

        # dont mix tasks with subprojects
        if self.Project.SubProjects: raise ue.Exception("pcstask_err_mix")
        '''
        pass

    def hasTimeSheetEntries(self):
        return len(self.TimeSheets) > 0

    def hasResourceDemands(self):
        return False

    def hasResourceAssignments(self):
        return False

    def assignedDemands(self, _attr):
        u''' This method serves as a placeholder that is overwritten from
            cs.resources
        '''
        return 0.0

    def assignedResources(self, _attr):
        u''' This method serves as a placeholder that is overwritten from
            cs.resources
        '''
        return 0.0

    def demandRemainderInPercent(self):
        # unplanned efforts in percent
        if self.effort_fcast:
            try:
                total = float(self.effort_fcast_d)
            except Exception:
                total = 0.0
            return 100 * (self.effort_fcast - total) / self.effort_fcast
        return 0.0

    def assignmentRemainderInPercent(self):
        # unassigned efforts in percent
        if self.effort_fcast:
            try:
                total = float(self.effort_fcast_a)
            except Exception:
                total = 0.0
            return 100 * (self.effort_fcast - total) / self.effort_fcast
        return 0.0

    def assignmentRemainderInHours(self):
        # unassigned efforts in hours
        result = 0.0
        if self.effort_fcast_a:
            result -= self.effort_fcast_a
        if self.effort_fcast:
            result += self.effort_fcast
        elif self.effort_fcast != 0.0:
            result += self.getEffortMax()
        return result

    def getWorkdays(self, persno=None, assignment_oid=None):
        try:
            if self.milestone:
                return 0
            start_date = self.getStartTime()
            end_date = self.getEndTime()
            if not start_date or not end_date:
                return 0
            return Calendar.combined_workday_count(start_date=start_date,
                                                   end_date=end_date,
                                                   prj=self.Project,
                                                   persno=persno,
                                                   assignment_oid=assignment_oid)
        except Exception:
            misc.log_traceback("Workdays invalid")
            return 0

    def getWorkhours(self):
        return workday.days_to_hours(self.getWorkdays())

    def getWorkdaysInPeriod(self, start_date, end_date):
        if start_date and end_date:
            try:
                sd = self.getStartTime()
                ed = self.getEndTime()
                if not sd or not ed:
                    return 0
                if sd < start_date:
                    sd = start_date
                if end_date < ed:
                    ed = end_date
                if sd <= ed:
                    return len(Calendar.project_workdays(self.cdb_project_id, sd, ed))
            except Exception:
                pass
        return 0

    def getWorkhoursInPeriod(self, start_date, end_date):
        return workday.days_to_hours(self.getWorkdaysInPeriod(start_date, end_date))

    def on_delete_pre(self, ctx):
        dependancies = self.check_deepdelete(reason=True)
        if dependancies:
            message = '\n'.join(dependancies)

            # 1655 ist "Folgende Elemente verhindern das Löschen\n\n%s"
            raise ue.Exception("cdbpcs_delete_deny", message)

        # explicitly pass ctx args in order to support task deletion
        # via officelink (when msp is set as editor)
        args = system_args(**{a: ctx.sys_args[a] for a in ctx.sys_args.get_attribute_names()})

        for task in self.SubTasks:
            for c in task.Checklists:
                operation(kOperationDelete, c, args)
            operation(kOperationDelete, task, args)

        # Vorgänger-Nachfolger beziehung anpassen
        for pred in self.PredecessorTaskRelationsByType.all():
            for succ in self.SuccessorTaskRelationsByType.all():
                TaskRelation.compose(pred, succ)

    def setObjectart(self, ctx):
        u''' Set attribute cdb_objectart to 'cdbpcs_task'. '''
        self.cdb_objektart = "cdbpcs_task"

    def on_cdb_show_responsible_now(self, ctx):
        return self.openSubject()

    def getParent(self):
        u''' Returns either the project for project stages
        or the parent task for sub tasks or None, if parent_task ist empty. '''
        if self.parent_task:
            return self.ParentTask
        return self.Project

    def getParentIDs(self):
        if self.ParentTask:
            return [self.ParentTask.task_id] + self.ParentTask.getParentIDs()
        return []

    def checkParent(self, ctx):
        parent = self.getParent()
        if parent and ctx and ctx.action in ['copy', 'create']:
            # Action 'modify' not required here:
            # - the assignment to a project can never be changed
            # - The check on the parent task can only be performed if the user has actually changed the assignment
            #   The check is relocated.
            parent.acceptNewTask()
        if self.ParentTask:
            if self.parent_task != getattr(ctx.object, "parent_task", self.parent_task):
                if self.status != self.NEW.status:
                    raise ue.Exception("pcs_err_task_move")
                if ctx and ctx.action not in ['copy', 'create']:
                    # If parent is True, self.ParentTask is always True.
                    # In this case and "modify"-action, this is to avoid a double call of acceptNewTask.
                    self.ParentTask.acceptNewTask()
            if self.task_id in self.getParentIDs():
                raise ue.Exception("pcs_err_rec")
            if self.ParentTask.milestone:
                raise ue.Exception("cdbpcs_err_task_milestone")
            if self.ParentTask in self.AllSubTasks:
                raise ue.Exception("cdbpcs_task_recursion", self.ParentTask.task_name)
            pred_rel_types = [rel.rel_type for rel in self.ParentTask.PredecessorTaskRelations]
            if not set(pred_rel_types).issubset(set(ALLOWED_TASK_GROUP_DEPENDECIES)):
                raise util.ErrorMessage("just_a_replacement",
                    util.get_label('cdbpcs_task_group_rel_not_allowed2') % self.ParentTask.task_name)
            parent.checkConstraints()
            # if len(self.ParentTask.TimeSheets):
            #    raise ue.Exception("pcs_err_effort4", self.ParentTask.task_name)

    def acceptNewTask(self, task=None):
        rule = Rule.ByKeys("cdbpcs: Finalized Task")
        if rule and self.MatchRule(rule):
            raise ue.Exception("pcs_err_new_task2", self.task_name)

    def checkStructureLock(self, ctx=None):
        if self.Project:
            self.Project.checkStructureLock(ctx=ctx)

    def acceptAllocation(self):
        # Check the deadlines
        # Work together with autoSetDemandTime/autoSetAssignementTime
        # Other checks would be found in Demand/Assignment classes
        return self.start_time_plan and self.end_time_plan

    def parentReferenceModifiable(self):
        rule = Rule.ByKeys("cdbpcs: Parent Task Modifiable")
        result = True
        if rule:
            result = self.MatchRule(rule)
        return result

    def on_create_pre_mask(self, ctx):
        if self.cdb_project_id:
            self.checkForSubProjects(ctx)
            self.setPosition(ctx)
            # Projektattribute vorblenden, falls die
            # Aufgabe im Kontext eines Projekts angelegt wird.
            self.division = self.Project.division
        else:
            self.division = auth.get_department()

    def on_copy_post_mask(self, ctx):
        # reset task uid used by ms project integration
        self.tuid = ""
        self.msp_uid = ""
        self.msp_guid = ""

    def _getResponsibleRole(self):
        return Role.ByKeys(role_id=self.subject_id,
                           cdb_project_id=self.cdb_project_id)

    def getReadOnlyFields(self, action=u"modify", avoid_check=False):
        readonly = ["start_time_plan", "end_time_plan", "days", "effort_plan", "is_group"]

        if self.status != Task.EXECUTION.status:
            readonly += ["percent_complet"]

        if self.is_group:
            readonly += ["percent_complet", "milestone",
                         "start_time_act", "end_time_act", "effort_act"]

        if action == u"modify":
            readonly += ["project_name"]

            if self.Project.msp_active or self.Project.locked_by and self.Project.locked_by != auth.persno:
                readonly += ["start_time_fcast", "end_time_fcast", "days_fcast", "milestone",
                             "parent_task_name", "parent_task", "auto_update_time",
                             "early_position", "position",
                             "automatic", "constraint_type", "constraint_date",
                             "task_name"]

            if avoid_check:
                readonly += ["parent_task_name", "parent_task", "milestone", "position"]
            else:
                if not self.CheckAccess("pcstask_edit_all"):
                    # this access can only be granted by "FULL ACCESS"
                    # Structural changes may only be done by Project Manager or Administrator
                    readonly += ["parent_task_name", "parent_task", "milestone", "position"]
                elif not self.parentReferenceModifiable():
                    readonly += ["parent_task_name", "parent_task"]
                if self.hasResourceDemands() or self.hasResourceAssignments():
                    readonly += ["milestone"]
                if self.hasTimeSheetEntries():
                    readonly += ["milestone", "effort_act"]
            if self.milestone:
                readonly += ["effort_fcast", "effort_plan", "effort_act", "days_fcast"]
                if self.early_position:
                    readonly += ["end_time_fcast"]
                else:
                    readonly += ["start_time_fcast"]

            if self.is_group:
                if self.auto_update_time:
                    readonly += ["start_time_fcast", "end_time_fcast", "days_fcast"]
                if self.auto_update_effort:
                    readonly += ["effort_fcast"]

            if self.effort_act:
                readonly += ["milestone"]
        return unique(readonly)

    def on_modify_post_mask(self, ctx):
        if self.parent_task != ctx.object.parent_task:
            self.checkParent(ctx)
            ctx.keep("parent_task_changed", ctx.object.parent_task)

    def on_modify_post(self, ctx):
        if "parent_task_changed" in ctx.ue_args.get_attribute_names():
            old_parent_task_id = ctx.ue_args["parent_task_changed"]
            old_parent_task = None
            if old_parent_task_id:
                old_parent_task = Task.ByKeys(self.cdb_project_id, old_parent_task_id)
            self.updateParentTask(ctx, old_parent_task=old_parent_task)

    def on_cdbxml_excel_report_pre_mask(self, ctx):
        self.Super(Task).on_cdbxml_excel_report_pre_mask(ctx)
        if ctx.get_current_mask() != "initial":
            ctx.set("task_name", self.task_name)
            ctx.set("project_name", self.project_name)
            ctx.set("cdbpcs_project_id", self.cdb_project_id)

    def updateParentTask(self, ctx, old_parent_task=None):
        if self.ParentTask:
            # finish parent task if this was the last active subtask
            target_status = self.ParentTask.getFinalStatus()
            if target_status:
                self.ParentTask.ChangeState(target_status, check_access=0)
            if len(self.ParentTask.SubTasks):
                if not self.ParentTask.is_group:
                    self.ParentTask.updateObject(is_group=1)
            else:
                if self.ParentTask.is_group:
                    self.ParentTask.updateObject(is_group=0)
        else:
            if len(self.Project.TopTasks):
                if not self.Project.is_group:
                    self.Project.updateObject(is_group=1)
            else:
                if self.Project.is_group:
                    self.Project.updateObject(is_group=0)
        if old_parent_task:
            if not len(old_parent_task.SubTasks):
                old_parent_task.updateObject(is_group=0)
            old_parent_task.final_check()

    def GetDisplayAttributes(self):
        u'''This method creates and returns a results dictionary, containing the
        necessary information for the html display in the client.'''
        results = super(Task, self).GetDisplayAttributes()
        results[u"attrs"].update({u"heading": unicode(self["category"])})
        return results

    def GetSearchSummary(self):
        u'''Provides configurable diplay text for the html search results.'''
        obj = self.getPersistentObject()
        summary = []
        summary.append(u"%s" % obj["description"])
        summary.append(u"%s" % obj["joined_status_name"])
        return unicode(u"\n".join(summary))

    def updateStatusSignals(self, time=False, effort=False, **kwargs):
        task_subtasks, task_infos, _ = Task._get_task_id_dictionary(self.cdb_project_id)
        parents = Task._get_all_parents(self.task_id, task_infos, parent_task=self.parent_task)
        task_ids = task_subtasks[self.task_id] + parents
        if time:
            Task._adjust_time_status(prj_id=self.cdb_project_id, task_ids=task_ids)
            Project._adjust_time_status(prj_id=self.cdb_project_id)
        if effort:
            Task._adjust_effort_status(prj_id=self.cdb_project_id)
            Project._adjust_effort_status(prj_id=self.cdb_project_id)

    def validateSchedule(self):
        # Falls die Aufgabe nicht durchführbar ist,
        # wird sie als ungültig markiert
        myTask = Task.ByKeys(self.cdb_project_id, self.task_id)
        if myTask:
            if myTask.work_uncovered != 0:
                myTask.work_uncovered = 0
            if not myTask.milestone:
                sig.emit(Task, "validateSchedule")(myTask)

    def changeMilestone(self, ctx):
        # Meilensteinflag wurde gesetzt oder aufgehoben:
        # Start- und Endzeitpunkte sowie Dauer anpassen
        start, end, duration, days = self.calculateTimeFrame(start=self.start_time_fcast,
                                                             end=self.end_time_fcast)
        self.start_time_fcast = start
        self.start_time_plan = start
        self.end_time_plan = end
        self.duration_fcast = duration
        self.days_fcast = days
        self.duration = duration
        self.days = days
        readonly = ["effort_fcast", "days_fcast"]
        if self.early_position:
            readonly += ["end_time_fcast"]
        else:
            readonly += ["start_time_fcast"]
        if self.milestone:
            self.is_group = 0
            ctx.set_fields_readonly(readonly)
            self.effort_fcast = 0.0
        else:
            ctx.set_fields_writeable(readonly)
            self.effort_fcast = self.getEffortMax()

    def changeGroup(self, ctx):
        if self.is_group:
            self.milestone = 0
            s, e, duration, days = self.calculateTimeFrame(start=self.start_time_fcast,
                                                           end=self.end_time_fcast)
            self.duration_fcast = duration
            self.days_fcast = days
            s, e, duration, days = self.calculateTimeFrame(start=self.start_time_plan,
                                                           end=self.end_time_plan)
            self.duration = duration
            self.days = days

    def changeEffort(self, ctx):
        if self.effort_fcast and self.effort_fcast < 0:
            self.effort_fcast = 0.0
        if not self.is_group:
            self.effort_plan = self.effort_fcast

    def initConstraintDate(self, ctx):
        if ctx.action in [u"create", u"copy"]:
            self._setConstraintDate(ctx)

    def checkConstraintDate(self, ctx):
        """
        This method is only called by the Desktop Client if the value of the field has really been changed.
        NOTE the different behavior in the Web Client as described in
        E048567: The User Exit maskaction is always running,
                 even if the value of the field has not been changed.
        In the user exit code, it is not possible to compare the old value of the field against the
        current value because the old value is not available.
        Comparisons against the value of `ctx.object` do not compare the values of the mask field,
        but the value of the mask field against the value in the database (not applicable for new creation).
        Comparisons against the value of `ctx.object` do raise an AttributeError, when creating a new task.
        """
        self._setConstraintDate(ctx)

    def _setConstraintDate(self, ctx):
        ct = int(self.constraint_type)
        if ct in [0, 1]:
            ctx.set_optional("constraint_date")
        else:
            ctx.set_mandatory("constraint_date")
            if ct in [2, 4, 5]:
                self.constraint_date = self.start_time_fcast
            elif ct in [3, 6, 7]:
                self.constraint_date = self.end_time_fcast

    def checkAutoUpdate(self, ctx):
        if self.automatic == 0:
            self.auto_update_time = 0

    def checkAutomatic(self, ctx):
        if self.auto_update_time == 1:
            self.automatic = 1

    dialog_item_change_methods = {
        "days_fcast": "self.changeDuration(ctx)",
        "start_time_fcast": "self.changeStartTime(ctx)",
        "end_time_fcast": "self.changeEndTime(ctx)",
        "milestone": "self.changeMilestone(ctx)",
        "is_group": "self.changeGroup(ctx)",
        "effort_fcast": "self.changeEffort(ctx)",
        "constraint_type": "self.checkConstraintDate(ctx)",
        "automatic": "self.checkAutoUpdate(ctx)",
        "auto_update_time": "self.checkAutomatic(ctx)",
        }

    def dialog_item_change(self, ctx):
        attr = ctx.changed_item
        if (ctx.action == "create" or attr in ctx.dialog.get_attribute_names()):
            if self.dialog_item_change_methods.has_key(attr):
                eval(self.dialog_item_change_methods[attr])

    def setInitValues(self, ctx):
        """
        This method is used for the following actions: create, copy, modify, info
        Note: Copying a task using Drag&Drop identified by action create
        """
        ctx.set_focus("task_name")
        eava = self.getEffortMax()
        # Create and Copy
        if ctx.action in ('copy', 'create'):
            self.percent_complet = 0
            self.start_time_act = ''
            self.end_time_act = ''
            self.psp_code = ''
            self.automatic = 1
            self.position = self.makePosition()
        # Copy
        if ctx.action in ('copy'):
            self.subject_id = ctx.cdbtemplate['subject_id']
            self.subject_type = ctx.cdbtemplate['subject_type']
        # Create
        if ctx.action == 'create':
            self.constraint_type = "0"
            self.constraint_date = ""
            copy_keys = []
            my_parent = None
            ctx.set("effort_fcast", eava)
            if self.ParentTask:
                copy_keys = ["task_name", "subject_id", "subject_type", "category",
                             "start_time_plan", "end_time_plan",
                             "days", "duration",
                             "division", "cdb_objektart",
                             "start_time_fcast", "end_time_fcast",
                             "days_fcast", "duration_fcast",
                             "auto_update_effort", "auto_update_time",
                             "constraint_type", "constraint_date"
                             ]
                my_parent = self.ParentTask
            elif self.Project:
                copy_keys = ["start_time_fcast", "end_time_fcast",
                             "days_fcast", "duration_fcast",
                             "start_time_plan", "end_time_plan",
                             "days", "duration"
                             ]
                my_parent = self.Project
            # Copy using Drag&Drop
            if ctx.dragdrop_op_count > 0:
                pnumber = ctx.dragged_obj['cdb_project_id']
                tnumber = ctx.dragged_obj['task_id']
                task_template = Task.ByKeys(pnumber, tnumber)
                copy_keys = task_template.keys()
                copy_keys.remove("cdb_object_id")
                copy_keys.remove("task_id")
                copy_keys.remove("psp_code")
                copy_keys.remove("tuid")
                copy_keys.remove("msp_uid")
                copy_keys.remove("msp_guid")
                my_parent = task_template
                # prefill longtext field with description of dragged object
                ctx.set("cdbpcs_task_txt", ctx.dragged_obj["cdbpcs_task_txt"])

            # Werte des übergeordndeten Objekts übertragen
            if my_parent:
                for key in my_parent.keys():
                    if key in copy_keys:
                        self[key] = my_parent[key]

        # All actions
        ctx.set(u"effort_ava", u"%.2f" % eava)
        sta = self.getStartTimeTopDown()
        start_time_ava = sta.date() if sta else u""
        ctx.set(u"start_time_ava",
                typeconversion.to_user_repr_date_format(start_time_ava,
                                                        i18n.get_date_format())
                )
        eta = self.getEndTimeTopDown()
        end_time_ava = eta.date() if eta else u""
        ctx.set(u"end_time_ava",
                typeconversion.to_user_repr_date_format(end_time_ava,
                                                        i18n.get_date_format())
                )
        ctx.set_fields_readonly(self.getReadOnlyFields(action=ctx.action))
        self.initConstraintDate(ctx)

    def equals(self, obj, attrs=None, date_attrs=None):
        if not attrs:
            attrs = obj.keys()
        if not obj:
            return False
        for attr in attrs:
            if not attr in self.keys() or not attr in obj.keys():
                a = self[attr]
                b = obj[attr]
                if attr in date_attrs and a and b:
                    # Datumswerte in date_attrs sollen näherungsweise
                    # verglichen werden:
                    # Änderungen im Stunden- bzw. Minutenbereich werden
                    # hierbei ignoriert
                    if cdbtime.Time(a).date() != cdbtime.Time(b).date():
                        return False
                elif a != b:
                    return False
        return True

    def getActualWorkday(self):
        u'''
        liefert den aktuellen Stand der Aufgabe als Datum das zwischen
        dem geplanten Start- und Enddatum liegt
        '''
        # Aufgabe wurde bereits beendet
        if self.end_time_act:
            return self.end_time_plan

        # Aufgabe wurde noch nicht gestartet
        if not self.start_time_plan:
            return None

        # Aufgabe ist Sammelaufgabe: Ermittle den aktuellen Stand via Unteraufgaben
        tasks = filter(lambda x: x.start_time_plan and not x.end_time_act, self.SubTasks)
        if tasks:
            tasks.sort(lambda x, y: cmp(x.getActualWorkday(), y.getActualWorkday()))
            return tasks[0].getActualWorkday()

        # Offenen Aufgabenanteil bestimmen und das resultierende Datum ermitteln
        days_done = 0
        if self.percent_complet:
            days_done = int(float(self.getWorkdays()) * float(self.percent_complet) / 100)
        return Calendar.next_project_workday(self.cdb_project_id, self.start_time_plan, days_done)

    def getStartDateFcast(self):
        if self.start_time_fcast:
            return cdbtime.Time(self.start_time_fcast).date()
        return None

    def getEndDateFcast(self):
        if self.end_time_fcast:
            return cdbtime.Time(self.end_time_fcast).date()
        return None

    def getStartDatePlan(self):
        if self.start_time_plan:
            return cdbtime.Time(self.start_time_plan).date()
        return None

    def getEndDatePlan(self):
        if self.end_time_plan:
            return cdbtime.Time(self.end_time_plan).date()
        return None

    def getStartDateAct(self):
        if self.start_time_act:
            return cdbtime.Time(self.start_time_act).date()
        return None

    def getEndDateAct(self):
        if self.end_time_act:
            return cdbtime.Time(self.end_time_act).date()
        return None

    def getEarnedValue(self):
        if not self.isValid():
            return 0.0
        earned_values = [x.getEarnedValue() for x in self.SubTasks]
        if earned_values:
            return float(sum(earned_values))
        return self.getWorkCompletion() / 100 * self.getPlanCost()

    def getPlannedValue(self, myDate=None):
        if not self.isValid():
            return 0.0
        planned_values = [x.getPlannedValue(myDate) for x in self.SubTasks]
        if planned_values:
            return float(sum(planned_values))
        return self.getPlanTimeCompletion(myDate) * self.getPlanCost()

    def getWorkCompletion(self):
        if self.percent_complet and self.isValid():
            return float(self.percent_complet)
        return 0.0

    def getPlanCost(self):
        if self.effort_plan and self.isValid():
            return float(self.effort_plan)
        return 0.0

    def getForeCast(self):
        if self.effort_fcast and self.isValid():
            return float(self.effort_fcast)
        return 0.0

    def getDemandForeCast(self):
        if self.effort_fcast_d and self.isValid():
            return float(self.effort_fcast_d)
        return 0.0

    def getAssignmentForeCast(self):
        if self.effort_fcast_a and self.isValid():
            return float(self.effort_fcast_a)
        return 0.0

    def getActCost(self):
        if self.effort_act:
            return float(self.effort_act)
        return 0.0

    def getPlanTimeCompletion(self, myDate=None):
        if not myDate:
            myDate = datetime.date.today()
        etp = self.getEndDatePlan()
        if etp and etp <= myDate:
            return 1.0
        return 0.0

    def getPlanTimeCompletion2(self):
        maxWorkdays = self.getWorkdays()
        myDate = datetime.date.today()
        stp = self.getStartDatePlan()
        etp = self.getEndDatePlan()
        if not maxWorkdays or not stp or not etp or stp > myDate:
            return 0.0
        if etp <= myDate:
            return 1.0
        days_done = float(len(Calendar.project_workdays(self.cdb_project_id, stp, myDate)))
        return days_done / maxWorkdays

    def getActTimeCompletion(self):
        maxWorkdays = self.getWorkdays()
        myDate = self.getActualWorkday()
        stp = self.getStartDatePlan()
        if not maxWorkdays or not stp or not myDate:
            return 0.0
        days_done = float(len(Calendar.project_workdays(self.cdb_project_id, stp, myDate)))
        return days_done / maxWorkdays

    def isValid(self):
        return self.status != Task.DISCARDED.status

    @classmethod
    def isFinalStatus(cls, status):
        return int(status) in [Task.FINISHED.status, Task.COMPLETED.status, Task.DISCARDED.status]

    def hasEnded(self):
        return Task.isFinalStatus(self.status)

    def getDurationInDays(self):
        if self.duration:
            return self.duration / 8
        return 0

    def ask_user(self, ctx):
        # Create a message box
        msgbox = ctx.MessageBox("cdb_capa_adjust_01", [], "adjust", ctx.MessageBox.kMsgBoxIconQuestion)
        msgbox.addButton(ctx.MessageBoxButton("pcs_adjust_percent", "pcs_adjust_percent"))
        msgbox.addButton(ctx.MessageBoxButton("pcs_adjust_hours", "pcs_adjust_hours"))
        msgbox.addCancelButton(1)
        ctx.show_message(msgbox)

    def checkEfforts(self, ctx):
        if self.milestone and (self.effort_act or self.effort_plan or self.effort_fcast or
                               self.hasResourceDemands() or self.hasResourceAssignments() or
                               self.hasTimeSheetEntries()):
            raise ue.Exception("pcs_err_effort3")

    @classmethod
    def adjustDurations(cls, prj_id, day_from, day_until):
        try:
            sqlfrom = sqlapi.SQLdbms_date(day_from)
            sqluntil = sqlapi.SQLdbms_date(day_until)
            # betroffene Aufgaben nach Kalenderaenderung anpassen
            cond = ("cdb_project_id = '%s'"
                    " AND ((end_time_fcast IS NOT NULL AND %s <= end_time_fcast)"
                    "      OR (end_time_fcast IS NULL AND %s <= end_time_plan))"
                    " AND ((start_time_fcast IS NOT NULL AND start_time_fcast <= %s)"
                    "      OR (start_time_fcast IS NULL AND start_time_plan <= %s))"
                    % (sqlapi.quote(prj_id),
                       sqlfrom, sqlfrom,
                       sqluntil, sqluntil))
            tasks = Task.Query(cond)
            task_ids = [t.task_id for t in tasks]
            Calendar.adjustTaskWorkdays(prj_id=prj_id, task_ids=task_ids,
                                        adjust_plan=True, adjust_fcast=True)
            Task._adjust_effort_status(prj_id=prj_id, task_ids=task_ids)
            for t in tasks:
                t.adjustDependingObjects()
                # update effort status
                # effstat = Task.clsCheckResourceStatusSignals(t)
                # if effstat:
                #    t.status_effort_fcast = effstat
        except Exception:
            misc.log_traceback("Tasks have not been"
                               " adjusted to calendar changes")

    def adjustDependingObjects(self):
        u'''
        Diese Methode muss aufgerufen werden, nachdem die Aufgabe ausserhalb
        des cdb.objects-Frameworks modifiziert wurde.
        '''
        # Ressourcenbedarfe und -zuweisungen anpassen
        sig.emit(Task, "adjustDependingObjects")(self)

        # Testen ob die Aufgabe nicht durchführbar ist
        self.validateSchedule()

    def final_check(self, ctx=None):
        u''' Final aggregations to ensure consistency
        '''
        # ---- new: no final event any more, moved handling to post
        if ctx and ctx.mode == "final":
            return
        # ----------
        with transactions.Transaction():
            with SecureTaskBase(self.cdb_project_id):
                self.adjust_values(adjust_parents=True, time_act=True,
                                   effort_plan=True, effort_fcast=self.auto_update_effort, effort_act=True)
                self.adjust_values(adjust_parents=True, percentage=True)
                self.updateStatusSignals(effort=True)

    # == Email notification ==

    def getNotificationTitle(self, ctx=None):
        """
        :param ctx:
        :return: title of the notification mail
        :rtype: basestring
        """
        return "{} - Aufgabe bereit / Task ready".format(
            gui.Message.GetMessage("branding_product_name")
        )

    def getNotificationTemplateName(self, ctx=None):
        """
        :param ctx:
        :return: template name of the notification mail body
        :rtype: basestring
        """
        return "cdbpcs_task_ready.html"

    def getNotificationReceiver(self, _ctx=None):
        """ Build a dictionary with adresses to notify. The dictionary must be
            in the form defined by WithEmailNotification.getNotificationReceiver()
        """
        rcvr = {}
        tolist = []
        if self.Subject:
            for pers in self.Subject.getPersons():
                if pers.email_notification_task():
                    tolist.append((pers.e_mail, pers.name))
        if tolist:
            rcvr["to"] = tolist
        # Dependent objects may want to add receivers to notify. Each connected
        # slot must return a dict as described above.
        results = sig.emit(Task, "getNotificationReceiver")(self)
        # Collect results into a single dict.
        for result_dict in results:
            for key in ("to", "cc", "bcc"):
                lst = result_dict.get(key)
                if lst:
                    rcvr[key] = unique(rcvr.get(key, []) + lst)
        return [rcvr]

    # == End email notification ==

    @classmethod
    def _get_task_id_dictionary(cls, prj_id, check_access=False, tasks_to_check=None):
        task_subtasks = defaultdict(list)
        task_infos = {}
        save_granted = []
        tasks = Project.ByKeys(prj_id).Tasks
        for t in tasks:
            if not check_access or tasks_to_check and t.task_id not in tasks_to_check or t.CheckAccess('save', auth.persno):
                save_granted.append(t.task_id)
            tid = t.task_id
            task_subtasks[t.parent_task].append(tid)
            task_infos[tid] = t
        return task_subtasks, task_infos, save_granted

    @classmethod
    def _get_all_parents(cls, task_id, dic, parent_task=None):
        result = []
        if not dic.has_key(task_id):
            task_id = parent_task
        if task_id in dic:
            pt = dic[task_id]["parent_task"]
            if pt:
                result.append(pt)
                result += cls._get_all_parents(pt, dic)
        return result

    @classmethod
    def _check_task_rel_special_case(cls, prj_id, additional=None):
        edges = []
        nodes = set()
        _, task_infos, _ = Task._get_task_id_dictionary(prj_id)
        for task_id in task_infos:
            nodes.add(task_id)
        sql = ("SELECT task_id AS succ, task_id2 AS pred, rel_type"
               " FROM cdbpcs_taskrel"
               " WHERE cdb_project_id = '%s' AND cdb_project_id2 = '%s'"
               % (prj_id, prj_id))
        rset = sqlapi.RecordSet2(sql=sql)
        for rec in rset:
            edges.append((rec.pred, rec.succ))
        if additional is not None:
            task_id_pred, task_id_succ, _ = additional
            edges.append((task_id_pred, task_id_succ))
            nodes.add(task_id_pred)
            nodes.add(task_id_succ)
#       First clear out nodes without any edges
        toremove = []
        for node in nodes:
            result = False
            for edge in edges:
                if node in edge:
                    result = True
            if not result:
                toremove.append(node)
        for each in toremove:
            nodes.remove(each)

        visited = []
        finished = []

        def dfs(v):
            if v in finished:
                return True
            if v in visited:
                return False
            visited.append(v)
            edges_of_v = filter(lambda (t_id, task_id2): v == t_id, edges)
            result = True
            for each in edges_of_v:
                if not dfs(each[1]):
                    result = False
            if result:
                finished.append(v)
            return result
        result = True
        for node in nodes:
            r2 = dfs(node)
            if not r2:
                result = False
                break

        notfinished = list(set(nodes) - set(finished))
        predecessor = None
        if not result:
            predecessor = {}
            for node in notfinished:
                edges_of_v = filter(lambda (t_id, task_id2): node == t_id, edges)
                sucessors = [(y, "") for _, y in edges_of_v]
                predecessor[(node, "")] = sucessors

        return predecessor

    @classmethod
    def _check_task_rel_cycles(cls, prj_id, additional=None):
        """ Check if there are cyclic task relationships defined inside the
            project given by prj_id. To account for the different relationship
            types (EA, EE, AA, AE), each task is split into a START and an END
            position, and implicit relationships are added between each task's
            START and END, as well as between the START of a parent and subtask
            and the END of a subtask and its parent.
            In the parameter additional, a further relationship can be given by
            the caller as a tuple
            (predecessor task id, successor task id, relationship type),
            that is added to the total set. The purpose of this parameter is to
            implement a cycle check before a relationship is actually added to
            the DB.
            Returns a dict [task id] -> set([predecessor task ids]).
            If a cycle is found, the dict contains all the relationships that
            are (directly or indirectly) part of the cycle. If no cycle is found,
            the dict is empty.
        """
        START = "START"
        END = "END"
        REL_TYPE_POSITIONS = {'AA': (START, START),
                              'EA': (END, START),
                              'AE': (START, END),
                              'EE': (END, END)}
        task_subtasks, task_infos, _ = Task._get_task_id_dictionary(prj_id)
        # For each task start / end, store all task relations that point there.
        predecessors = defaultdict(set)
        # Each task has an implicit relation from start to end, this simplifies
        # the logic later because we don't have to distinguish between the
        # various relation types.
        for task_id in task_infos.iterkeys():
            predecessors[(task_id, END)].add((task_id, START))
        # Child tasks may not start before their parents, and not end after
        # their parents.
        for parent_id, subtasks in task_subtasks.iteritems():
            for subtask_id in subtasks:
                predecessors[(subtask_id, START)].add((parent_id, START))
                predecessors[(parent_id, END)].add((subtask_id, END))
        # Add the explicitly stored task relations.
        sql = ("SELECT task_id AS succ, task_id2 AS pred, rel_type"
               " FROM cdbpcs_taskrel"
               " WHERE cdb_project_id = '%s' AND cdb_project_id2 = '%s'"
               % (prj_id, prj_id))
        rset = sqlapi.RecordSet2(sql=sql)
        for rec in rset:
            pred_pos, succ_pos = REL_TYPE_POSITIONS[rec.rel_type]
            predecessors[(rec.succ, succ_pos)].add((rec.pred, pred_pos))
        # If an additional relship is given, add that too.
        if additional is not None:
            task_id_pred, task_id_succ, rel_type = additional
            pred_pos, succ_pos = REL_TYPE_POSITIONS[rel_type]
            predecessors[(task_id_succ, succ_pos)].add((task_id_pred, pred_pos))
        # Check for cycles
        while predecessors:
            progress = False
            # Collect everything listed as a predecessors.
            candidates = set()
            for rels in predecessors.itervalues():
                candidates.update(rels)
            # Remove entries that are not listed as a predecessor.
            not_mentioned = set(predecessors.keys()).difference(candidates)
            for task_id in not_mentioned:
                del predecessors[task_id]
                progress = True
            # Remove refs to entries that don't have predecessors themselves.
            candidates.difference_update(predecessors.keys())
            if candidates:
                # Remove those entries from the predecessor list ...
                for rels in predecessors.itervalues():
                    rels.difference_update(candidates)
                # ... and remove all entries, that have no more predecessors
                empties = [k for k, v in predecessors.iteritems() if not v]
                for task_id in empties:
                    del predecessors[task_id]
                    progress = True
            # If we did nothing at all, break the loop -> we have a circle.
            if not progress:
                break
        return dict(predecessors)

    @classmethod
    def _check_task_rel_parent_cycles(cls, prj_id, additional=None):
        Calendar.loadTaskRelations(prj_id, check_access=False)
        pred = Task.ByKeys(prj_id, additional[0])
        succ = Task.ByKeys(prj_id, additional[1])
        if succ in Calendar.getAllSubtasks(pred):
            return "parent circle found"
        if pred in Calendar.getAllSubtasks(succ):
            return "parent circle found"

    def _ensureResourceConstraints(self, start, end):
            if self.hasResourceDemands() and (not start or not end):
                raise AbortMessage("cdbpcs_demand_needs_dates", self.task_name)
            if self.hasResourceAssignments() and (not start or not end):
                raise AbortMessage("cdbpcs_assignment_needs_dates", self.task_name)

    def setTimeframe(self, ctx=None, start=None, end=None, days=None, **kwargs):
        with transactions.Transaction():
            # adjust this task
            start, end, duration, days = self.calculateTimeFrame(start=start, end=end, days=days)
            self._ensureResourceConstraints(start=start, end=end)
            if not self.is_group:
                self.setAttributeValues(ctx=ctx,
                                        start_time_fcast=start, end_time_fcast=end,
                                        duration_fcast=duration, days_fcast=days,
                                        start_time_plan=start, end_time_plan=end,
                                        duration=duration, days=days, **kwargs)
            else:
                self.setAttributeValues(ctx=ctx,
                                        start_time_fcast=start, end_time_fcast=end,
                                        duration_fcast=duration, days_fcast=days, **kwargs)

    @classmethod
    def _connectConditionsByOR(cls, **kwargs):
        return cls._connectConditions(conntect_by=' OR ', **kwargs)

    @classmethod
    def _connectConditionsByAND(cls, **kwargs):
        return cls._connectConditions(conntect_by=' AND ', **kwargs)

    @classmethod
    def _connectConditions(cls, conntect_by, **kwargs):
        conds = []
        for k, v in kwargs.items():
            if v:
                if isinstance(v, set):
                    v = list(v)
                if isinstance(v, list):
                    subconds = []
                    mylist = v
                    while len(mylist):
                        v = mylist[:500]
                        mylist = mylist[500:]
                        subconds.append(u"%s IN (%s)" % (k, u','.join([u"'%s'" % x for x in v])))
                    conds.append('(%s)' % ' OR '.join(subconds))
                elif isinstance(v, (str, unicode)):
                    conds.append(u"%s = '%s'" % (k, v))
        return conntect_by.join(conds)

    @classmethod
    def _mark_changed_tasks(cls, prj_id=None, task_ids=None, task_oids=None):
        if not (prj_id or task_ids or task_oids):
            return
        kwargs = Task.MakeChangeControlAttributes()
        kwargs["cdb_apersno"] = kwargs["cdb_mpersno"]
        kwargs["cdb_adate"] = sqlapi.SQLdbms_date(kwargs["cdb_mdate"])
        where = Task._connectConditionsByAND(cdb_object_id=task_oids, cdb_project_id=prj_id, task_id=task_ids)
        upd = """cdbpcs_task SET cdb_apersno='%s', cdb_adate=%s WHERE %s
        """ % (kwargs["cdb_apersno"], kwargs["cdb_adate"], where)
        sqlapi.SQLupdate(upd)
        ts = Task.Query(where)
        for t in ts:
            t.Reload()

    @classmethod
    def _adjust_critical_path(cls, prj_id):
        c = CriticalPath(prj_id=prj_id)
        c.update()

    def getWorkdaysFcast(self):
        return Calendar.getWorkdays(self.cdb_project_id, self.start_time_fcast, self.end_time_fcast)

    def adjust_values(self, adjust_parents=False, **kwargs):
        kwargs["prj_id"] = self.cdb_project_id
        kwargs["task_id"] = self.task_id
        with transactions.Transaction():
            if self.is_group:
                Task._adjust_parent_to_subtasks(**kwargs)
            else:
                Task._adjust_own_values(**kwargs)
            if adjust_parents:
                if self.ParentTask:
                    if kwargs.has_key("time_fcast"):
                        kwargs["time_fcast"] = self.ParentTask.auto_update_time
                    if kwargs.has_key("effort_fcast"):
                        kwargs["effort_fcast"] = self.ParentTask.auto_update_effort
                    self.ParentTask.adjust_values(adjust_parents=adjust_parents, **kwargs)
                else:
                    if kwargs.has_key("time_fcast"):
                        kwargs["time_fcast"] = self.Project.auto_update_time
                    if kwargs.has_key("effort_fcast"):
                        kwargs["effort_fcast"] = self.Project.auto_update_effort
                    self.Project.adjust_values(**kwargs)

    @classmethod
    def _adjust_own_values(cls, prj_id, task_id, time_plan=False, effort_plan=False,
                           effort_act=False, **kwargs):
        changes = []
        if time_plan:
            changes.append("start_time_plan = start_time_fcast, end_time_plan = end_time_fcast")
        if effort_plan:
            changes.append("effort_plan = effort_fcast")
        if effort_act:
            changes.append("""  effort_act =   (SELECT CASE
                                                WHEN SUM(e.hours) > 0
                                                THEN SUM(e.hours)
                                                ELSE cdbpcs_task.effort_act END
                                                FROM cdbpcs_time_sheet e
                                                WHERE e.task_id = cdbpcs_task.task_id
                                                AND e.cdb_project_id = cdbpcs_task.cdb_project_id
                                                AND e.hours IS NOT NULL)""")
        sig.emit(Task, "extend_task_adjust_own_values")(changes, **kwargs)
        if changes:
            change_str = ', '.join(changes)
            upd = "cdbpcs_task SET %s WHERE cdb_project_id = '%s' AND task_id = '%s'" % (change_str, prj_id, task_id)
            return sqlapi.SQLupdate(upd)
        return 0

    @classmethod
    def _adjust_parent_to_subtasks(cls, prj_id, task_id, time_plan=False, time_fcast=False, time_act=False,
                                   effort_plan=False, effort_fcast=False, effort_act=False,
                                   percentage=False, **kwargs):
        kwargs2 = {}
        kwargs2["canceled"] = Task.DISCARDED.status
        changes = []
        if time_plan:
            changes.append("""  start_time_plan = (SELECT MIN(CASE
                                                   WHEN t.start_time_fcast IS NULL
                                                   THEN t.start_time_plan
                                                   ELSE t.start_time_fcast END)
                                                   FROM cdbpcs_task t
                                                   WHERE t.parent_task = cdbpcs_task.task_id
                                                   AND t.cdb_project_id = cdbpcs_task.cdb_project_id),
                                end_time_plan =   (SELECT MAX(CASE
                                                   WHEN t.end_time_fcast IS NULL
                                                   THEN t.end_time_plan
                                                   ELSE t.end_time_fcast END)
                                                   FROM cdbpcs_task t
                                                   WHERE t.parent_task = cdbpcs_task.task_id
                                                   AND t.cdb_project_id = cdbpcs_task.cdb_project_id)""" % kwargs2)
        if time_fcast:
            changes.append("""  start_time_fcast = (SELECT MIN(CASE
                                                    WHEN t.start_time_fcast IS NULL
                                                    THEN t.start_time_plan
                                                    ELSE t.start_time_fcast END)
                                                    FROM cdbpcs_task t
                                                    WHERE t.parent_task = cdbpcs_task.task_id
                                                    AND t.cdb_project_id = cdbpcs_task.cdb_project_id),
                                end_time_fcast =   (SELECT MAX(CASE
                                                    WHEN t.end_time_fcast IS NULL
                                                    THEN t.end_time_plan
                                                    ELSE t.end_time_fcast END)
                                                    FROM cdbpcs_task t
                                                    WHERE t.parent_task = cdbpcs_task.task_id
                                                    AND t.cdb_project_id = cdbpcs_task.cdb_project_id)""" % kwargs2)
        if time_act:
            changes.append("""  start_time_act =   (SELECT MIN(t.start_time_act)
                                                    FROM cdbpcs_task t
                                                    WHERE t.parent_task = cdbpcs_task.task_id
                                                    AND t.cdb_project_id = cdbpcs_task.cdb_project_id
                                                    AND t.start_time_act IS NOT NULL
                                                    AND t.status != %(canceled)s),
                                end_time_act =     (SELECT CASE
                                                    WHEN MAX(CASE WHEN t.end_time_act IS NULL THEN 1 ELSE 0 END) = 1
                                                    THEN NULL
                                                    ELSE MAX(t.end_time_act) END
                                                    FROM cdbpcs_task t
                                                    WHERE t.parent_task = cdbpcs_task.task_id
                                                    AND t.cdb_project_id = cdbpcs_task.cdb_project_id
                                                    AND t.status != %(canceled)s)""" % kwargs2)
        if effort_plan:
            changes.append("""  effort_plan =  (SELECT SUM(CASE
                                                WHEN t.effort_fcast IS NULL
                                                THEN 0
                                                ELSE t.effort_fcast END)
                                                FROM cdbpcs_task t
                                                WHERE t.parent_task = cdbpcs_task.task_id
                                                AND t.cdb_project_id = cdbpcs_task.cdb_project_id
                                                AND t.status != %(canceled)s)""" % kwargs2)
        if effort_fcast:
            changes.append("""  effort_fcast = (SELECT SUM(CASE
                                                WHEN t.effort_fcast IS NULL
                                                THEN 0
                                                ELSE t.effort_fcast END)
                                                FROM cdbpcs_task t
                                                WHERE t.parent_task = cdbpcs_task.task_id
                                                AND t.cdb_project_id = cdbpcs_task.cdb_project_id
                                                AND t.status != %(canceled)s)""" % kwargs2)
        if effort_act:
            changes.append("""  effort_act =   (SELECT SUM(t.effort_act)
                                                FROM cdbpcs_task t
                                                WHERE t.parent_task = cdbpcs_task.task_id
                                                AND t.cdb_project_id = cdbpcs_task.cdb_project_id
                                                AND t.effort_act IS NOT NULL) +
                                               (SELECT CASE
                                                WHEN SUM(e.hours) > 0
                                                THEN SUM(e.hours)
                                                ELSE 0 END
                                                FROM cdbpcs_time_sheet e
                                                WHERE e.task_id = cdbpcs_task.task_id
                                                AND e.cdb_project_id = cdbpcs_task.cdb_project_id
                                                AND e.hours IS NOT NULL)""")
        if percentage:
            changes.append("""  percent_complet = (SELECT cast(ROUND(CASE
                                                   WHEN SUM(t.effort_fcast) > 0
                                                   THEN SUM(t.percent_complet * t.effort_fcast) / SUM(t.effort_fcast)
                                                   WHEN COUNT(CASE WHEN t.effort_fcast = 0 THEN 1 ELSE 0 END) > 0
                                                   THEN SUM(t.percent_complet) / COUNT(CASE WHEN t.effort_fcast = 0 THEN 1 ELSE 0 END)
                                                   ELSE 0 END, 0) as int)
                                                   FROM cdbpcs_task t
                                                   WHERE t.parent_task = cdbpcs_task.task_id
                                                   AND t.cdb_project_id = cdbpcs_task.cdb_project_id
                                                   AND t.status != %(canceled)s)""" % kwargs2)
        sig.emit(Task, "extend_task_adjust_parent_to_subtasks")(changes, **kwargs)
        if changes:
            change_str = ', '.join(changes)
            upd = "cdbpcs_task SET %s WHERE cdb_project_id = '%s' AND task_id = '%s'" % (change_str, prj_id, task_id)
            return sqlapi.SQLupdate(upd)
        return 0

    @classmethod
    def _adjust_time_status(cls, prj_id, task_ids=None):
        kwargs = {}
        kwargs["chr1"] = u"''"
        if sqlapi.SQLdbms() == sqlapi.DBMS_ORACLE:
            kwargs["chr1"] = u"chr(1)"
        where = " WHERE " + Task._connectConditionsByAND(cdb_project_id=prj_id, task_id=task_ids)
        upd = """cdbpcs_task SET status_time_fcast = (SELECT CASE
                     WHEN cdbpcs_task.start_time_fcast IS NULL THEN 0
                     WHEN cdbpcs_task.end_time_fcast = NULL THEN 0
                     WHEN cdbpcs_task.start_time_fcast < t.start_time_fcast THEN 3
                     WHEN cdbpcs_task.end_time_fcast > t.end_time_fcast THEN 3
                     WHEN cdbpcs_task.start_time_fcast > cdbpcs_task.start_time_plan THEN 2
                     WHEN cdbpcs_task.end_time_fcast < cdbpcs_task.end_time_plan THEN 2
                     ELSE 1 END
                     FROM cdbpcs_task t
                     WHERE t.task_id = cdbpcs_task.parent_task
                     AND t.cdb_project_id = cdbpcs_task.cdb_project_id)""" % kwargs
        changes = sqlapi.SQLupdate(upd + where)

        where += " AND parent_task = %(chr1)s" % kwargs
        upd = """cdbpcs_task SET status_time_fcast = (SELECT CASE
                     WHEN cdbpcs_task.start_time_fcast IS NULL THEN 0
                     WHEN cdbpcs_task.end_time_fcast IS NULL THEN 0
                     WHEN cdbpcs_task.start_time_fcast < p.start_time_fcast THEN 3
                     WHEN cdbpcs_task.end_time_fcast > p.end_time_fcast THEN 3
                     WHEN cdbpcs_task.start_time_fcast > cdbpcs_task.start_time_plan THEN 2
                     WHEN cdbpcs_task.end_time_fcast < cdbpcs_task.end_time_plan THEN 2
                     ELSE 1 END
                     FROM cdbpcs_project p
                     WHERE cdbpcs_task.parent_task = %(chr1)s
                     AND p.cdb_project_id = cdbpcs_task.cdb_project_id)""" % kwargs
        return changes + sqlapi.SQLupdate(upd + where)

    @classmethod
    def _adjust_effort_status(cls, prj_id, task_ids=None):
        kwargs = {}
        kwargs["chr1"] = u"''"
        if sqlapi.SQLdbms() == sqlapi.DBMS_ORACLE:
            kwargs["chr1"] = u"chr(1)"
        where = " WHERE " + Task._connectConditionsByAND(cdb_project_id=prj_id, task_id=task_ids)
        upd = """cdbpcs_task SET status_effort_fcast = (SELECT CASE
                     WHEN cdbpcs_task.effort_fcast IS NULL THEN 0
                     WHEN cdbpcs_task.work_uncovered IS NOT NULL
                     AND cdbpcs_task.work_uncovered = 1 THEN 3
                     WHEN t.effort_fcast IS NOT NULL
                     AND cdbpcs_task.effort_fcast > t.effort_fcast THEN 3
                     WHEN t.effort_plan IS NOT NULL
                     AND t.effort_fcast IS NOT NULL
                     AND t.effort_plan > t.effort_fcast THEN 3
                     WHEN cdbpcs_task.effort_act IS NOT NULL
                     AND cdbpcs_task.effort_fcast < cdbpcs_task.effort_act
                     AND cdbpcs_task.effort_fcast_a < cdbpcs_task.effort_act THEN 3
                     WHEN cdbpcs_task.effort_plan IS NOT NULL
                     AND cdbpcs_task.effort_fcast < cdbpcs_task.effort_plan THEN 2
                     WHEN cdbpcs_task.effort_fcast_d IS NOT NULL
                     AND cdbpcs_task.effort_fcast < cdbpcs_task.effort_fcast_d THEN 2
                     WHEN cdbpcs_task.effort_fcast_a IS NOT NULL
                     AND cdbpcs_task.effort_fcast > 0.0
                     AND cdbpcs_task.effort_fcast < cdbpcs_task.effort_fcast_a THEN 2
                     ELSE 1 END
                     FROM cdbpcs_task t
                     WHERE t.task_id = cdbpcs_task.parent_task
                     AND t.cdb_project_id = cdbpcs_task.cdb_project_id)""" % kwargs
        changes = sqlapi.SQLupdate(upd + where)

        where += " AND parent_task = %(chr1)s" % kwargs
        upd = """cdbpcs_task SET status_effort_fcast = (SELECT CASE
                     WHEN cdbpcs_task.effort_fcast IS NULL THEN 0
                     WHEN cdbpcs_task.work_uncovered IS NOT NULL
                     AND cdbpcs_task.work_uncovered = 1 THEN 3
                     WHEN p.effort_fcast IS NOT NULL
                     AND cdbpcs_task.effort_fcast > p.effort_fcast THEN 3
                     WHEN p.effort_plan IS NOT NULL
                     AND p.effort_fcast IS NOT NULL
                     AND p.effort_plan > p.effort_fcast THEN 3
                     WHEN cdbpcs_task.effort_act IS NOT NULL
                     AND cdbpcs_task.effort_fcast < cdbpcs_task.effort_act
                     AND cdbpcs_task.effort_fcast_a < cdbpcs_task.effort_act THEN 3
                     WHEN cdbpcs_task.effort_plan IS NOT NULL
                     AND cdbpcs_task.effort_fcast < cdbpcs_task.effort_plan THEN 2
                     WHEN cdbpcs_task.effort_fcast_d IS NOT NULL
                     AND cdbpcs_task.effort_fcast < cdbpcs_task.effort_fcast_d THEN 2
                     WHEN cdbpcs_task.effort_fcast_a IS NOT NULL
                     AND cdbpcs_task.effort_fcast > 0.0
                     AND cdbpcs_task.effort_fcast < cdbpcs_task.effort_fcast_a THEN 2
                     ELSE 1 END
                     FROM cdbpcs_project p
                     WHERE cdbpcs_task.parent_task = %(chr1)s
                     AND p.cdb_project_id = cdbpcs_task.cdb_project_id)""" % kwargs
        return changes + sqlapi.SQLupdate(upd + where)

    @classmethod
    def _move_tasks(cls, prj_id, tasks, closed_tasks=None, fcast_movement=0, plan_movement=0):
        if not tasks:
            return
        open_task_cond = Task._connectConditionsByAND(task_id=tasks)
        closed_task_cond = Task._connectConditionsByAND(task_id=closed_tasks)
        if fcast_movement:
            Task._move_task_single_task_attr(prj_id=prj_id, open_task_cond=open_task_cond,
                                             closed_task_cond=closed_task_cond, movement=fcast_movement,
                                             attr="start_time_fcast", idx="late_work_idx")
            Task._move_task_single_task_attr(prj_id=prj_id, open_task_cond=open_task_cond,
                                             closed_task_cond=closed_task_cond, movement=fcast_movement,
                                             attr="end_time_fcast", idx="early_work_idx")
        if plan_movement:
            Task._move_task_single_task_attr(prj_id=prj_id, open_task_cond=open_task_cond,
                                             closed_task_cond=closed_task_cond, movement=plan_movement,
                                             attr="start_time_plan", idx="late_work_idx")
            Task._move_task_single_task_attr(prj_id=prj_id, open_task_cond=open_task_cond,
                                             closed_task_cond=closed_task_cond, movement=plan_movement,
                                             attr="end_time_plan", idx="early_work_idx")

    @classmethod
    def _adjust_fcast(cls, prj_id, t_ids):
        upd = """cdbpcs_task SET start_time_fcast = start_time_plan, end_time_fcast = end_time_plan
        WHERE %s""" % Task._connectConditionsByAND(cdb_project_id=prj_id, task_id=t_ids)
        return sqlapi.SQLupdate(upd)

    @classmethod
    def _move_task_single_task_attr(cls, prj_id, open_task_cond, closed_task_cond, movement, attr, idx):
        upd = """
        cdbpcs_task SET %(attr)s =
        (SELECT b.day FROM cdb_calendar_entry a, cdb_calendar_entry b, cdbpcs_project p
        WHERE cdbpcs_task.%(attr)s = a.day
        AND a.%(idx)s = b.%(idx)s - %(movement)s AND b.day_type_id = 1
        AND a.calendar_profile_id = p.calendar_profile_id
        AND b.calendar_profile_id = p.calendar_profile_id
        AND p.cdb_project_id = '%(prj_id)s'
        AND a.personalnummer IS NULL AND a.cdb_project_id IS NULL
        AND b.personalnummer IS NULL AND b.cdb_project_id IS NULL)
        WHERE cdb_project_id = '%(prj_id)s'
        AND (%(open_task_cond)s)
        """ % locals()
        if closed_task_cond:
            upd += " AND NOT (%(closed_task_cond)s)" % locals()
        return sqlapi.SQLupdate(upd)

    def on_cdbpcs_task_reset_start_time_pre_mask(self, ctx):
        self.checkStructureLock(ctx=ctx)
        start_time_old = self.start_time_fcast if self.start_time_fcast else self.start_time_plan
        if not start_time_old:
            raise ue.Exception('pcs_move_task_error_01')
        ctx.set('start_time_old', to_user_repr_date_format(start_time_old))

    def on_cdbpcs_task_reset_start_time_now(self, ctx):
        self.checkStructureLock(ctx=ctx)
        newsd = None
        try:
            newsd = ctx.dialog.start_time_new
        except Exception:
            pass
        if not newsd:
            return
        self.reset_start_time(ctx, newsd)

    @classmethod
    def getDefaultMoveMode(cls):
        '''
        Die Methode legt fest, wie bei der Verschiebung von Aufgaben mit den Vorgängern und Nachfolgern
        der zu verschiebenen Elemente verfahren werden soll. Der eingestellte Modus bezieht sich stets nur auf
        die Elemente des gleichen Projekts.
        return MODE_MOVE_SINGLE_TASK (Wert = 0) --> nur Child- und Parent-Elemente werden angeglichen
        return MODE_MOVE_DROP_GAPS (Wert = 2)   --> zusätzlich werden abhängige Elemente soweit wie notwendig verschoben
        return MODE_MOVE_HOLD_GAPS (Wert = 3)   --> zusätzlich werden abhängige Elemente unter beibehaltenem Abstand verschoben
        '''
        return MODE_MOVE_DROP_GAPS

    def reset_start_time(self, ctx=None, start_time_new=None):
        '''
        Die Methode verschiebt sowohl den Sollwert als auch den aggregierten Wert des aufgerufenen und
        aller untergeordneten Elemente. Abschließend werden auch die übergeordneten Elemente angeglichen.
        Bei den terminlichen Verschiebungen werden ggf. auch Vorgänger bzw. Nachfolgern mit verschoben,
        sofern sie Teil des selben Projektes sind. Durch Anpassung der Methode 'getDefaultMoveMode'
        kann festgelegt werden, wie mit Vorgängern und Nachfolgern verfahren werden soll.
        '''
        if not start_time_new:
            return

        # determine the new start date
        newsd = None
        try:
            newsd = cdbtime.Time(start_time_new).date()
        except Exception:
            return

        # new start date must be within the valid time span
        if newsd < self.Project.CalendarProfile.valid_from.date():
            nsd = to_legacy_date_format_auto(newsd)
            cp_sd = to_legacy_date_format_auto(self.Project.CalendarProfile.valid_from)
            cp_ed = to_legacy_date_format_auto(self.Project.CalendarProfile.valid_until)
            raise ue.Exception("cdb_proj_cal_prof", nsd, "?", cp_sd, cp_ed)

        # determine distance to move
        calendar_profile_id = self.Project.calendar_profile_id
        (new_start_idx, _) = Calendar.getIndexByDate(calendar_profile_id,
                                                     to_python_rep(sqlapi.SQL_DATE, start_time_new))
        (old_start_idx, _) = Calendar.getIndexByDate(calendar_profile_id,
                                                     to_python_rep(sqlapi.SQL_DATE,
                                                                   ctx.dialog['start_time_old'])
                                                     )
        if old_start_idx and new_start_idx:
            distance = new_start_idx - old_start_idx
            if distance:
                # adjust constraint dates of all subtasks and start dates for all manual tasks
                for t in self.AllSubTasks:
                    t.moveFixedDates(distance=distance, calendar_profile_id=calendar_profile_id)
                # move task and start adjustment process
                self.setStartTimeFcast(start=start_time_new)

    def moveFixedDates(self, distance, calendar_profile_id):
        try:
            if self.constraint_date:
                (constraint_idx, _) = Calendar.getIndexByDate(calendar_profile_id, self.constraint_date)
                if constraint_idx and distance:
                    self.constraint_date = Calendar.getDateByIndex(calendar_profile_id, constraint_idx + distance)
            if not self.automatic and distance:
                if self.start_time_fcast and self.end_time_fcast:
                    (start_time_dix, _) = Calendar.getIndexByDate(calendar_profile_id, self.start_time_fcast)
                    (end_time_dix, _) = Calendar.getIndexByDate(calendar_profile_id, self.end_time_fcast)
                if start_time_dix and end_time_dix:
                    sd = Calendar.getDateByIndex(calendar_profile_id, start_time_dix + distance)
                    ed = Calendar.getDateByIndex(calendar_profile_id, end_time_dix + distance)
                    self.Update(start_time_fcast=sd, end_time_fcast=ed)
        except Exception, e:
            misc.cdblogv(misc.kLogErr, 0, e)

    # == Create ==
    def on_create_post(self, ctx):
        if ctx.dragdrop_op_count > 0:
            pnumber = ctx.dragged_obj['cdb_project_id']
            tnumber = ctx.dragged_obj['task_id']
            task_template = Task.ByKeys(pnumber, tnumber)
            with transactions.Transaction():
                self._copy_task_structure(ctx, pnumber, tnumber)
                self.Reload()
                self.Project.adopt_all_project_roles_from_template(task_template=task_template)
                self.Project.reset_invalid_subject_ids()

    # == Copy ==
    def on_copy_post(self, ctx):
        pnumber = ctx.cdbtemplate['cdb_project_id']
        tnumber = ctx.cdbtemplate['task_id']
        task_template = Task.ByKeys(pnumber, tnumber)
        with transactions.Transaction():
            self._copy_task_structure(ctx, pnumber, tnumber)
            self.Reload()
            self.Project.adopt_all_project_roles_from_template(task_template=task_template)
            self.Project.reset_invalid_subject_ids()

    def _copy_task_structure(self, ctx, pnumber, tnumber):
        with SecureTaskBase(self.cdb_project_id):
            task_template = Task.ByKeys(pnumber, tnumber)

            new_project_id = self.cdb_project_id
            parent_id = self.parent_task
            my_task = self.getPersistentObject()
            task_id_mapping_table, _ = task_template._copy_task(ctx, new_project_id, parent_id, my_task)
            # Copy of task relations
            Task._copy_taskrels_by_mapping(pnumber, new_project_id, task_id_mapping_table)

        # Check consistency for whole project
        self.Project.Reload()
        self.Project.recalculate()

    @classmethod
    def _copy_taskrels_by_mapping(cls, old_project_id, new_project_id, task_id_mapping_table):
        # Copy of task relations
        from cdb import InstallScript
        task_rel_keys = InstallScript.quotejoin(task_id_mapping_table.keys())
        # Only the relations within internal tasks are copied
        task_relations = TaskRelation.Query("cdb_project_id='%s' AND task_id IN (%s) AND cdb_project_id2='%s' AND task_id2 IN (%s)" %
                                            (old_project_id, task_rel_keys, old_project_id, task_rel_keys))
        for rel in task_relations:
            copy_cdb_project_id = rel.cdb_project_id
            copy_cdb_project_id2 = rel.cdb_project_id2
            copy_task_id = rel.task_id
            copy_task_id2 = rel.task_id2
            if copy_cdb_project_id == old_project_id:
                copy_cdb_project_id = new_project_id
            if copy_cdb_project_id2 == old_project_id:
                copy_cdb_project_id2 = new_project_id
            if copy_task_id in task_rel_keys:
                copy_task_id = task_id_mapping_table[copy_task_id]
            if copy_task_id2 in task_rel_keys:
                copy_task_id2 = task_id_mapping_table[copy_task_id2]

            rel.Copy(cdb_project_id=copy_cdb_project_id,
                     cdb_project_id2=copy_cdb_project_id2,
                     task_id=copy_task_id,
                     task_id2=copy_task_id2)
        Task._updateTaskRelations(new_project_id)

    @classmethod
    def _updateTaskRelations(cls, prj_id):
        sql_where = " WHERE cdb_project_id = '%s'" % prj_id
        upd1 = """
        cdbpcs_taskrel SET succ_project_oid = (SELECT cdb_object_id FROM cdbpcs_project
        WHERE cdbpcs_taskrel.cdb_project_id = cdbpcs_project.cdb_project_id)
        """
        upd2 = """
        cdbpcs_taskrel SET pred_project_oid = (SELECT cdb_object_id FROM cdbpcs_project
        WHERE cdbpcs_taskrel.cdb_project_id2 = cdbpcs_project.cdb_project_id)
        """
        upd3 = """
        cdbpcs_taskrel SET succ_task_oid = (SELECT cdb_object_id FROM cdbpcs_task
        WHERE cdbpcs_taskrel.cdb_project_id = cdbpcs_task.cdb_project_id AND cdbpcs_taskrel.task_id = cdbpcs_task.task_id)
        """
        upd4 = """
        cdbpcs_taskrel SET pred_task_oid = (SELECT cdb_object_id FROM cdbpcs_task
        WHERE cdbpcs_taskrel.cdb_project_id2 = cdbpcs_task.cdb_project_id AND cdbpcs_taskrel.task_id2 = cdbpcs_task.task_id)
        """

        sqlapi.SQLupdate(upd1 + sql_where)
        sqlapi.SQLupdate(upd2 + sql_where)
        sqlapi.SQLupdate(upd3 + sql_where)
        sqlapi.SQLupdate(upd4 + sql_where)

    # == Updates of Create From ==
    def on_cdbpcs_msp_create_from_template_now(self, ctx):
        project = Project.ByKeys(ctx.objects[0]['cdb_project_id'])
        parent_obj = Task.ByKeys(ctx.objects[0]['cdb_project_id'], ctx.objects[0]['task_id'])
        Task._cdbpcs_create_from(ctx=ctx, project=project, parent_obj=parent_obj)

    @classmethod
    def on_cdbpcs_create_from_now(cls, ctx):
        project = None
        parent_obj = None
        if "cdbpcs_project" in ctx.parent_keys:
            parent_obj = Project.ByKeys(ctx.parent['cdb_project_id'])
            project = parent_obj
        elif "cdbpcs_task" in ctx.parent_keys:
            parent_obj = Task.ByKeys(ctx.parent['cdb_project_id'], ctx.parent['task_id'])
            project = parent_obj.Project
        if parent_obj:
            parent_obj.checkStructureLock(ctx=ctx)
        cls._cdbpcs_create_from(ctx=ctx, project=project, parent_obj=parent_obj)

    @classmethod
    def _cdbpcs_create_from(cls, ctx, project=None, parent_obj=None):
        if not project or not parent_obj or not getattr(parent_obj, 'cdb_project_id', False):
            raise ue.Exception("pcs_error_create_from_context")

        parent_obj.acceptNewTask()
        if not parent_obj.CheckAccess('save'):
            raise ue.Exception("cdbpcs_no_right_to_create_task_from_template")

        if not ctx.catalog_selection:
            ctx.start_selection(catalog_name="cdbpcs_projects")
        elif "task_id" not in ctx.catalog_selection[0].get_attribute_names():
            pnumber = ctx.catalog_selection[0]["cdb_project_id"]
            targs = {"cdb_project_id": pnumber}
            # ctx.start_selection(catalog_name = "cdbpcs_tasks", **targs)
            ctx.start_selection(catalog_name="cdbpcs_task_templates", **targs)
        else:
            pnumber = ctx.catalog_selection[0]["cdb_project_id"]
            tnumber = ctx.catalog_selection[0]["task_id"]
            task_template = Task.ByKeys(pnumber, tnumber)

            parent_id = ""
            if "task_id" in parent_obj:
                parent_id = parent_obj["task_id"]

            new_project_id = parent_obj["cdb_project_id"]
            with transactions.Transaction():
                task_id_mapping_table, new_task = task_template._copy_task(ctx, new_project_id, parent_id)

                # Copy of task relations
                Task._copy_taskrels_by_mapping(pnumber, new_project_id, task_id_mapping_table)

            # Check consistency for whole project
            project.Reload()
            project.recalculate()

            project.adopt_all_project_roles_from_template(task_template=task_template)
            project.reset_invalid_subject_ids()
            if not project.msp_active:
                ctx.url(new_task.MakeURL('cdbpcs_task_reset_start_time'))

    def _copy_task(self, ctx, new_project_id, parent="", new_task=None, clear_msp_task_ids=True):
        """
        The behavior of the position numbers can be controlled via the operation parameter 'keep_positions_of_tasks',
        accessible by ctx.ue_args.

        If the position numbers of the tasks should be unchanged when creating a project from a template, the code
        of the class cs.pcs.projects.Project can be extended as follows:

        class myProject(cs.pcs.projects.Project):
            def on_copy_pre(self, ctx):
                from_template = True if getattr(ctx.ue_args, "create_project_from_template", "0") == "1" else False
                if from_template:
                    ctx.keep("keep_positions_of_tasks", "1")
                self.Super(myProject).on_copy_pre(ctx)

        If the position numbers of the tasks should be unchanged when creating a task from a template, the code
        of the class cs.pcs.projects.tasks.Task can be extended as follows:

        Note: Please make sure that the method on_cdbpcs_create_from_now exists in the parent class,
        otherwise an AttributeError will be raised.

        class myTask(Task):
            @classmethod
            def on_cdbpcs_create_from_now(cls, ctx):
                setattr(ctx.ue_args, "keep_positions_of_tasks", "1")
                super(myTask, cls).on_cdbpcs_create_from_now(ctx)

        For other use cases, the operation parameter 'keep_positions_of_tasks' can be customized using
        user exit calls of the affected operation (create=pre, copy=pre).
        """
        mapping_table = {}

        # We assume in the delivery state, no attributes are changed that determine the type
        # of the task object (class determined by the Most-Derived-Type-Discovery of the CE Server).
        cls = type(self)
        new_task_check = cls(**self._record)

        new_task_check.cdb_project_id = new_project_id
        new_task_check.parent_task = parent

        # Create a new UUID for the copied task object
        new_task_check.cdb_object_id = cdbuuid.create_uuid()

        # Reset psp_code for the copied task object
        new_task_check.psp_code = ""

        # Template object id stored to identify the original copied task
        new_task_check.template_oid = self.cdb_object_id

        # Reset status for the copied task object. Needs to be 0 to allow copy.
        new_task_check.status = 0

        # Reset position for the copied task object. Position will be set later.
        keep_positions_of_tasks = True if getattr(ctx.ue_args, "keep_positions_of_tasks", "0") == "1" else False
        if not keep_positions_of_tasks:
            new_task_check.position = ""

        # Reset start and end time values in order to avoid constraints in MSP
        proj = Project.ByKeys(new_project_id)
        if proj.msp_active:
            new_task_check.start_time_fcast = ""
            new_task_check.start_time_plan = ""
            new_task_check.end_time_fcast = ""
            new_task_check.end_time_plan = ""

        if clear_msp_task_ids:
            # Reset tuid for the copied task object
            # (identifier for transmitting task between msp and cdb)
            new_task_check.tuid = ""
            new_task_check.msp_uid = ""
            new_task_check.msp_guid = ""

        old_task_id = new_task_check.task_id
        if not new_task:
            new_task_check._create_from_pre_check(ctx)

        # Create a new task object and write it into database
        new_task_check.Update(**Task.MakeChangeControlAttributes())

        if not new_task:
            new_task = Task.Create(**new_task_check)
        new_task.Reset()

        # Mapping table for task ID (old task ID -> new task ID)
        new_task_id = new_task.task_id
        mapping_table[old_task_id] = new_task_id

        # Copy long text fields
        new_cdbpcs_task_txt = self.GetText("cdbpcs_task_txt")
        if ctx and ctx.dialog and hasattr(ctx.dialog, "cdbpcs_task_txt")\
                              and hasattr(ctx.dialog, "task_id"):
            if ctx.dialog.task_id == new_task.task_id:
                new_cdbpcs_task_txt = ctx.dialog.cdbpcs_task_txt
        new_task.SetText("cdbpcs_task_txt", new_cdbpcs_task_txt)

        # Copy sub-tasks recursively
        for task in self.SubTasks:
            task_mapping, _ = task._copy_task(ctx, new_project_id, new_task.task_id,
                                                      clear_msp_task_ids=clear_msp_task_ids)
            mapping_table.update(task_mapping)

        new_project = Project.ByKeys(new_project_id)
        self.copyRelatedObjects(new_project, new_task)

        # Check copied task
        new_task.Reload()
        new_task._create_from_post_check(ctx)
        new_task._create_from_final_check(ctx)

        return mapping_table, new_task

    def copyRelatedObjects(self, new_project, new_task):
        # Copy referenced document templates
        doc_templ_t = ddl.Table("cdbpcs_task2doctmpl")
        if doc_templ_t.exists():
            for temp_doc in self.TemplateDocRefs:
                values = new_task.KeyDict()
                values["created_at"] = None
                temp_doc.Copy(**values)

        # Copy referenced checklists
        for checklist in self.Checklists:
            new_checklist = checklist.MakeCopy(new_project, new_task)
            new_checklist.Reset()

        # Copy referenced issues
        # for issue in self.Issues:
        #     new_issue = issue.MakeCopy(new_project, new_task)
        #     new_issue.Reset()

        # Copy referenced objects (eg. resource demands)
        sig.emit(Task, "copy_task_hook")(self, new_project, new_task)

    def _create_from_pre_check(self, ctx=None):

        # Check follows before cdbpcs_create_from operation
        # 1. checkSchedule
        # 2. checkParent
        # 3. checkProjectID
        # 4. setTaskID
        # 5. setPosition

        # Check schedule
        self.checkSchedule(ctx)

        # Check parent
        self.checkParent(ctx)

        # Check project ID
        self.checkProjectID(ctx)

        # Set task ID
        self.setTaskID(ctx)

        # Set position
        self.setPosition(ctx)

    def _create_from_post_check(self, ctx=None):
        # Check follows after cdbpcs_create_from operation
        self.updateParentTask(ctx)

    def _create_from_final_check(self, ctx=None):
        # Final check after cdbpcs_create_from operation
        # 1. final_check
        self.adjust_values(adjust_parents=True, time_act=True,
                           effort_plan=True, effort_fcast=self.auto_update_effort, effort_act=True)
        self.adjust_values(adjust_parents=True, percentage=True)
        self.updateStatusSignals(effort=True)
    # == End Create From ==

    # === new class methods to optimize the calendar logic ===
    @classmethod
    def adjustCalenderChanges(cls, current_task, day_from, day_until):
        cdb_project_id = current_task["cdb_project_id"]
        task_id = current_task["task_id"]
        result = {}

        # adjust all subtasks
        sqlfrom = sqlapi.SQLdbms_date(day_from)
        sqluntil = sqlapi.SQLdbms_date(day_until)
        cond = ("cdb_project_id = '%s'"
                " AND ((end_time_fcast IS NOT NULL AND %s<=end_time_fcast)"
                "      OR (end_time_fcast IS NULL AND %s<=end_time_plan))"
                " AND ((start_time_fcast IS NOT NULL AND start_time_fcast<=%s)"
                "      OR (start_time_fcast IS NULL AND start_time_plan<=%s))"
                " AND parent_task = '%s'"
                % (sqlapi.quote(cdb_project_id),
                   sqlfrom, sqlfrom,
                   sqluntil, sqluntil,
                   sqlapi.quote(task_id)))
        chg_sub_tasks = sqlapi.RecordSet2(Task.GetTableName(), cond)
        for task in chg_sub_tasks:
            Task.adjustCalenderChanges(task, day_from, day_until)

        # TODO: also need to be called: TimeStatusSignals()?
        #       or save all the calls bcz. no date changes would be done
        status_list = [Task.NEW.status, Task.READY.status,
                       Task.EXECUTION.status, Task.FINISHED.status]
        cond = ("cdb_project_id = '%s'"
                " AND parent_task = '%s'"
                % (sqlapi.quote(cdb_project_id),
                   sqlapi.quote(task_id)))
        subtasks = sqlapi.RecordSet2(Task.GetTableName(), cond)
        if subtasks and current_task.status in status_list:
            try:
                # Nur existierende "start_time_plan" der Unteraufgaben werden aggregiert
                start_dates = map(lambda x: x.getStartTime(), subtasks)
                start_dates = filter(lambda x: x, start_dates)
                stp = min(start_dates)
            except Exception:
                stp = None
            try:
                # Nur existierende "end_time_plan" der Unteraufgaben werden aggregiert
                end_dates = map(lambda x: x.getEndTime(), subtasks)
                end_dates = filter(lambda x: x, end_dates)
                etp = max(end_dates)
            except Exception:
                etp = None

            # Neuberechung der Dauer nur vornehmen wenn Änderungen erfolgt sind
            if current_task.start_time_plan != stp or current_task.end_time_plan != etp:
                if stp:
                    result["start_time_plan"] = stp
                else:
                    result["start_time_plan"] = ''
                if etp:
                    result["end_time_plan"] = etp
                else:
                    result["end_time_plan"] = ''
        # Neuberechung von Dauer immer vornehmen, da auch
        # Kalenderänderungen die Dauer beeinflussen können
        # self.duration = self.getWorkhours()
        # Task.getWorkdays
        changed_task = dict(current_task)
        changed_task.update(result)
        wdays = cls.clsGetWorkdays(changed_task)
        result["duration"] = workday.days_to_hours(wdays)
        result["days"] = wdays
        changed_task.update(result)

        # Testen ob die Aufgabe nicht durchführbar ist
        result["work_uncovered"] = cls.isWorkUncovered(current_task, changed_task)

        # Abstandswerte der Vorgänger-/Nachfolgerbeziehungen anpassen
        # self.adjustTaskRelations()
        cond = ("cdb_project_id = '%s'"
                " AND task_id = '%s'"
                " AND rel_type='%s'"
                % (sqlapi.quote(cdb_project_id),
                   sqlapi.quote(task_id),
                   sqlapi.quote(kTaskDependencyEA)))
        ptaskrels = sqlapi.RecordSet2(TaskRelation.GetTableName(), cond)
        for con in ptaskrels:
            cls.clsAdjustGap(con)
        cond = ("cdb_project_id2 = '%s'"
                " AND task_id2 = '%s'"
                " AND rel_type='%s'"
                % (sqlapi.quote(cdb_project_id),
                   sqlapi.quote(task_id),
                   sqlapi.quote(kTaskDependencyEA)))
        staskrels = sqlapi.RecordSet2(TaskRelation.GetTableName(), cond)
        for con in staskrels:
            cls.clsAdjustGap(con)

        # check effort status:
        result["status"] = current_task.status
        effstat = Task.clsCheckResourceStatusSignals(result)
        if effstat:
            result["status_effort_fcast"] = effstat
        if result:
            current_task.update(**result)

    @classmethod
    def isWorkUncovered(cls, current_task, changed_task):
        return 0

    @classmethod
    def clsGetWorkdays(cls, task, persno=None):
        try:
            if task["milestone"]:
                return 0
            start_date = task["start_time_fcast"]
            if not start_date:
                start_date = task["start_time_plan"]
            start_date = cdbtime.Time(start_date).date()
            end_date = task["end_time_fcast"]
            if not end_date:
                end_date = task["end_time_plan"]
            end_date = cdbtime.Time(end_date).date()
            p = Project.ByKeys(task[u"cdb_project_id"])
            return Calendar.combined_workday_count(start_date=start_date,
                                                   end_date=end_date,
                                                   prj=p,
                                                   persno=persno)
        except Exception:
            misc.log_traceback("Workdays invalid")
            return 0

    @classmethod
    def clsAdjustGap(cls, obj):
        cond = ("cdb_project_id = '%s'"
                " AND task_id = '%s'"
                % (sqlapi.quote(obj["cdb_project_id"]),
                   sqlapi.quote(obj["task_id2"])))
        ptaskt = sqlapi.RecordSet2(Task.GetTableName(), cond, ["end_time_plan"])
        cond = ("cdb_project_id = '%s'"
                " AND task_id = '%s'"
                % (sqlapi.quote(obj["cdb_project_id"]),
                   sqlapi.quote(obj["task_id"])))
        staskt = sqlapi.RecordSet2(Task.GetTableName(), cond, ["start_time_plan"])
        if len(ptaskt) and len(staskt):
            petpd = cdbtime.Time(ptaskt[0].end_time_plan).date()
            sstpd = cdbtime.Time(staskt[0].start_time_plan).date()
            if petpd and sstpd:
                petp = workday.next_day(petpd, 1)
                sstp = workday.next_day(sstpd, -1)
                gap = len(Calendar.project_workdays(cdb_project_id=obj["cdb_project_id"],
                                                    start_date=petp,
                                                    end_date=sstp))
                obj.update(gap=gap)

    def getEffortAggr(self):
        if not self.isValid():
            return 0.0
        if self.effort_fcast:
            return self.effort_fcast
        if self.effort_plan:
            return self.effort_plan
        return 0.0

    def getEffortAvailable(self):
        result = 0.0
        if self.effort_fcast:
            result = self.effort_fcast
        else:
            result = self.getEffortMax()
        if self.is_group and self.effort_plan:
            result -= self.effort_plan
        return result

    def getEffortMax(self):
        parentobj = self.getParent()
        emax = self.getEffortAggr()
        if parentobj:
            emax += parentobj.getEffortAvailable()
        return max(0.0, emax)

    def calculateTimeFrame(self, start=None, end=None, days=None, shift_right=True):
        calendar_profile_id = None
        if self.Project:
            calendar_profile_id = self.Project.calendar_profile_id
        if not days and self.automatic:
            days = int(not self.milestone)
        start, end, hours, days = Calendar.calculateTimeFrame(calendar_profile_id,
                                                              start=start, end=end, days=days,
                                                              shift_right=shift_right,
                                                              milestone=self.milestone)
        if not start and not end and self.is_group and self.auto_update_time:
            days = None
            hours = None
        return start, end, hours, days

    def changeDuration(self, ctx):
        self.setDaysFcast(ctx=ctx, days=self.days_fcast)

    def changeStartTime(self, ctx):
        self.setStartTimeFcast(ctx=ctx, start=self.start_time_fcast)

    def changeEndTime(self, ctx):
        self.setEndTimeFcast(ctx=ctx, end=self.end_time_fcast)

    # create/copy/modify: post_mask
    def checkEffortFields(self, ctx):
        # if no children: aggregate values = plan values = forecast values
        if not self.SubTasks:
            if self.effort_plan != self.effort_fcast:
                self.effort_plan = self.effort_fcast
            if self.start_time_fcast is None:
                self.start_time_fcast = ""
            if self.start_time_plan != self.start_time_fcast:
                self.start_time_plan = self.start_time_fcast
            if self.end_time_fcast is None:
                self.end_time_fcast = ""
            if self.end_time_plan != self.end_time_fcast:
                self.end_time_plan = self.end_time_fcast

        # start/end must be filled jointly
        if (self.start_time_fcast and not self.end_time_fcast) or \
            (not self.start_time_fcast and self.end_time_fcast):
            raise ue.Exception("pcs_capa_err_025")

        # Allow other components to check preconditions before modifying a task
        sig.emit(Task, "checkEffortFields")(self)

        if ctx.action == "modify":
            if "start_time_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.start_time_fcast != ctx.object.start_time_fcast:
                ctx.keep("_time_fcast_changed", 1)
            if "end_time_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.end_time_fcast != ctx.object.end_time_fcast:
                ctx.keep("_time_fcast_changed", 1)
            if "effort_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.effort_fcast != ctx.object.effort_fcast:
                ctx.keep("_effort_fcast_changed", 1)
        if ctx.action == "copy":
            if "start_time_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.start_time_fcast != ctx.cdbtemplate.start_time_fcast:
                ctx.keep("_time_fcast_changed", 1)
            if "end_time_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.end_time_fcast != ctx.cdbtemplate.end_time_fcast:
                ctx.keep("_time_fcast_changed", 1)
            if "effort_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.effort_fcast != ctx.cdbtemplate.effort_fcast:
                ctx.keep("_effort_fcast_changed", 1)

    @classmethod
    def getDemandStartTimeFieldName(cls):
        return "start_time_fcast"

    @classmethod
    def getDemandEndTimeFieldName(cls):
        return "end_time_fcast"

    @classmethod
    def getAssignmentStartTimeFieldName(cls):
        return "start_time_fcast"

    @classmethod
    def getAssignmentEndTimeFieldName(cls):
        return "end_time_fcast"

    def autoSetDemandTime(self, ctx=None):
        # Set missing DemandTimeStart/DemandTimeEnd automatically
        # Fieldnames must be changed if getDemand...TimeFieldName() changed
        if not self.start_time_fcast or not self.end_time_fcast:
            self.getPersistentObject().start_time_fcast = self.start_time_plan
            self.getPersistentObject().end_time_fcast = self.end_time_plan
            self.updateStatusSignals(time=True)

    def autoSetAssignmentTime(self, ctx=None):
        # Set missing AssignmentTimeStart/AssignmentTimeEnd automatically
        # Fieldnames must be changed if getAssignment...TimeFieldName() changed
        if not self.start_time_fcast or not self.end_time_fcast:
            self.getPersistentObject().start_time_fcast = self.start_time_plan
            self.getPersistentObject().end_time_fcast = self.end_time_plan
            self.updateStatusSignals(time=True)

    def getDemandStartTime(self):
        return self[self.getDemandStartTimeFieldName()]

    def getDemandEndTime(self):
        return self[self.getDemandEndTimeFieldName()]

    def getAssignmentStartTime(self):
        return self[self.getAssignmentStartTimeFieldName()]

    def getAssignmentEndTime(self):
        return self[self.getAssignmentEndTimeFieldName()]

    def getStartTimeAggr(self):
        return self.start_time_fcast if self.start_time_fcast else self.start_time_plan

    def getEndTimeAggr(self):
        return self.end_time_fcast if self.end_time_fcast else self.end_time_plan

    def getEffortForeCast(self):
        if not self.isValid():
            return 0.0
        return self.effort_fcast

    def getEffortPlan(self):
        if not self.isValid():
            return 0.0
        return self.effort_plan

    def getStartTimeFcast(self):
        return self.start_time_fcast

    def getStartTimePlan(self):
        return self.start_time_plan

    def getEndTimeFcast(self):
        return self.end_time_fcast

    def getEndTimePlan(self):
        return self.end_time_plan

    def getStartTimeTopDown(self):
        if self.ParentTask:
            if self.ParentTask.start_time_fcast:
                return self.ParentTask.start_time_fcast
            else:
                return self.ParentTask.getStartTimeTopDown()
        elif self.Project:
            return self.Project.start_time_fcast
        else:
            return None

    def getEndTimeTopDown(self):
        if self.ParentTask:
            if self.ParentTask.end_time_fcast:
                return self.ParentTask.end_time_fcast
            else:
                return self.ParentTask.getEndTimeTopDown()
        elif self.Project:
            return self.Project.end_time_fcast
        else:
            return None

    def getStartTime(self):
        return self.start_time_fcast if self.start_time_fcast else self.start_time_plan

    def getEndTime(self):
        return self.end_time_fcast if self.end_time_fcast else self.end_time_plan

    @classmethod
    def clsCheckResourceStatusSignals(cls, obj, ctx=None):
        # Check effort status after calendar changes
        # work_uncovered => red
        if obj and Task.isFinalStatus(obj["status"]) and obj["work_uncovered"] == 1:
            return 3
        else:
            return 0

    def getPredecessorTasks(self, dependency=kTaskDependencyEA):
        return map(lambda x: x.PredecessorTask, self.PredecessorTaskRelationsByType[dependency])

    def check_Project_State(self, ctx):
        if self.Project:
            st = self.Project.status
            if st == Project.COMPLETED.status or st == Project.DISCARDED.status:
                raise ue.Exception("cdbpcs_check_proj_status")

    def setTemplateOID(self, ctx=None):
        if not ctx or ctx.action == u"delete":
            sqlapi.SQLupdate(u"cdbpcs_task SET template_oid = '' WHERE template_oid = '%s'"
                             % self.cdb_object_id)

    def check_deepdelete(self, reason=False):
        u''' Returns a list of objects which could block the deletion of the Task
        '''
        import operator

        result = []
        if self.status != Task.NEW.status:
            text = u"Task %s" + (u"" if not reason else u" (%s)" % util.get_label("cdbpcs_notplanned"))
            result.append(text % self.GetDescription())

        # Vorgänger-Nachfolger
        if (self.PredecessorTaskRelationsByType[kTaskDependencyAE] or self.PredecessorTaskRelationsByType[kTaskDependencyEE]) and (self.SuccessorTaskRelationsByType[kTaskDependencyAE] or self.SuccessorTaskRelationsByType[kTaskDependencyAA]):
            for pre in self.PredecessorTaskRelationsByType[kTaskDependencyAE] + self.PredecessorTaskRelationsByType[kTaskDependencyEE]:
                text = u"Vorgänger: %s" + (u"" if not reason else u" (%s)" % util.get_label("cdbpcs_delete_vnrels"))
                result.append(text % pre.GetDescription())

            for succ in self.SuccessorTaskRelationsByType[kTaskDependencyAE] + self.SuccessorTaskRelationsByType[kTaskDependencyAA]:
                text = u"Nachfolger: %s" + (u"" if not reason else u" (%s)" % util.get_label("cdbpcs_delete_vnrels"))
                result.append(text % succ.GetDescription())

        # Timesheets
        result += [ts.GetDescription() for ts in self.TimeSheets]

        # Checklists
        text = u"%s" + (u"" if not reason else u" (%s)" % util.get_label("cdbpcs_hassubcl"))
        result += [text % cl.GetDescription() for cl in self.Checklists if
                   [clit for clit in cl.ChecklistItems if clit.SubChecklists]]

        text = u"%s" + (u"" if not reason else u" (%s)" % util.get_label("cdbpcs_rated"))
        result += [text % cl.GetDescription() for cl in self.Checklists if
                   [clit for clit in cl.ChecklistItems if clit.Rating]]

        result_sub = [subtask.check_deepdelete(reason) for subtask in self.SubTasks]
        if result_sub:
            result += reduce(operator.add, result_sub)

        return result

    def ask_delete(self, ctx, message):
        msgbox = ctx.MessageBox("cdbpcs_delete_confirm", [message], "force_delete")
        msgbox.addYesButton(1)
        msgbox.addNoButton()

        ctx.show_message(msgbox)

    def ask_remove_date_values(self, ctx):
        msgbox = ctx.MessageBox("cdbpcs_remove_dates_confirm", [], "remove_date_values")
        msgbox.addYesButton(1)
        msgbox.addCancelButton()

        ctx.show_message(msgbox)

    def prepare_delete(self, ctx):
        dependancies = self.check_deepdelete()
        if dependancies and not "force_delete" in ctx.dialog.get_attribute_names():
            message = u'\n'.join(dependancies)
            self.ask_delete(ctx, message)

        elif not dependancies or dependancies and ctx.dialog.force_delete == "1":
            args = {}
            if "force_delete" in ctx.dialog.get_attribute_names():
                args['force_delete'] = ctx.dialog.force_delete

            # Reset status
            self.Reset()

            # delete timesheets
            for ts in self.TimeSheets:
                ts.Delete()

            # reset checklists
            for cl in self.Checklists:
                cl.Reset()

            # iterate on subtasks
            for subtask in self.SubTasks:
                operation("task_delete", subtask, **args)

            ctx.set_followUpOperation(kOperationDelete, op_object=self)

    def msp_delete(self):
        # iterate on subtasks
        for subtask in self.SubTasks:
            subtask.msp_delete()

        args = {"active_integration": "OfficeLink"}
        operation(kOperationDelete, self, system_args(**args))

    def GetActivityStreamTopics(self, posting):
        u'''
        Activity Stream postings should be assigned
        to the project and the object itself.
        '''
        return [self, self.Project]

    def addQCArguments(self, args):
        args.update(cdb_project_id=self.cdb_project_id)

    def on_cdbpcs_new_subtask_now(self, ctx):
        create_msg = cmsg.Cdbcmsg("cdbpcs_task", kOperationNew, True)
        create_msg.add_item('cdb_project_id', 'cdbpcs_task', self.cdb_project_id)
        create_msg.add_item('parent_task', 'cdbpcs_task', self.task_id)
        ctx.url(create_msg.eLink_url())

    def getResponsiblePersons(self):
        if self.Subject:
            return [s.personalnummer for s in self.Subject.getPersons()]
        return []

    def recalculation_after_state_change(self, ctx):
        if not ctx.batch:
            self.recalculate()

    def check_project_role_needed(self, ctx):
        self.Project.check_project_role_needed(ctx)

    event_map = {
        (('create', 'copy'), 'pre_mask'): ("checkStructureLock", "setDefaults", "checkSchedule",
                                           "checkParent", "setInitValues", "check_Project_State"),
        (('modify'), 'pre_mask'): ("setInitValues"),
        (('info'), 'pre_mask'): ("setInitValues"),
        (('create', 'copy', 'modify'), 'dialogitem_change'): ("dialog_item_change"),
        (('create', 'copy'), 'post_mask'): ("checkTaskId"),
        (('create'), 'post_mask'): ("checkEfforts",
                                    "checkEffortFields", "checkForSubProjects"),
        (('copy', 'modify'), 'post_mask'): ("checkEffortFields"),
        (('create', 'copy', 'modify'), 'post_mask'): "checkConstraints",
        (('copy', 'modify'), 'pre'): ("checkParent", "checkEfforts", "recalculate_preparation"),
        (('create', 'copy'), 'pre'): ("checkStructureLock", "setObjectart", "checkSchedule", "checkParent",
                                      "checkProjectID", "setTaskID", "setPosition", "check_Project_State"),
        (('delete'), 'pre'): ("checkStructureLock", "checkSchedule"),
        (('create'), 'post'): ("updateParentTask", "recalculate", "final_check", "check_project_role_needed"),
        (('copy'), 'post'): ("updateParentTask", "recalculate", "check_project_role_needed"),
        (('modify'), 'post'): ("recalculate", "final_check", "check_project_role_needed"),
        (('delete'), 'post'): ("updateParentTask", "setTemplateOID", "recalculate", "final_check",
                               "check_project_role_needed"),
        (('task_delete'), 'pre'): ("checkStructureLock"),
        (('task_delete'), 'now'): ("checkStructureLock", "prepare_delete"),
        (('state_change'), 'post'): ("recalculation_after_state_change", "check_project_role_needed"),
        }


class SecureTaskBase(object):
    def __init__(self, prj_id):
        self.prj = prj_id

    def __enter__(self):
        # ttysetattr etc goes here before opening and returning the file object
        self.transaction_id = self.setTaskBase()
        return self

    def __exit__(self, exception_type, exception_value, traceback):
        # Exception handling here
        if exception_type is None:
            self.markTaskBaseChanges()
            Project._mark_changed_project(self.prj)
        self.deleteTaskBase()

    def setTaskBase(self):
        kwargs = {}
        kwargs[u"transaction_id"] = cdbuuid.create_uuid()
        kwargs[u"prj_id"] = self.prj
        kwargs[u"attrs"] = ', '.join(BASE_ATTRIBUTES)
        sql = u"""INTO cdbpcs_task_b (transaction_id, task_oid, cdb_project_id, task_id, %(attrs)s)
                  SELECT '%(transaction_id)s', cdb_object_id, cdb_project_id, task_id, %(attrs)s
                  FROM cdbpcs_task WHERE cdb_project_id = '%(prj_id)s'""" % kwargs
        sqlapi.SQLinsert(sql)
        return kwargs[u"transaction_id"]

    def deleteTaskBase(self):
        sqlapi.RecordSet2(sql=u"DELETE FROM cdbpcs_task_b WHERE transaction_id = '%s'" % self.transaction_id)

    def getTaskBaseDiff(self):
        kwargs = {}
        kwargs[u"transaction_id"] = self.transaction_id
        conds = [u"a.{0} != b.{0}".format(x) for x in BASE_ATTRIBUTES]
        kwargs[u"cond"] = ' OR '.join(conds)
        sql = u"""SELECT b.task_oid FROM cdbpcs_task a, cdbpcs_task_b b
                  WHERE b.transaction_id = '%(transaction_id)s'
                  AND b.task_oid = a.cdb_object_id
                  AND (%(cond)s)""" % kwargs
        result = sqlapi.RecordSet2(sql=sql)
        return [u"%(task_oid)s" % x for x in result]

    def markTaskBaseChanges(self):
        task_oids = self.getTaskBaseDiff()
        Task._mark_changed_tasks(task_oids=task_oids)


class TaskRelation(Object):
    __maps_to__ = "cdbpcs_taskrel"

    PredecessorProject = Reference(1, Project, TaskRelation.cdb_project_id2)
    SuccessorProject = Reference(1, Project, TaskRelation.cdb_project_id)
    PredecessorTask = Reference(1, Task, TaskRelation.cdb_project_id2, TaskRelation.task_id2)
    SuccessorTask = Reference(1, Task, TaskRelation.cdb_project_id, TaskRelation.task_id)
    RelType = Reference(1, TaskRelationType, TaskRelation.rel_type)

    def getLateFinish(self):
        if self.rel_type == kTaskDependencyEA and self.SuccessorTask.start_time_fcast:
            return workday.next_day(self.SuccessorTask.getStartDateFcast(), -1)
        if self.rel_type == kTaskDependencyEE and self.SuccessorTask.end_time_fcast:
            return self.SuccessorTask.getEndDateFcast()
        return None

    def getLateStart(self):
        if self.rel_type == kTaskDependencyAA and self.SuccessorTask.start_time_fcast:
            return self.SuccessorTask.getStartDateFcast()
        if self.rel_type == kTaskDependencyAE and self.SuccessorTask.end_time_fcast:
            return self.SuccessorTask.getEndDateFcast()
        return None

    def getEarlyFinish(self):
        if self.rel_type == kTaskDependencyEE and self.PredecessorTask.end_time_fcast:
            return self.PredecessorTask.getEndDateFcast()
        if self.rel_type == kTaskDependencyAE and self.PredecessorTask.start_time_fcast:
            return self.PredecessorTask.getStartDateFcast()
        return None

    def getEarlyStart(self):
        if self.rel_type == kTaskDependencyEA and self.PredecessorTask.end_time_fcast:
            return workday.next_day(self.PredecessorTask.getEndDateFcast(), 1)
        if self.rel_type == kTaskDependencyAA and self.PredecessorTask.start_time_fcast:
            return self.PredecessorTask.getStartDateFcast()
        return None

    def checkRelation(self, ctx):
        if self.cdb_project_id2 == self.cdb_project_id and self.task_id2 == self.task_id:
            raise ue.Exception("cdbpcs_taskrel_same_task")
        if self.SuccessorTask.is_group and not self.rel_type in ALLOWED_TASK_GROUP_DEPENDECIES:
            raise util.ErrorMessage("just_a_replacement", util.get_label('cdbpcs_task_group_rel_not_allowed'))

    def checkSchedule(self, ctx):
        # self.PredecessorProject.checkScheduleLock()
        # self.SuccessorProject.checkScheduleLock()
        pass

    def setOIDs(self, ctx=None):
        obj = TaskRelation.ByKeys(**self)
        if not obj:
            return
        kwargs = {}
        if obj.PredecessorProject and obj.pred_project_oid != obj.PredecessorProject.cdb_object_id:
            kwargs["pred_project_oid"] = obj.PredecessorProject.cdb_object_id
        if obj.SuccessorProject and obj.succ_project_oid != obj.SuccessorProject.cdb_object_id:
            kwargs["succ_project_oid"] = obj.SuccessorProject.cdb_object_id
        if obj.PredecessorTask and obj.pred_task_oid != obj.PredecessorTask.cdb_object_id:
            kwargs["pred_task_oid"] = obj.PredecessorTask.cdb_object_id
        if obj.SuccessorTask and obj.succ_task_oid != obj.SuccessorTask.cdb_object_id:
            kwargs["succ_task_oid"] = obj.SuccessorTask.cdb_object_id
        if self.cross_project != int(obj.pred_project_oid != obj.succ_project_oid):
            kwargs["cross_project"] = int(obj.pred_project_oid != obj.succ_project_oid)
        if kwargs:
            obj.Update(**kwargs)

    def isViolated(self):
        return self.violation

    @classmethod
    def createRelation(cls, **kwargs):
        return operation(kOperationNew, TaskRelation, **kwargs)

    @classmethod
    def copyRelations(cls, old_cdb_project_id, new_cdb_project_id):
        kwargs = {u"cdb_project_id": new_cdb_project_id,
                  u"cdb_project_id2": new_cdb_project_id}
        taskrelations = TaskRelation.KeywordQuery(cdb_project_id=old_cdb_project_id, cdb_project_id2=old_cdb_project_id)
        for taskrel in taskrelations:
            operation(kOperationCopy, taskrel, **kwargs)

    @classmethod
    def deleteRelations(cls, cdb_project_id):
        taskrelations = TaskRelation.KeywordQuery(cdb_project_id=cdb_project_id) + TaskRelation.KeywordQuery(cdb_project_id2=cdb_project_id)
        for taskrel in taskrelations:
            operation(kOperationDelete, taskrel)

    @classmethod
    def compose(cls, lhs, rhs):
        if lhs.SuccessorTask != rhs.PredecessorTask:
            return None
        else:
            task = lhs.SuccessorTask

        composition_type = TaskRelationType.composeTypes(lhs.rel_type, rhs.rel_type)

        if composition_type:
            if (composition_type != "AA" or lhs.PredecessorTask != task.ParentTask) and (composition_type != "EE" or rhs.SuccessorTask != task.ParentTask):
                args = {"cdb_project_id": rhs.cdb_project_id,
                        "cdb_project_id2": lhs.cdb_project_id,
                        "task_id2": lhs.task_id2,
                        "task_id": rhs.task_id,
                        "rel_type": composition_type
                        }
                query = TaskRelation.Query(**args)
                if not query:
                    operation(kOperationNew, TaskRelation, **args)

    def check_for_taskrel_cycles(self, ctx):
        if self.cdb_project_id == self.cdb_project_id2:
            cycle = Task._check_task_rel_cycles(self.cdb_project_id, (self.task_id2, self.task_id, self.rel_type))
            cycle2 = Task._check_task_rel_special_case(self.cdb_project_id, (self.task_id2, self.task_id, self.rel_type))
            cycle3 = Task._check_task_rel_parent_cycles(self.cdb_project_id, (self.task_id2, self.task_id, self.rel_type))
            cycle = cycle or cycle2 or cycle3
            if cycle:
                raise AbortMessage("cdbpcs_taskrel_cycle")

    def _fill_oid_fields(self, ctx):
        dlg_fields = ctx.dialog.get_attribute_names()
        if ('cdb_project_id2' in dlg_fields and 'pred_project_oid' in dlg_fields
                and ctx.dialog.cdb_project_id2 and not ctx.dialog.pred_project_oid):
            pred_project = Project.ByKeys(ctx.dialog.cdb_project_id2)
            if pred_project:
                ctx.set('pred_project_oid', pred_project.cdb_object_id)
        if ('cdb_project_id2' in dlg_fields and 'task_id2' in dlg_fields
                and 'pred_task_oid' in dlg_fields
                and ctx.dialog.cdb_project_id2 and ctx.dialog.task_id2
                and not ctx.dialog.pred_task_oid):
            pred_task = Task.ByKeys(ctx.dialog.cdb_project_id2, ctx.dialog.task_id2)
            if pred_task:
                ctx.set('pred_task_oid', pred_task.cdb_object_id)
        if ('cdb_project_id' in dlg_fields and 'succ_project_oid' in dlg_fields
                and ctx.dialog.cdb_project_id and not ctx.dialog.succ_project_oid):
            succ_project = Project.ByKeys(ctx.dialog.cdb_project_id)
            if succ_project:
                ctx.set('succ_project_oid', succ_project.cdb_object_id)
        if ('cdb_project_id' in dlg_fields and 'task_id' in dlg_fields
                and 'succ_task_oid' in dlg_fields
                and ctx.dialog.cdb_project_id and ctx.dialog.task_id
                and not ctx.dialog.succ_task_oid):
            succ_task = Task.ByKeys(ctx.dialog.cdb_project_id, ctx.dialog.task_id)
            if succ_task:
                ctx.set('succ_task_oid', succ_task.cdb_object_id)

    def checkStructureLock(self, ctx=None):
        if self.cdb_project_id and self.cdb_project_id == self.cdb_project_id2:
            self.PredecessorProject.checkStructureLock(ctx=ctx)

    def adjustSuccessorStatus(self, ctx):
        if ctx.error:
            return
        self.PredecessorTask.adjustSuccessorStatus()

    def recalculate(self, ctx=None):
        if ctx.action in ["create", "delete"]:
            changes = Task.MakeChangeControlAttributes()
            self.SuccessorTask.Update(**changes)
            self.PredecessorTask.Update(**changes)

        changes = {}
        cca = Project.MakeChangeControlAttributes()
        changes.update(cdb_mdate=cca[u"cdb_mdate"])
        changes.update(cdb_mpersno=cca[u"cdb_mpersno"])
        self.PredecessorProject.recalculate()
        self.PredecessorProject.Update(**changes)
        if self.cdb_project_id != self.cdb_project_id2:
            self.SuccessorProject.recalculate()
            self.SuccessorProject.Update(**changes)

    NUMBER_OF_PROJECTS_FOR_SETTING_TASK_SELECTION_READONLY = 50
    _ATTRIBUTES_FOR_TASK_SELECTION_READONLY = {'cdb_project_id': 'task_id',
                                               'cdb_project_id2': 'task_id2'}

    @property
    def is_task_selection_enabled(self):
        return len(Project.Query()) > self.NUMBER_OF_PROJECTS_FOR_SETTING_TASK_SELECTION_READONLY

    def set_task_selection_readonly(self, ctx):
        if not self.is_task_selection_enabled:
            return
        for attr in [attr for attr in self._ATTRIBUTES_FOR_TASK_SELECTION_READONLY.itervalues()
                     if not getattr(self, attr, False)]:
            ctx.set_fields_readonly([attr])

    def set_task_selection(self, ctx):
        if not self.is_task_selection_enabled:
            return
        if ctx.changed_item in self._ATTRIBUTES_FOR_TASK_SELECTION_READONLY.iterkeys():
            if getattr(self, ctx.changed_item, None):
                ctx.set_fields_writeable([self._ATTRIBUTES_FOR_TASK_SELECTION_READONLY[ctx.changed_item]])
            else:
                ctx.set_fields_readonly([self._ATTRIBUTES_FOR_TASK_SELECTION_READONLY[ctx.changed_item]])

    event_map = {
        (('create', 'copy'), 'pre_mask'): ("checkStructureLock", "checkSchedule", "set_task_selection_readonly"),
        (('create', 'copy'), 'pre'): ("checkStructureLock", "checkSchedule", "check_for_taskrel_cycles"),
        (('delete'), 'pre'): ("checkStructureLock", "checkSchedule"),
        (('create', 'copy', 'modify'), 'post_mask'): "checkRelation",
        (('create', 'copy'), 'post'): ("setOIDs", "recalculate", "adjustSuccessorStatus"),
        (('delete'), 'post'): ("recalculate", "adjustSuccessorStatus"),
        (('modify'), 'post'): "recalculate",
        (('create', 'copy', 'query', 'requery'), 'pre_mask'): "_fill_oid_fields",
        (('create', 'copy'), 'dialogitem_change'): 'set_task_selection'
        }


class TaskRelationType(Object):
    __maps_to__ = "cdbpcs_tr_types"
    __classname__ = "cdbpcs_tr_types"

    @classmethod
    def getTypeLabels(cls):
        lang = CADDOK.get('ISOLANG', 'en')
        if lang == 'de':
            return {'AA': 'AA',
                    'EA': 'EA',
                    'AE': 'AE',
                    'EE': 'EE'}
        return {'AA': 'SS',
                'EA': 'FS',
                'AE': 'SF',
                'EE': 'FF'}

    @classmethod
    def composeTypes(cls, type1, type2):
        if type1[1] + type2[0] == "EA":
            return None
        else:
            return type1[0] + type2[1]


class TaskCategory(Object):
    __maps_to__ = "cdbpcs_task_cat"


class CatalogPCSResponsibleData(gui.CDBCatalogContent):
    def __init__(self, cdb_project_id, catalog):
        tabdefname = catalog.getTabularDataDefName()
        self.cdef = catalog.getClassDefSearchedOn()
        if self.cdef:
            tabdef = self.cdef.getProjection(tabdefname, True)
        else:
            tabdef = tabdefname

        gui.CDBCatalogContent.__init__(self, tabdef)
        self.cdb_project_id = cdb_project_id
        self.data = None

    def _initData(self, refresh=False):
        if not self.data or refresh:
            condition = self.getSQLCondition()
            self.data = sqlapi.RecordSet2("cdbpcs_resp_brows", "%s" % condition, addtl=" ORDER BY order_by")

    def onSearchChanged(self):
        self._initData(True)

    def refresh(self):
        self._initData(True)

    def getNumberOfRows(self):
        self._initData()
        return len(self.data)

    def getRowObject(self, row):
        if not self.cdef:
            return gui.CDBCatalogContent.getRowObject(self, row)
        else:
            self._initData()
            keys = mom.SimpleArgumentList()
            for keyname in self.cdef.getKeyNames():
                keys.append(mom.SimpleArgument(keyname, self.data[row][keyname]))
            return mom.CDBObjectHandle(self.cdef, keys, False, True)

    def _get_value(self, rec, attr):
        """
        Retrieves the value of `attr` from the record `rec`-
        """
        result = u""
        if self.cdef:
            adef = self.cdef.getAttributeDefinition(attr)
            for db_name in adef.getSQLSelectNames():
                result = rec[db_name]
                if result:
                    break
        else:
            result = rec[attr]
        return typeconversion.to_untyped_c_api(result)

    def getRowData(self, row):
        self._initData()
        result = []
        tdef = self.getTabDefinition()
        for col in tdef.getColumns():
            attr = col.getAttribute()
            value = u""
            try:
                obj = self.data[row]
                value = self._get_value(obj, attr)
                if not value:
                    value = u""
                if attr.startswith(u"description"):
                    # Append the persons. who own, the role
                    if (obj["subject_type"] == "PCS Role"):
                        r = Role.BySubjectReferrer(obj)
                        if (r.Owners):
                            value += u" ("
                            for owner in r.Owners:
                                value += owner.getSubjectName()
                                if (len(value) > 256):
                                    value += u"/ ... / "
                                    break
                                value += u"/ "

                            value = value[:-2]
                            value += u")"

            except Exception:
                value = u""
            result.append(value)
        return result


class CatalogPCSResponsible(gui.CDBCatalog):
    def __init__(self):
        gui.CDBCatalog.__init__(self)

    def init(self):
        # if the project is known, we fill the catalog on our own
        cdb_project_id = ""
        try:
            cdb_project_id = self.getInvokingDlgValue("cdb_project_id")
        except Exception:
            pass

        if cdb_project_id:
            self.setResultData(CatalogPCSResponsibleData(cdb_project_id, self))


class CatalogPCSTeamMemberData(gui.CDBCatalogContent):
    def __init__(self, cdb_project_id, catalog):
        tabdefname = catalog.getTabularDataDefName()
        self.cdef = catalog.getClassDefSearchedOn()
        if self.cdef:
            tabdef = self.cdef.getProjection(tabdefname, True)
        else:
            tabdef = tabdefname

        gui.CDBCatalogContent.__init__(self, tabdef)
        self.cdb_project_id = cdb_project_id
        self.data = None
        self.personalnummer = None

    def getSQLCondition(self, *args):
        # TODO: structure browser should also be adjusted to filter persons with active_account=1
        condition = u"is_resource=1 and active_account='1' and visibility_flag=1"
        if self.personalnummer:
            condition += u" AND personalnummer LIKE '%s'" % (self.personalnummer).replace(u"*", u"%")
        if self.cdb_project_id:
            condition += u" AND personalnummer IN (SELECT cdb_person_id FROM cdbpcs_team WHERE cdb_project_id='%s')" % self.cdb_project_id
        return condition

    def _initData(self, refresh=False):
        if not self.data or refresh:
            condition = self.getSQLCondition()
            # self.data = sqlapi.RecordSet2("cdb_person_v", "%s" % condition)
            self.data = sqlapi.RecordSet2("angestellter", "%s" % condition)

    def onSearchChanged(self):
        args = self.getSearchArgs()
        self.cdb_project_id = None
        self.personalnummer = None
        for argn in args:
            if argn.name == "personalnummer":
                self.personalnummer = argn.value
        self._initData(True)

    def refresh(self):
        self._initData(True)

    def getNumberOfRows(self):
        self._initData()
        return len(self.data)

    def getRowObject(self, row):
        if not self.cdef:
            return gui.CDBCatalogContent.getRowObject(self, row)
        else:
            from cdb.platform import mom
            self._initData()
            keys = mom.SimpleArgumentList()
            for keyname in self.cdef.getKeyNames():
                keys.append(mom.SimpleArgument(keyname, self.data[row][keyname]))
            return mom.CDBObjectHandle(self.cdef, keys, False, True)


class CatalogPCSTeamMember(gui.CDBCatalog):
    def __init__(self):
        gui.CDBCatalog.__init__(self)

    def init(self):
        # if the project is known, we fill the catalog on our own
        cdb_project_id = ""
        try:
            cdb_project_id = self.getInvokingDlgValue("cdb_project_id")

        except Exception:
            pass

        if cdb_project_id:
            self.setResultData(CatalogPCSTeamMemberData(cdb_project_id, self))


class TaskBase(Object):
    __maps_to__ = "cdbpcs_task_b"
    __classname__ = "cdbpcs_task_b"


class AbortMessage(ue.Exception):
    pass


@classbody
class Action(object):
    Task = Reference_1(Task, Action.cdb_project_id, Action.task_id)


class CriticalPath(object):

    def __init__(self, prj_id):
        self.project = Project.ByKeys(prj_id)
        self.calendar_profile_id = self.project.calendar_profile_id if self.project else None
        self.tasksByID = defaultdict(dict)
        self.early_start = defaultdict(list)
        self.early_finish = defaultdict(list)
        self.late_start = defaultdict(list)
        self.late_finish = defaultdict(list)
        self.gaps = defaultdict(list)
        sql = "SELECT * FROM cdbpcs_taskrel WHERE cdb_project_id = '%(prj_id)s' OR cdb_project_id2 = '%(prj_id)s'" % locals()
        self.taskrels = sqlapi.RecordSet2(table="cdbpcs_taskrel", sql=sql)
        ids = []
        for t in self.taskrels:
            ids.append(t['pred_task_oid'])
            ids.append(t['succ_task_oid'])
        ids = list(set(ids))
        self.tasks = Task.KeywordQuery(cdb_object_id=ids)
        for t in self.tasks:
            self.tasksByID[t["cdb_project_id"]][t["task_id"]] = t
        self.calendar_by_day, self.calendar_by_idx = Calendar.getCalendarIndex(calendar_profile_id=self.calendar_profile_id)
        self.calculateValues()

    def minIndex(self, indexes):
        return max(min(indexes), 1)

    def maxIndex(self, indexes):
        return min(max(indexes), len(self.calendar_by_idx))

    def update(self):
        change_args = Task.MakeChangeControlAttributes()
        kwargs = {}
        kwargs["cdb_apersno"] = change_args["cdb_mpersno"]
        kwargs["cdb_adate"] = change_args["cdb_mdate"]
        for t in self.tasks:
            my_id = t["cdb_project_id"] + t["task_id"]
            changes = {}
            es = self.early_start[my_id]
            if es:
                es = self.maxIndex(es)
                if t["early_start"] != es:
                    changes["early_start"] = self.calendar_by_idx[es]
            else:
                if t["early_start"]:
                    changes["early_start"] = ''
            ef = self.early_finish[my_id]
            if ef:
                ef = self.maxIndex(ef)
                if t["early_finish"] != ef:
                    changes["early_finish"] = self.calendar_by_idx[ef]
            else:
                if t["early_finish"]:
                    changes["early_finish"] = ''
            ls = self.late_start[my_id]
            if ls:
                ls = self.minIndex(ls)
                if t["late_start"] != ls:
                    changes["late_start"] = self.calendar_by_idx[ls]
            else:
                if t["late_start"]:
                    changes["late_start"] = ''
            lf = self.late_finish[my_id]
            if lf:
                lf = self.minIndex(lf)
                if t["late_finish"] != lf:
                    changes["late_finish"] = self.calendar_by_idx[lf]
            else:
                if t["late_finish"]:
                    changes["late_finish"] = ''
            if changes:
                changes.update(kwargs)
                t.Update(**changes)
        for tr, gap in self.gaps.items():
            tr.update(gap=gap, violation=int(gap < tr.minimal_gap))

    def calculateValues(self):
        for tr in self.taskrels:
            succ = self.tasksByID[tr['cdb_project_id']][tr['task_id']]
            pred = self.tasksByID[tr['cdb_project_id2']][tr['task_id2']]
            rel_type = tr['rel_type']
            minimal_gap = 0
            if tr['minimal_gap']:
                minimal_gap = tr['minimal_gap']
            es, ef, ls, lf, gap = CriticalPath._getValues(pred, rel_type, succ, self.calendar_by_day, minimal_gap)
            if es:
                self.early_start[succ["cdb_project_id"] + succ["task_id"]].append(es)
            if ef:
                self.early_finish[succ["cdb_project_id"] + succ["task_id"]].append(ef)
            if ls:
                self.late_start[pred["cdb_project_id"] + pred["task_id"]].append(ls)
            if lf:
                self.late_finish[pred["cdb_project_id"] + pred["task_id"]].append(lf)
            if gap != tr['gap']:
                self.gaps[tr] = gap

    @classmethod
    def _getValues(cls, pred, rel_type, succ, cal, min_gap):
        succ_early_start = 0
        succ_early_finish = 0
        pred_late_start = 0
        pred_late_finish = 0
        gap = 0
        pred_sd = pred["start_time_fcast"]
        pred_ed = pred["end_time_fcast"]
        succ_sd = succ["start_time_fcast"]
        succ_ed = succ["end_time_fcast"]
        if not (pred_sd and pred_ed and succ_sd and succ_ed):
            return '', '', '', '', 0
        pred_start_idx = cal[pred_sd][1]
        pred_end_idx = cal[pred_ed][0]
        succ_start_idx = cal[succ_sd][1]
        succ_end_idx = cal[succ_ed][0]
        succ_days = succ["days_fcast"]
        pred_days = pred["days_fcast"]
        if not pred["milestone"] and not succ["milestone"]:
            if rel_type == 'EA':
                succ_early_start = pred_end_idx + 1
                succ_early_finish = pred_end_idx + 1 + succ_days
                pred_late_start = succ_start_idx - pred_days
                pred_late_finish = succ_start_idx - 1
                gap = succ_start_idx - pred_end_idx - 1
            elif rel_type == 'AA':
                succ_early_start = pred_start_idx
                succ_early_finish = pred_start_idx + succ_days
                pred_late_start = succ_start_idx
                pred_late_finish = succ_start_idx + max(pred_days - 1, 0)
                gap = succ_start_idx - pred_start_idx
            elif rel_type == 'EE':
                succ_early_start = pred_end_idx - max(succ_days - 1, 0)
                succ_early_finish = pred_end_idx
                pred_late_start = succ_end_idx - pred_days
                pred_late_finish = succ_end_idx
                gap = succ_end_idx - pred_end_idx
            elif rel_type == 'AE':
                succ_early_start = pred_start_idx - max(succ_days - 1, 0)
                succ_early_finish = pred_start_idx
                pred_late_start = succ_end_idx
                pred_late_finish = succ_end_idx + max(pred_days - 1, 0)
                gap = succ_end_idx - pred_start_idx
        elif pred["milestone"] and not succ["milestone"]:
            if rel_type == 'EA' and not pred["early_position"]:
                succ_early_start = pred_end_idx + 1
                succ_early_finish = pred_end_idx + 1 + succ_days
                pred_late_start = succ_start_idx - pred_days
                pred_late_finish = succ_start_idx - 1
                gap = succ_start_idx - pred_end_idx - 1
            elif rel_type == 'AA' or rel_type == 'EA' and pred["early_position"]:
                succ_early_start = pred_start_idx
                succ_early_finish = pred_start_idx + succ_days
                pred_late_start = succ_start_idx
                pred_late_finish = succ_start_idx + max(pred_days - 1, 0)
                gap = succ_start_idx - pred_start_idx
            elif rel_type == 'EE' and not pred["early_position"]:
                succ_early_start = pred_end_idx - max(succ_days - 1, 0)
                succ_early_finish = pred_end_idx
                pred_late_start = succ_end_idx - pred_days
                pred_late_finish = succ_end_idx
                gap = succ_end_idx - pred_end_idx
            elif rel_type == 'AE' or rel_type == 'EE' and pred["early_position"]:
                succ_early_start = pred_start_idx - max(succ_days - 1, 0)
                succ_early_finish = pred_start_idx
                pred_late_start = succ_end_idx
                pred_late_finish = succ_end_idx + max(pred_days - 1, 0)
                gap = succ_end_idx - pred_start_idx
        elif not pred["milestone"] and succ["milestone"]:
            if rel_type == 'EA' and succ["early_position"]:
                succ_early_start = pred_end_idx + 1
                succ_early_finish = pred_end_idx + 1 + succ_days
                pred_late_start = succ_start_idx - pred_days
                pred_late_finish = succ_start_idx - 1
                gap = succ_start_idx - pred_end_idx - 1
            elif rel_type == 'AA' and succ["early_position"]:
                succ_early_start = pred_start_idx
                succ_early_finish = pred_start_idx + succ_days
                pred_late_start = succ_start_idx
                pred_late_finish = succ_start_idx + max(pred_days - 1, 0)
                gap = succ_start_idx - pred_start_idx
            elif rel_type == 'EE' or rel_type == 'EA' and not succ["early_position"]:
                succ_early_start = pred_end_idx - max(succ_days - 1, 0)
                succ_early_finish = pred_end_idx
                pred_late_start = succ_end_idx - pred_days
                pred_late_finish = succ_end_idx
                gap = succ_end_idx - pred_end_idx
            elif rel_type == 'AE' or rel_type == 'AA' and not succ["early_position"]:
                succ_early_start = pred_start_idx - max(succ_days - 1, 0)
                succ_early_finish = pred_start_idx
                pred_late_start = succ_end_idx
                pred_late_finish = succ_end_idx + max(pred_days - 1, 0)
                gap = succ_end_idx - pred_start_idx
        elif pred["milestone"] and succ["milestone"]:
            if not pred["early_position"] and succ["early_position"]:
                succ_early_start = pred_end_idx + 1
                succ_early_finish = pred_end_idx + 1 + succ_days
                pred_late_start = succ_start_idx - pred_days
                pred_late_finish = succ_start_idx - 1
                gap = succ_start_idx - pred_end_idx - 1
            elif pred["early_position"] and succ["early_position"]:
                succ_early_start = pred_start_idx
                succ_early_finish = pred_start_idx + succ_days
                pred_late_start = succ_start_idx
                pred_late_finish = succ_start_idx + max(pred_days - 1, 0)
                gap = succ_start_idx - pred_start_idx
            elif not pred["early_position"] and not succ["early_position"]:
                succ_early_start = pred_end_idx - max(succ_days - 1, 0)
                succ_early_finish = pred_end_idx
                pred_late_start = succ_end_idx - pred_days
                pred_late_finish = succ_end_idx
                gap = succ_end_idx - pred_end_idx
            elif pred["early_position"] and not succ["early_position"]:
                succ_early_start = pred_start_idx - max(succ_days - 1, 0)
                succ_early_finish = pred_start_idx
                pred_late_start = succ_end_idx
                pred_late_finish = succ_end_idx + max(pred_days - 1, 0)
                gap = succ_end_idx - pred_start_idx
        succ_early_start += min_gap
        succ_early_finish += min_gap
        pred_late_start -= min_gap
        pred_late_finish -= min_gap
        return succ_early_start, succ_early_finish, pred_late_start, pred_late_finish, gap
