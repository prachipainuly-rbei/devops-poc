#!/usr/bin/env powerscript
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

"""
Custom data providers
"""

# we want to import calendar from the std. lib, not from cs.pcs.projects
from __future__ import absolute_import

__revision__ = "$Id: reports.py 164148 2017-08-29 11:54:31Z heg $"

import datetime
import calendar

from cdb import ue
from cdb import sqlapi
from cdb import cdbtime
from cdb import i18n
from cdb import typeconversion
from cdb.platform import gui
from cdb.platform.gui import I18nCatalogEntry
from cdb.objects import Rule
from cdb.objects.org import Organization
from cs.tools import powerreports as PowerReports
from cs.metrics.qualitycharacteristics import ObjectQualityCharacteristic
from cs.metrics.computationrules import UpdateClock
from cs.metrics.qualitycharacteristics import History
from cs.metrics.qualitycharacteristics import ClassAssociation
from cs.metrics.qualitycharacteristics import QCDefinition
from cs.pcs.projects import Project
from cs.pcs.projects.tasks import Task
from cs.pcs.projects.consistency import DataCheck


def _quote(val):
    if type(val) in (datetime.date, datetime.datetime):
        return typeconversion.to_user_repr_date_format(val, i18n.get_date_format())
    return unicode(val)


class ProjectDataCheck(PowerReports.CustomDataProvider):
    CARD = PowerReports.CARD_N
    CALL_CARD = PowerReports.CARD_0

    def getData(self, parent_result, source_args, **kwargs):
        result = PowerReports.ReportDataList(self)
        dc = DataCheck()
        inconsistent_data_found = 0

        for obj_list, msg_txt in dc.check_data_existence():
            inconsistent_data_found += len(obj_list)
            for obj in obj_list:
                rd = self._getReportData(obj)
                rd[u"inconsistency"] = msg_txt
                result.append(rd)

        for obj_list, msg_txt in dc.check_data_aggregation():
            inconsistent_data_found += len(obj_list)
            for obj, primary, secondary in obj_list:
                rd = self._getReportData(obj)
                rd[u"inconsistency"] = msg_txt % (primary, secondary)
                result.append(rd)

        if not inconsistent_data_found:
            rd = PowerReports.ReportData(self)
            rd[u"cdbxml_hyperlink"] = u"No inconsistent data found..."
            result.append(rd)
        return result

    def _getReportData(self, obj):
        rd = PowerReports.ReportData(self)
        rd[u"cdbxml_hyperlink"] = PowerReports.MakeReportURL(obj, u"CDB_ShowObject")
        rd[u"table"] = obj.GetTableName()
        pkeys = obj.GetClassDef().getKeyNames()
        keys = []
        values = []
        for i in range(len(pkeys)):
            keys.append(pkeys[i])
            values.append(_quote(obj[pkeys[i]]))
        rd[u"keys"] = u" / ".join(keys)
        rd[u"values"] = u" / ".join(values)
        return rd

    def getSchema(self):
        t = PowerReports.XSDType(self.CARD)
        t.add_attr(u"cdbxml_hyperlink", sqlapi.SQL_CHAR)
        t.add_attr(u"table", sqlapi.SQL_CHAR)
        t.add_attr(u"inconsistency", sqlapi.SQL_CHAR)
        t.add_attr(u"keys", sqlapi.SQL_CHAR)
        t.add_attr(u"values", sqlapi.SQL_CHAR)
        return t


class ProjectEvaluationProvider(PowerReports.CustomDataProvider):
    CARD = PowerReports.CARD_N
    CALL_CARD = PowerReports.CARD_N

    def getData(self, parent_result, source_args, **kwargs):
        result = PowerReports.ReportDataList(self)
        for pr in parent_result:
            p = pr.getObject()
            rule = self.__class__.__name__
            if not Rule.ByKeys(rule):
                raise ue.Exception("cdb_pyrule_err8", rule)
            if p.MatchRule(rule):
                r = PowerReports.ReportData(self, p)
                # Hyperlink übernehmen
                r["cdbxml_hyperlink"] = pr["cdbxml_hyperlink"]

                # Kundenname
                if p.customer:
                    myOrg = Organization.ByKeys(p.customer)
                    if myOrg:
                        r["eval_customer"] = myOrg.name

                # Projektdauer
                r["eval_duration"] = p.getDurationInDays()

                # Existieren kritische offene Punkte
                criticals = len(p.getCriticalIssues())
                if criticals:
                    r["eval_critical"] = criticals

                # Zeit- und Kosteneffizienz berechnen
                cost_state = p.get_cost_state()
                schedule_state = p.get_schedule_state()
                plan_time = p.getPlanTimeCompletion2()
                r["eval_completed"] = int(round(plan_time, 2) * 100)
                r["eval_earned_value"] = schedule_state[4]
                r["eval_planned_value"] = schedule_state[5]
                r["eval_time"] = spi = schedule_state[3]
                r["eval_cost"] = cpi = cost_state[3]
                r["eval_total"] = min(spi, cpi)

                # multilang fields
                r["mapped_category_name_de"] = p.mapped_category_name_de
                r["mapped_category_name_en"] = p.mapped_category_name_en

                result += r

        result.sort(cmpData)
        return result

    def getSchema(self):
        t = PowerReports.XSDType(self.CARD, 'cdbpcs_project')
        t.add_attr("eval_earned_value", sqlapi.SQL_FLOAT)
        t.add_attr("eval_planned_value", sqlapi.SQL_FLOAT)
        t.add_attr("eval_critical", sqlapi.SQL_INTEGER)
        t.add_attr("eval_total", sqlapi.SQL_FLOAT)
        t.add_attr("eval_completed", sqlapi.SQL_INTEGER)
        t.add_attr("eval_time", sqlapi.SQL_FLOAT)
        t.add_attr("eval_cost", sqlapi.SQL_FLOAT)
        t.add_attr("eval_duration", sqlapi.SQL_INTEGER)
        t.add_attr("eval_customer", sqlapi.SQL_CHAR)
        t.add_attr("cdbxml_hyperlink", sqlapi.SQL_CHAR)
        t.add_attr("mapped_category_name_de", sqlapi.SQL_CHAR)
        t.add_attr("mapped_category_name_en", sqlapi.SQL_CHAR)
        return t

    def getClass(self):
        return Project


class ProjectMTA(PowerReports.CustomDataProvider):
    CARD = PowerReports.CARD_N
    CALL_CARD = PowerReports.CARD_1

    _clock_daily = u"täglich"
    _clock_weekly = u"wöchentlich"
    _clock_monthly = u"monatlich"
    _clock_yearly = u"jährlich"
    _clock_quarterly = u"vierteljährlich"
    _clock_half_yearly = u"halbjährlich"
    _date_format = "%d.%m.%Y"
    _map_to_start = 1
    _map_to_end = 0
    _map_to_milestones = 1
    _map_to_project = 0

    def __init__(self):
        """ get the actual possible clock update_clock values, set the default mapping mode """
        ucs = UpdateClock.Query()
        self.ucs = {}
        self.map_mode = None
        for uc in ucs:
            self.ucs[uc.name_de] = uc.position

    def getWeekStartDate(self, date):
        """
        calculates the start date of the week in year of the given date
        """
        return date - datetime.timedelta(days=date.weekday())

    def getWeekEndDate(self, date):
        """
        calculates the end date of the week in year of the given date
        """
        return date + datetime.timedelta(days=6 - date.weekday())

    def getBorderMilestoneDates(self, milestones):
        """ returns a tuple of the first/last date
        of a given list of tasks/milestones and None if there
        is no planed start/end date in all given milestones """
        tmpDateFirst = None
        tmpDateLast = None
        for milestone in milestones:
            if milestone.start_time_fcast:
                start_time_fcast_date = milestone.getStartDateFcast()
                if tmpDateFirst and start_time_fcast_date < tmpDateFirst:
                    tmpDateFirst = start_time_fcast_date
                elif not tmpDateFirst:
                    tmpDateFirst = start_time_fcast_date
            if milestone.end_time_fcast:
                end_time_fcast_date = milestone.getEndDateFcast()
                if tmpDateLast and end_time_fcast_date > tmpDateLast:
                    tmpDateLast = end_time_fcast_date
                elif not tmpDateLast:
                    tmpDateLast = end_time_fcast_date

        return (tmpDateFirst, tmpDateLast)

    def getIntervalMatchingDate(self, basedate, clock=_clock_daily):
        """ returns the corresponding start/end basedate of the given interval, basedate and map mode """
        resolve = lambda x: self.ucs[x] if x in self.ucs else None
        clock = int(clock)
        if clock == resolve(self._clock_daily):
            # daily
            return datetime.date.fromordinal(basedate.toordinal())
        elif clock == resolve(self._clock_weekly):
            # weekly
            if self.map_mode == self._map_to_start:
                return self.getWeekStartDate(basedate)
            else:
                return self.getWeekEndDate(basedate)
        elif clock == resolve(self._clock_monthly):
            # monthly
            if self.map_mode == self._map_to_start:
                return datetime.date(basedate.year, basedate.month, 1)
            else:
                return datetime.date(basedate.year, basedate.month, calendar.monthrange(basedate.year, basedate.month)[1])
        elif clock == resolve(self._clock_quarterly):
            # quarterly
            if basedate.month > 0 and basedate.month < 4:
                if self.map_mode == self._map_to_start:
                    return datetime.date(day=1, month=1, year=basedate.year)
                else:
                    return datetime.date(year=basedate.year, month=3, day=31)
            elif basedate.month >= 4 and basedate.month < 7:
                if self.map_mode == self._map_to_start:
                    return datetime.date(day=1, month=4, year=basedate.year)
                else:
                    return datetime.date(year=basedate.year, month=6, day=30)
            elif basedate.month >= 7 and basedate.month < 10:
                if self.map_mode == self._map_to_start:
                    return datetime.date(day=1, month=7, year=basedate.year)
                else:
                    return datetime.date(year=basedate.year, month=9, day=30)
            else:
                if self.map_mode == self._map_to_start:
                    return datetime.date(day=1, month=10, year=basedate.year)
                else:
                    return datetime.date(year=basedate.year, month=12, day=31)
        elif clock == resolve(self._clock_half_yearly):
            # half yearly
            if basedate.month <= 6:
                if self.map_mode == self._map_to_start:
                    return datetime.date(day=1, month=1, year=basedate.year)
                else:
                    return datetime.date(year=basedate.year, month=6, day=30)
            else:
                if self.map_mode == self._map_to_start:
                    return datetime.date(day=1, month=7, year=basedate.year)
                else:
                    return datetime.date(year=basedate.year, month=12, day=31)
        elif clock == resolve(self._clock_yearly):
            # yearly
            if self.map_mode == self._map_to_start:
                return datetime.date(day=1, month=1, year=basedate.year)
            else:
                return datetime.date(year=basedate.year, month=12, day=31)

    def getData(self, parent_result, source_args, **kwargs):
        from cs.metrics.services import get_next_computation
        result = PowerReports.ReportDataList(self)
        milestone_result = []
        firstDate = None
        lastDate = None
        qc = None
        qc_id = None
        resultdata = {}

        update_clock = source_args.get("update_clock", None)
        map_mode = int(source_args.get("map_mode", None))
        time_window_mode = int(source_args.get("time_window_mode", None))

        # set interval map mode
        if map_mode in (self._map_to_end, self._map_to_start):
            self.map_mode = map_mode
        else:
            self.map_mode = self._map_to_end

        # set time_window_mode
        if time_window_mode in (self._map_to_project, self._map_to_milestones):
            self.time_window_mode = time_window_mode
        else:
            self.time_window_mode = self._map_to_project

        # get project information
        context_project = parent_result.getObject()
        milestones = context_project.Milestones
        projectFirstDate = context_project.getStartDateFcast()
        projectLastDate = context_project.getEndDateFcast()
        milestoneBorderDates = self.getBorderMilestoneDates(milestones)

        # start/end date can be set by start_time_plan/end_time_plan of project, milestone, dialogue (later on)

        if not firstDate:
            if time_window_mode == self._map_to_milestones and milestoneBorderDates[0]:
                firstDate = milestoneBorderDates[0]
            else:
                firstDate = projectFirstDate
        if not lastDate:
            if time_window_mode == self._map_to_milestones and milestoneBorderDates[1]:
                lastDate = milestoneBorderDates[1]
            else:
                lastDate = projectLastDate

        if firstDate is None or lastDate is None:
            return result

        today = datetime.date.today()

        # get qc definition information - only set update_clock if not set
        qc_id_list = QCDefinition.KeywordQuery(name_de=u'Meilensteintermine Wöchentlich')
        if qc_id_list and len(qc_id_list) == 1:
            qc_id = qc_id_list[0]
        interval_list = ClassAssociation.KeywordQuery(cdbqc_def_object_id=qc_id.cdb_object_id)
        if not update_clock and interval_list and len(interval_list) == 1:
            update_clock = interval_list[0].update_clock

        # traverse the tree of qc information: milestone->qc->qc_hist->value
        if qc_id and update_clock:
            # if operation is on mapped dates - start/end also have to be mapped
            firstDate = self.getIntervalMatchingDate(firstDate, update_clock)
            lastDate = self.getIntervalMatchingDate(lastDate, update_clock)
            todayDate = self.getIntervalMatchingDate(today, update_clock)
            for milestone in milestones:
                milestoneFinished = False
                milestone_end_date = None
                if milestone.end_time_act:
                    milestone_end_date = self.getIntervalMatchingDate(datetime.date.fromordinal(cdbtime.Time(milestone.end_time_act).date().toordinal()), update_clock)
                # get the corresponding qc
                qc = ObjectQualityCharacteristic.KeywordQuery(cdbqc_def_object_id=qc_id.cdb_object_id, cdbf_object_id=milestone.cdb_object_id)
                if qc and len(qc) == 1:
                    # get the corresponding qc history - do not fetch history entries before viewing window
                    qc_hist_list = History.Query(((History.cdbqc_object_id == qc[0].cdb_object_id)), order_by="cdb_cdate")
                    qchli = 0
                    # go over the defined timedelta and insert points - make sure not to interpolate points into future
                    tmpDate = firstDate
                    while len(qc_hist_list) > qchli and tmpDate <= lastDate and not milestoneFinished and tmpDate <= todayDate:
                        # increase qchl index if measurement date is lower than last actual measurement in interval date
                        if self.getIntervalMatchingDate(datetime.date.fromordinal((cdbtime.Time(qc_hist_list[qchli].cdb_cdate).date()).toordinal()), update_clock) < tmpDate:
                            tmp_qchli = qchli
                            while (tmp_qchli + 1 < len(qc_hist_list)) and (self.getIntervalMatchingDate(datetime.date.fromordinal((cdbtime.Time(qc_hist_list[tmp_qchli + 1].cdb_cdate).date()).toordinal()), update_clock) <= tmpDate):
                                tmp_qchli += 1
                            qchli = tmp_qchli
                        # get measured planed milestone date and save into distinct dict
                        # indexed by the tmpDate which is mapped to the selected interval and the milestones
                        # this makes sure that there is only one y-value per x-value even if the granularity
                        # of the measurement is much higher than the visualisation granularity
                        ms_date = datetime.date.fromordinal(int(qc_hist_list[qchli].value))
                        if not tmpDate in resultdata:
                            resultdata[tmpDate] = {}
                        resultdata[tmpDate][milestone.task_name] = self.getIntervalMatchingDate(ms_date, update_clock).strftime(self._date_format)

                        # check finished milestones in next iteration - if last point - reset ms_date to end date of milestone
                        str_next_interval_date = get_next_computation(update_clock, tmpDate)
                        nidt = datetime.datetime.combine(str_next_interval_date, datetime.datetime.min.time())
                        checkDate = self.getIntervalMatchingDate(datetime.date(nidt.year, nidt.month, nidt.day), update_clock)
                        if milestone.status == Task.FINISHED.status and milestone_end_date and milestone_end_date < checkDate:
                            resultdata[tmpDate][milestone.task_name] = milestone_end_date.strftime(self._date_format)
                            milestoneFinished = True

                        # increase measurement interval date with update_clock interval
                        str_next_interval_date = get_next_computation(update_clock, tmpDate)
                        nidt = datetime.datetime.combine(str_next_interval_date, datetime.datetime.min.time())
                        tmpDate = self.getIntervalMatchingDate(datetime.date(nidt.year, nidt.month, nidt.day), update_clock)

            # generate diagonal line
            if qc and len(qc) == 1:
                tmpDate = firstDate
                while tmpDate <= lastDate:
                    data = PowerReports.ReportData(self)
                    data["ms_date"] = tmpDate.strftime(self._date_format)
                    data["ms_name"] = "Verlauf"
                    data["report_date"] = tmpDate.strftime(self._date_format)

                    # increase tmpDate with update_clock interval
                    str_next_interval_date = get_next_computation(update_clock, tmpDate)
                    nidt = datetime.datetime.combine(str_next_interval_date, datetime.datetime.min.time())
                    tmpDate = self.getIntervalMatchingDate(datetime.date(nidt.year, nidt.month, nidt.day), update_clock)
                    result.append(data)

        # insert measured milestone dates

        measurementDates = resultdata.keys()
        measurementDates.sort()

        for measurementDate in measurementDates:
            milestoneDict = resultdata[measurementDate].keys()
            milestoneDict.sort()
            for milestoneName in milestoneDict:
                data = PowerReports.ReportData(self)
                data["ms_date"] = resultdata[measurementDate][milestoneName]
                data["ms_name"] = milestoneName
                data["report_date"] = measurementDate.strftime(self._date_format)
                milestone_result.append(data)

        final_result = result + milestone_result
        return final_result

    def getSchema(self):
        qc = PowerReports.XSDType(self.CARD, ObjectQualityCharacteristic)
        qc.add_attr("ms_date", sqlapi.SQL_DATE)
        qc.add_attr("ms_name", sqlapi.SQL_CHAR)
        qc.add_attr("report_date", sqlapi.SQL_DATE)
        return qc

    def getClass(self):
        return ObjectQualityCharacteristic


class MTAUpdateClockCatalog(gui.CDBCatalog):
    def __init__(self):
        gui.CDBCatalog.__init__(self)

    def handlesI18nEnumCatalog(self):
        return True

    def getI18nEnumCatalogEntries(self):
        return [I18nCatalogEntry(u"%s" % (uc.position), uc.Name[''])
                for uc in UpdateClock.Query(UpdateClock.name_de != 'manuell', order_by="position")]


def cmpData(o1, o2):
    try:
        res = cmp(cdbtime.Time(o1["end_time_plan"]).date(),
                  cdbtime.Time(o2["end_time_plan"]).date())
        if res:
            return res
        for a in ["category", "status"]:
            res = cmp(o1[a], o2[a])
            if res:
                return res
        return 0
    except Exception:
        return 0
