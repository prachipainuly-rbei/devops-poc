#!/usr/bin/env powerscript
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

import traceback
import sys
from cdb import sqlapi
from cdb import dberrors
from cdb.comparch import protocol
from cs.pcs.projects.tasks import ALLOWED_TASK_GROUP_DEPENDECIES
from cs.pcs.projects.tasks_schedule import VALID_CONSTRAINTS_FOR_TASK_GROUPS
from collections import defaultdict


class UpdateTaskRelations(object):
    def run(self):
        sqlapi.SQLupdate("cdbpcs_taskrel SET minimal_gap = gap")


class UpdateTaskAttributes(object):
    def run(self):
        sqlapi.SQLupdate("cdbpcs_task SET automatic = 0")


class UpdateConstraintTypeOfTasks(object):
    u""" Constraint types:
        ASAP = "0"  # as soon as possible
        ALAP = "1"  # as late as possible
        MSO = "2"   # must start on
        MFO = "3"   # must finish on
        SNET = "4"  # start no earlier than
        SNLT = "5"  # start no later than
        FNET = "6"  # finish no earlier than
        FNLT = "7"  # finish no later than
    """

    def run(self):

        def updateTask(pid, tid, c_type, c_date):
            sqlapi.SQLupdate(u"""cdbpcs_task SET constraint_type = '{c_type}',  constraint_date = {c_date} WHERE constraint_type IS NULL
                                 AND cdb_project_id = '{pid}' AND task_id = '{tid}'""".format(
                                     pid=pid, tid=tid, c_date=sqlapi.SQLdbms_date(c_date), c_type=c_type))

        # determine tasks, that need a "Must finish on" constraint
        sqlapi.SQLupdate(u"cdbpcs_task SET constraint_type = '3', constraint_date = end_time_fcast WHERE constraint_type IS NULL AND end_plan_fix = 1")

        # create dictionaries with projects, tasks and task relations
        predecessor_dict = defaultdict(list)
        pred_result = sqlapi.RecordSet2(sql=u"SELECT cdb_project_id2, task_id2, cdb_project_id, task_id FROM cdbpcs_taskrel")
        for r in pred_result:
            predecessor_dict[(r.cdb_project_id, r.task_id)].append((r.cdb_project_id2, r.task_id2))
        parent_dict = {}
        project_result = sqlapi.RecordSet2(sql=u"SELECT cdb_project_id, start_time_fcast, end_time_fcast FROM cdbpcs_project")
        for r in project_result:
            parent_dict[(r.cdb_project_id, u"")] = r
        task_result = sqlapi.RecordSet2(sql=u"SELECT task_name, cdb_project_id, task_id, parent_task, start_time_fcast, end_time_fcast FROM cdbpcs_task")
        for r in task_result:
            parent_dict[(r.cdb_project_id, r.task_id)] = r

        # determine tasks, that need a "Start no earlier than" constraint
        for r in task_result:
            predecessors = predecessor_dict[(r.cdb_project_id, r.task_id)]
            parent = parent_dict[(r.cdb_project_id, r.parent_task)]
            if parent.start_time_fcast and r.start_time_fcast:
                if r.start_time_fcast < parent.start_time_fcast:
                    updateTask(pid=r.cdb_project_id, tid=r.task_id, c_type=u"4", c_date=r.start_time_fcast)
                elif r.start_time_fcast > parent.start_time_fcast and not predecessors:
                    updateTask(pid=r.cdb_project_id, tid=r.task_id, c_type=u"4", c_date=r.start_time_fcast)
            elif not parent and not predecessors:
                updateTask(pid=r.cdb_project_id, tid=r.task_id, c_type=u"4", c_date=r.start_time_fcast)

        # set all other tasks to "As soon as possible" constraint
        sqlapi.SQLupdate(u"cdbpcs_task SET constraint_type = '0' WHERE constraint_type IS NULL")


class CheckNotAllowedRelations(object):
    def run(self):
        stmt = u"""cdbpcs_task.cdb_project_id, cdbpcs_task.task_id, cdbpcs_task.task_name
            FROM cdbpcs_taskrel INNER JOIN cdbpcs_task
            ON cdbpcs_taskrel.cdb_project_id = cdbpcs_task.cdb_project_id AND cdbpcs_taskrel.task_id = cdbpcs_task.task_id
            WHERE cdbpcs_taskrel.rel_type NOT IN ({0}) AND cdbpcs_task.is_group = 1""".format(
            unicode(ALLOWED_TASK_GROUP_DEPENDECIES)[1:-1])
        t = sqlapi.SQLselect(stmt)
        t_rows = sqlapi.SQLrows(t)
        if t_rows:
            message = u"The following task groups have relations which are not allowed:\n"
            for i in range(sqlapi.SQLrows(t)):
                pid = sqlapi.SQLstring(t, 0, i)
                tid = sqlapi.SQLstring(t, 1, i)
                name = sqlapi.SQLstring(t, 2, i)
                message += u" task '{0}' with cdb_project_id {1} and task_id {2}.\n".format(name, pid, tid)
            message += u"Please delete offending relations or change the task groups to normal tasks."
            protocol.logError(message)
            raise RuntimeError("""Task groups with incompatible relations have been found.
                This requires manual changes. Check error log for more information""")


class CheckNotAllowedConstraints(object):
    def run(self):
        stmt = u"""cdbpcs_task.cdb_project_id, cdbpcs_task.task_id, cdbpcs_task.task_name
            FROM cdbpcs_task WHERE cdbpcs_task.is_group = 1 AND cdbpcs_task.constraint_type NOT IN ({0})""".format(
            unicode(VALID_CONSTRAINTS_FOR_TASK_GROUPS)[1:-1])
        t = sqlapi.SQLselect(stmt)
        t_rows = sqlapi.SQLrows(t)
        if t_rows:
            message = u"The following task groups have constraint types which are not allowed:\n"
            for i in range(sqlapi.SQLrows(t)):
                pid = sqlapi.SQLstring(t, 0, i)
                tid = sqlapi.SQLstring(t, 1, i)
                name = sqlapi.SQLstring(t, 2, i)
                message += u" task '{0}' with cdb_project_id {1} and task_id {2}.\n".format(name, pid, tid)
            message += u"Please change the constraint types or change the task groups to normal tasks."
            protocol.logError(message)
            raise RuntimeError("""Task groups with incompatible constraint types have been found.
                This requires manual changes. Check error log for more information""")


class DropViewPCSSubjectAll(object):

    def run(self):
        """
        Before updating the view is dropped. It is intended to ensure that the new definition is applied.
        """
        try:
            sqlapi.SQL('DROP VIEW pcs_sharing_subjects_all')
        except dberrors.DBError, update_error:
            protocol.logWarning('View pcs_aharing_subjects_all could not be dropped. Maybe view did not exist.',
                                details_longtext=update_error.errmsg)
            return
        except:
            protocol.logError('Error while dropping view pcs_sharing_all.',
                              details_longtext="".join(traceback.format_exception(*sys.exc_info())))
            return


class MigrateFolders(object):

    def run(self):
        """
        Migrate z_categ in cdb_folder
        """
        for i in range(1, 3):
            recs = sqlapi.RecordSet2(table='cdb_folder', updatable=1,
                                     sql="SELECT * FROM cdb_folder WHERE z_categ%s != ''" % i)
            missing_categ = []
            for rec in recs:
                categ_name_d = rec["z_categ%s" % i]
                if not categ_name_d.isdigit():
                    categs = self.get_categ_id(categ_name_d, i)
                    if len(categs) == 1:
                        kwargs = {}
                        kwargs["z_categ%s" % i] = categs[0].categ_id
                        rec.update(**kwargs)
                    elif len(categs) == 0:
                        if categ_name_d not in missing_categ:
                            missing_categ.append(categ_name_d)
                    else:
                        protocol.logWarning('Not unique z_categ%s: %s' % (i, categ_name_d),
                                            details_longtext='Category has to be unique.')
            if missing_categ:
                protocol.logWarning('Missing z_categ%s: %s' % (i, ', '.join(missing_categ)),
                                    details_longtext='Create the missing categories.')

    def get_categ_id(self, name_d, z_categ):
        if z_categ == 1:
            return sqlapi.RecordSet2(sql="SELECT * FROM cdb_doc_categ WHERE name_d LIKE '%s' AND parent_id = ''" % name_d)
        elif z_categ == 2:
            return sqlapi.RecordSet2(sql="SELECT * FROM cdb_doc_categ WHERE name_d LIKE '%s' AND parent_id != ''" % name_d)
        return []


pre = [DropViewPCSSubjectAll]
post = [UpdateTaskRelations,
        UpdateTaskAttributes,
        UpdateConstraintTypeOfTasks,
        CheckNotAllowedRelations,
        CheckNotAllowedConstraints,
        MigrateFolders]
