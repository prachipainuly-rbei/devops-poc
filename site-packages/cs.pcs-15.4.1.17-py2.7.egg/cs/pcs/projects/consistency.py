#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

__docformat__ = u"restructuredtext en"
__revision__ = u"$Id: consistency.py 183442 2018-09-06 10:40:28Z heg $"


from cdb import sig
from cdb import sqlapi
from cdb.objects import ClassRegistry
from cdb.platform.mom.entities import CDBClassDef


OP_EQUAL = u"="
OP_DIFF = u"!="
OP_IN = u"IN"
OP_NOT_IN = u"NOT IN"


def _output_exist(table, sql_statememt):
    cls = _find_parent_cls(table)
    objs = sqlapi.RecordSet2(sql=sql_statememt)
    result = []
    for obj in objs:
        o = cls.ByKeys(**obj)
        result.append(o)
    return result


def _output_aggregate(table, sql_statememt):
    cls = _find_parent_cls(table)
    objs = sqlapi.RecordSet2(sql=sql_statememt)
    result = []
    for obj in objs:
        o = cls.ByKeys(**obj)
        result.append((o, obj[u"attr"], obj[u"aggregation_attr"]))
    return result


def _find_parent_cls(classname):
    cd = CDBClassDef(classname)
    return ClassRegistry().find(cd.getPrimaryTable())


def _getCheckExistStatement(primary_table, joined_table, key_pairs,
                            joined_attributes=[], **constants):
    if not joined_attributes:
        joined_attributes = []
    joined_attributes.append((key_pairs[0][2], u"check_attribute"))
    joined_attrs = u", ".join(map(lambda x: u"b.%s AS %s" % x, joined_attributes))
    join_condition = u" AND ".join(map(lambda x: u"a.%s %s b.%s" % x, key_pairs))
    added_constants = u""
    if constants:
        constant_list = []
        for k, v in constants.items():
            constant_list.append(u"t.%s = %s" % (k, v))
        added_constants = u" AND " + u" AND ".join(constant_list)
    return u""" SELECT DISTINCT * FROM
            (   SELECT a.*, %(joined_attrs)s
                FROM %(primary_table)s a LEFT JOIN %(joined_table)s b
                ON %(join_condition)s
            ) AS t WHERE (t.check_attribute = '' OR t.check_attribute IS NULL)
                %(added_constants)s""" % locals()


def _getCheckAggregationStatement(table, aggregation_table, key_pairs, aggregation_const,
                                  attr, primary_attr, secondary_attr=None, **constants):
    tolerance = u"0.00001"
    join_condition = u" AND ".join(map(lambda x: u"a.%s %s b.%s" % x, key_pairs))
    for ac in aggregation_const:
        join_condition += u" AND b.%s %s %s" % ac
    if secondary_attr:
        secondary_attr = primary_attr
        aggregation_attr = u"""CASE WHEN b.%(primary_attr)s IS NULL OR b.%(primary_attr)s = 0
                                    THEN b.%(secondary_attr)s
                                    ELSE b.%(primary_attr)s
                               END""" % locals()
    else:
        aggregation_attr = u"b.%(primary_attr)s" % locals()

    added_constants = u""
    if constants:
        constant_list = []
        for k, v in constants.items():
            constant_list.append(u"t.%s = %s" % (k, v))
        added_constants = u" AND " + u" AND ".join(constant_list)
    return u"""SELECT DISTINCT * FROM
               (SELECT DISTINCT a.*, a.%(attr)s AS attr,
                ( SELECT SUM(%(aggregation_attr)s)
                  FROM %(aggregation_table)s b
                  WHERE %(join_condition)s ) AS aggregation_attr
                FROM %(table)s a) AS t
                WHERE ( (t.attr + %(tolerance)s) < t.aggregation_attr
                OR (t.attr - %(tolerance)s) > t.aggregation_attr )
                %(added_constants)s""" % locals()


class DataCheck(object):

    _exist_checks = None
    _aggregation_checks = None

    def __init__(self, **kwargs):
        self._exist_checks = []
        self._aggregation_checks = []
        self.addContext(**kwargs)

    def addContext(self, **kwargs):
        for k, v in kwargs.items():
            kwargs[k] = u"'%s'" % v
        self._add_pcs_checks(**kwargs)
        sig.emit(DataCheck, u"add_check_hook")(self, **kwargs)

    def addProjectContext(self, cdb_project_id):
        self.addContext(cdb_project_id=cdb_project_id)

    def check_data_existence(self):
        result = []
        for rel, sql, msg in self._exist_checks:
            result.append((_output_exist(rel, sql), msg))
        return result

    def check_data_aggregation(self):
        result = []
        for rel, sql, msg in self._aggregation_checks:
            result.append((_output_aggregate(rel, sql), msg))
        return result

    def add_existence_check(self, check_message,
                            primary_table, joined_table, key_pairs,
                            joined_attributes=[], **constants):
        statement = _getCheckExistStatement(primary_table=primary_table,
                                            joined_table=joined_table,
                                            joined_attributes=joined_attributes,
                                            key_pairs=key_pairs,
                                            **constants)
        self._exist_checks.append((primary_table, statement, check_message))

    def add_aggregate_check(self, check_message,
                            table, aggregation_table, key_pairs, aggregation_const,
                            attr, primary_attr, secondary_attr=None, **constants):
        statement = _getCheckAggregationStatement(table=table,
                                                  aggregation_table=aggregation_table,
                                                  key_pairs=key_pairs,
                                                  aggregation_const=aggregation_const,
                                                  attr=attr,
                                                  primary_attr=primary_attr,
                                                  secondary_attr=secondary_attr,
                                                  **constants)
        self._aggregation_checks.append((table, statement, check_message))

    def _add_pcs_checks(self, **kwargs):
        self.add_aggregate_check(check_message=u"effort_plan ( %s ) of parent task does not match effort_fcast ( %s ) of subtasks",
                                 table=u"cdbpcs_task",
                                 aggregation_table=u"cdbpcs_task",
                                 key_pairs=[(u"cdb_project_id", OP_EQUAL, u"cdb_project_id"),
                                            (u"task_id", OP_EQUAL, u"parent_task")],
                                 aggregation_const=[(u"status", OP_NOT_IN, u"( 180 )")],
                                 attr=u"effort_plan",
                                 primary_attr=u"effort_fcast",
                                 is_group=u"1",
                                 **kwargs)

        self.add_existence_check(check_message=u"Project is missing.",
                                 primary_table=u"cdbpcs_task",
                                 joined_table=u"cdbpcs_project",
                                 key_pairs=[(u"cdb_project_id", OP_EQUAL, u"cdb_project_id")],
                                 **kwargs)

        self.add_existence_check(check_message=u"Successor task is missing.",
                                 primary_table=u"cdbpcs_taskrel",
                                 joined_table=u"cdbpcs_task",
                                 key_pairs=[(u"cdb_project_id", OP_EQUAL, u"cdb_project_id"),
                                            (u"task_id", OP_EQUAL, u"task_id")],
                                 **kwargs)

        self.add_existence_check(check_message=u"Predecessor task is missing.",
                                 primary_table=u"cdbpcs_taskrel",
                                 joined_table=u"cdbpcs_task",
                                 key_pairs=[(u"cdb_project_id2", OP_EQUAL, u"cdb_project_id"),
                                            (u"task_id2", OP_EQUAL, u"task_id")],
                                 **kwargs)

        self.add_existence_check(check_message=u"Project role assignment has no matching team member.",
                                 primary_table=u"cdbpcs_subject",
                                 joined_table=u"cdbpcs_team",
                                 key_pairs=[(u"subject_id", OP_EQUAL, u"cdb_person_id"),
                                            (u"cdb_project_id", OP_EQUAL, u"cdb_project_id")],
                                 subject_type=u"'Person'",
                                 **kwargs)

        self.add_existence_check(check_message=u"Project team member has no matching project role 'Project Member'.",
                                 primary_table=u"cdbpcs_team",
                                 joined_table=u"cdbpcs_subject",
                                 joined_attributes=[(u"subject_type", u"subject_type")],
                                 key_pairs=[(u"cdb_person_id", OP_EQUAL, u"subject_id"),
                                            (u"cdb_project_id", OP_EQUAL, u"cdb_project_id")],
                                 subject_type=u"'Projektmitglied'",
                                 **kwargs)

        self.add_existence_check(check_message=u"Project role 'Project Leader' has no project role 'Project Member'.",
                                 primary_table=u"cdbpcs_subject",
                                 joined_table=u"cdbpcs_subject",
                                 key_pairs=[(u"subject_id", OP_EQUAL, u"subject_id"),
                                            (u"cdb_project_id", OP_EQUAL, u"cdb_project_id"),
                                            (u"role_id", OP_DIFF, u"role_id")],
                                 subject_type=u"'Person'",
                                 role_id=u"'Projektleiter'",
                                 **kwargs)
