#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: set fileencoding=latin1:
# -*- Python -*-
# $Id: project_status.py 172052 2018-01-22 12:35:54Z umu $
# CDB:Browse
# Copyright (C) 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

# pylint: disable-msg=E0213,E0203,W0142,W0212,W0201

import datetime
from cdb import sig
from cdb import transactions
from cdb import ue
from cdb import util
from cdb.classbody import classbody
from cdb.objects import State
from cdb.objects import Transition
from cs.activitystream.objects import SystemPosting
from cs.activitystream.objects import Topic2Posting
from cs.pcs.projects import Project


@classbody
class Project(object):
    def on_wf_step_post_mask(self, ctx):
        if self.status == self.NEW.status:
            self.user_confirmation(
                ctx, "ask_reset_project", "cdbpcs_reset_proj")
        if self.status == self.COMPLETED.status and self.containsNonFinalObjects():
            self.user_confirmation(
                ctx, "ask_complete_project", "cdbpcs_complete_proj")

    def user_confirmation(self, ctx, attr, msg):
        if not attr in ctx.dialog.get_attribute_names() or ctx.dialog[attr] == "":
            msgbox = ctx.MessageBox(msg, [self.project_name, self.cdb_project_id], attr)
            msgbox.addYesButton(1)
            msgbox.addNoButton()
            ctx.show_message(msgbox)
            return False
        else:
            result = ctx.dialog[attr]
            if result == "0":
                raise ue.Exception("cdbpcs_sc_cancel")

    def containsNonFinalObjects(self):
        for relship in [self.TopTasks, self.Issues, self.TopLevelChecklists]:
            if [x for x in relship if x.status not in x.endStatus(False)]:
                return True

    @sig.connect(Project, "state_change", "post")
    def setFrozen(self, ctx=None):
        if ctx and getattr(ctx, "error", None):
            return

        frozen = int(self.status == self.FROZEN.status)
        with transactions.Transaction():
            self.Checklists.Update(cdbpcs_frozen=frozen)
            self.ChecklistItems.Update(cdbpcs_frozen=frozen)
            self.Issues.Update(cdbpcs_frozen=frozen)
            self.Tasks.Update(cdbpcs_frozen=frozen)

    @classmethod
    def endStatus(cls, full_cls=True):
        """
        returns set of "final" status classes (full_cls True) or integer values
        (full_cls False) and cache them for subsequent access
        """
        if not hasattr(cls, "__end_status_cls__"):
            cls.__end_status_cls__ = [cls.DISCARDED, cls.COMPLETED]
            cls.__end_status_int__ = [x.status for x in cls.__end_status_cls__]
        if full_cls:
            return cls.__end_status_cls__
        return cls.__end_status_int__

    class NEW(State):
        status = 0

        def Constraints(state, self):
            return [("MatchStateList", [[self.ParentProject], [self.NEW, self.EXECUTION], "pcs_proj_wf_rej_0"])]

        def FollowUpStateChanges(state, self):
            from cs.pcs.checklists import Checklist
            return [
                (Checklist.NEW, [c for c in self.TopLevelChecklists if c.status != Checklist.DISCARDED.status], 0, 0),
                ]

    class EXECUTION(State):
        status = 50

        def Constraints(state, self):
            return [("MatchStateList", [[self.ParentProject], [self.EXECUTION], "pcs_proj_wf_rej_0"])]

    class FROZEN(State):
        status = 60

        def Constraints(state, self):
            return [("MatchStateList", [self.SubProjects, [self.FROZEN, self.DISCARDED, self.COMPLETED], "pcs_proj_wf_rej_1"])]

    class DISCARDED(State):
        status = 180

        def FollowUpStateChanges(state, self):
            from cs.pcs.projects.tasks import Task
            from cs.pcs.issues import Issue
            from cs.pcs.checklists import Checklist
            return [
                (Task.DISCARDED, [t for t in self.TopTasks if t.status not in Task.endStatus(False)], 0, 0),
                (Issue.DISCARDED, [i for i in self.Issues if not i.task_id and i.status not in Issue.endStatus(False)], 0, 0),
                (Checklist.DISCARDED, [c for c in self.TopLevelChecklists if c.status not in Checklist.endStatus(False)], 0, 0),
                ]

    class COMPLETED(State):
        status = 200

        def FollowUpStateChanges(state, self):
            from cs.pcs.projects.tasks import Task
            from cs.pcs.issues import Issue
            from cs.pcs.checklists import Checklist
            result = [
                (Task.COMPLETED, [t for t in self.TopTasks if t.status == Task.FINISHED.status], 0, 0),
                (Task.DISCARDED, [t for t in self.TopTasks if t.status not in Task.endStatus(False)], 0, 0),
                (Issue.COMPLETED, [i for i in self.Issues if not i.task_id and i.status not in Issue.endStatus(False)], 0, 0),
                (Checklist.DISCARDED, [c for c in self.TopLevelChecklists if c.status not in Checklist.endStatus(False)], 0, 0),
                ]
            return result

    class NEW_EXECUTION(Transition):
        transition = (0, 50)

        def FollowUpStateChanges(transition, self):
            from cs.pcs.projects.tasks import Task
            from cs.pcs.projects.tasks import kTaskDependencyEA
            from cs.pcs.projects.tasks import kTaskDependencyEE

            def predecessors(task):
                if task.getPredecessors(kTaskDependencyEA):
                    return True
                if task.getPredecessors(kTaskDependencyEE):
                    return True

            return [(Task.READY, [t for t in self.TopTasks if not predecessors(t)], 0, 0)]

    class TO_NEW(Transition):
        transition = ("*", 0)

        def FollowUpStateChanges(transition, self):
            from cs.pcs.projects.tasks import Task
            old = transition.SourceState(self).status

            if old == self.DISCARDED.status:
                return [(Task.NEW, [t for t in self.TopTasks if t.status not in [
                    Task.FINISHED.status, Task.COMPLETED.status]], 0, 0)]

            return [
                (Task.NEW, [t for t in self.TopTasks if t.status != Task.DISCARDED.status], 0, 0)
                ]

    class DISCARDED_EXECUTION(Transition):
        transition = (180, 50)

        def FollowUpStateChanges(transition, self):
            from cs.pcs.projects.tasks import Task

            ready = []
            new = []

            for task in self.TopTasks:
                if task.status == Task.DISCARDED.status:
                    if task.getSubtasksMeetingPredecessorCondition():
                        ready.append(task)
                    else:
                        new.append(task)

            return [
                (Task.READY, ready, 0, 0),
                (Task.NEW, new, 0, 0),
                ]
