#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
# vim: set fileencoding=latin1:
# -*- Python -*-
# $Id: __init__.py 185532 2018-10-24 13:50:41Z umu $
# CDB:Browse
# Copyright (C) 1990 - 2006 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
# File:     Projects.py
# Author:   aki
# Creation: 19.07.06
# Purpose:

# pylint: disable-msg=E0213,E0203,W0142,W0212,W0201

"""
This module provides the business logic of a project.
"""

__all__ = ['Project', 'ProjectCategory', 'DomainAssignment', 'TeamMember', 'SubjectAssignment',
           'PersonAssignment', 'CommonRoleAssignment', 'PCSRoleAssignment', 'Role']

import datetime

from cdb import sqlapi
from cdb import ddl
from cdb import auth
from cdb import util
from cdb import ue
from cdb import decomp
from cdb import cdbtime
from cdb import misc
from cdb import sig
from cdb import transactions
from cdb import constants
from cdb import cmsg
from cdb.lru_cache import lru_cache

from cs.calendar import workday
from cdb.objects import unique
from cdb.classbody import classbody
from cdb.objects import org
from cdb.objects import Reference_N
from cdb.objects import Reference_1
from cdb.objects import ReferenceMapping_1
from cdb.objects import ReferenceMapping_N
from cdb.objects import Forward
from cdb.objects import Object
from cdb.objects import State
from cdb.objects import Rule
from cdb.objects import Reference_Methods
from cdb.objects.org import Person
from cdb.typeconversion import to_legacy_date_format
from cdb.typeconversion import to_legacy_date_format_auto
from cdb.typeconversion import to_python_rep
from cdb.typeconversion import to_user_repr_date_format
from cs.pcs.efforts import WithEffortReport
from cs.pcs.issues import WithFrozen
from cs.pcs.issues import WithIssueReport, Issue
from cs.pcs.projects import calendar as Calendar
from cs.workflow.schemacomponents import SchemaComponent
from cs.workflow.processes import Process
from cs.workflow.systemtasks import InfoMessage
from cs.actions import Action
from cdb.objects.common import WithImage
from cs.metrics.qcclasses import WithQualityCharacteristic
from cs.tools.powerreports import WithPowerReports
from cdb.platform.acs import WithOCRoleQuery
from cs.sharing.share_objects import WithSharing
from cdb.platform.gui import PythonColumnProvider

# Forward declarations
fProject = Forward(__name__ + ".Project")
fRole = Forward(__name__ + ".Role")
fTeamMember = Forward(__name__ + ".TeamMember")
fDomainAssignment = Forward(__name__ + ".DomainAssignment")
fSubjectAssignment = Forward(__name__ + ".SubjectAssignment")
fPCSRoleAssignment = Forward(__name__ + ".PCSRoleAssignment")

fTimeSheet = Forward("cs.pcs.efforts.TimeSheet")
fTask = Forward("cs.pcs.projects.tasks.Task")
fTaskRelation = Forward("cs.pcs.projects.tasks.TaskRelation")
fIssue = Forward("cs.pcs.issues.Issue")
fChecklist = Forward("cs.pcs.checklists.Checklist")
fChecklistItem = Forward("cs.pcs.checklists.ChecklistItem")
fCalendarProfile = Forward("cs.calendar.CalendarProfile")

kProjectManagerRole = 'Projektleiter'
kProjectMemberRole = 'Projektmitglied'

bAutoUpdateTimeMask = 0b00000001
bAutoUpdateEffortMask = 0b00000010

FCAST_MOVEMENT_NONE = "no movement"
FCAST_MOVEMENT_ADJUST = "adjust dates"
FCAST_MOVEMENT_RELATIVE = "move relative"

MY_PROJECTS_MAX_RECORDS = 50


class Project(Object, WithEffortReport, WithIssueReport, WithOCRoleQuery, WithPowerReports, WithImage,
              WithQualityCharacteristic, WithSharing, WithFrozen):

    __maps_to__ = "cdbpcs_project"
    __wf_step_reject_msg__ = "pcsproj_wfstep_rej"

    __contexts__ = ["ProjectContext"]

    constDefaultCalendarProfileName = "Standard"

    default_roles = ['Projektmitglied']
    """
    List of project roles.

    Project roles must be defined in the project role catalog.

    The values of the identifier of the project role must be entered.

    Each project role that is defined, can be used as a default role in a derived class similar
    to the following lines:

       .. code-block:: python

          from cs.pcs.projects import Project

          class MyProject(Project):

              default_roles = ['Projektmitglied', 'Projektassistent']
    """

    RolesByID = ReferenceMapping_1(fRole, fRole.cdb_project_id == fProject.cdb_project_id, indexed_by=fRole.role_id)
    Roles = Reference_N(fRole, fRole.cdb_project_id == fProject.cdb_project_id)
    TeamMembers = Reference_N(fTeamMember, fTeamMember.cdb_project_id == fProject.cdb_project_id)

    TeamMembersByPersno = ReferenceMapping_1(fTeamMember,
                                             fTeamMember.cdb_project_id == fProject.cdb_project_id,
                                             indexed_by=fTeamMember.cdb_person_id)

    DomainAssignmentsByID = ReferenceMapping_1(fDomainAssignment,
                                               fDomainAssignment.cdb_project_id == fProject.cdb_project_id,
                                               indexed_by=fDomainAssignment.acd_id)

    TasksByParentTask = ReferenceMapping_N(fTask, fTask.cdb_project_id == fProject.cdb_project_id, indexed_by=fTask.parent_task, order_by='position')
    Issues = Reference_N(fIssue, fIssue.cdb_project_id == fProject.cdb_project_id)
    TopLevelChecklists = Reference_N(fChecklist, fChecklist.cdb_project_id == fProject.cdb_project_id, fChecklist.task_id == '',
                                     fChecklist.parent_checkl_id == 0)
    Checklists = Reference_N(fChecklist, fChecklist.cdb_project_id == fProject.cdb_project_id)
    ChecklistItems = Reference_N(fChecklistItem, fChecklistItem.cdb_project_id == fProject.cdb_project_id)
    TimeSheets = Reference_N(fTimeSheet, fTimeSheet.cdb_project_id == fProject.cdb_project_id)
    Tasks = Reference_N(fTask, fTask.cdb_project_id == fProject.cdb_project_id, order_by='position')
    TaskRelations = Reference_N(fTaskRelation, fTaskRelation.cdb_project_id == fProject.cdb_project_id, fTaskRelation.cdb_project_id2 == fProject.cdb_project_id)
    TaskRelationsPre = Reference_N(fTaskRelation, fTaskRelation.cdb_project_id == fProject.cdb_project_id,)
    TaskRelationsSucc = Reference_N(fTaskRelation, fTaskRelation.cdb_project_id2 == fProject.cdb_project_id)
    Milestones = Reference_N(fTask, fTask.cdb_project_id == fProject.cdb_project_id, fTask.milestone == 1)
    SubProjects = Reference_N(fProject, fProject.parent_project == fProject.cdb_project_id)
    ParentProject = Reference_1(fProject, fProject.parent_project)
    TasksAutomatic = Reference_N(fTask, fTask.cdb_project_id == fProject.cdb_project_id, fTask.automatic == 1)
    TasksManual = Reference_N(fTask, fTask.cdb_project_id == fProject.cdb_project_id, fTask.automatic == 0)

    CalendarProfile = Reference_1(fCalendarProfile, fProject.calendar_profile_id)

    @property
    def DefaultCalendarProfileName(cls):
        """
        Returns the name of the default calendar profile to be used by creating a project.

        Can be overwritten by customizations in order to preset the name depending on location,
        project category or whatever needed.

        ``:return: string``
        """
        return cls.constDefaultCalendarProfileName

    def _AllTaskRelations(self):
        """
        Method to get all taskrelations

        :return: returns a list of taskrelation objects (1, n, none)
        """
        return unique(self.TaskRelationsPre + self.TaskRelationsSucc)

    AllTaskRelations = Reference_Methods(fTask, lambda self: self._AllTaskRelations())

    TopTasks = Reference_N(fTask,
                           fTask.cdb_project_id == fProject.cdb_project_id,
                           fTask.parent_task == '',
                           order_by='position')
    AllTasks = Reference_N(fTask,
                           fTask.cdb_project_id == fProject.cdb_project_id)

    def _allTasksByOrder(self):
        result = []
        for task in self.TopTasks:
            result.append(task)
            result += task._allSubtasks(by_order=True)
        return result

    AllTasksByOrder = Reference_Methods(fTask, lambda self: self._allTasksByOrder())
    Subprojects = Reference_N(fProject,
                              fProject.parent_project == fProject.cdb_project_id)
    SuperProject = Reference_1(fProject, fProject.parent_project)

    def resolveSubProjects(self):
        result = list(self.SubProjects)
        for p in self.SubProjects:
            result += p.resolveSubProjects()
        return result

    def on_cdbpcs_project_details_now(self, ctx):
        from cs.pcs.dashboard import KosmodromTools
        ctx.url(KosmodromTools.get_detail_url(self))

    def on_cdbpcs_milestone_report_now(self, ctx):
        from cs.tools import powerreports
        urlstr = powerreports.MakeReportURL(self, None, "", subReport="Meilensteintrendanalyse")
        url = urlstr[:urlstr.find(" cdb:texttodisplay")]
        ctx.url(url)

    def createRole(self, role_id):
        role = self.getRole(role_id=role_id)
        if not role:
            valdict = self._key_dict()
            valdict["role_id"] = role_id
            role = Role.Create(**valdict)
        return role

    def getRole(self, role_id):
        return self.RolesByID[role_id]

    def assignTeamMember(self, person):
        if not person:
            return
        persno = person
        if not isinstance(persno, basestring):
            persno = person.personalnummer
        tm = self.TeamMembersByPersno[persno]
        if not tm:
            valdict = self._key_dict()
            valdict["cdb_person_id"] = persno
            tm = TeamMember.Create(**valdict)
            self.handleAutoSubscription([tm])
        return tm

    def assignDomain(self, acd_id, ctx=None):
        from cdb.platform import acs
        if not acs.AccessControlDomain.ByKeys(acd_id):
            # Domain does not exist, ignore it
            return
        if not self.DomainAssignmentsByID[acd_id]:
            valdict = self._key_dict()
            valdict["acd_id"] = acd_id
            DomainAssignment.Create(**valdict)
            # wg. AEnderungen an den Schutzklassenzuordnungen den Cache explizit
            # aktualisieren (In Abhaengigkeit vom Property cmlt auch fuer andere Anwender)
            if ctx:
                ctx.refresh_caches(util.kCGDomainAssignmentCache, util.kSynchronizedReload)

    def removeDomain(self, acd_id, ctx=None):
        d = self.DomainAssignmentsByID[acd_id]
        if d:
            d.Delete()
        if ctx:
            # wg. AEnderungen an den Schutzklassenzuordnungen den Cache explizit
            # aktualisieren (In Abhaengigkeit vom Property cmlt auch fuer andere Anwender)
            ctx.refresh_caches(util.kCGDomainAssignmentCache, util.kSynchronizedReload)

    def getParent(self):
        return self.ParentProject

    def setProjectId(self, ctx):
        if self.cdb_project_id in ['#', '']:
            # automatische Nummerung
            self.cdb_project_id = "P%06d" % util.nextval("PROJECT_ID_SEQ")

    def setPosition(self, ctx):
        if self.ParentProject and not self.position:
            self.position = (len(self.ParentProject.SubProjects) + 1) * 10

    def setTemplateOID(self, ctx):
        if ctx:
            if ctx.action == u"copy" and ctx.cdbtemplate[u"cdb_object_id"]:
                self.template_oid = ctx.cdbtemplate[u"cdb_object_id"]
            elif ctx.action == u"delete":
                sqlapi.SQLupdate(u"cdbpcs_project SET template_oid = '' WHERE template_oid = '%s'"
                                 % self.cdb_object_id)
                for t in self.Tasks:
                    t.setTemplateOID()

    def on_cdbpcs_reinit_position_now(self, ctx):
        """
        Event handler for initializing positions of tasks
        """
        self.reinitPosition(ctx)

    def reinitPosition(self, ctx):
        """
        Initializes the positions of the task structure
        :param ctx:
        :return:
        """
        with transactions.Transaction():
            tasks = map(lambda x: x, self.TopTasks)
            self.TopTasks.Update(position=0)
            for task in tasks:
                task.setPosition()
                task.reinitPosition()

    def checkProjectId(self, ctx):
        if ctx.get_current_mask() == "initial":
            if self.cdb_project_id not in ['#', ''] and Project.ByKeys(self.cdb_project_id):
                # already exists
                raise ue.Exception("pcs_err_project_id", self.cdb_project_id)

    def setDefaults(self, ctx):
        # if ctx.action == 'create':
        # self.first_day_valid = 1
        if ctx.get_current_mask() == "initial":
            self.cdb_project_id = ""
            self.division = auth.get_department()
            calendar_profile = fCalendarProfile.get_by_name(self.DefaultCalendarProfileName)
            if calendar_profile:
                self.calendar_profile_id = calendar_profile.cdb_object_id
                ctx.set("mapped_calendar_profile", calendar_profile.name)

    def setWorkflow(self, ctx):
        if ctx.get_current_mask() == "initial":
            if self.category:
                self.cdb_objektart = ProjectCategory.ByKeys(self.category).workflow
            else:
                self.cdb_objektart = "cdbpcs_project"

    def setProjectManager(self, ctx):
        if ctx.error != 0:
            return
        # Defaultrollen anlegen
        self.createBasicRoles(ctx)
        if self.initial_manager:
            pm = org.Person.ByKeys(self.initial_manager)
            # Projektleiter als Teammitglied hinzufuegen und
            # Projektleiterrolle anlegen und mit Projektleiter besetzen
            self.assignTeamMember(pm)
            role = self.createRole(kProjectManagerRole)
            role.assignSubject(pm, ctx)
            # Defaultrollen an den Projektleiter vergeben
            self.assignDefaultRoles(pm, ctx)

    def getProjectManagerName(self):
        role = self.RolesByID[kProjectManagerRole]
        if role:
            return role.GetDescription()
        return u""

    def getProjectManagers(self):
        role = self.RolesByID[kProjectManagerRole]
        if role:
            return role._Owners()
        return []

    def createBasicRoles(self, ctx):
        role = self.createRole(kProjectManagerRole)
        for role in self.default_roles:
            self.createRole(role)

    def assignDefaultRoles(self, person, ctx=None):
        if isinstance(person, basestring):
            person = org.Person.ByKeys(person)
        # Defaultrollen anlegen und an die Person vergeben
        for role_id in self.default_roles:
            role = self.getRole(role_id=role_id)
            if role:
                role.assignSubject(person, ctx)
        self.updateTeam()

    def createFollowUp(self, ctx):
        u"""
        Tells `ctx` to start the follow up operation
        ``cdbpcs_project_overview``. The follow up is
        only created if there is no pending error. Because
        CDB/Win starts a follow up on its own when performing
        a copy on the toplevel structure node, this method
        skips the creation of an additional follow up in this case.
        """
        if ctx.error != 0 or ctx.cad_system == u"MS-Project":
            return
        if ctx.action != "copy" or getattr(ctx.sys_args, "structurerootaction", "") != "1":
            ctx.set_followUpOperation('cdbpcs_project_overview', 1)

    def makeID(self, attr, obj, prefix="", length=0):
        u""" Builds a new ID for the object specified by object within the project context based
        on the attribute specified by attr.
        The specified prefix will be prepended to the generated ID.
        All key attributes, except attr, will be used as query condition
        to find the max value for attr. cdb_project_id must be part of the primary key."""
        additional_keys = obj.KeyDict()
        del additional_keys["cdb_project_id"]
        del additional_keys[attr]
        return self.newID(self.cdb_project_id, obj.GetTableName(), attr, prefix, length, additional_keys)

    @classmethod
    def newID(cls, cdb_project_id, relation, attr, prefix="", length=0, additional_keys={}):
        stmt = "max(%s) FROM %s WHERE cdb_project_id = '%s'" % (attr, relation, cdb_project_id)
        if prefix:
            stmt += " AND %s LIKE '%s%%'" % (attr, prefix)
        ti = util.tables[relation]
        # Add additional keys to query condition (e.g. checklist_id for checkpoints)
        for key, value in additional_keys.items():
            stmt += u" AND %s = %s" % (key, ti.make_literal(key, u"%s" % value))
        t = sqlapi.SQLselect(stmt)
        max_id = sqlapi.SQLstring(t, 0, 0)
        fmt = u"%s%0" + u"%s" % (length) + "d"
        if len(max_id) == 0:
            new_id = fmt % (prefix, 1)
        else:
            new_id = fmt % (prefix, (int(max_id[len(prefix):]) + 1))
        return new_id

    def getReadOnlyFields(self, action=u"modify", avoid_check=False):
        readonly = ["start_time_plan", "end_time_plan", "days", "effort_plan", "is_group"]

        if self.status != Project.EXECUTION.status:
            readonly += ["percent_complet"]

        if self.is_group:
            readonly += ["start_time_act", "end_time_act", "effort_act", "percent_complet"]

        if action == u"modify":
            # Das Vorlagenkennzeichen kann nachtraeglich nicht mehr geaendert werden
            readonly += ["template"]

            if self.is_group:
                if self.auto_update_time:
                    readonly += ["start_time_fcast", "end_time_fcast", "days_fcast"]
                if self.auto_update_effort:
                    readonly += ["effort_fcast"]

            # Bei einem gesperrten Projekt duerfen die Planungsdaten nicht veraendert werden,
            # ebenso bei einem MSP-Projekt
            if self.msp_active or self.locked_by and self.locked_by != auth.persno:
                readonly += ["start_time_fcast", "end_time_fcast", "days_fcast", "auto_update_time"]

            if len(self.TimeSheets):
                readonly += ["effort_act"]

        return unique(readonly)

    def on_copy_pre_mask(self, ctx):
        if ctx.get_current_mask() == "initial":
            # Projektleiterauswahl nur dann, wenn das kopierte Projekt keine besetzte Projektleiterrolle hat oder es eine Vorlage ist
            template_project = Project.ByKeys(ctx.cdbtemplate["cdb_project_id"])
            prj_mgr_role = template_project.RolesByID[kProjectManagerRole]
            if self.template or not prj_mgr_role or (prj_mgr_role and not prj_mgr_role.SubjectAssignmentsByType):
                ctx.next_mask_expected(1)
            if getattr(ctx.ue_args, "create_project_from_template", "0") == "1":
                self.Update(template=0,
                            parent_project='',
                            parent_project_name='')
            self.initial_manager = ""
        if ctx.get_current_mask() == "cdbpcs_prj_manager":
            self.initial_manager = auth.persno

        # Ist-Attribute werden nicht mitkopiert
        ctx.set("start_time_act", "")
        ctx.set("end_time_act", "")
        ctx.set("effort_act", 0)
        ctx.set("percent_complet", 0)
        ctx.set_fields_readonly(self.getReadOnlyFields(action=ctx.action))

    def on_copy_post_mask(self, ctx):
        if ctx.get_current_mask() == "initial" and not self.template:
            # Projektleiterauswahl nur dann, wenn das kopierte Projekt keine besetzte Projektleiterrolle hat oder es eine Vorlage ist
            template_project = Project.ByKeys(ctx.cdbtemplate["cdb_project_id"])
            prj_mgr_role = template_project.RolesByID[kProjectManagerRole]
            if template_project.template or not prj_mgr_role or (prj_mgr_role and not prj_mgr_role.SubjectAssignmentsByType):
                ctx.next_mask("cdbpcs_prj_manager")

    def on_relship_copy_post(self, ctx):
        if ctx.error != 0:
            return
        # Rollen, Rollenvergaben und Teamzuordnungen werden ueber die Beziehungen mitkopiert.
        # Falls beim Kopieren ein neuer Projektleiter festgelegt wurde, diesen
        # nun nach dem Kopieren der entsprechenden Beziehungen eintragen.
        template_project = Project.ByKeys(ctx.cdbtemplate["cdb_project_id"])
        prj_mgr_role = template_project.RolesByID[kProjectManagerRole]
        if not self.template and (template_project.template or not prj_mgr_role or (prj_mgr_role and not prj_mgr_role.SubjectAssignmentsByType)):
            if ctx.relationship_name == 'cdbpcs_project_to_cdb_person':
                # Projektleiter als Teammitglied hinzufuegen
                self.assignTeamMember(org.Person.ByKeys(self.initial_manager))
            elif ctx.relationship_name == 'cdbpcs_project_to_subjects':
                # Projektleiterrolle ggf. anlegen und vergeben
                assigned_subj = SubjectAssignment.KeywordQuery(cdb_project_id=self.cdb_project_id)
                for subject in assigned_subj:
                    if subject.subject_id2 == template_project.cdb_project_id:
                        subject.subject_id2 = self.cdb_project_id
                pm = org.Person.ByKeys(self.initial_manager)
                role = self.createRole(kProjectManagerRole)
                role.assignSubject(pm, ctx)
                # Defaultrollen anlegen und fuer den Projektleiter vergeben
                for role in self.default_roles:
                    self.createRole(role).assignSubject(pm, ctx)

        # Aufgaben-, Checklisten- und ChecklistItem- status wird auf "NEW" zurückgesetzt
        if ctx.relationship_name == 'cdbpcs_project2tasks':
            for ts in self.Tasks:
                ts.Reset()

        if ctx.relationship_name == 'cdbpcs_project2cdbpcs_checklist':
            for cl in self.Checklists:
                cl.Reset()

        if ctx.relationship_name == 'cdbpcs_project2cdbpcs_cl_item':
            for cl_it in self.ChecklistItems:
                cl_it.Reset()

    def on_cdbxml_excel_report_pre_mask(self, ctx):
        self.Super(Project).on_cdbxml_excel_report_pre_mask(ctx)
        if ctx.get_current_mask() != "initial":
            ctx.set("project_name", self.project_name)

    def on_copy_post(self, ctx):
        if ctx.error != 0:
            return
        # Ist-Beginndatum, Ist-Enddatum, Ist-Aufwand und fertigestellt zurücksetzen
        self.Update(start_time_act="", end_time_act="", effort_act=0, percent_complet=0)

        if ctx:
            ctx.refresh_caches(util.kCGAccessSystemRuntimeCaches, util.kSynchronizedReload)

        # Projekt anzeigen
        self.createFollowUp(ctx)

    def checkProjectLevel(self, ctx):
        u""" SampleCode below can be used in subclasses to implement
        restrictions for the project hierachie.

        if ctx.get_current_mask() == 'initial':
            # allow only first level subprojects
            if self.ParentProject and self.ParentProject.ParentProject: raise ue.Exception("pcs_err_crt_subprj")
            # dont mix suprojects and tasks
            if self.ParentProject and self.ParentProject.Tasks: raise ue.Exception("pcs_err_mod_mix")
            """
        pass

    def on_create_pre_mask(self, ctx):
        if ctx.get_current_mask() == "initial":
            self.checkProjectLevel(ctx)
            self.setPosition(ctx)
            # Folgemaske zur Projektleiterauswahl
            ctx.next_mask_expected(1)
            if self.parent_project and self.ParentProject.template == 1:
                self.template = 1

    def on_create_post_mask(self, ctx):
        if ctx.get_current_mask() == "initial" and not self.template:
            ctx.next_mask("cdbpcs_prj_manager")

    def on_modify_post_mask(self, ctx):
        if ctx.dialog.parent_project != ctx.object.parent_project:
            # Sample code to allow one-level project hierarchy only: see also checkProjectLevel
            # if self.ParentProject and self.SubProjects:
            #    raise ue.Exception("pcs_err_mod_subprj")
            # recalculate position
            self.setPosition(ctx)

    def on_delete_pre(self, ctx):
        if self.SubProjects:
            raise ue.Exception("pcs_err_del_proj4")
        if self.TimeSheets:
            raise ue.Exception("pcs_err_del_proj1")

    def on_delete_post(self, ctx, db_relations=[]):
        """
        Deletes referenced records using cdb.sqlapi.SQLDelete within a transaction
        Can be customized similar to the following lines

        class MyProject(Project):
            ...
            def on_delete_post(self, ctx):
                additional_relations = ['my_additional_relation']
                self.Super(MyProject).on_delete_post(ctx, additional_relations)
            ...

        :param db_relations: Additional relations from which referenced records are to be deleted
        """
        if ctx.error != 0:
            return
        relations = ['cdbpcs_cl_prot', 'cdbpcs_doc2cl', 'cdbpcs_cli_prot', 'cdbpcs_doc2cli',
                     'cdbpcs_iss_rem', 'cdbpcs_issr_txt', 'cdbpcs_doc2iss', 'cdbpcs_iss_prot',
                     'cdbpcs_iss_log', 'cdbpcs_doc2task']
        with transactions.Transaction():
            for relation in relations + db_relations:
                if ddl.Table(relation) and ddl.Table(relation).hasColumn('cdb_object_id'):
                    sqlapi.SQLdelete(
                        "from cdb_object where id in (select cdb_object_id from {} where cdb_project_id = '{}')".format(
                            relation, self.cdb_project_id)
                    )
                sqlapi.SQLdelete("from {} where cdb_project_id = '{}'".format(relation, self.cdb_project_id))

    def on_modify_pre_mask(self, ctx):
        ctx.set_fields_readonly(self.getReadOnlyFields(action=ctx.action))

    @classmethod
    def _set_template_catalog_query_args(cls, ctx):
        if ctx.catalog_invoking_op_name == "cdbpcs_create_project":
            if not ctx.catalog_requery:
                if not "templatecatalogargsset" in ctx.ue_args.get_attribute_names():
                    ctx.keep("templatecatalogargsset", "1")
                    # We might got some decomposition-attributes by on_cdb_create_doc_from_template_now
                    for attr in ctx.catalog_invoking_dialog.get_attribute_names():
                        if attr[-15:] == "_initalqueryarg":
                            ctx.set(attr[:-15], ctx.catalog_invoking_dialog[attr])

    def on_cdbpcs_msp_create_from_template_now(self, ctx):
        from cs.pcs.projects.tasks import Task
        project = Project.ByKeys(ctx.objects[0]['cdb_project_id'])
        parent_obj = project
        Task._cdbpcs_create_from(ctx=ctx, project=project, parent_obj=parent_obj)

    @classmethod
    def on_cdbpcs_create_project_now(cls, ctx):
        u"""
        Create an project by selecting an template and copy it
        """
        # Get the project
        if not ctx.catalog_selection:
            kwargs = {}
            # If we are in a decomposition, evaluate the predefined attributes
            if "decompositionclsid" in ctx.sys_args.get_attribute_names():
                decomposition = ctx.sys_args["decompositionclsid"]
                if decomposition:
                    # get predefined attrs, e.g. from decompositions
                    from cdb.platform.mom import entities
                    cdef = entities.CDBClassDef(decomposition)
                    predef_args = cdef.getPredefinedOpArgs("CDB_Search", True)
                    for arg in predef_args:
                        # This one is for the catalog configuration
                        # to behave as if the attributes were in the
                        # dialog
                        kwargs[arg.name] = arg.value
                        # This one is for _set_template_catalog_query_args
                        kwargs[arg.name + "_initalqueryarg"] = arg.value
            ctx.start_selection(catalog_name="pcs_project_templates", **kwargs)
        else:
            pnumber = ctx.catalog_selection[0]["cdb_project_id"]
            template = Project.ByKeys(pnumber)
            ctx.set_followUpOperation("CDB_Copy",
                                      opargs=[
                                          ("create_project_from_template", True),
                                          ("keep_positions_of_tasks", False)],
                                      keep_rship_context=True,
                                      op_object=template)

    def reset_invalid_subject_ids(self):
        team = self.TeamMembersByPersno.keys()
        for t in self.Tasks.KeywordQuery(subject_type=u"Person"):
            if t.subject_id not in team:
                t.subject_id = kProjectManagerRole
                t.subject_type = u"PCS Role"

    def adopt_all_project_roles_from_template(self, task_template):
        self.adopt_project_role_from_template(task_template=task_template)
        for t in task_template.SubTasks:
            self.adopt_all_project_roles_from_template(task_template=t)

    def adopt_project_role_from_template(self, task_template):
        old_role = task_template._getResponsibleRole()
        if not old_role:
            return

        # if role not already exists: add role to project
        new_role = Role.ByKeys(role_id=old_role.role_id, cdb_project_id=self.cdb_project_id)
        if not new_role:
            Role.Create(role_id=old_role.role_id,
                        cdb_project_id=self.cdb_project_id,
                        description=old_role.description)

    def acceptNewTask(self, task=None):
        rule = "cdbpcs: Finalized Project"
        if Rule.ByKeys(rule) and self.MatchRule(rule):
            raise ue.Exception("pcs_err_new_task1", self.project_name)

    def checkStructureLock(self, ctx=None):
        calledByOfficeLink = ctx and hasattr(ctx, "active_integration") \
            and ctx.active_integration == "OfficeLink"
        if not calledByOfficeLink \
           and not Project.structuralChangesAllowed(project=self, ctx=ctx):
            raise ue.Exception(u"cdbpcs_msp_structure_lock")

    @classmethod
    def structuralChangesAllowed(cls, project, ctx=None):
        if project.msp_active and (ctx == None or ctx.cad_system != u"MS-Project"):
            return False
        return True

    def GetDisplayAttributes(self):
        u"""This method creates and returns a results dictionary, containing the
        necessary information for the html display in the client."""
        results = self.Super(Project).GetDisplayAttributes()
        results[u"attrs"].update({u"heading": unicode(self["mapped_category_name"])})
        return results

    def GetSearchSummary(self):
        obj = self.getPersistentObject()
        summary = []
        summary.append(u"%s" % obj["description"])
        summary.append(u"%s" % obj["joined_status_name"])
        return unicode(u"\n".join(summary))

    def initTaskRelationOIDs(self):
        upd = """cdbpcs_taskrel SET
                    pred_project_oid = (SELECT cdb_object_id FROM cdbpcs_project p
                                        WHERE cdbpcs_taskrel.cdb_project_id2 = p.cdb_project_id),
                    succ_project_oid = (SELECT cdb_object_id FROM cdbpcs_project p
                                        WHERE cdbpcs_taskrel.cdb_project_id = p.cdb_project_id),
                    pred_task_oid = (SELECT cdb_object_id FROM cdbpcs_task t
                                     WHERE cdbpcs_taskrel.cdb_project_id2 = t.cdb_project_id
                                     AND cdbpcs_taskrel.task_id2 = t.task_id),
                    succ_task_oid = (SELECT cdb_object_id FROM cdbpcs_task t
                                     WHERE cdbpcs_taskrel.cdb_project_id = t.cdb_project_id
                                     AND cdbpcs_taskrel.task_id = t.task_id),
                    cross_project = (CASE WHEN cdbpcs_taskrel.cdb_project_id2 != cdbpcs_taskrel.cdb_project_id
                                         THEN 1 ELSE 0 END)
                WHERE cdbpcs_taskrel.cdb_project_id = '%s' OR cdbpcs_taskrel.cdb_project_id2 = '%s'
              """ % (self.cdb_project_id, self.cdb_project_id)
        return sqlapi.SQLupdate(upd)

    def adjustDependingObjects(self, adjust_tasks=False):
        u'''
        Diese Methode muss aufgerufen werden, nachdem das Projekt ausserhalb
        des cdb.objects-Frameworks modifiziert wurde.
        Änderungen an allen betroffenen Aufgaben werden abhängigen Objekten bekannt gemacht
        '''
        if adjust_tasks:
            for t in self.AllTasks:
                t.adjustDependingObjects()
        sig.emit(Project, "adjustDependingObjects")(self)

    def getCriticalIssues(self):
        status_list = [Issue.NEW.status, Issue.EVALUATION.status, Issue.EXECUTION.status,
                       Issue.DEFERRED.status, Issue.WAITINGFOR.status, Issue.REVIEW.status]
        return filter(lambda x: x.priority == "kritisch" and x.status in status_list, self.Issues)

    def getStartDateFcast(self):
        if self.start_time_fcast:
            return cdbtime.Time(self.start_time_fcast).date()
        return None

    def getEndDateFcast(self):
        if self.end_time_fcast:
            return cdbtime.Time(self.end_time_fcast).date()
        return None

    def getStartDatePlan(self):
        if self.start_time_plan:
            return cdbtime.Time(self.start_time_plan).date()
        return None

    def getEndDatePlan(self):
        if self.end_time_plan:
            return cdbtime.Time(self.end_time_plan).date()
        return None

    def getStartDateAct(self):
        if self.start_time_act:
            return cdbtime.Time(self.start_time_act).date()
        return None

    def getEndDateAct(self):
        if self.end_time_act:
            return cdbtime.Time(self.end_time_act).date()
        return None

    def getEarnedValue(self):
        tasks = self.TopTasks
        if tasks:
            return float(sum(x.getEarnedValue() for x in tasks))
        return self.getWorkCompletion() / 100 * self.getPlanCost()

    def getPlannedValue(self, myDate=None):
        tasks = self.TopTasks
        if tasks:
            return float(sum(x.getPlannedValue(myDate) for x in tasks))
        return self.getPlanTimeCompletion(myDate) * self.getPlanCost()

    def getWorkCompletion(self):
        if self.percent_complet:
            return float(self.percent_complet)
        return 0.0

    def getPlanCost(self):
        if self.effort_plan:
            return float(self.effort_plan)
        return 0.0

    def getForeCast(self):
        if self.effort_fcast:
            return float(self.effort_fcast)
        return 0.0

    def getActCost(self):
        if self.effort_act:
            return float(self.effort_act)
        return 0.0

    def getPlanTimeCompletion(self, myDate=None):
        if not myDate:
            myDate = datetime.date.today()
        etp = self.getEndDatePlan()
        if etp and etp <= myDate:
            return 1.0
        return 0.0

    def getPlanTimeCompletion2(self):
        maxWorkdays = self.getWorkdays()
        myDate = datetime.date.today()
        stp = self.getStartDatePlan()
        etp = self.getEndDatePlan()
        if not maxWorkdays or not stp or not etp or stp > myDate:
            return 0.0
        if etp <= myDate:
            return 1.0
        days_done = float(len(Calendar.project_workdays(self.cdb_project_id, stp, myDate)))
        return days_done / maxWorkdays

    def getActTimeCompletion(self):
        maxWorkdays = self.getWorkdays()
        myDate = self.getActualWorkday()
        stp = self.getStartDatePlan()
        if not maxWorkdays or not stp or not myDate:
            return 0.0
        days_done = float(len(Calendar.project_workdays(self.cdb_project_id,
                                                        stp, myDate)))
        return days_done / maxWorkdays

    def getActualWorkday(self):
        u'''
        liefert den aktuellen Stand des Projekts als Datum das zwischen
        dem geplanten Start- und Enddatum liegt
        '''
        # Projekte wurde bereits beendet
        if self.end_time_act:
            return self.getEndDatePlan()

        # Projekt wurde noch nicht gestartet
        if not self.start_time_plan:
            return None

        # Projekt besitzt Unteraufgaben: Ermittle den aktuellen Stand via Unteraufgaben
        tasks = filter(lambda x: not len(x.SubTasks) and x.start_time_plan and not x.end_time_act, self.Tasks)
        if tasks:
            tasks.sort(lambda x, y: cmp(x.getActualWorkday(), y.getActualWorkday()))
            return tasks[0].getActualWorkday()

        # Offenen Projektanteil bestimmen und das resultierende Datum ermitteln
        days_done = 0
        if self.percent_complet:
            days_done = int(float(self.getWorkdays()) * float(self.percent_complet) / 100)
        return Calendar.next_project_workday(self.cdb_project_id, self.getStartDatePlan(), days_done)

    def getWorkdays(self):
        try:
            sd = self.getStartDatePlan()
            ed = self.getEndDatePlan()
            return max(len(Calendar.project_workdays(self.cdb_project_id, sd, ed)), 0)
        except Exception:
            misc.log_traceback("Workdays can not been determined")
            return 0

    def getWorkhours(self):
        return workday.days_to_hours(self.getWorkdays())

    dialog_item_change_methods = {
        "days_fcast": "self.changeDuration(ctx)",
        "start_time_fcast": "self.changeStartTime(ctx)",
        "end_time_fcast": "self.changeEndTime(ctx)",
        "effort_fcast": "self.changeEffort(ctx)",
        }

    def dialog_item_change(self, ctx):
        attr = ctx.changed_item
        if (ctx.action == "create" or attr in ctx.dialog.get_attribute_names()):
            if self.dialog_item_change_methods.has_key(attr):
                eval(self.dialog_item_change_methods[attr])

    def changeEffort(self, ctx):
        cld = len(self.Tasks)
        if ctx and ctx.action == "copy":
            cld = len(fTask.KeywordQuery(cdb_project_id=ctx.cdbtemplate.cdb_project_id))
        if self.effort_fcast and self.effort_fcast < 0:
            self.effort_fcast = 0.0
        if cld == 0:
            self.effort_plan = self.effort_fcast

    def calculateTimeFrame(self, start="", end="", days="", shift_right=True):
        return Calendar.calculateTimeFrame(self.calendar_profile_id, start, end, days, shift_right)

    def changeDuration(self, ctx):
        self.setDaysFcast(ctx=ctx, days=self.days_fcast)

    def changeStartTime(self, ctx):
        self.setStartTimeFcast(ctx=ctx, start=self.start_time_fcast)

    def changeEndTime(self, ctx):
        self.setEndTimeFcast(ctx=ctx, end=self.end_time_fcast)

    # create/copy/modify: post_mask
    def checkEffortFields(self, ctx):
        # if no children: aggregate values = plan values = forecast values
        cld = len(self.Tasks)
        if ctx and ctx.action == "copy":
            cld = len(fTask.KeywordQuery(cdb_project_id=ctx.cdbtemplate.cdb_project_id))
        if cld == 0:
            if self.effort_plan != self.effort_fcast:
                self.effort_plan = self.effort_fcast
            if self.start_time_fcast is None:
                self.start_time_fcast = ""
            if self.start_time_plan != self.start_time_fcast:
                self.start_time_plan = self.start_time_fcast
            if self.end_time_fcast is None:
                self.end_time_fcast = ""
            if self.end_time_plan != self.end_time_fcast:
                self.end_time_plan = self.end_time_fcast

        # set auto_update_* flags
        if "auto_update_time" in ctx.dialog.get_attribute_names() and \
            u"%s" % ctx.dialog.auto_update_time == u"1":
            ctx.keep("auto_update_changed", 1)
            if cld > 0:
                ctx.set("start_time_fcast", self.start_time_plan)
                ctx.set("end_time_fcast", self.end_time_plan)
        if "auto_update_effort" in ctx.dialog.get_attribute_names() and \
            u"%s" % ctx.dialog.auto_update_effort == u"1":
            ctx.keep("auto_update_changed", 1)
            if cld > 0:
                ctx.set("effort_fcast", self.effort_plan)

        # start/end must be filled jointly
        if (self.start_time_fcast and not self.end_time_fcast) or \
            (not self.start_time_fcast and self.end_time_fcast):
            raise ue.Exception("pcs_capa_err_025")
        if ctx.action == "modify":
            if "start_time_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.start_time_fcast != ctx.object.start_time_fcast:
                ctx.keep("_time_fcast_changed", 1)
            if "end_time_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.end_time_fcast != ctx.object.end_time_fcast:
                ctx.keep("_time_fcast_changed", 1)
            if "effort_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.effort_fcast != ctx.object.effort_fcast:
                ctx.keep("_effort_fcast_changed", 1)
        if ctx.action == "copy":
            if "start_time_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.start_time_fcast != ctx.cdbtemplate.start_time_fcast:
                ctx.keep("_time_fcast_changed", 1)
            if "end_time_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.end_time_fcast != ctx.cdbtemplate.end_time_fcast:
                ctx.keep("_time_fcast_changed", 1)
            if "effort_fcast" in ctx.dialog.get_attribute_names() and \
                ctx.dialog.effort_fcast != ctx.cdbtemplate.effort_fcast:
                ctx.keep("_effort_fcast_changed", 1)

    def on_Prj_Autolock_now(self, ctx):
        if self.CheckAccess('lock') and not self.locked_by:
            myPersno = u"%s" % auth.persno
            self.locked_by = myPersno

    def on_Prj_Autounlock_now(self, ctx):
        if self.CheckAccess('unlock') and self.locked_by == u"%s" % auth.persno:
            self.locked_by = ''
            # if not "unlock" in ctx.dialog.get_attribute_names():
            #    msgbox = ctx.MessageBox("pcs_unlocked", [], "unlock", ctx.MessageBox.kMsgBoxIconInformation)
            #    msgbox.addButton(ctx.MessageBoxButton("ok", 1))
            #    ctx.show_message(msgbox)

    def on_Prj_Lock_now(self, ctx):
        myPersno = u"%s" % auth.persno
        if self.locked_by == myPersno:
            return
        if self.locked_by:
            raise ue.Exception("pcs_err_lock", self.mapped_locked_by_name)
        self.locked_by = myPersno
        if not "lock" in ctx.dialog.get_attribute_names():
            msgbox = ctx.MessageBox("pcs_locked", [], "lock", ctx.MessageBox.kMsgBoxIconInformation)
            msgbox.addButton(ctx.MessageBoxButton("ok", 1))
            ctx.show_message(msgbox)

    def on_Prj_Unlock_now(self, ctx):
        if not self.locked_by:
            return
        self.locked_by = ''
        if not "unlock" in ctx.dialog.get_attribute_names():
            msgbox = ctx.MessageBox("pcs_unlocked", [], "unlock", ctx.MessageBox.kMsgBoxIconInformation)
            msgbox.addButton(ctx.MessageBoxButton("ok", 1))
            ctx.show_message(msgbox)

    def checkScheduleLock(self):
        if self.locked_by and self.locked_by != u"%s" % auth.persno:
            raise ue.Exception("pcs_write_locked")

    def setLock(self, ctx=None, verbose=False):
        myPersno = u"%s" % auth.persno
        if self.CheckAccess('lock'):
            if not self.locked_by:
                self.locked_by = myPersno
                # if ctx and verbose and not "lock" in ctx.dialog.get_attribute_names():
                #    msgbox = ctx.MessageBox("pcs_locked", [], "lock", ctx.MessageBox.kMsgBoxIconInformation)
                #    msgbox.addButton(ctx.MessageBoxButton("ok", 1))
                #    ctx.show_message(msgbox)
            elif ctx and verbose and self.locked_by and self.locked_by != myPersno:
                if not "lock" in ctx.dialog.get_attribute_names():
                    msgbox = ctx.MessageBox("pcs_write_locked", [], "lock", ctx.MessageBox.kMsgBoxIconInformation)
                    msgbox.addButton(ctx.MessageBoxButton("ok", 1))
                    ctx.show_message(msgbox)
        return self.isLockedByMe()

    def isLockedByMe(self):
        return self.locked_by == u"%s" % auth.persno

    def isPartOfTemplateProject(self, part):
        from cs.pcs.projects.tasks import Task
        from cs.pcs.checklists import Checklist
        from cs.pcs.checklists import ChecklistItem
        if part and isinstance(part, Project):
            return part.template == 1
        if part and isinstance(part, (Task, Checklist, ChecklistItem)):
            return part.Project and part.Project.template == 1
        return False

    def on_cdb_cal_refresh_project_now(self, ctx):
        self.recalculate()
        for t in self.Tasks:
            t.adjustDependingObjects()

    # post_mask
    def _correctCalendarDates(self, ctx):
        u""" Check if the planned project start and end dates are included in
            the specified calendar profile. If not, raise an exception to the
            user to change it.
        """
        self.checkEffortFields(ctx)
        if ctx.get_current_mask() != 'initial':
            return
        if ctx.dialog.calendar_profile_id != '':
            from cs import calendar
            newCalProf = calendar.CalendarProfile\
                          .ByKeys(ctx.dialog.calendar_profile_id)
            cp_start = newCalProf.valid_from
            cp_end = newCalProf.valid_until
            proj_start = self.getStartTime()
            proj_end = self.getEndTime()
            # 3 cases where the dates could be invalid, depending on whether
            # start_time_plan is defined, end_time_plan is defined or both are
            if ((proj_start and (proj_start < cp_start or cp_end < proj_start)) or
                   (proj_end and (proj_end < cp_start or cp_end < proj_end))):
                p_sd = to_legacy_date_format(proj_start, full=False)
                p_ed = to_legacy_date_format(proj_end, full=False)
                cp_sd = to_legacy_date_format(cp_start, full=False)
                cp_ed = to_legacy_date_format(cp_end, full=False)
                raise ue.Exception("cdb_proj_cal_prof", p_sd, p_ed, cp_sd, cp_ed)

    # now
    @classmethod
    def on_cdb_cal_prof_chg_now(cls, ctx):
        MAX_ELEMS_IN_CLAUSE = 500
        list_of_groups = []
        # Split into distinct groups.
        list_of_projno = [obj.cdb_project_id for obj in ctx.objects]
        cutoffs = range(0, len(list_of_projno), MAX_ELEMS_IN_CLAUSE) + \
                  [len(list_of_projno)]
        for n in range(len(cutoffs) - 1):
            list_of_groups.append(list_of_projno[cutoffs[n]:cutoffs[n + 1]])
        for proj_group in list_of_groups:
            projno_str = ", ".join(["'%s'" % sqlapi.quote(proj) for
                                    proj in proj_group])
            sqlapi.SQLupdate("cdbpcs_project SET calendar_profile_id = '%s' "
                             "WHERE cdb_project_id in ( %s )" %
                             (ctx.dialog.calendar_profile_id, projno_str))

    def getResponsiblePersons(self):
        # return the id of persons who own, the role "ProjectManager"
        persons = []
        for pm in self.getProjectManagers():
            persons.append(pm.personalnummer)
        return persons

    @classmethod
    def adjustCalenderChanges(cls, cdb_project_id, day_from, day_until):
        p = Project.ByKeys(cdb_project_id)
        p.recalculate()

    def getEffortAvailable(self):
        fcast = 0.0
        aggr = 0.0
        try:
            fcast = float(self.effort_fcast)
        except Exception:
            pass
        if self.Tasks:
            try:
                aggr = float(self.effort_plan)
            except Exception:
                pass
        return fcast - aggr

    def getEffortForeCast(self):
        return self.effort_fcast

    def getEffortPlan(self):
        return self.effort_plan

    def getStartTimeFcast(self):
        return self.start_time_fcast

    def getStartTimePlan(self):
        return self.start_time_plan

    def getStartTimeAct(self):
        return self.start_time_act

    def getEndTimeFcast(self):
        return self.end_time_fcast

    def getEndTimePlan(self):
        return self.end_time_plan

    def getEndTimeAct(self):
        return self.end_time_act

    def getStartTime(self):
        return self.start_time_fcast if self.start_time_fcast else self.start_time_plan

    def getEndTime(self):
        return self.end_time_fcast if self.end_time_fcast else self.end_time_plan

    def finalStatusCheck(self, ctx=None):
        u"""
        To be called if changes are done by external program like
        MS-Project interface or time schedule to refresh the status signals
        for the whole project incl. all tasks.
        """
        self.updateStatusSignals(time=True, effort=True)

    def finalCheck(self, ctx):
        with transactions.Transaction():
            from cs.pcs.projects.tasks import SecureTaskBase
            with SecureTaskBase(self.cdb_project_id):
                self.aggregateValues(time_act=True, effort_plan=True,
                                     effort_fcast=self.auto_update_effort, effort_act=True)
                self.aggregateValues(percentage=True)
                fTask._adjust_effort_status(self.cdb_project_id)
                Project._adjust_effort_status(self.cdb_project_id)

    def MSPtoDB(self):
        with transactions.Transaction():
            for t in self.TopTasks:
                t.MSPtoDB()
            self.is_group = len(self.TopTasks) > 0
            self.adjust_values(time_plan=True)
            self.initTaskRelationOIDs()
            if self.msp_active:
                sig.emit(Project, "adjustAllocationsOnly")(self)
                sig.emit(Project, "do_consistency_checks")(self)
            else:
                self.recalculate()

    def on_cdbpcs_prj_reset_start_time_pre_mask(self, ctx):
        self.checkStructureLock(ctx=ctx)
        start_time_old = self.start_time_fcast if self.start_time_fcast else self.start_time_plan
        if not start_time_old:
            raise ue.Exception('pcs_move_project_error_01')
        ctx.set('start_time_old', to_user_repr_date_format(start_time_old))

    def on_cdbpcs_prj_reset_start_time_now(self, ctx):
        self.checkStructureLock(ctx=ctx)
        newsd = None
        try:
            newsd = ctx.dialog.start_time_new
        except Exception:
            pass
        if not newsd:
            return
        self.reset_start_time(ctx, ctx.dialog['start_time_old'], newsd)

    def reset_start_time(self, ctx=None, start_time_old=None, start_time_new=None):
        '''
        Die Methode verschiebt sowohl den Sollwert als auch den aggregierten Wert des aufgerufenen und
        aller untergeordneten Elemente.
        '''
        if not start_time_new or not start_time_old:
            return

        # determine the new start date
        newsd = None
        try:
            newsd = cdbtime.Time(start_time_new).date()
        except Exception:
            return

        # new start date must be within the valid time span
        if newsd < self.CalendarProfile.valid_from.date():
            nsd = to_legacy_date_format_auto(newsd)
            cp_sd = to_legacy_date_format_auto(self.CalendarProfile.valid_from)
            cp_ed = to_legacy_date_format_auto(self.CalendarProfile.valid_until)
            raise ue.Exception("cdb_proj_cal_prof", nsd, "?", cp_sd, cp_ed)

        # determine distance to move
        (new_start_idx, _) = Calendar.getIndexByDate(self.calendar_profile_id,
                                                     to_python_rep(sqlapi.SQL_DATE, start_time_new))
        (old_start_idx, _) = Calendar.getIndexByDate(self.calendar_profile_id,
                                                     to_python_rep(sqlapi.SQL_DATE, start_time_old))
        if old_start_idx and new_start_idx:
            distance = new_start_idx - old_start_idx
            if distance:
                # adjust constraint dates of all tasks and start dates for all manual tasks
                for t in self.Tasks:
                    t.moveFixedDates(distance=distance, calendar_profile_id=self.calendar_profile_id)
                # move project and start adjustment process
                self.setStartTimeFcast(start=Calendar.getDateByIndex(self.calendar_profile_id, new_start_idx))

    def setTimeframe(self, ctx=None, start=None, end=None, days=None, **kwargs):
        with transactions.Transaction():
            start, end, duration, days = self.calculateTimeFrame(start=start, end=end, days=days)
            if not self.is_group:
                self.setAttributeValues(ctx=ctx,
                                        start_time_fcast=start, end_time_fcast=end,
                                        duration_fcast=duration, days_fcast=days,
                                        start_time_plan=start, end_time_plan=end,
                                        duration=duration, days=days, **kwargs)
            else:
                self.setAttributeValues(ctx=ctx,
                                        start_time_fcast=start, end_time_fcast=end,
                                        duration_fcast=duration, days_fcast=days, **kwargs)

    def adjust_values(self, **kwargs):
        kwargs["prj_id"] = self.cdb_project_id
        with transactions.Transaction():
            if self.is_group:
                Project._adjust_parent_to_subtasks(**kwargs)
            else:
                Project._adjust_own_values(**kwargs)

    @classmethod
    def _adjust_own_values(cls, prj_id, time_plan=False, effort_plan=False, **kwargs):
        kwargs2 = Project.MakeChangeControlAttributes()
        kwargs2["cdb_apersno"] = kwargs2["cdb_mpersno"]
        kwargs2["cdb_adate"] = sqlapi.SQLdbms_date(kwargs2["cdb_mdate"])
        changes = []
        changes.append("cdb_apersno='%(cdb_apersno)s', cdb_adate=%(cdb_adate)s" % kwargs2)
        if time_plan:
            changes.append("start_time_plan = start_time_fcast, end_time_plan = end_time_fcast")
        if effort_plan:
            changes.append("effort_plan = effort_fcast")
        sig.emit(Project, "extend_project_adjust_own_values")(changes, **kwargs)
        if changes:
            change_str = ', '.join(changes)
            upd = "cdbpcs_project SET %s WHERE cdb_project_id = '%s'" % (change_str, prj_id)
            return sqlapi.SQLupdate(upd)
        return 0

    @classmethod
    def _adjust_parent_to_subtasks(cls, prj_id, time_plan=False, time_fcast=False, time_act=False,
                                   effort_plan=False, effort_fcast=False, effort_act=False,
                                   percentage=False, **kwargs):
        from cs.pcs.projects.tasks import Task
        kwargs2 = Project.MakeChangeControlAttributes()
        kwargs2["cdb_apersno"] = kwargs2["cdb_mpersno"]
        kwargs2["cdb_adate"] = sqlapi.SQLdbms_date(kwargs2["cdb_mdate"])
        kwargs2["canceled"] = Task.DISCARDED.status
        kwargs2["chr1"] = u"''"
        if sqlapi.SQLdbms() == sqlapi.DBMS_ORACLE:
            kwargs2["chr1"] = u"chr(1)"
        changes = []
        changes.append("cdb_apersno='%(cdb_apersno)s', cdb_adate=%(cdb_adate)s" % kwargs2)
        if time_plan:
            changes.append("""  start_time_plan = (SELECT MIN(CASE
                                                   WHEN t.start_time_fcast IS NULL
                                                   THEN t.start_time_plan
                                                   ELSE t.start_time_fcast END)
                                                   FROM cdbpcs_task t
                                                   WHERE t.parent_task = %(chr1)s
                                                   AND t.cdb_project_id = cdbpcs_project.cdb_project_id),
                                end_time_plan =   (SELECT MAX(CASE
                                                   WHEN t.end_time_fcast IS NULL
                                                   THEN t.end_time_plan
                                                   ELSE t.end_time_fcast END)
                                                   FROM cdbpcs_task t
                                                   WHERE t.parent_task = %(chr1)s
                                                   AND t.cdb_project_id = cdbpcs_project.cdb_project_id)""" % kwargs2)
        if time_fcast:
            changes.append("""  start_time_fcast = (SELECT MIN(CASE
                                                    WHEN t.start_time_fcast IS NULL
                                                    THEN t.start_time_plan
                                                    ELSE t.start_time_fcast END)
                                                    FROM cdbpcs_task t
                                                    WHERE t.parent_task = %(chr1)s
                                                    AND t.cdb_project_id = cdbpcs_project.cdb_project_id),
                                end_time_fcast =   (SELECT MAX(CASE
                                                    WHEN t.end_time_fcast IS NULL
                                                    THEN t.end_time_plan
                                                    ELSE t.end_time_fcast END)
                                                    FROM cdbpcs_task t
                                                    WHERE t.parent_task = %(chr1)s
                                                    AND t.cdb_project_id = cdbpcs_project.cdb_project_id)""" % kwargs2)
        if time_act:
            changes.append("""  start_time_act =   (SELECT MIN(t.start_time_act)
                                                    FROM cdbpcs_task t
                                                    WHERE t.parent_task = %(chr1)s
                                                    AND t.cdb_project_id = cdbpcs_project.cdb_project_id
                                                    AND t.start_time_act IS NOT NULL
                                                    AND t.status != %(canceled)s),
                                end_time_act =     (SELECT CASE
                                                    WHEN MAX(CASE WHEN t.end_time_act IS NULL THEN 1 ELSE 0 END) = 1
                                                    THEN NULL
                                                    ELSE MAX(t.end_time_act) END
                                                    FROM cdbpcs_task t
                                                    WHERE t.parent_task = %(chr1)s
                                                    AND t.cdb_project_id = cdbpcs_project.cdb_project_id
                                                    AND t.status != %(canceled)s)""" % kwargs2)
        if effort_plan:
            changes.append("""  effort_plan =  (SELECT SUM(CASE
                                                WHEN t.effort_fcast IS NULL
                                                THEN 0
                                                ELSE t.effort_fcast END)
                                                FROM cdbpcs_task t
                                                WHERE t.parent_task = %(chr1)s
                                                AND t.cdb_project_id = cdbpcs_project.cdb_project_id
                                                AND t.status != %(canceled)s)""" % kwargs2)
        if effort_fcast:
            changes.append("""  effort_fcast = (SELECT SUM(CASE
                                                WHEN t.effort_fcast IS NULL
                                                THEN 0
                                                ELSE t.effort_fcast END)
                                                FROM cdbpcs_task t
                                                WHERE t.parent_task = %(chr1)s
                                                AND t.cdb_project_id = cdbpcs_project.cdb_project_id
                                                AND t.status != %(canceled)s)""" % kwargs2)
        if effort_act:
            changes.append("""  effort_act =   (SELECT SUM(t.effort_act)
                                                FROM cdbpcs_task t
                                                WHERE t.parent_task = %(chr1)s
                                                AND t.cdb_project_id = cdbpcs_project.cdb_project_id
                                                AND t.effort_act IS NOT NULL)""" % kwargs2)
        if percentage:
            changes.append("""  percent_complet = (SELECT cast(ROUND(CASE
                                                   WHEN SUM(t.effort_fcast) > 0
                                                   THEN SUM(t.percent_complet * t.effort_fcast) / SUM(t.effort_fcast)
                                                   WHEN COUNT(CASE WHEN t.effort_fcast = 0 THEN 1 ELSE 0 END) > 0
                                                   THEN SUM(t.percent_complet) / COUNT(CASE WHEN t.effort_fcast = 0 THEN 1 ELSE 0 END)
                                                   ELSE 0 END, 0) as int)
                                                   FROM cdbpcs_task t
                                                   WHERE t.parent_task = %(chr1)s
                                                   AND t.cdb_project_id = cdbpcs_project.cdb_project_id
                                                   AND t.status != %(canceled)s)""" % kwargs2)
        sig.emit(Project, "extend_project_adjust_parent_to_subtasks")(changes, **kwargs)
        if changes:
            change_str = ', '.join(changes)
            upd = "cdbpcs_project SET %s WHERE cdb_project_id = '%s'" % (change_str, prj_id)
            return sqlapi.SQLupdate(upd)
        return 0

    def aggregateValues(self, **kwargs):
        if len(self.Tasks):
            kwargs["prj_id"] = self.cdb_project_id
            with transactions.Transaction():
                Project._adjust_parent_to_subtasks(**kwargs)

    @classmethod
    def _adjust_time_status(cls, prj_id):
        kwargs = {}
        kwargs["prj_id"] = prj_id
        upd = """
        cdbpcs_project SET status_time_fcast = (CASE
                 WHEN cdbpcs_project.start_time_fcast IS NULL THEN 0
                 WHEN cdbpcs_project.end_time_fcast IS NULL THEN 0
                 WHEN cdbpcs_project.start_time_fcast > cdbpcs_project.start_time_plan THEN 2
                 WHEN cdbpcs_project.end_time_fcast < cdbpcs_project.end_time_plan THEN 2
                 ELSE 1 END)
        WHERE cdb_project_id = '%(prj_id)s'
        """ % kwargs
        return sqlapi.SQLupdate(upd)

    @classmethod
    def _adjust_effort_status(cls, prj_id):
        kwargs = {}
        kwargs["prj_id"] = prj_id
        kwargs["chr1"] = u"''"
        if sqlapi.SQLdbms() == sqlapi.DBMS_ORACLE:
            kwargs["chr1"] = u"chr(1)"
        upd = """
        cdbpcs_project SET status_effort_fcast = (CASE
                 WHEN cdbpcs_project.effort_fcast IS NULL THEN 0
                 WHEN cdbpcs_project.effort_act IS NOT NULL
                 AND cdbpcs_project.effort_fcast < cdbpcs_project.effort_act
                 AND cdbpcs_project.effort_fcast_a < cdbpcs_project.effort_act THEN 3
                 WHEN cdbpcs_project.effort_plan IS NOT NULL
                 AND cdbpcs_project.effort_fcast < cdbpcs_project.effort_plan THEN 2
                 WHEN cdbpcs_project.effort_fcast_d IS NOT NULL
                 AND cdbpcs_project.effort_fcast < cdbpcs_project.effort_fcast_d THEN 2
                 WHEN cdbpcs_project.effort_fcast_a IS NOT NULL
                 AND cdbpcs_project.effort_fcast < cdbpcs_project.effort_fcast_a THEN 2
                 ELSE 1 END)
        WHERE cdb_project_id = '%(prj_id)s'
        """ % kwargs
        return sqlapi.SQLupdate(upd)

    def _get_update_statements(self, fcast_movement, plan_movement):
        cpid = self.calendar_profile_id
        changes = []
        if plan_movement:
            changes.append("""
                start_time_plan = (SELECT b.day FROM cdb_calendar_entry a, cdb_calendar_entry b
                                   WHERE start_time_plan = a.day
                                   AND a.late_work_idx = b.late_work_idx - %(plan_movement)s AND b.day_type_id = 1
                                   AND a.calendar_profile_id = '%(cpid)s' AND b.calendar_profile_id = '%(cpid)s'
                                   AND a.personalnummer IS NULL AND a.cdb_project_id IS NULL
                                   AND b.personalnummer IS NULL AND b.cdb_project_id IS NULL)
                           """ % locals())
            changes.append("""
                end_time_plan   = (SELECT b.day FROM cdb_calendar_entry a, cdb_calendar_entry b
                                   WHERE end_time_plan = a.day
                                   AND a.early_work_idx = b.early_work_idx - %(plan_movement)s AND b.day_type_id = 1
                                   AND a.calendar_profile_id = '%(cpid)s' AND b.calendar_profile_id = '%(cpid)s'
                                   AND a.personalnummer IS NULL AND a.cdb_project_id IS NULL
                                   AND b.personalnummer IS NULL AND b.cdb_project_id IS NULL)
                           """ % locals())
        if fcast_movement:
            changes.append("""
                start_time_fcast = (SELECT b.day FROM cdb_calendar_entry a, cdb_calendar_entry b
                                    WHERE start_time_fcast = a.day
                                    AND a.late_work_idx = b.late_work_idx - %(fcast_movement)s AND b.day_type_id = 1
                                    AND a.calendar_profile_id = '%(cpid)s' AND b.calendar_profile_id = '%(cpid)s'
                                    AND a.personalnummer IS NULL AND a.cdb_project_id IS NULL
                                    AND b.personalnummer IS NULL AND b.cdb_project_id IS NULL)
                           """ % locals())
            changes.append("""
                end_time_fcast   = (SELECT b.day FROM cdb_calendar_entry a, cdb_calendar_entry b
                                    WHERE end_time_fcast = a.day
                                    AND a.early_work_idx = b.early_work_idx - %(fcast_movement)s AND b.day_type_id = 1
                                    AND a.calendar_profile_id = '%(cpid)s' AND b.calendar_profile_id = '%(cpid)s'
                                    AND a.personalnummer IS NULL AND a.cdb_project_id IS NULL
                                    AND b.personalnummer IS NULL AND b.cdb_project_id IS NULL)
                           """ % locals())
        return changes

    @classmethod
    def _mark_changed_project(cls, prj_id):
        kwargs = Project.MakeChangeControlAttributes()
        kwargs["cdb_apersno"] = kwargs["cdb_mpersno"]
        kwargs["cdb_adate"] = sqlapi.SQLdbms_date(kwargs["cdb_mdate"])
        upd = """cdbpcs_project SET cdb_apersno='%s', cdb_adate=%s WHERE cdb_project_id = '%s'
        """ % (kwargs["cdb_apersno"], kwargs["cdb_adate"], prj_id)
        sqlapi.SQLupdate(upd)
        prj = Project.ByKeys(prj_id)
        prj.Reload()

    def updateStatusSignals(self, time=False, effort=False, **kwargs):
        with transactions.Transaction():
            if time:
                Project._adjust_time_status(prj_id=self.cdb_project_id)
            if effort:
                Project._adjust_effort_status(prj_id=self.cdb_project_id)

    def get_delay(self):
        fcast = self.getEndDateFcast()
        act = self.getEndDateAct()
        if fcast and act:
            return (act - fcast).days
        return 0

    def get_time_completion(self, myDate=None):
        u""" Calculates the work days of the project:
            SD:            Start Date of project
            ED:            End Date of project
            myDate:        given date or actual date
            days_done:     workdays passed
            days_total:    workdays in total
            done_percent:  workdays done in percent
            returns tuple (<SD>, <ED>, <myDate>, <days done>, <days total>
                            <done percent>)
        """
        days_total = self.getDurationInDays()
        if not myDate:
            myDate = datetime.date.today()
        stp = self.getStartDatePlan()
        etp = self.getEndDatePlan()
        if not stp or not etp:
            return (stp, etp, myDate, 0, 0, 0)
        if myDate < stp:
            days_done = 0
        elif myDate > etp:
            days_done = days_total
        else:
            days_done = len(Calendar.project_workdays(self.cdb_project_id,
                                                      stp,
                                                      myDate))
        done_percent = 0
        if days_total:
            done_percent = int(round(100.0 * days_done / days_total, 0))
        return (stp, etp, myDate, days_done, days_total, done_percent)

    def get_total_state(self):
        u""" Calculates the total state of the project
            return one of the following values representing signal lights
                0: undefiend
                1: green (good)
                2: yellow (warning)
                3: red (bad)
        """
        cost_state = self.get_cost_state()[6]
        schedule_state = self.get_schedule_state()[6]
        return max(cost_state, schedule_state)

    def get_manual_light(self):
        u""" Determines value of manual light rating for project
                0: undefiend
                1: green (good)
                2: yellow (warning)
                3: red (bad)
        """
        rating = self.rating
        if rating == 'gruen':
            state = 1
        elif rating == 'rot':
            state = 3
        elif rating == 'gelb':
            state = 2
        else:
            state = 0
        return state

    def get_time_state(self):  # todo: WRONG - DO NOT USE
        u""" Calculates time efficiency of the project by date:
            ED: Earned Days
            AD: Actual Days
            TV: Time Variance            (ED - AD)
            TPI: Time Performance Index  (ED / AD)
            EDC: Earned Days Completion  (ED / <Scheduled Workdays>)
            ADC: Actual Days Completion  (AD / <Scheduled Workdays>)
            state color: Signal color (red, green, yellow, undefiened)
            returns a tuple (<ED>, <AD>, <TV>, <TPI>, <EDC>, <ADC>,
                            <state color>)
        """
        # Bestimme die erbrachte Arbeitsleistung
        earned_value = self.getEarnedValue()

        # Bestimme den Zeitpunkt, zu dem die Arbeitsleistung zu erbringen war
        stp = self.getStartDatePlan()
        etp = self.getEndDatePlan()
        scheduled_date = self.getCompletionDateByEffort(stp, etp, earned_value)

        # Bestimme die geleisteten Arbeitstage und die geplanten Arbeittage
        actual_date = datetime.date.today()
        ed = len(Calendar.project_workdays(self.cdb_project_id, stp,
                                           scheduled_date))
        ad = len(Calendar.project_workdays(self.cdb_project_id, stp,
                                           actual_date))
        # Setzte die geleisteten Arbeitstage mit den geplanten in Relation
        days_total = self.getDurationInDays()
        tv = 0.0
        tpi = 1.0
        myState = 0
        if ad:
            tv = ed - ad
            tpi = round(float(ed) / float(ad), 1)
            myState = self._getState(tpi)
        edc = 0
        adc = 0
        if days_total:
            edc = int(round(100.0 * ed / days_total, 0))
            adc = int(round(100.0 * ad / days_total, 0))
        return (ed, ad, tv, tpi, edc, adc, myState)

    def get_cost_state(self):
        u""" Calculates the cost efficiency of the project:
            EV: Earned Value
            AC: Actual Costs
            CV: Cost Variance            (EV - AC)
            CPI: Cost Performance Index  (EV / AC)
            EVC: Earned Value Completion (EV / <Scheduled Costs>)
            ACC: Actual Cost Completion  (AC / <Scheduled Costs>)
            state color: Signal color (red, green, yellow, undefiened)
            returns a tuple (<EV>, <AC>, <CV>, <CPI>, <EVC>, <ACC>,
                            <state color>)
        """
        # Bestimme die erbrachte Arbeitsleistung
        ev = self.getEarnedValue()

        # Bestimme die bislang angefallenen Kosten
        ac = self.getActCost()

        # Setzte aktuelle Kosten mit erbrachter Leistung Relation
        scheduled_costs = self.getPlanCost()
        cv = 0.0
        cpi = 1.0
        myState = 0
        if ac:
            cv = ev - ac
            cpi = round(ev / ac, 1)
            myState = self._getState(cpi)
        evc = 0
        acc = 0
        if scheduled_costs:
            evc = int(round(100 * ev / scheduled_costs, 0))
            acc = int(round(100 * ac / scheduled_costs, 0))
        return (ev, ac, cv, cpi, evc, acc, myState)

    def get_schedule_state(self):
        u""" Calculates the time efficiency of the project by effort:
            EV: Earned Value
            PV: Planned Value
            SV: Schedule Variance            (EV - PV)
            SPI: Schedule Performance Index  (EV / PV)
            EVC: Earned Value Completion     (EV / <Scheduled Costs>)
            PVC: Planned Value Completion    (PV / <Scheduled Costs>)
            state color: Signal color (red, green, yellow, undefiened)
            returns a tuple (<EV>, <PV>, <SV>, <SPI>, <EVC>, <PVC>,
                            <state color>)
        """
        # Bestimme die erbrachte Arbeitsleistung
        ev = self.getEarnedValue()

        # Bestimme die zum aktuellen Zeitpunkt geplante Leistung
        pv = self.getPlannedValue()

        # Setzte geplante Leistung mit erbrachter Leistung Relation
        scheduled_costs = self.getPlanCost()
        sv = 0.0
        spi = 1.0
        myState = 0
        if pv:
            sv = ev - pv
            spi = round(ev / pv, 1)
            myState = self._getState(spi)
        evc = 0
        pvc = 0
        if scheduled_costs:
            evc = int(round(100 * ev / scheduled_costs, 0))
            pvc = int(round(100 * pv / scheduled_costs, 0))
        return (ev, pv, sv, spi, evc, pvc, myState)

    def _getState(self, efficiency):
        if efficiency >= 1.0:
            return 1
        if efficiency >= 0.9:
            return 2
        return 3

    def getCompletionDateByEffort(self, start_date, end_date, myEffort):  # todo: WRONG - DO NOT USE
        def my_compare(a, b):
            if not a[0] and b[0]:
                return -1
            if a[0] and not b[0]:
                return 1
            comp = cmp(a[0], b[0])
            if comp:
                return comp
            return cmp(b[1], a[1])

        if not myEffort:
            return start_date
        tasks = map(lambda x: (x.getEndDatePlan(),
                               x.getPlanCost()),
                               self.Tasks)
        # tasks_end = filter(lambda x: x[0], tasks)
        # tasks_no_end = filter(lambda x: not x[0], tasks)
        # total_effort = reduce(lambda a, b: a + b, tasks_no_end, 0.0)
        tasks.sort(my_compare)
        total_effort = 0.0
        for t in tasks:
            if t[1]:
                total_effort += t[1]
            if total_effort >= myEffort:
                return t[0]
        return end_date

    def getDurationInDays(self):
        if self.duration:
            return self.duration / 8
        return 0

    def handleAutoSubscription(self, members):
        u"""
        Subscribes all `members` to the project's
        activity channel, if the conditions are
        suitable.
        """
        if self.status == Project.EXECUTION.status:
            if self.GetClassDef().isActivityChannel():
                from cs.activitystream.objects import Subscription
                for member in members:
                    Subscription.subscribeToChannel(self.cdb_object_id, member.cdb_person_id)

    def _handleSubscriptions(self, ctx):
        u"""
        Autosubscribe all team members to the project, on the
        workflow step to EXECUTION.
        """
        if not ctx.error:
            self.handleAutoSubscription(self.TeamMembers)

    def addQCArguments(self, args):
        args.update(cdb_project_id=self.cdb_project_id)

    def setInitValues(self, ctx):
        ctx.set_focus("project_name")
        ctx.set_fields_readonly(self.getReadOnlyFields(action=ctx.action))

    def resetValues(self, ctx):
        ctx.set(u"msp_z_nummer", "")

    def copyAllTasksWithRelations(self, ctx):
        with transactions.Transaction():
            from cs.pcs.projects.tasks import SecureTaskBase
            with SecureTaskBase(self.cdb_project_id):
                task_id_mapping_table = {}
                self = self.getPersistentObject()
                project_template = Project.ByKeys(ctx.cdbtemplate.cdb_project_id)
                for task_template in project_template.TopTasks:
                    # Copy task structure
                    mapping_table, new_task = task_template._copy_task(ctx, self.cdb_project_id, "",
                                                                       clear_msp_task_ids=False)
                    task_id_mapping_table.update(mapping_table)
                # Copy task relations
                fTask._copy_taskrels_by_mapping(ctx.cdbtemplate.cdb_project_id, self.cdb_project_id, task_id_mapping_table)
                # Following line is a little confusing: within the method for copying tasks and their referenced
                # objects, a call is hidden, which copies all checklists - as well as checklists without reference
                # to a task
                project_template.copyRelatedObjects(self)
                self.Reload()
                self.initTaskRelationOIDs()

    def approximate_to_forecast(self, ctx):
        if ctx and hasattr(ctx, 'cdbtemplate'):
            self.reset_start_time(start_time_old=ctx.cdbtemplate.start_time_fcast,
                                  start_time_new=self.start_time_fcast)

    def copyRelatedObjects(self, new_project):
        # Copy referenced checklists
        for checklist in self.TopLevelChecklists:
            new_checklist = checklist.MakeCopy(new_project)
            new_checklist.Reset()

        # Copy referenced objects (eg. resource demands)
        sig.emit(Project, "copy_project_hook")(self, new_project)

    def on_cdbpcs_new_subtask_now(self, ctx):
        create_msg = cmsg.Cdbcmsg("cdbpcs_task", constants.kOperationNew, True)
        create_msg.add_item('cdb_project_id', 'cdbpcs_task', self.cdb_project_id)
        ctx.url(create_msg.eLink_url())

    @staticmethod
    def start_project_dashboard(ctx):
        if len(ctx.objects) > MY_PROJECTS_MAX_RECORDS:
            raise ue.Exception("cdbpcs_open_dashboard_num_too_big", MY_PROJECTS_MAX_RECORDS)

        from cs.pcs.dashboard import ProjectOverviewApp
        url_params = "?%s" % "&".join(["project=%s" % project.cdb_project_id for project in ctx.objects])
        return ProjectOverviewApp.OpenPageURL(ProjectOverviewApp.getModuleURL() + url_params)

    def updateTeam(self):
        """
        update team members to exactly reflect current subject assignments

        this method will be called whenever the project subjects change, but
        not if a project subject changes at a lower level (e.g. a common role
        that is part of the project members has its subjects changed)
        """
        persons = []

        for role in self.Roles:
            persons += role.getPersons()

        with transactions.Transaction():
            self.TeamMembers.Delete()
            for person in set(persons):
                self.assignTeamMember(person)

    def check_project_role_assignments(self, ctx):
        """ Called when assignments to a project role is changed."""
        for role in self.Roles:
            if role.Owners:
                if not role.team_assigned:
                    role.Update(team_assigned=1)
            else:
                if role.team_assigned:
                    role.Update(team_assigned=0)

    def check_project_role_needed(self, ctx):
        """ Called when status of project, task, checklist,
            checklist item or issue is changed.
            If any such object within the project has a project role as
            responsible, check if the role has been assigned to a person.
        """
        sql_list = ["""SELECT subject_id FROM cdbpcs_task
                       WHERE cdb_project_id = '{cdb_project_id}'
                       AND subject_type = 'PCS Role'
                       AND status IN %s
                    """ % unicode((20, 50)),
                    """SELECT subject_id FROM cdbpcs_checklst
                       WHERE cdb_project_id = '{cdb_project_id}'
                       AND subject_type = 'PCS Role'
                       AND status = %s
                    """ % unicode(20),
                    """SELECT subject_id FROM cdbpcs_cl_item
                       WHERE cdb_project_id = '{cdb_project_id}'
                       AND subject_type = 'PCS Role'
                       AND status = %s
                    """ % unicode(20),
                    """SELECT subject_id FROM cdbpcs_issue
                       WHERE cdb_project_id = '{cdb_project_id}'
                       AND subject_type = 'PCS Role'
                       AND status IN %s
                    """ % unicode((30, 50, 70, 100))
                    ]
        sql = " UNION ".join(sql_list)
        assigned_roles = sqlapi.RecordSet2(sql=sql.format(**self))
        assigned_roles = map(lambda x: x.subject_id, assigned_roles)
        for role in self.Roles:
            if role.role_id in assigned_roles:
                if role.team_needed != 1:
                    role.Update(team_needed=1)
            else:
                if role.team_needed != 0:
                    role.Update(team_needed=0)

    def recalculation_after_state_change(self, ctx):
        if not ctx.batch:
            self.recalculate()

    event_map = {
        (('create', 'copy'), 'pre'): ("setProjectId", "setPosition", "setTemplateOID"),
        (('create', 'copy'), 'pre_mask'): ("setDefaults", "setInitValues", "resetValues"),
        (('modify'), 'pre_mask'): ("setInitValues"),
        (('create', 'copy', 'modify'), 'dialogitem_change'): ("dialog_item_change"),
        (('create', 'copy'), 'post_mask'): ("checkProjectId", "setWorkflow", "checkProjectLevel"),
        (('modify'), 'post_mask'): ("checkProjectLevel"),
        (('modify'), 'pre'): ("recalculate_preparation"),
        (('modify'), 'post'): ("recalculate", "finalCheck"),
        (('create'), 'post'): ("setProjectManager", "recalculate", "finalCheck", "createFollowUp"),
        (('create', 'copy', 'modify'), 'post_mask'): ('_correctCalendarDates'),
        (('query_catalog'), ('pre_mask', 'pre')): ('_set_template_catalog_query_args'),
        (('copy'), 'post'): ('copyAllTasksWithRelations', 'recalculate', 'finalCheck', 'approximate_to_forecast',
                             'check_project_role_needed'),
        (('wf_step'), 'post'): ("_handleSubscriptions"),
        (('state_change'), 'post'): ("recalculation_after_state_change", "check_project_role_needed"),
        ('cdbpcs_launch_project_dashboard', 'now'): ("start_project_dashboard"),
        ('delete', 'pre'): ("setTemplateOID"),
        }

# TODO: Legacy mode from c.spcs 15.4.1 due to E0E039981 will be removed in later versions
default_roles = Project.default_roles


class ProjectCategory(Object):
    __maps_to__ = "cdbpcs_proj_cat"

    @classmethod
    def on_CDB_GenProjectsDecomp_now(cls, ctx):
        cls.GenerateDecomposition()

    @classmethod
    def GenerateDecomposition(cls):
        categ_rel = "cdbpcs_proj_cat"
        categ_key = "name"
        categ_parent = None
        conditions = {"category": "name"}
        c_conditions = {}
        s_conditions = {}
        label_attr = "name_<language>"
        position_attr = ""
        icon_attr = ""
        leaf_attr = ""
        default_icon = "Folder"
        leaf_icon = "Folder"
        root_id = ""
        order_by = "name_d"
        # create source object
        decompsource = decomp.DecompSource(None, categ_rel, categ_key, categ_parent,
                                           conditions, c_conditions, s_conditions,
                                           label_attr, position_attr, icon_attr,
                                           leaf_attr, default_icon, leaf_icon, root_id,
                                           order_by,
                                           py_generator="cs.pcs.projects.ProjectCategory.GenerateDecomposition")
        # remove decompositions based on the source object
        decompsource.delete_decompositions()
        # create decomposition
        decompsource.generate_decomposition("CDBPCS_PROJECTS")


class DomainAssignment(Object):
    Project = Reference_1(fProject, fDomainAssignment.cdb_project_id)
    __maps_to__ = "cdbpcs_prj_acd"


class TeamMember(Object):
    __maps_to__ = "cdbpcs_team"

    Project = Reference_1(fProject, fTeamMember.cdb_project_id)
    Person = Reference_1(org.Person, fTeamMember.cdb_person_id)

    def setDefaultRoles(self, ctx):
        if ctx.error != 0:
            return
        for role_id in self.Project.default_roles:
            self.Project.createRole(role_id).assignSubject(self.Person, ctx)

    def checkProjectStatus(self, ctx):
        u"""
        if the person already has been assigned a role in the project,
        then the person will be deleted from the role.

        :Parameters:
            ``ctx``: *Context*

        """

        sql_query = u"""
        SELECT role_id, subject_id2, subject_id, subject_type, exception_id, cdb_project_id
        FROM cdbpcs_subject
        WHERE subject_id='%s' AND cdb_project_id='%s'
        """ % (self.Person.personalnummer, self.Project.cdb_project_id)
        rec_set = sqlapi.RecordSet2(sql=sql_query)

        if rec_set:
            for pers in rec_set:
                obj_id = u"""
                role_id='%s' AND
                cdb_project_id='%s' AND
                subject_id='%s' AND
                subject_id2='%s' AND
                subject_type='%s' AND
                exception_id='%s'
                """ % (pers.role_id,
                       pers.cdb_project_id,
                       pers.subject_id,
                       pers.subject_id2,
                       pers.subject_type,
                       pers.exception_id)

                SubjectAssignment.Query(obj_id)[0].Delete()

    def checkTasks(self, _ctx):
        u"""
        the methode checkt the assignment between task and person.

        :Parameters:
            ``ctx``: *Context*

        :raise cdbpcs_check_tasks: Team member can not be deleted, beacause this
            team member was already added as responsible!
        """

        # # Suche Rollenzuweisung einer Person
        mylist = self.Project.Tasks.KeywordQuery(subject_id=self.Person.personalnummer,
                                                 subject_type="Person")
        if mylist:
            raise ue.Exception("cdbpcs_check_tasks", self.Person.name, mylist[0].task_name)

    def _handleSubscription(self, _ctx):
        u"""
        Subscribe the team-member to the projects activity channel.
        """
        if self.Project:
            self.Project.handleAutoSubscription([self])

    # noinspection PyUnusedLocal
    def keep_at_least_one_project_manager(self, ctx):
        if len(fSubjectAssignment.get_further_role_member(self.cdb_project_id, self.cdb_person_id)) == 0:
            raise ue.Exception('pcs_keep_at_least_one_project_manager')

    event_map = {
        ('delete', 'pre'): ("keep_at_least_one_project_manager", "checkTasks"),
        (('create', 'copy'), 'post'): ("setDefaultRoles",
                                       "_handleSubscription")
        }


class SubjectAssignment(org.WithSubject):
    __maps_to__ = "cdbpcs_subject"

    Role1 = Reference_1(fRole, fSubjectAssignment.role_id,
                        fSubjectAssignment.cdb_project_id)
    Role2 = Reference_1(fRole, fSubjectAssignment.subject_id,
                        fSubjectAssignment.subject_id2)
    CommonRole2 = Reference_1(org.CommonRole, fSubjectAssignment.subject_id)
    Project = Reference_1(fProject, fSubjectAssignment.cdb_project_id)

    def on_create_pre(self, _ctx):
        role = self.Role1
        role2 = None
        if self.subject_type == "PCS Role":
            role2 = self.Role2
        elif self.subject_type == "Common Role":
            role2 = self.CommonRole2
        if role and role2:
            myRoles = role.Roles
            myRoles2 = role2.Roles
            if role == role2 or role in myRoles2 or role2 in myRoles:
                raise ue.Exception("cdbpcs_subject_recursion")

    def updateTeam(self, ctx):
        if ctx.error:
            return
        self.Project.updateTeam()

    @classmethod
    def get_further_role_member(cls, cdb_project_id, subject_id, role_id=kProjectManagerRole):
        return fSubjectAssignment.Query("role_id = '{}' AND cdb_project_id = '{}' and subject_id != '{}'".format(
                                        role_id,
                                        cdb_project_id,
                                        subject_id))

    # noinspection PyUnusedLocal
    def keep_at_least_one_project_manager(self, ctx):
        if self.role_id in [kProjectManagerRole, kProjectMemberRole]:
            if len(fSubjectAssignment.get_further_role_member(self.cdb_project_id, self.subject_id)) == 0:
                raise ue.Exception('pcs_keep_at_least_one_project_manager')

    def check_project_role_assignments(self, ctx):
        self.Project.check_project_role_assignments(ctx)

    event_map = {
        ('delete', 'pre'): 'keep_at_least_one_project_manager',
        (('create', 'copy', 'modify', 'delete'), 'post'): ("updateTeam",
                                                           "check_project_role_assignments"),
    }


class PersonAssignment(SubjectAssignment):
    __classname__ = "cdbpcs_subject_per"
    __match__ = SubjectAssignment.cdb_classname >= __classname__

    @staticmethod
    def _auto_complete_hidden_fields(ctx):
        """
        If an assignment will be created by drag & drop, hidden fields are initialized to prevent the input dialog
        from appearing
        """
        if not ctx.dragdrop_action_id:
            return
        ctx.set('subject_id2', '')
        ctx.set('exception_id', '')

    def on_create_post(self, ctx):
        if ctx.error:
            return
        # Automatisch dem Team und Projekmitglied/Default-Rollen zuordnen
        person = org.Person.ByKeys(self.subject_id)

        # due to E018328 - it makes more sense to
        # assign the default roles to every person
        # if self.role_id == kProjectManagerRole:
        if self.Project:
            for dft_role_id in self.Project.default_roles:
                role = self.Project.RolesByID[dft_role_id]
                if role:
                    role.assignSubject(person)

    def on_copy_post(self, ctx):
        if ctx.error:
            return
        person = org.Person.ByKeys(self.subject_id)
        prj = Project.ByKeys(self.cdb_project_id)
        prj.assignTeamMember(person)

    def on_delete_pre(self, _ctx):
        if not self.Project:
            return
        self.keep_at_least_one_project_manager(_ctx)
        if self.role_id == kProjectMemberRole:
            mylist = self.Project.Tasks.KeywordQuery(
                subject_id=self.subject_id, subject_type="Person")
            if mylist:
                raise ue.Exception("cdbpcs_check_person_task_assignment",
                                   self.Subject.name,
                                   mylist[0].task_name)

    def on_delete_post(self, _ctx):
        person = org.Person.ByKeys(self.subject_id)
        if self.Project and person and self.role_id == kProjectMemberRole:
            addtl_assignments = PersonAssignment.KeywordQuery(
                subject_id=self.subject_id,
                cdb_project_id=self.cdb_project_id)
            for assignment in addtl_assignments:
                assignment.Delete()

    event_map = {
        ('create', 'pre_mask'): '_auto_complete_hidden_fields'
    }


class CommonRoleAssignment(SubjectAssignment):
    __classname__ = "cdbpcs_subj_com_role"
    __match__ = SubjectAssignment.cdb_classname >= __classname__

    @staticmethod
    def _auto_complete_hidden_fields(ctx):
        """
        If an assignment will be created by drag & drop, hidden fields are initialized to prevent the input dialog
        from appearing
        """
        if not ctx.dragdrop_action_id:
            return
        ctx.set('subject_id2', '')
        ctx.set('exception_id', '')

    event_map = {
        ('create', 'pre_mask'): '_auto_complete_hidden_fields'
    }


class PCSRoleAssignment(SubjectAssignment):
    __classname__ = "cdbpcs_subj_prj_role"
    __match__ = SubjectAssignment.cdb_classname >= __classname__

    Project = Reference_1(fProject, fPCSRoleAssignment.cdb_project_id)

    @staticmethod
    def _auto_complete_hidden_fields(ctx):
        """
        If an assignment will be created by drag & drop, hidden fields are initialized to prevent the input dialog
        from appearing
        """
        if not ctx.dragdrop_action_id:
            return
        ctx.set('exception_id', '')

    event_map = {
        ('create', 'pre_mask'): '_auto_complete_hidden_fields',
    }


class Role(org.OCRole):
    __maps_to__ = "cdbpcs_prj_role"
    __subject_type__ = "PCS Role"
    __subject_assign_cls__ = SubjectAssignment
    __context_attr__ = "cdb_project_id"
    __default_action__ = "CDBPCS_Role"

    __subject_type_map__ = {"Person": PersonAssignment,
                            "Common Role": CommonRoleAssignment,
                            "PCS Role": PCSRoleAssignment}

    @classmethod
    def BySubjectReferrer(cls, referrer):
        return cls.ByKeys(referrer.subject_id, referrer.cdb_project_id)

    SubjectAssignmentsByType = ReferenceMapping_N(fSubjectAssignment,
                                                  fSubjectAssignment.role_id == fRole.role_id,
                                                  fSubjectAssignment.cdb_project_id == fRole.cdb_project_id,
                                                  indexed_by=fSubjectAssignment.subject_type)

    Tasks = Reference_N(fTask, fTask.subject_id == fRole.role_id,
                        fTask.cdb_project_id == fRole.cdb_project_id,
                        fTask.subject_type == 'PCS Role')

    Checklists = Reference_N(fChecklist, fChecklist.subject_id == fRole.role_id,
                             fChecklist.cdb_project_id == fRole.cdb_project_id,
                             fChecklist.subject_type == 'PCS Role')

    ChecklistItems = Reference_N(fChecklistItem, fChecklistItem.subject_id == fRole.role_id,
                                 fChecklistItem.cdb_project_id == fRole.cdb_project_id,
                                 fChecklistItem.subject_type == 'PCS Role')

    Issues = Reference_N(fIssue, fIssue.subject_id == fRole.role_id,
                         fIssue.cdb_project_id == fRole.cdb_project_id,
                         fIssue.subject_type == 'PCS Role')

    def assignSubject(self, subject, ctx=None):
        if not subject:
            return
        subj_type = subject.SubjectType()
        if not self.__subject_type_map__.has_key(subj_type):
            raise RuntimeError("invalid subject types %s" % subj_type)

        valdict = self._key_dict()
        sid = subject.SubjectID()
        valdict["subject_id"] = sid[0]
        valdict["subject_id2"] = sid[1]
        valdict["subject_type"] = subject.SubjectType()
        valdict["exception_id"] = ""

        assign_cls = self.__subject_type_map__.get(subj_type, None)
        if assign_cls:
            res = assign_cls.ByKeys(**valdict)
            if res is None or res.IsDeleted():
                assign_cls.Create(**valdict)
        # wg. AEnderungen an den Rollenzuordnungen den Rollencache explizit
        # aktualisieren (In Abhaengigkeit vom Property cmlt auch fuer andere Anwender)
        if ctx:
            ctx.refresh_caches(util.kCGRoleCaches, util.kSynchronizedReload)

    def _check_no_tasks(self, _ctx=None):
        if self.Tasks or self.Checklists or self.ChecklistItems or self.Issues:
            raise ue.Exception("cdbpcs_role_still_used")

    def getSubjectName(self):
        return self["mapped_name"]

    event_map = {
        (('delete'), 'pre'): "_check_no_tasks",
        }


@classbody
class SchemaComponent(object):
    Project = Reference_1(Project, SchemaComponent.cdb_project_id)


@classbody
class InfoMessage(object):
    Project = Reference_1(Project, SchemaComponent.cdb_project_id)


@classbody
class Process(object):
    Project = Reference_1(Project, Process.cdb_project_id)

    @classmethod
    def getPCSRoleType(cls):
        u"""
        Returns pcs role subject type.
        """
        return fRole.__subject_type__

    @classmethod
    def getPCSRoles(cls, cdb_project_id, role_id=None):
        u"""
        Returns pcs roles specified by `cdb_project_id` and, if given,
        by `role_id`. The result is always an `cdb.objects.ObjectCollection`.
        """
        cond = "cdb_project_id='%s'" % cdb_project_id
        if role_id:
            cond += " and role_id='%s'" % role_id
        return fRole.Query(cond)


@classbody
class Action(object):
    Project = Reference_1(Project, Action.cdb_project_id)


@classbody
class Person(object):

    constDefaultCalendarProfileName = "Standard"

    constDefaultWorkdays = {
        '1': True,
        '2': True,
        '3': True,
        '4': True,
        '5': True,
        '6': True,
        '7': True
    }

    @property
    def DefaultCalendarProfileName(self):
        """
        Returns the name of the default calendar profile to be used by creating a person
        Can be overwritten by customizations in order to preset the name depending on location,
        organization or whatever needed
        :return: string
        """
        return self.constDefaultCalendarProfileName

    @property
    def default_work_days(self):
        """
        Defines the default values, which weekdays are working days
        :rtype: dict
        """
        return self.constDefaultWorkdays

    def manage_resource_input_fields(self, ctx):
        """
        Input fields of resource management are tagged as optional or mandatory fields
        :param ctx:
        :return: None
        """
        if self.is_resource:
            ctx.set_mandatory(".mapped_calendar_profile")
            ctx.set_mandatory("capacity")
        else:
            ctx.set_optional(".mapped_calendar_profile")
            ctx.set_optional("capacity")

    def manage_default_calendar_profile(self, ctx):
        """
        If the person has been tagged as resource, default calendar profile to be set
        :param ctx:
        :return: None
        """
        if not self.is_resource:
            return
        if self.is_resource and self.calendar_profile_id:
            return
        calendar_profile = fCalendarProfile.get_by_name(self.DefaultCalendarProfileName)
        if calendar_profile:
            self.calendar_profile_id = calendar_profile.cdb_object_id
            ctx.set("mapped_calendar_profile", calendar_profile.name)

    @sig.connect(Person, "modify", "pre_mask")
    def _modify_pre_mask(self, ctx):
        self.manage_resource_input_fields(ctx)

    @sig.connect(Person, "create", "dialogitem_change")
    @sig.connect(Person, "copy", "dialogitem_change")
    @sig.connect(Person, "modify", "dialogitem_change")
    def resource_dialog_item_change(self, ctx):
        if ctx.changed_item == 'is_resource':
            self.manage_resource_input_fields(ctx)
            self.manage_default_calendar_profile(ctx)

    @sig.connect(Person, 'create', 'pre')
    @sig.connect(Person, 'copy', 'pre')
    @sig.connect(Person, 'modify', 'pre')
    def _ensureCalendarProfileForResource(self, ctx):
        if self.is_resource and not self.calendar_profile_id:
            raise ue.Exception("cdb_cal_prof_mand")

    @sig.connect(Person, 'create', 'pre')
    @sig.connect(Person, 'copy', 'pre')
    @sig.connect(Person, 'modify', 'pre')
    def _ensureCapacityForResource(self, ctx):
        if not self.is_resource:
            return
        if not self.capacity or self.capacity <= 0:
            raise ue.Exception("resource_with_invalid_capacity")


class ProjectResponsibleProvider(PythonColumnProvider):

    @staticmethod
    def getColumnDefinitions(classname, query_args):
        return [{'column_id': 'responsible_txt',
                 'label': util.get_label("cdbpcs_project_responsibles"),
                 'data_type': 'text'}]

    @staticmethod
    @lru_cache()
    def getProjectResponsibles(cdb_project_id):
        """
        This method should be used in other applications too.
        The caching is with web apps in mind, which would call this method
        multiple times for the same project
        """
        result = ""
        _role = Role.KeywordQuery(cdb_project_id=cdb_project_id, role_id=kProjectManagerRole)
        if len(_role):
            role = _role[0]
            result = "; ".join([pers.getSubjectName() for pers in role.Persons])
        return result

    @staticmethod
    def getColumnData(classname, table_data):
        return [{
            "responsible_txt": ProjectResponsibleProvider.getProjectResponsibles(data["cdb_project_id"]),
        } for data in table_data]

    @staticmethod
    def getRequiredColumns(classname, available_columns):
        return ["cdb_project_id"]
