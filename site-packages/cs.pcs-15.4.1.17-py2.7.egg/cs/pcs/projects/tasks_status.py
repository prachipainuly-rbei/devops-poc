#!/usr/bin/env python
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
# CDB:Browse
# pylint: disable-msg=E0213,E1103,E0102,E0203,W0212,W0621,W0201,W0142

__docformat__ = "restructuredtext en"
__revision__ = "$Id: tasks_status.py 168005 2017-11-08 09:21:58Z heg $"

from cdb import cdbtime
from cdb import sqlapi
from cdb import ue
from cdb import util
from cdb.classbody import classbody
from cdb.objects import State
from cdb.objects import Transition
from cdb.platform import gui
from cs.pcs.projects.tasks import Task
from cs.pcs.projects.tasks import kTaskDependencyAA
from cs.pcs.projects.tasks import kTaskDependencyAE
from cs.pcs.projects.tasks import kTaskDependencyEA
from cs.pcs.projects.tasks import kTaskDependencyEE


Task.__taskrel_constraints__ = {
    20: False,
    200: True,
    }


@classbody
class Task(object):
    def on_wf_step_post_mask(self, ctx):
        if self.status == 0 and (len(self.Subtasks) or len(self.Checklists)):
            self.user_confirmation(ctx, "cdbpcs_reset_task", "ask_reset_task")
        if self.status == 250 and len(self.Subtasks):
            self.user_confirmation(ctx, "cdbpcs_finish_task", "ask_finish_task")

    def user_confirmation(self, ctx, question, attr):
        attr_value = getattr(ctx.dialog, attr, "")
        if attr_value == "":
            msgbox = ctx.MessageBox(question, [self.task_name], attr)
            msgbox.addYesButton(1)
            msgbox.addNoButton()
            ctx.show_message(msgbox)
            return False
        else:
            result = ctx.dialog[attr]
            if result == "0":
                # Statuswechsel abgebrochen.
                raise ue.Exception("cdbpcs_sc_cancel")

    def _getTaskRelConstraints(self, to_status):
        """
        enforcement of task relationship constraints is customizable in
        Task.__taskrel_constraints__
        """
        if to_status == 20 and self.__taskrel_constraints__[20]:
            return [
                ("MatchStateList", [self.getPredecessors(kTaskDependencyEA), Task.endStatus(), "pcstask_wf_rej_7"]),
                ("MatchStateList", [self.getPredecessors(kTaskDependencyAA), [Task.EXECUTION] + Task.endStatus(), "pcstask_wf_rej_6"]),
                ]
        if to_status == 200 and self.__taskrel_constraints__[200]:
            return [
                ("MatchStateList", [self.getPredecessors(kTaskDependencyEA), Task.endStatus(), "pcstask_wf_rej_7"]),
                ("MatchStateList", [self.getPredecessors(kTaskDependencyAA), [Task.EXECUTION] + Task.endStatus(), "pcstask_wf_rej_6"]),
                ("MatchStateList", [self.getPredecessors(kTaskDependencyEE), Task.endStatus(), "pcstask_wf_rej_10"]),
                ("MatchStateList", [self.getPredecessors(kTaskDependencyAE), [Task.EXECUTION] + Task.endStatus(), "pcstask_wf_rej_11"]),
            ]
        return []

    @classmethod
    def endStatus(cls, full_cls=True):
        """
        returns set of "final" status classes (full_cls True) or integer values
        (full_cls False) and cache them for subsequent access
        """
        if not hasattr(cls, "__end_status_cls__"):
            cls.__end_status_cls__ = [cls.DISCARDED, cls.FINISHED, cls.COMPLETED]
            cls.__end_status_int__ = [x.status for x in cls.__end_status_cls__]
        if full_cls:
            return cls.__end_status_cls__
        return cls.__end_status_int__

    def getFinalStatus(self):
        """
        returns next status for this task after one of its children's status
        was changed.

        if all children's status is final and at least one child is FINISHED or
        COMPLETED -> FINISHED

        else None
        """
        result = None

        for relship in [self.SubTasks, self.Checklists, self.Issues]:
            for child in relship:
                if child.status not in child.endStatus(full_cls=False):
                    return False
                if child.status != child.DISCARDED.status:
                    result = self.FINISHED

        return result

    def getPredecessors(self, dependency):
        return [task_rel.PredecessorTask for task_rel in self.PredecessorTaskRelationsByType[dependency]]

    def getSuccessors(self, dependency):
        return [task_rel.SuccessorTask for task_rel in self.SuccessorTaskRelationsByType[dependency]]

    def getInitialSubtasks(self):
        end = self.endStatus(False)

        def predecessors(task):
            for rel in [kTaskDependencyEA, kTaskDependencyEE]:
                if [p for p in task.getPredecessors(rel) if p.status not in end]:
                    return True

        return [sub for sub in self.SubTasks if not predecessors(sub)]

    def getSubtasksMeetingPredecessorCondition(self):
        """
        "Predecessor Condition" - this is referenced throughout status change
        logic

        return all subtasks that meet alle the following criteria:
          - all EA predecessors are COMPLETED or FINISHED
          - all AA predecessors are EXECUTION, DISCARDED, COMPLETED, or FINISHED
        """
        ea_status = [Task.COMPLETED.status, Task.FINISHED.status]
        aa_status = [Task.EXECUTION.status, Task.DISCARDED.status,
                     Task.COMPLETED.status, Task.FINISHED.status]
        return [sub for sub in self.SubTasks
                if not [
                    pre for pre in sub.getPredecessors(kTaskDependencyEA)
                    if int(pre.status) not in ea_status]
                and not [
                    succ for succ in sub.getSuccessors(kTaskDependencyAA)
                    if int(succ.status) not in aa_status]
            ]

    def _getTransitions(self, source_status, target_status):
        import itertools
        for x in itertools.product(["*", source_status], [target_status]):
            transition = Task.__transitions__.get(x, None)
            if transition:
                copied_transition = transition.__class__()
                copied_transition.init(source_status, target_status)
                yield copied_transition

    def adjustSuccessorStatus(self):
        if self.IsDeleted():
            source_status = self.status
            target_status = self.DISCARDED.status
        else:
            source_status = self.NEW.status
            target_status = self.status

        self.GetState(target_status).PerformFollowUpStateChanges(self)
        for transition in self._getTransitions(source_status, target_status):
            transition.PerformFollowUpStateChanges(self)

    def isDiscarded(self):
        return self.status == Task.DISCARDED.status

    class NEW(State):
        status = 0

        def checkStructureConsistency(state, self):
            if not self.checkStructureStatus([0]):
                raise ue.Exception("cdbpcs_structure_consistency_new")

        def Constraints(state, self):
            u'''
            - Project's status has to be NEW, EXECUTION, or FROZEN
            - Parent task's status has to be NEW, READY or EXECUTION
            '''
            from cs.pcs.projects import Project
            return [
                ("MatchStateList", [[self.Project], [Project.NEW, Project.EXECUTION, Project.FROZEN], "pcstask_wf_rej_5"]),
                ("MatchStateList", [[self.ParentTask], [Task.NEW, Task.READY, Task.EXECUTION], "pcstask_wf_rej_1"]),
            ]

        # Transition TO_NEW implements FollowUpStateChanges

        def post(state, self, ctx):
            # reset checklists
            from cs.pcs.checklists import Checklist
            for cl in self.Checklists:
                if cl.status != Checklist.DISCARDED.status:
                    cl.Reset()
            # reset dates and completion percentage
            self.start_time_act = ""
            self.end_time_act = ""
            self.percent_complet = 0
            # recalculate efforts (planned efforts have to be re-aggregated
            # after task is changed from DISCARDED to NEW)
            self.adjust_values(
                adjust_parents=True,
                time_act=True,
                effort_plan=True,
                effort_fcast=self.auto_update_effort,
                effort_act=True)
            self.adjust_values(adjust_parents=True, percentage=True)
            self.updateStatusSignals(time=True, effort=True)

    class READY(State):
        status = 20

        def Constraints(state, self):
            u'''
            - Optional task relationship constraints may be enabled
            - Project's status has to be either EXECUTION or FROZEN
            - Parent task's status has to be either NEW or EXECUTION
            - Status of subtasks has to be anything but COMPLETED and FINISHED
            - Status of Checklists has to be NEW, or DISCARDED
            '''
            from cs.pcs.projects import Project
            from cs.pcs.checklists import Checklist
            return self._getTaskRelConstraints(state.status) + [
                ("MatchStateList", [[self.Project], [Project.EXECUTION, Project.FROZEN], "pcstask_wf_rej_5"]),
                ("MatchStateList", [[self.ParentTask], [Task.READY, Task.EXECUTION], "pcstask_wf_rej_1"]),
                ("MatchStateList", [self.SubTasks, [Task.NEW, Task.READY, Task.EXECUTION, Task.DISCARDED], "pcstask_wf_rej_3"]),
                ("MatchStateList", [self.Checklists, [Checklist.NEW, Checklist.EVALUATION, Checklist.DISCARDED], "pcstask_wf_rej_0"]),
            ]

        # Transitions TO_READY implement FollowUpStateChanges

        def post(state, self, ctx):
            self.percent_complet = 0
            self.start_time_act = ""
            self.end_time_act = ""
            self.adjust_values(adjust_parents=True, time_act=True, percentage=True)
            self.updateStatusSignals(time=True, effort=True)

    class EXECUTION(State):
        status = 50

        def Constraints(state, self):
            u'''
            - Project's status has to be either EXECUTION or FROZEN
            - Parent task's status has to be either READY, EXECUTION,
              DISCARDED, or FINISHED
            '''
            return [
                ("MatchStateList", [[self.Project], [self.Project.EXECUTION, self.Project.FROZEN], "pcstask_wf_rej_5"]),
                ("MatchStateList", [[self.ParentTask], [Task.READY, Task.EXECUTION, Task.DISCARDED, Task.FINISHED], "pcstask_wf_rej_1"])
            ]

        # see also Transition FINISHED_EXECUTION
        def FollowUpStateChanges(state, self):
            u'''
            - ParentTask * -> EXECUTION
            - SubTasks NEW -> READY if they have no EA or EE predecessors
            - AA Successors NEW -> READY
            - EA Successors READY -> NEW
            '''
            conditionMet = self.getInitialSubtasks()
            return [
                (Task.EXECUTION, [task for task in [self.ParentTask] if task], 0, 0),
                (Task.READY, [s for s in conditionMet if s.status == Task.NEW.status], 0, 0),
                (Task.READY, [s for s in self.getSuccessors(kTaskDependencyAA) if s.status == Task.NEW.status], 0, 0),
                (Task.NEW, [s for s in self.getSuccessors(kTaskDependencyEA) if s.status == Task.READY.status], 0, 0),
                ]

        def post(state, self, ctx):
            # set current times, reset completion percentage
            self.end_time_act = ""
            if not self.start_time_act:
                self.start_time_act = cdbtime.now()
            self.percent_complet = 1
            self.adjust_values(
                adjust_parents=True,
                effort_plan=True,
                effort_fcast=self.auto_update_effort,
                effort_act=True,
                time_act=True)
            self.adjust_values(adjust_parents=True, percentage=True)
            self.updateStatusSignals(time=True, effort=True)

    class DISCARDED(State):
        status = 180

        def FollowUpStateChanges(state, self):
            u'''
            - Non-final SubTasks -> DISCARDED
            - Non-final Issues -> DISCARDED
            - Non-final Checklists -> DISCARDED
            - ParentTask * -> FINISHED (if all children in final status)
            '''
            from cs.pcs.checklists import Checklist
            from cs.pcs.issues import Issue

            result = [
                (Task.DISCARDED, [task for task in self.SubTasks if task.status not in Task.endStatus(False)], 0, 0),
                (Issue.DISCARDED, [i for i in self.Issues if i.status not in Issue.endStatus(False)], 0, 0),
                (Checklist.DISCARDED, [cl for cl in self.Checklists if cl.status not in Checklist.endStatus(False)], 0, 0),
                ]

            if self.ParentTask:
                target_status = self.ParentTask.getFinalStatus()
                if target_status:
                    result.append((target_status, [self.ParentTask], 0, 0))

            return result

        def pre_mask(state, self, ctx):
            # only allow changing status back to READY or EXECUTION if task's
            # status has been READY since last planning cycle
            from cdb.platform.olc import StateDefinition
            sd = StateDefinition.ByKeys(
                Task.READY.status, self.GetObjectKind())
            ready_txt = sd.statusbezeich
            sd = StateDefinition.ByKeys(
                Task.NEW.status, self.GetObjectKind())
            planned_txt = sd.statusbezeich
            t = sqlapi.SQLselect(
                "cdbprot_neustat FROM cdbpcs_tsk_prot WHERE "
                "cdb_project_id='%s' AND task_id='%s' AND cdbprot_neustat IN "
                "('%s', '%s') ORDER BY cdbprot_zaehler"
                % (self.cdb_project_id, self.task_id, ready_txt, planned_txt))
            rows = sqlapi.SQLrows(t)
            if rows and sqlapi.SQLstring(t, 0, rows - 1) != ready_txt:
                ctx.excl_state(Task.EXECUTION.status)
                ctx.excl_state(Task.READY.status)

        def post(state, self, ctx):
            # set current start and end times, reset completion percentage
            if not self.start_time_act:
                self.start_time_act = cdbtime.now()
            if not self.end_time_act:
                self.end_time_act = cdbtime.now()
            self.percent_complet = 0

            # recalculate efforts, since planned efforts may not be aggregated
            # when task is DISCARDED
            self.adjust_values(
                adjust_parents=True,
                effort_plan=True,
                effort_fcast=self.auto_update_effort,
                effort_act=True,
                time_act=True)
            self.adjust_values(adjust_parents=True, percentage=True)
            self.updateStatusSignals(time=True, effort=True)

    class FINISHED(State):
        status = 200

        def Constraints(state, self):
            u'''
            - Project EXECUTION, FROZEN, or DISCARDED
            - Parent Task EXECUTION, FINISHED, or DISCARDED
            - Status of all children has to be final (Tasks, Checklists,
              Issues)
            '''
            from cs.pcs.checklists import Checklist
            from cs.pcs.issues import Issue
            from cs.pcs.projects import Project

            return self._getTaskRelConstraints(state.status) + [
                ("MatchStateList", [[self.Project], [Project.EXECUTION, Project.FROZEN, Project.DISCARDED], "pcstask_wf_rej_5"]),
                ("MatchStateList", [[self.ParentTask], [Task.EXECUTION, Task.FINISHED, Task.DISCARDED], "pcstask_wf_rej_1"]),
                ("MatchStateList", [self.SubTasks, Task.endStatus(), "pcstask_wf_rej_3"]),
                ("MatchStateList", [self.Checklists, Checklist.endStatus(), "pcstask_wf_rej_0"]),
                ("MatchStateList", [self.Issues, Issue.endStatus(), "pcstask_wf_rej_8"]),
                ]

        def FollowUpStateChanges(state, self):
            u'''
            - EA and EE Successors NEW -> READY
                EA, AA Successors only if they do not have another EA, AA
                    predecessor in status NEW or READY
            - ParentTask * -> FINISHED (if all children in final status)
            '''
            def no_other_predecessors(successor):
                if successor.status == Task.NEW.status:
                    preds = [
                        p for p in successor.getPredecessors(kTaskDependencyAA) + successor.getPredecessors(kTaskDependencyEA)
                        if p.status in [Task.NEW.status, Task.READY.status]]
                    return not preds

            result = [
                (Task.READY, filter(no_other_predecessors, self.getSuccessors(kTaskDependencyAA) + self.getSuccessors(kTaskDependencyEA)), 0, 0),
                (Task.READY, [s for s in self.getSuccessors(kTaskDependencyEE) if int(s.status) == Task.NEW.status], 0, 0),
                ]

            if self.ParentTask:
                target_status = self.ParentTask.getFinalStatus()
                if target_status:
                    result.append((target_status, [self.ParentTask], 0, 0))

            return result

        def post(state, self, ctx):
            # set current end time, full completion percentage
            if not self.end_time_act:
                self.end_time_act = cdbtime.now()
            self.percent_complet = 100
            # ?
            self.adjust_values(
                adjust_parents=True,
                effort_plan=True,
                effort_fcast=self.auto_update_effort,
                effort_act=True,
                time_act=True)
            self.adjust_values(adjust_parents=True, percentage=True)
            self.updateStatusSignals(time=True, effort=True)

    class COMPLETED(State):
        status = 250

        def Constraints(transition, self):
            u'''
            - Status of all children has to be final (Tasks, Checklists,
              Issues)
            '''
            from cs.pcs.checklists import Checklist
            from cs.pcs.issues import Issue

            return [
                ("MatchStateList", [self.SubTasks, Task.endStatus(), "pcstask_wf_rej_3"]),
                ("MatchStateList", [self.Checklists, Checklist.endStatus(), "pcstask_wf_rej_0"]),
                ("MatchStateList", [self.Issues, Issue.endStatus(), "pcstask_wf_rej_8"]),
                ]

        def FollowUpStateChanges(state, self):
            return [(Task.COMPLETED, self.SubTasks, 0, 0)]

    class TO_NEW(Transition):
        transition = ("*", 0)

        def FollowUpStateChanges(transition, self):
            u'''
            - SubTasks* -> NEW
            - Checklists* -> NEW
            - EA- and AA successors READY -> NEW (if old status was not
              DISCARDED)

            *) If self's old status was DISCARDED, only change SubTasks and
               Checklists which are not in an "end" status. All other
               transitions change SubTasks and Checklists that are not DISCARDED
            '''
            from cs.pcs.checklists import Checklist
            old = transition.SourceState(self).status

            result = []

            if old == Task.DISCARDED.status:
                filtered_subtasks = [
                    t for t in self.SubTasks
                    if t.status in Task.endStatus(False)]
                filtered_checklists = [
                    c for c in self.Checklists
                    if c.status in Checklist.endStatus(False)]
            else:
                result.append((
                    Task.NEW,
                    [s for s in self.getSuccessors(kTaskDependencyEA) +
                                self.getSuccessors(kTaskDependencyAA)
                                if s.status == self.READY.status],
                    0, 0))

                filtered_subtasks = [
                    t for t in self.SubTasks
                    if t.status != Task.DISCARDED.status]
                filtered_checklists = [
                    c for c in self.Checklists
                    if c.status != Checklist.DISCARDED.status]
            return [
                (Task.NEW, filtered_subtasks, 0, 0),
                (Checklist.NEW, filtered_checklists, 0, 0),
                ] + result

    class TO_READY(Transition):
        transition = ("*", 20)

        def FollowUpStateChanges(transition, self):
            u'''

            From status NEW:
              - SubTasks NEW -> READY if they have no unfinished EA or EE predecessor

            From status EXECUTION or DISCARDED:
              - SubTasks NEW, EXECUTION -> READY if they have no unfinished EA or EE predecessor
              - All other SubTasks EXECUTION -> NEW
              - Checklists EVALUATION -> NEW

            - AA and EA successors NEW -> READY
            '''
            result = []
            old = transition.SourceState(self).status
            conditionMet = self.getInitialSubtasks()

            if old == Task.NEW.status:
                result.append((Task.READY, [s for s in conditionMet if s.status == Task.NEW.status], 0, 0))

            if old in [Task.EXECUTION.status, Task.DISCARDED.status]:
                from cs.pcs.checklists import Checklist
                result.append((Task.READY, [s for s in conditionMet if s.status in [Task.NEW.status, Task.EXECUTION.status]], 0, 0))
                result.append((Task.NEW, [s for s in self.SubTasks if s not in conditionMet and s.status == Task.EXECUTION.status], 0, 0))
                result.append((Checklist.NEW, [c for c in self.Checklists if c.status == Checklist.EVALUATION.status], 0, 0))

            result.append((
                Task.NEW,
                [s for s in self.getSuccessors(kTaskDependencyEA) +
                            self.getSuccessors(kTaskDependencyAA)
                            if s.status == Task.READY.status],
                0, 0))

            return result

    class FINISHED_EXECUTION(Transition):
        transition = (200, 50)

        def FollowUpStateChanges(state, self):
            u'''
            - EA Successors READY -> NEW
            '''
            return [
                (Task.NEW, [s for s in self.getSuccessors(kTaskDependencyEA) if int(s.status) == Task.READY.status], 0, 0),
                ]

    def msp_to_cdb_consistency_check(self):
        if self.status == self.NEW.status:
            # propagate status "New" to children
            for subtask in self.Subtasks:
                if subtask.status in [self.READY.status,
                                      self.EXECUTION.status,
                                      self.FINISHED.status]:
                    subtask.ChangeState(self.NEW.status)
            for checklist in self.Checklists:
                if checklist.status == checklist.EVALUATION.status:
                    checklist.ChangeState(checklist.NEW.status)

        elif self.status == self.READY.status:
            if [s for s in self.Subtasks if s.status == self.COMPLETED.status]:
                raise ue.Exception("pcs_msp_closed_subtask", self.GetDescription())

            new_predecessors = [
                rel.PredecessorTask for rel in self.PredecessorTaskRelations
                if rel.PredecessorTask.status == Task.NEW.status]
            if new_predecessors:
                # reset task if a predecessor is in initial status
                self.ChangeState(self.NEW.status)
            else:
                # aggregate status if children are final and parent is active
                target_status = self.getFinalStatus()
                if target_status:
                    if target_status == self.FINISHED:
                        self.ChangeState(self.EXECUTION.status)
                    self.ChangeState(target_status.status)

        elif self.status == self.EXECUTION.status:
            # aggregate status "execution" to parents
            if self.ParentTask and self.ParentTask.status in [
                    self.READY.status, self.FINISHED.status]:
                self.ParentTask.ChangeState(self.EXECUTION.status)
            # aggregate status if children are final and parent is active
            target_status = self.getFinalStatus()
            if target_status:
                self.ChangeState(target_status.status)

        elif self.status == self.FINISHED.status:
            # change parent's status to "execution"
            if self.ParentTask and self.ParentTask.status == self.READY.status:
                self.ParentTask.ChangeState(self.EXECUTION.status)
            # change to "execution" if children are still active
            active_subs = [sub for sub in self.Subtasks if sub.status in [
                self.NEW.status,
                self.READY.status,
                self.EXECUTION.status]]
            active_cls = [cl for cl in self.Checklists if cl.status in [
                cl.NEW.status, cl.EVALUATION.status]]
            active_iss = [i for i in self.Issues if i.status in [
                i.NEW.status, i.EVALUATION.status]]
            if active_subs or active_cls or active_iss:
                self.ChangeState(self.EXECUTION.status)

        elif self.status == self.COMPLETED.status:
            # make sure final tasks are treated as final
            if self.ParentTask and self.ParentTask.status in [
                    self.NEW.status, self.READY.status]:
                raise ue.Exception("pcs_msp_closed_subtask", self.GetDescription())
            non_final = [sub for sub in self.Subtasks if sub.status not in [
                self.COMPLETED.status, self.DISCARDED.status]]
            if non_final:
                raise ue.Exception("pcs_msp_closed_task", self.GetDescription())

        elif self.status == self.DISCARDED.status:
            # propagate to non-final children
            for sub in self.Subtasks:
                if sub.status not in self.endStatus(False):
                    sub.ChangeState(self.DISCARDED.status)
            for cl in self.Checklists:
                if cl.status not in cl.endStatus(False):
                    cl.ChangeState(cl.DISCARDED.status)
            for i in self.Issues:
                if i.status not in i.endStatus(False):
                    i.ChangeState(i.DISCARDED.status)

        # recursion
        for sub in self.Subtasks:
            sub.msp_to_cdb_consistency_check()
