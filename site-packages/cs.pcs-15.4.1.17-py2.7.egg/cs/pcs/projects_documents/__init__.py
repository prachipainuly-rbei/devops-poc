#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
from cdb.constants import kOperationCopy
from cdb.constants import kOperationShowObject
from cdb.classbody import classbody
from cdb import auth
from cdb import cdbtime
from cdb import misc
from cdb import sig
from cdb import ue
from cdb import util
from cdb import cad
from cdb import kernel

from cdb.objects import Object
from cdb.objects import ByID
from cdb.objects import Forward
from cdb.objects import ReferenceMethods_1
from cdb.objects import ReferenceMethods_N
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import TableNotFound
from cdb.objects.operations import operation

from cs.actions import Action
from cs.documents import Document
from cs.pcs.projects import Project
from cs.pcs.projects.tasks import Task
from cs.pcs.projects_documents import folders

fTaskDocumentReference = Forward(__name__ + ".TaskDocumentReference")


class AbstractTemplateDocRef(Object):

    def _get_document_to_copy(self):
        docs2copy = []
        if self.use_selected_index:
            doc = Document.ByKeys(self.z_nummer, self.z_index)
            if doc.MatchRule(u"cdbpcs: Index-dependent Valid Documents for Instantiation"):
                docs2copy = [doc]
        else:
            _docs = Document.KeywordQuery(z_nummer=self.z_nummer)
            if len(_docs):
                docs2copy = [d for d in _docs[0].Versions if d.MatchRule(u"cdbpcs: Documents valid for Instantiation")]
        return docs2copy
    DocumentsToCopy = ReferenceMethods_N(Document, lambda self: self._get_document_to_copy())

    def _get_referer(self):
        return self.__referer_cls__.ByKeys(**self._get_referer_keys())
    Referer = ReferenceMethods_1(Object, lambda self: self._get_referer())

    def _get_referer_keys(self):
        result = {}
        for k in self.__referer_cls__.KeyNames():
            result[k] = self[k]
        return result

    @staticmethod
    def _find_document_templates(obj, template_ref_cls):
        try:
            ref_table = template_ref_cls.GetTableName()
        except TableNotFound, e:
            misc.cdblogv(misc.kLogMsg, 1, "WithDocumentTemplates: Table not found: %s" % e)
            return []
        template_refs = template_ref_cls.SQL(
            "SELECT %(ref_table)s.* FROM %(ref_table)s, %(target_table)s WHERE %(join)s"
            " AND %(target_table)s.status = %(ref_table)s.instantiation_state"
            " AND %(ref_table)s.created_at is null" % ({"ref_table": ref_table,
                                                        "target_table": obj.GetTableName(),
                                                        "join": obj.JoinCondition(template_ref_cls)}))
        valid_refs = []
        invalid_refs = []
        for ref in template_refs:
            if ref.DocumentsToCopy:
                valid_refs.append(ref)
            else:
                invalid_refs.append(ref)
        return (valid_refs, invalid_refs)

    @staticmethod
    def create_docs_instances(obj, template_ref_cls):
        (valid_refs, invalid_refs) = AbstractTemplateDocRef._find_document_templates(obj, template_ref_cls)
        for ref in valid_refs:
            ref.create_doc_instances()
        if len(invalid_refs):
            raise ue.Exception(
                u"cdbpcs_no_valid_docs",
                u", ".join([u'' + unicode(d.z_nummer) +
                            u'/' + unicode(d.z_index) +
                            u': ' + unicode(d.titel) for d in invalid_refs])
            )

    def create_doc_instances(self, **kwargs):

        """ Creates a new instance of the referenced template document and
        assigns the new document to the refer using the specified assign_cls.
        If assign_cls is None, the document will be assigned directly by setting
        the foreign keys of the referer (e.g. zeichnung.cdb_project_id).
        Keyword arguments are used as initial document attributes.
        """
        new_docs = []
        if not kwargs.has_key("vorlagen_kz"):
            kwargs["vorlagen_kz"] = 0
        for doc in self.DocumentsToCopy:
            new_doc = doc.copyDoc(**kwargs)
            self._assign_new_doc(new_doc)
            new_docs.append(new_doc)
        ref_object = self._get_referer()
        templateProject = False
        if ref_object:
            if hasattr(ref_object, "isPartOfTemplateProject"):
                templateProject = ref_object.isPartOfTemplateProject(ref_object)
            if (hasattr(ref_object, "Project") and ref_object.Project
                    and hasattr(ref_object.Project, "isPartOfTemplateProject")):
                templateProject = ref_object.Project.isPartOfTemplateProject(ref_object)
        if not templateProject:
            self.created_at = cdbtime.now('%d.%m.%Y %H:%M:%S')
        return new_docs

    def assignBy(self):
        return getattr(self, "__doc_ref_cls__", None)

    def _assign_new_doc(self, doc):

        """ Assigns the newly created document to the referer object of the
        template document."""
        assign_cls = self.assignBy()
        if assign_cls:
            values = self.KeyDict()
            values.update(doc.KeyDict())
            assign_cls.Create(**values)
        else:
            doc.Update(**self._get_referer_keys())

    def on_CDB_WithDocTemplates_New_now(self, ctx):
        for doc in self.create_doc_instances():
            self.followUpAction(doc, ctx)

    def followUpAction(self, new_doc, ctx):
        """ Sets a follow-up action after a new document instance has been created
        explicitly by the user. This method may be overriden to disable the follow-up
        action or to show a message instead of opening the new document.

        Sample code to display a usefull message instead of opening the document:

        raise ue.Exception(-4821, new_doc.GetDescription(), self.Referer.GetDescription())
        """
        ctx.set_followUpOperation(kOperationShowObject, op_object=new_doc)


class ProjectTemplateDocRef(AbstractTemplateDocRef):
    __maps_to__ = "cdbpcs_prj2doctmpl"
    __classname__ = "cdbpcs_prj2doctmpl"
    __referer_cls__ = Project

    def create_doc_instances(self, **kwargs):
        """ Obverriden to add cdb_project_id to the document attributes."""
        kwargs[u"cdb_project_id"] = self.cdb_project_id
        return self.Super(ProjectTemplateDocRef).create_doc_instances(**kwargs)


@classbody
class Project(object):

    Documents = Reference_N(Document, Document.cdb_project_id == Project.cdb_project_id)
    PrimaryMSPDocuments = Reference_N(Document,
                                      Document.z_nummer == Project.msp_z_nummer,
                                      Document.cdb_obsolete == 0,
                                      Document.z_status < 100)

    def getLastPrimaryMSPDocument(self):
        """
        Returns the document that contains the current time schedule
        The current time schedule is defined as:
        - Number is referenced in the master data of the project
        - Highest index of all non-obsolete indexes
        CONTACT Elements Server feature 'index sequence' is considered (property ixsm')
        :return: cs.document.Document
        """
        if not self.msp_z_nummer:
            return None
        index = cad.getMaxIndex(self.msp_z_nummer, Document.__maps_to__)
        result = Document.ByKeys(self.msp_z_nummer, index)
        while result and result.cdb_obsolete:
            index = kernel.get_prev_index(result.z_nummer, result.z_index, result.__maps_to__)
            result = Document.ByKeys(self.msp_z_nummer, index)
        return result

    def copyMSPDocumentTemplate(self):
        """Read out the property 'mspt' whose value should be of type '<z_nummer>;<z_index>'."""
        mspt = util.get_prop("mspt")
        if mspt:
            if ";" in mspt:
                z_nummer, z_index = mspt.split(";")
            else:
                z_nummer = mspt
                z_index = ""
            doc = Document.ByKeys(z_nummer=z_nummer, z_index=z_index)
            if not doc:
                raise ue.Exception(u"cdbpcs_msp_defined_template_not_found")

            return operation(kOperationCopy, doc,
                             cdb_project_id=self.cdb_project_id,
                             vorlagen_kz=0)
        return None

    def on_cdbpcs_msp_schedule_now(self, ctx):
        if not self.msp_active or not self.CheckAccess("save"):
            if not "open_in_msp_anyway" in ctx.dialog.get_attribute_names():
                msgbox = ctx.MessageBox("cdbpcs_msp_msp_not_set_as_project_editor",
                                        [], "open_in_msp_anyway")
                msgbox.addYesButton(is_dflt=1)
                msgbox.addNoButton()
                ctx.show_message(msgbox)
                return
            else:
                if ctx.dialog["open_in_msp_anyway"] != ctx.MessageBox.kMsgBoxResultYes:
                    return
        msp_doc = self.getLastPrimaryMSPDocument()
        if not msp_doc:
            msp_doc = self.copyMSPDocumentTemplate()
            if msp_doc:
                msp_doc.Reload()
                self.msp_z_nummer = msp_doc.z_nummer
            else:
                raise ue.Exception(u"cdbpcs_msp_neither_primary_plan_set_nor_template_defined")
        ctx.set_followUpOperation("CDB_Edit", keep_rship_context=True, op_object=msp_doc)

    @sig.connect(Project, "state_change", "post")
    def create_doc_instances(self, ctx=None):
        """ Creates instances of assigned document templates. """
        if (ctx is None or not ctx.error) and not self.template:
            ProjectTemplateDocRef.create_docs_instances(self, ProjectTemplateDocRef)

    @sig.connect(Project, "relship_copy", "post")
    def handle_doc_templates(self, ctx):
        if ctx.error != 0:
            return

        # ggf. Dokumentvorlagen instanziieren
        if ctx.relationship_name == 'cdbpcs_prj2doctmpl':
            self.create_doc_instances()
        elif ctx.relationship_name == 'cdbpcs_project2task_doctemplates':
            if not self.template:
                self._create_documents_from_templates(Task, TaskTemplateDocRef)

    def _create_documents_from_templates(self, with_templates_cls, template_ref_cls):
        v = {"ref_table": template_ref_cls.GetTableName(),
             "target_table": with_templates_cls.GetTableName(),
             "cdb_project_id": self.cdb_project_id,
             "join": with_templates_cls._buildKeyJoin(template_ref_cls)}

        stmt = "SELECT %(ref_table)s.* FROM %(ref_table)s, %(target_table)s WHERE %(join)s"
        stmt += " AND %(target_table)s.cdb_project_id = '%(cdb_project_id)s' AND %(target_table)s.status = %(ref_table)s.instantiation_state"
        stmt += " AND %(ref_table)s.created_at is null"
        refs = template_ref_cls.SQL(stmt % v)
        for ref in refs:
            docs = ref.DocumentsToCopy
            if docs:
                for doc in docs:
                    ref.create_doc_instances()

    def copyPrimaryMSPDocument(self, ctx):
        template_project = Project.ByKeys(ctx.cdbtemplate.cdb_project_id)
        msp_doc = template_project.getLastPrimaryMSPDocument()
        if msp_doc:
            new_msp_doc = msp_doc.copyDoc(cdb_project_id=self.cdb_project_id,
                                          autoren=auth.name,
                                          vorlagen_kz=self.template)
            self.getPersistentObject().msp_z_nummer = new_msp_doc.z_nummer

    @sig.connect(Project, "copy", "post")
    def _copyPrimaryMSPDocument(self, ctx):
        if ctx.error != 0:
            return
        self.copyPrimaryMSPDocument(ctx)

    def check_docs_delete_pre(self, ctx):
        if self.Documents:
            raise ue.Exception("pcs_err_del_proj2")

    @sig.connect(Project, "delete", "pre")
    def _check_docs_delete_pre(self, ctx):
        self.check_docs_delete_pre(ctx)

    # -------------- Folders --------------------------------

    def copyFolders(self, ctx):
        tpl_folders = folders.Folder.Query("cdb_project_id = '%s' and parent_id = 'root'" %
                                           (ctx.cdbtemplate.cdb_project_id),
                                           order_by="folder_id")
        for tf in tpl_folders:
            folders.Folder.CopyFolderStructure(tf, self.cdb_project_id, copy_docs=True)
        if tpl_folders:
            ctx.refresh_tables(["cdb_folder2doc", "cdb_folder"])

    @sig.connect(Project, "copy", "post")
    def _copyFolders(self, ctx):
        if ctx.error != 0:
            return
        self.copyFolders(ctx)

    def deleteFolders(self, ctx):
        tpl_folders = folders.Folder.Query("cdb_project_id = '%s' and parent_id = 'root'" %
                                           (self.cdb_project_id), order_by="folder_id")
        for tf in tpl_folders:
            tf.DeleteFolderStructure(ctx)

    @sig.connect(Project, "delete", "post")
    def _deleteFolders(self, ctx):
        if ctx.error != 0:
            return
        self.deleteFolders(ctx)

    @classmethod
    @sig.connect(Project, "cdb_copyfolderstruct_pcs", "pre_mask")
    def PredefineCopyStructLanguage(cls, ctx):
        folders.Folder.PredefineCopyStructLanguage(ctx)

    @sig.connect(Project, "cdb_copyfolderstruct_pcs", "now")
    def CopyFoldStruct(self, ctx):
        folders.Folder.CopyFolderStruct(ctx, self.cdb_project_id)


class TaskDocumentReference(Object):
    __maps_to__ = "cdbpcs_doc2task"

    Document = Reference_1(Document, fTaskDocumentReference.z_nummer, fTaskDocumentReference.z_index)


class TaskTemplateDocRef(AbstractTemplateDocRef):
    __maps_to__ = "cdbpcs_task2doctmpl"
    __classname__ = "cdbpcs_task2doctmpl"
    __referer_cls__ = Task
    __doc_ref_cls__ = TaskDocumentReference

    def _assign_new_doc(self, doc):
        values = self.KeyDict()
        values.update(doc.KeyDict())
        values["rel_type"] = "doc2task"
        self.assignBy().Create(**values)

    def create_doc_instances(self, **kwargs):
        """ Obverriden to add cdb_project_id to the document attributes."""
        kwargs[u"cdb_project_id"] = self.cdb_project_id
        return self.Super(TaskTemplateDocRef).create_doc_instances(**kwargs)


@classbody
class Task(object):

    DocumentReferences = Reference_N(TaskDocumentReference,
                                     TaskDocumentReference.cdb_project_id == Task.cdb_project_id,
                                     TaskDocumentReference.task_id == Task.task_id)

    def _get_Documents(self):
        return self.SimpleJoinQuery(Document, TaskDocumentReference)
    Documents = ReferenceMethods_N(Document, _get_Documents)

    TemplateDocRefs = Reference_N(TaskTemplateDocRef,
                                  TaskTemplateDocRef.cdb_project_id == Task.cdb_project_id,
                                  TaskTemplateDocRef.task_id == Task.task_id)

    @sig.connect(Task, "state_change", "post")
    def create_doc_instances(self, ctx):
        """ Creates instances of assigned document templates. """
        if not ctx.error:
            TaskTemplateDocRef.create_docs_instances(self, TaskTemplateDocRef)


@sig.connect(Document, "state_change", "post")
def delete_invalid_doc_templates(cls, ctx):
    document = ctx.object
    from cs.pcs.checklists_documents import CLTemplateDocRef
    template_refs = CLTemplateDocRef.KeywordQuery(z_nummer=document.z_nummer)
    for template_ref in template_refs:
        # If related document state is invalid
        if not len([doc for doc in template_ref.DocumentsToCopy if doc.status != 180]):
            template_ref.Delete()


@sig.connect(Document, "delete", "pre")
def delete_msp_time_schedule(cls, ctx):
    """Prevents deleting a document when it's set as a project's time schedule"""
    prj = Project.KeywordQuery(msp_z_nummer=ctx.object.z_nummer)
    if prj:
        raise ue.Exception(u"cdbpcs_msp_time_schedule_must_not_be_deleted",
                           prj[0].GetDescription())


@classbody
class Document(object):

    Project = Reference_1(Project, Document.cdb_project_id)

    FolderAssignments = Reference_N(folders.Folder2doc,
                                    folders.Folder2doc.z_nummer == Document.z_nummer,
                                    folders.Folder2doc.z_index == Document.z_index)

    def PresetFolderAttributes(self, ctx):
        if ctx.relationship_name in ['cdb_folder2doc', 'cdb_folder2valid_docs']:
            folder_id = ctx.parent["folder_id"]
            if folder_id:
                f = folders.Folder.ByKeys(folder_id)
                f.ApplyDefaults(self, overwrite=False)

    @sig.connect(Document, "copy", "pre_mask")
    @sig.connect(Document, "create", "pre_mask")
    def _PresetFolderAttributes(self, ctx):
        self.PresetFolderAttributes(ctx)

    @sig.connect(Document, "create", "pre_mask")
    def _preset_project_id(self, ctx):
        """
        When a document is created in the context of a project-specific action, the system proposes the project number
        of the action as the project number of the document.
        If a document is copied in the context of a project-specific action, the document's existing project number
        will not be changed.
        """
        if ctx.relationship_name == 'cdb_action2docs' and hasattr(ctx.parent, 'cdb_object_id'):
            parent_object = ByID(ctx.parent['cdb_object_id'])
            if isinstance(parent_object, Action) and parent_object.cdb_project_id:
                ctx.set('cdb_project_id', parent_object.cdb_project_id)

    @sig.connect(Document, "create", "post")
    def CopyFilesAtDragAndDrop(self, ctx):
        if ctx.dragdrop_action_id != "":
            doc = Document.ByKeys(ctx.dragged_obj.z_nummer, ctx.dragged_obj.z_index)
            new_doc = Document.ByKeys(self.z_nummer, self.z_index)
            new_doc.erzeug_system = doc.erzeug_system
            kwargs = {u"cdbf_object_id": self.cdb_object_id}
            for file in doc.Files:
                operation(kOperationCopy, file, **kwargs)

    def CheckFolderAssignment(self, ctx):
        # Unterbindet ggf. die Zuordnung eines neuen Indexstandes oder
        # einer Kopie zur Verknuepfungsrelation
        if ctx.relationship_name == 'cdb_folder2valid_docs':
            # Wenn im Kontext dieser Beziehung eine Versionierung vorgenommen wurde
            # ist schon der alte Index drin, sonst haette man es ja nicht aufrufen koennen
            if ctx.action == "index":
                ctx.skip_relationship_assignment()

    @sig.connect(Document, "index", "pre")
    def _CheckFolderAssignment(self, ctx):
        self.CheckFolderAssignment(ctx)

    def RemoveFolderAssignments(self, ctx):
        # Loescht das Dokument aus der Ordnerzuordnung
        if not ctx or not ctx.error:
            assignments = self.FolderAssignments
            for a in assignments:
                a.DocDeleted(self, ctx)

    @sig.connect(Document, "delete", "post")
    def _RemoveFolderAssignments(self, ctx):
        self.RemoveFolderAssignments(ctx)
