#!/usr/bin/env powerscript
# -*- python -*- coding: UTF-8 -*-
#
# Copyright (C) 2017 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Export PCS projects via MSP's XML schema.
"""

from __future__ import unicode_literals

from datetime import datetime
from lxml import objectify
import tempfile

from cdb import CADDOK, sqlapi
from cdb.transactions import Transaction

from cs.tools import powerreports as PowerReports

from cs.pcs.msp import misc as msp_misc
from cs.pcs.msp.misc import log

__docformat__ = "restructuredtext en"
__revision__ = "$Id: exports.py 176073 2018-04-18 06:44:28Z kbu $"


class XmlExport(object):

    DEFAULT_START_HOUR = msp_misc.DEFAULT_START_HOUR
    DEFAULT_FINISH_HOUR = msp_misc.DEFAULT_FINISH_HOUR

    REF_OBJECTS_SEPARATOR = msp_misc.REF_OBJECTS_SEPARATOR
    REF_OBJECT_TOKENS_SEPARATOR = msp_misc.REF_OBJECT_TOKENS_SEPARATOR
    REF_CHECKLIST_ID_FIELD = msp_misc.REF_CHECKLIST_ID_FIELD
    REF_WORKFLOW_ID_FIELD = msp_misc.REF_WORKFLOW_ID_FIELD

    def __init__(self):
        self.pcs_project = None
        self.msp_project = None

    @classmethod
    def generate_xml_from_project(cls, pcs_project_object_or_id):
        """
        Performs a full export of given PCS project and returns the path to the resulting temporary
        xml file.
        """
        log("pcs_project_object_or_id=%s" % pcs_project_object_or_id)
        temp_filename = tempfile.mktemp(suffix=".xml", prefix="mspxml-", dir=CADDOK.TMPDIR)

        export = cls()
        with Transaction():
            export.set_pcs_project(pcs_project_object_or_id)
            export.set_target_xml_filename(temp_filename)
            export.execute()

        log("temp_filename=%s" % temp_filename)
        return temp_filename

    def set_pcs_project(self, pcs_project_object_or_id):
        from cs.pcs.projects import Project

        if isinstance(pcs_project_object_or_id, Project):
            self.pcs_project = pcs_project_object_or_id
        else:
            self.pcs_project = Project.ByKeys(pcs_project_object_or_id)

        t = sqlapi.SQLselect("max(msp_uid) from cdbpcs_task "
                             "where cdb_project_id='%s'" % self.pcs_project.cdb_project_id)
        self.max_msp_uid = sqlapi.SQLinteger(t, 0, 0)
        log("max_msp_uid=%s" % self.max_msp_uid)

    def set_target_xml_filename(self, xml_filename):
        self.xml_filename = xml_filename

    def execute(self):
        start_time = datetime.now()
        log("exporting project attributes..")
        self.msp_project = objectify.Element("Project", nsmap={None: msp_misc.MSP_XML_SCHEMA})
        self.get_mapped_attrs(self.PROJECT_MAPPING, self.PROJECT_DEFAULTS,
                              self.pcs_project, self.msp_project)

        log("exporting tasks..")
        self.msp_project.extend(objectify.Element("Tasks"))
        for pcs_task in self.pcs_project.TopTasks:
            self.traverse_task(pcs_task, 1)

        log("writing xml file..")
        objectify.deannotate(self.msp_project, xsi_nil=True)
        objectify.deannotate(self.msp_project.Tasks, xsi_nil=True)
        # TODO: add comment "created by <full classname> 15.x.x.x"
        self.msp_project.getroottree().write(self.xml_filename,
                                             encoding='UTF-8',
                                             pretty_print=True,
                                             xml_declaration=True)
        log("Export finished in %s second(s)" % (datetime.now() - start_time).seconds)

    def get_mapped_attrs(self, attr_mapping, attr_defaults, pcs_object, msp_object):
        """Adds default and mapped attribute values of a PCS object to an MSP XML object."""
        for msp_attr, default_value in attr_defaults.items():
            self.set_msp_object_attr(msp_object, msp_attr, default_value)
        for pcs_attr, msp_attrs in attr_mapping.items():
            if not isinstance(msp_attrs, list):
                msp_attrs = [msp_attrs]
            for msp_attr in msp_attrs:
                msp_column_name = None
                if isinstance(msp_attr, tuple):
                    function, msp_attr = msp_attr
                    function = getattr(self, function)
                    if msp_attr and (":" in msp_attr):
                        msp_attr, msp_column_name = msp_attr.split(":")
                    pcs_value = function(pcs_object, pcs_attr, msp_object, msp_attr)
                else:
                    if msp_attr and (":" in msp_attr):
                        msp_attr, msp_column_name = msp_attr.split(":")
                    pcs_value = getattr(pcs_object, pcs_attr, "")
                if msp_attr:
                    self.set_msp_object_attr(msp_object, msp_attr, pcs_value, msp_column_name)

    def traverse_task(self, pcs_task, msp_outline_level):
        """Recursively exports all PCS tasks and their relations into the MSP XML project."""
        msp_task = objectify.Element("Task")
        self.get_mapped_attrs(self.TASK_MAPPING, self.TASK_DEFAULTS, pcs_task, msp_task)
        self.get_task_links(pcs_task, msp_task)
        msp_task.OutlineLevel = msp_outline_level
        self.msp_project.Tasks.extend(msp_task)
        self.get_task_references(pcs_task, msp_task)
        for pcs_sub_task in pcs_task.SubTasks:
            self.traverse_task(pcs_sub_task, msp_outline_level + 1)

    def get_task_links(self, pcs_task, msp_task):
        for task_relation in pcs_task.PredecessorTaskRelations:
            msp_task_link = objectify.Element("PredecessorLink")
            msp_task_link.PredecessorUID = self.get_pcs_task_msp_uid(task_relation.PredecessorTask)
            msp_task_link.Type = msp_misc.PcsToMsp.TaskLinkType[task_relation.rel_type]
            # PredecessorLink.LinkLag: The amount of lag in tenths of a minute
            msp_task_link.LinkLag = task_relation.minimal_gap * 60 * 10 * 8
            msp_task_link.LagFormat = "7"
            msp_task_link.CrossProject = "0"
            msp_task.extend(msp_task_link)

    def get_task_references(self, pcs_task, msp_task):
        """Export task reference objects (e.g. checklist) into custom msp task fields ('Text*')"""
        for function, msp_attr in self.TASK_REFERENCE_MAPPING.items():
            function = getattr(self, function)
            if ":" in msp_attr:
                msp_attr, msp_column_name = msp_attr.split(":")
            else:
                msp_column_name = None
            msp_value = function(pcs_task, msp_task, msp_attr)
            self.set_msp_object_attr(msp_task, msp_attr, msp_value, msp_column_name)

    def get_pcs_task_msp_uid(self, pcs_task):
        """Ensures that a PCS task owns an MSP task UID."""
        msp_uid = getattr(pcs_task, "msp_uid", None)
        if not msp_uid:
            self.max_msp_uid += 1
            msp_uid = self.max_msp_uid
            pcs_task["msp_uid"] = msp_uid
        return msp_uid

    def set_msp_object_attr(self, msp_object, msp_attr, msp_value, msp_column_name=None):
        """Supports setting extended MSP task fields like 'Text*' or 'Number*'"""
        if msp_attr.startswith(("Text", "Number")):
            msp_extended_attribute = objectify.Element("ExtendedAttribute")
            msp_extended_attribute.FieldID = msp_misc.PcsToMsp.ExtendedAttributes[msp_attr]
            msp_extended_attribute.Value = msp_value
            msp_object.extend(msp_extended_attribute)
            if msp_column_name:
                msp_extended_attributes = self.msp_project.xpath("ExtendedAttributes")
                if not msp_extended_attributes:
                    msp_extended_attributes = objectify.Element("ExtendedAttributes")
                    self.msp_project.extend(msp_extended_attributes)
                else:
                    msp_extended_attributes = msp_extended_attributes[0]
                msp_extended_attribute = self.msp_project.xpath(
                    "ExtendedAttributes/ExtendedAttribute/FieldID[text()='%s']/.." %
                    msp_misc.PcsToMsp.ExtendedAttributes[msp_attr])
                if not msp_extended_attribute:
                    msp_extended_attribute = objectify.Element("ExtendedAttribute")
                    msp_extended_attribute.FieldID = msp_misc.PcsToMsp.ExtendedAttributes[msp_attr]
                    msp_extended_attribute.FieldName = msp_attr
                    msp_extended_attribute.Alias = msp_column_name
                    msp_extended_attributes.extend(msp_extended_attribute)
        else:
            setattr(msp_object, msp_attr, msp_value)

    # Attribute mappings

    #: Dictionary with a mapping between PCS project attributes (as keys) and MSP project fields
    #: (as values). Values can either be single strings, thus the targeted field names, or
    #: tuples containing a callback class method name and then the targeted field names.
    #: Callback method signature:
    #:
    #:    .. code-block:: python
    #:
    #:       def pcs_attr_x_to_msp_field_x(self, pcs_project, pcs_attr, msp_project, msp_attr):
    #:
    PROJECT_MAPPING = {
        "end_time_fcast": ("pcs_finish_date_to_msp_finish_date", "FinishDate"),
        "start_time_fcast": ("pcs_start_date_to_msp_start_date", "StartDate"),
        }
    #: Dictionary with a mapping between MSP project fields (as keys) and default values. The
    #: default value is only used when no value gets transferred via the PROJECT_MAPPING attribute.
    PROJECT_DEFAULTS = {
        }

    #: Dictionary with a mapping between PCS task attributes (as keys) and MSP task fields
    #: (as values). Values can either be single strings, thus the targeted field names, or
    #: tuples containing a callback class method name and then the targeted field names.
    #: Callback method signature:
    #:
    #:    .. code-block:: python
    #:
    #:       def pcs_attr_x_to_msp_field_x(self, pcs_task, pcs_attr, msp_task, msp_attr):
    #:
    TASK_MAPPING = {
        "automatic": ("pcs_automatic_to_msp_manual", "Manual"),
        "constraint_date": ("pcs_constraint_date_to_msp_constraint_date", "ConstraintDate"),
        "constraint_type": "ConstraintType",
        "days_fcast": ("pcs_duration_to_msp_durations", None),
        "end_time_fcast": [("pcs_finish_date_to_msp_finish_date", "Finish"),
                           ("pcs_finish_date_to_msp_finish_date", "ManualFinish")],
        "is_group": "Summary",
        "joined_status_name": "Text15:PCS Status",
        "milestone": "Milestone",
        "msp_guid": "GUID",
        "msp_uid": ("ensure_msp_uid", "UID"),
        "percent_complet": "PercentComplete",
        "psp_code": "WBS",
        "reference_id": "Text12:PCS Reference ID",
        "start_time_fcast": [("pcs_start_date_to_msp_start_date", "Start"),
                             ("pcs_start_date_to_msp_start_date", "ManualStart")],
        "status": [("pcs_status_to_msp_active", "Active"),
                   "Number10:PCS Status Number"],
        "subject_id": ("pcs_subject_to_msp_text", "Text14:PCS Responsible"),
        "task_name": "Name",
        }
    #: Dictionary with a mapping between MSP task fields (as keys) and default values. The
    #: default value is only used when no value gets transferred via the TASK_MAPPING attribute.
    TASK_DEFAULTS = {
        "Estimated": 0,  # MSP's default is "1" which ends in values with question marks
        }

    #: Dictionary with a mapping between callback class method names (as keys) and MSP task field
    #: names (as values). The task field name can optionally be followed by a colon and a custom
    #: MSP column name. Callback method signature:
    #:
    #:    .. code-block:: python
    #:
    #:       def pcs_object_x_to_msp_field_x(self, pcs_task, msp_task, msp_attr):
    #:
    TASK_REFERENCE_MAPPING = {
        "pcs_checklists_to_msp_text": "Text13:PCS Checklists",
        "pcs_workflows_to_msp_text": "Text11:PCS Workflows",
        }

    def ensure_msp_uid(self, pcs_task, pcs_attr, msp_task, msp_attr):
        pcs_value = self.get_pcs_task_msp_uid(pcs_task)
        return pcs_value

    def pcs_start_date_to_msp_start_date(self, pcs_object, pcs_attr, msp_object, msp_attr):
        from cs.pcs.projects.tasks import Task
        pcs_value = getattr(pcs_object, pcs_attr, "")
        if pcs_value:
            # currently PCS doesn't handle times, thus set a default one
            start_hour = self.DEFAULT_START_HOUR
            if isinstance(pcs_object, Task) and pcs_object["milestone"]\
                       and not pcs_object["early_position"]:
                # Milestones are specially handled in that the cdb attribute "early_position"
                # determines the start time of the MSP task
                # MSP rule: By the way MSP itself defaults to "early" milestones (contrary to PO)
                start_hour = self.DEFAULT_FINISH_HOUR
            pcs_value = pcs_value.replace(hour=start_hour)
            pcs_value = pcs_value.strftime(msp_misc.MSP_XML_DATETIME_FORMAT)
        return pcs_value

    def pcs_finish_date_to_msp_finish_date(self, pcs_object, pcs_attr, msp_object, msp_attr):
        from cs.pcs.projects.tasks import Task
        pcs_value = getattr(pcs_object, pcs_attr, "")
        if pcs_value:
            # currently PCS doesn't handle times, thus set a default one
            finish_hour = self.DEFAULT_FINISH_HOUR
            if isinstance(pcs_object, Task) and pcs_object["milestone"]\
               and pcs_object["early_position"]:
                # Milestones are specially handled in that the cdb attribute "early_position"
                # determines the end time of the MSP task
                # MSP rule: By the way MSP itself defaults to "early" milestones (contrary to PO)
                finish_hour = self.DEFAULT_START_HOUR
            pcs_value = pcs_value.replace(hour=finish_hour)
            pcs_value = pcs_value.strftime(msp_misc.MSP_XML_DATETIME_FORMAT)
        return pcs_value

    def pcs_duration_to_msp_durations(self, pcs_task, pcs_attr, msp_task, msp_attr):
        # MSP rule: only setting an MSP task's "Duration" field isn't sufficient, instead
        #           "ActualDuration" and "RemainingDuration" must be set depending on
        #           "PercentComplete"
        pcs_duration = getattr(pcs_task, pcs_attr, 0) * 8
        actual_duration = 0
        remaining_duration = pcs_duration
        if pcs_duration:
            # MSP rule: MSP simply rejects values with empty dates like "P0Y0M0DT8H0M0S",
            #           thus skip the date tokens if there's no date anyway => "PT8H0M0S"
            percent_complete = getattr(pcs_task, "percent_complet", 0)
            if percent_complete:
                actual_duration = int(round(float(pcs_duration) * percent_complete / 100))
                remaining_duration = pcs_duration - actual_duration
        # TODO: split large hour values into days?
        self.set_msp_object_attr(msp_task, "ActualDuration", "PT%sH0M0S" % actual_duration)
        self.set_msp_object_attr(msp_task, "RemainingDuration", "PT%sH0M0S" % remaining_duration)

    def pcs_flag_to_msp_flag_inverted(self, pcs_object, pcs_attr, msp_object, msp_attr):
        pcs_value = getattr(pcs_object, pcs_attr, 0)
        return 0 if (pcs_value == 1) else 1

    def pcs_automatic_to_msp_manual(self, pcs_task, pcs_attr, msp_task, msp_attr):
        if pcs_task.is_group:
            pcs_value = getattr(pcs_task, "auto_update_time", 0)
        else:
            pcs_value = getattr(pcs_task, pcs_attr, 0)
        return 0 if (pcs_value == 1) else 1

    def pcs_constraint_date_to_msp_constraint_date(self, pcs_task, pcs_attr, msp_task, msp_attr):
        pcs_value = getattr(pcs_task, pcs_attr, "")
        if pcs_value:
            if pcs_task.constraint_type in ["", "0", "1"]:  # ["", "ASAP", "ALAP"]
                pcs_value = ""
            elif pcs_task.constraint_type in ["3", "6", "7"]:  # ["MFO", "FNET", "FNLT"]
                pcs_value = pcs_value.replace(hour=self.DEFAULT_FINISH_HOUR)
                pcs_value = pcs_value.strftime(msp_misc.MSP_XML_DATETIME_FORMAT)
            else:  # ["MSO", "SNET", "SNLT"]
                pcs_value = pcs_value.replace(hour=self.DEFAULT_START_HOUR)
                pcs_value = pcs_value.strftime(msp_misc.MSP_XML_DATETIME_FORMAT)
        return pcs_value

    def pcs_status_to_msp_active(self, pcs_task, pcs_attr, msp_task, msp_attr):
        pcs_value = getattr(pcs_task, pcs_attr, 0)
        return "1" if (pcs_value != 180) else "0"

    def pcs_subject_to_msp_text(self, pcs_task, pcs_attr, msp_task, msp_attr):
        # show subject_type (role) as prefix
        pcs_value = self.REF_OBJECT_TOKENS_SEPARATOR.join(
            [getattr(pcs_task, "subject_type", "") or "",
             getattr(pcs_task, pcs_attr, "") or ""])
        return pcs_value

    def pcs_checklists_to_msp_text(self, pcs_task, msp_task, msp_attr):
        ref_checklist_ids = []
        for checklist in pcs_task.Checklists:
            ref_checklist_ids.append(getattr(checklist, self.REF_CHECKLIST_ID_FIELD, ""))
        return self.REF_OBJECTS_SEPARATOR.join(ref_checklist_ids)

    def pcs_workflows_to_msp_text(self, pcs_task, msp_task, msp_attr):
        ref_workflow_ids = []
        for process in pcs_task.Processes:
            ref_workflow_ids.append(getattr(process, self.REF_WORKFLOW_ID_FIELD, ""))
        return self.REF_OBJECTS_SEPARATOR.join(ref_workflow_ids)


class TaskAttributeProvider(PowerReports.CustomDataProvider):

    CARD = PowerReports.CARD_N
    CALL_CARD = PowerReports.CARD_1

    def getData(self, parent_result, source_args, **kwargs):
        result = PowerReports.ReportDataList(self)
        project = parent_result.getObject()
        for task in project.AllTasksByOrder:
            if not task.milestone:
                result.append(PowerReports.ReportData(self, task))
        return result

    def getSchema(self):
        from cs.pcs.projects.tasks import Task
        return PowerReports.XSDType(self.CARD, Task, provider=self)
