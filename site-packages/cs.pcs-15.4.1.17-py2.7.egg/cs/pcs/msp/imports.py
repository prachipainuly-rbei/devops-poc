#!/usr/bin/env powerscript
# -*- python -*- coding: UTF-8 -*-
#
# Copyright (C) 2017 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Import or update PCS projects via MSP's XML schema.
"""

from __future__ import unicode_literals

from collections import OrderedDict
from datetime import datetime
from lxml import objectify
import math
import re

from cdb import auth, misc, ue, util
from cdb.constants import kOperationCopy, kOperationDelete, kOperationModify, kOperationNew
from cdb.objects import Object
from cdb.objects.pdd.Files import Sandbox
from cdb.transactions import Transaction

from cs.pcs.msp import misc as msp_misc
from cs.pcs.msp.misc import log
from cs.pcs.msp.import_results import DiffType, ImportException, ImportResult

__docformat__ = "restructuredtext en"
__revision__ = "$Id: imports.py 179395 2018-06-21 12:30:36Z kbu $"


class XmlMergeImport(object):

    DEFAULT_START_HOUR = msp_misc.DEFAULT_START_HOUR
    DEFAULT_FINISH_HOUR = msp_misc.DEFAULT_FINISH_HOUR

    REF_OBJECTS_SEPARATOR = msp_misc.REF_OBJECTS_SEPARATOR
    REF_OBJECT_TOKENS_SEPARATOR = msp_misc.REF_OBJECT_TOKENS_SEPARATOR
    REF_PROJECT_ID_FIELD = msp_misc.REF_PROJECT_ID_FIELD
    REF_CHECKLIST_ID_FIELD = msp_misc.REF_CHECKLIST_ID_FIELD
    REF_WORKFLOW_ID_FIELD = msp_misc.REF_WORKFLOW_ID_FIELD

    def __init__(self):
        self.pcs_project = None
        self.msp_project = None
        self.called_from_officelink = False

    @classmethod
    def import_project_from_xml(cls, pcs_project_object_or_id, xml_doc, dry_run=False,
                                called_from_officelink=False):
        """
        Performs a full import of given Document into given PCS project and returns the import
        result. The Document must contain an MSP XML file.
        """
        log("pcs_project_object_or_id=%s, xml_doc=%s, dry_run=%s" %
            (pcs_project_object_or_id, xml_doc, dry_run))
        merge_import = cls()
        merge_import.called_from_officelink = called_from_officelink
        try:
            with Transaction():
                merge_import.set_pcs_project(pcs_project_object_or_id)
                merge_import.load_msp_project_from_document(xml_doc)
                merge_import.execute(dry_run)
        except ImportException:
            misc.log_traceback("")
        return merge_import.result

    def set_pcs_project(self, pcs_project_object_or_id):
        from cs.pcs.projects import Project
        from cs.pcs.projects.tasks import Task, TaskRelation

        if isinstance(pcs_project_object_or_id, Project):
            self.pcs_project = pcs_project_object_or_id
        else:
            self.pcs_project = Project.ByKeys(pcs_project_object_or_id)

        self.pcs_old_tasks = Task.KeywordQuery(
            cdb_project_id=self.pcs_project.cdb_project_id).Execute()  # prevent lazy evaluation
        log("PCS task count: %s" % len(self.pcs_old_tasks))
        self.pcs_old_task_links = TaskRelation.KeywordQuery(
            cdb_project_id=self.pcs_project.cdb_project_id,
            cdb_project_id2=self.pcs_project.cdb_project_id).Execute()  # prevent lazy evaluation
        log("PCS task link count: %s" % len(self.pcs_old_task_links))
        self.pcs_old_external_task_links = TaskRelation.Query(
            "cdb_project_id='%(pid)s' AND cdb_project_id2!='%(pid)s' OR "
            "cdb_project_id!='%(pid)s' AND cdb_project_id2='%(pid)s'"
            % {"pid": self.pcs_project.cdb_project_id})
        log("PCS external task link count: %s" % len(self.pcs_old_external_task_links))

        self.reset_results()

    def load_msp_project_from_document(self, keys):
        """Takes a key dictionary (Document) and reads the first found XML file."""
        from cs.documents import Document

        doc = Document.ByKeys(keys["z_nummer"], keys["z_index"])
        fobj = None
        for _fobj in doc.Files:
            if _fobj.cdbf_name.lower().endswith(".xml"):
                if fobj:
                    raise ue.Exception("cdbpcs_multiple_xml_files_in_document",
                                       doc.GetDescription())
                fobj = _fobj
        if not fobj:
            raise ue.Exception("cdbpcs_xml_file_not_found_in_document", doc.GetDescription())

        with Sandbox() as sb:
            sb.checkout(fobj)
            with open(sb.pathname(fobj)) as f:
                tree = objectify.parse(f)
        self.msp_project = tree.getroot()

        # exclude the project summary task since there's no such thing in PCS
        project_summary_task = self.msp_project.Tasks.xpath(
            "xmlns:Task/xmlns:OutlineLevel[text()='0']/..",
            namespaces={"xmlns": msp_misc.MSP_XML_SCHEMA})
        if project_summary_task:
            self.msp_project.Tasks.remove(project_summary_task[0])

        # for easier access later on add extended task attributes ("Text*") as regular attributes
        ext_attr_defs = self.msp_project.xpath("xmlns:ExtendedAttributes/xmlns:ExtendedAttribute",
                                               namespaces={"xmlns": msp_misc.MSP_XML_SCHEMA})
        for ext_attr_def in ext_attr_defs:
            ext_attrs = self.msp_project.xpath("xmlns:Tasks/xmlns:Task/xmlns:ExtendedAttribute/"
                                               "xmlns:FieldID[text()='%s']/.."
                                               % ext_attr_def.FieldID,
                                               namespaces={"xmlns": msp_misc.MSP_XML_SCHEMA})
            for ext_attr in ext_attrs:
                msp_task = ext_attr.xpath("..")[0]
                msp_task.addattr("%s" % ext_attr_def.FieldName, "%s" % ext_attr.Value)

        self.build_msp_task_tree()

        self.reset_results()

    def reset_results(self):
        self.mapped_tasks = OrderedDict()
        self.result = ImportResult(self.pcs_project)
        self.result.num_old_tasks = len(getattr(self, "pcs_old_tasks", []))

    def execute(self, dry_run=False):
        self.dry_run = dry_run
        start_time = datetime.now()

        log("Importing project attributes..")
        pcs_project_attrs, exceptions = self.get_mapped_pcs_attrs(
            self.PROJECT_MAPPING, self.PROJECT_DEFAULTS, self.msp_project, self.pcs_project)
        if not exceptions:
            self.modify_pcs_object(self.pcs_project, pcs_project_attrs,
                                   attr_display_order=self.PROJECT_ATTR_ORDER)
        else:
            for ex in exceptions:
                self.result.add_diff_object(DiffType.MODIFIED, self.pcs_project, exception=ex)

        log("Importing tasks..")
        self.update_pcs_task_tree("", self.msp_task_tree)
        self.update_pcs_task_links()
        log("Removing unmapped task objects..")
        self.delete_unmapped_task_objects()

        log("Finalizing import..")
        num_exceptions = self.result.exceptions_occurred()
        if not self.dry_run and not num_exceptions:
            self.pcs_project.MSPtoDB()

        log("Import finished in %s second(s)" % (datetime.now() - start_time).seconds)
        self.result.log_count()

        if not dry_run and num_exceptions:
            raise ImportException("Number of import exceptions: %s" % num_exceptions)

    def build_msp_task_tree(self):
        """
        Traverses the flat structured MSP XML project and builds a hierarchical task structure via
        ordered dictionary.
        """
        self.msp_task_tree = OrderedDict()
        self.msp_task_links = OrderedDict()
        parent_path = []
        for msp_task in self.msp_project.Tasks.getchildren():
            if getattr(msp_task, "IsNull", 0):
                continue  # empty MSP task
            while parent_path:
                if parent_path[-1].OutlineLevel < msp_task.OutlineLevel:
                    break
                parent_path.pop()
            _msp_task_tree = self.msp_task_tree
            for parent in parent_path:
                _msp_task_tree = _msp_task_tree[parent]
            _msp_task_tree[msp_task] = OrderedDict()
            parent_path.append(msp_task)

    def update_pcs_task_tree(self, parent_pcs_task_id, msp_task_tree):
        """Maps an MSP XML task tree and recursively updates the regarding PCS task tree."""
        from cs.pcs.projects.tasks import Task

        pcs_task_position = 10
        for msp_task, msp_sub_task_tree in msp_task_tree.items():
            # prefer the more reliable GUID if it exists (instead of UID):
            # 1) the UID changes when moving tasks in MSP via cut/paste
            # 2) the UID gets re-used when deleting tasks and re-opening the plan afterwards
            pcs_task = None
            if hasattr(msp_task, "GUID") and msp_task.GUID:
                pcs_task = self.pcs_old_tasks.KeywordQuery(msp_guid="%s" % msp_task.GUID)
            if not pcs_task and msp_task.UID:
                pcs_task = self.pcs_old_tasks.Query(
                    "msp_uid=%d AND (msp_guid IS NULL OR msp_guid='')" % msp_task.UID)

            # legacy: support importing MSP files formerly managed by the old interface
            # where the task id (UUID) mapping was msp_task.Text18 <-> pcs_task.tuid
            if not pcs_task and hasattr(msp_task, "Text18") and (len("%s" % msp_task.Text18) == 36):
                pcs_task = self.pcs_old_tasks.Query(
                    "tuid='%s' AND (msp_uid IS NULL) "
                    "AND (msp_guid IS NULL OR msp_guid='')" % msp_task.Text18)

            if pcs_task:
                if len(pcs_task) > 1:
                    raise ue.Exception("The task.msp_guid '%s' or task.msp_uid '%s'"
                                       "is not unique" % (msp_task.GUID, msp_task.UID))  # i18n
                pcs_task = pcs_task[0]

            pcs_task_attrs, exceptions = self.get_mapped_pcs_attrs(
                self.TASK_MAPPING, self.TASK_DEFAULTS, msp_task, pcs_task or Task)
            pcs_task_attrs["parent_task"] = parent_pcs_task_id

            pcs_task_attrs["position"] = pcs_task_position
            pcs_task_position += 10

            if pcs_task:
                if not exceptions:
                    self.modify_pcs_object(pcs_task, pcs_task_attrs,
                                           attr_display_order=self.TASK_ATTR_ORDER)
                else:
                    for ex in exceptions:
                        self.result.add_diff_object(DiffType.MODIFIED, pcs_task, exception=ex)
                for t in self.pcs_old_tasks:
                    # self.old_tasks.remove(pcs_task) is not reliable
                    if t.cdb_object_id == pcs_task.cdb_object_id:
                        self.pcs_old_tasks.remove(t)
                        break
            else:
                pcs_task_attrs["cdb_project_id"] = self.pcs_project.cdb_project_id
                pcs_task = pcs_task_attrs.copy()
                pcs_task["task_id"] = ""
                if not exceptions:
                    exception = None
                    if not self.dry_run:
                        try:
                            pcs_task = msp_misc.operation_ex(kOperationNew, Task, pcs_task_attrs,
                                                             self.called_from_officelink)
                        except Exception as exception:
                            misc.log_traceback("")
                    self.result.add_diff_object(DiffType.ADDED, pcs_task, Task, exception=exception)
                else:
                    for ex in exceptions:
                        self.result.add_diff_object(DiffType.ADDED, pcs_task, Task, exception=ex)

            self.mapped_tasks[msp_task.UID] = {"msp_task": msp_task, "pcs_task": pcs_task}

            links = msp_task.xpath("xmlns:PredecessorLink",
                                   namespaces={"xmlns": msp_misc.MSP_XML_SCHEMA})
            for link in links:
                self.msp_task_links.setdefault(msp_task.UID, [])
                self.msp_task_links[msp_task.UID].append(link)

            self.update_pcs_task_references(msp_task, pcs_task)

            self.update_pcs_task_tree(pcs_task["task_id"], msp_sub_task_tree)

    def update_pcs_task_references(self, msp_task, pcs_task):
        for msp_attr, function in self.TASK_REFERENCE_MAPPING.items():
            function = getattr(self, function)
            function(msp_task, msp_attr, pcs_task)

    def update_pcs_task_links(self):
        """Maps MSP XML task links and updates the regarding PCS task links."""
        from cs.pcs.projects.tasks import TaskRelation

        for successor_uid, links in self.msp_task_links.items():
            for link in links:
                predecessor = self.mapped_tasks[link.PredecessorUID]["pcs_task"]
                successor = self.mapped_tasks[successor_uid]["pcs_task"]

                # workaround to see a descriptive task link name in the import preview
                task_id2 = predecessor["task_id"] or "@%s" % predecessor["task_name"]

                pcs_link_keys = {
                    "cdb_project_id": successor["cdb_project_id"],
                    "task_id": successor["task_id"],
                    "cdb_project_id2": predecessor["cdb_project_id"],
                    "task_id2": task_id2,
                    "rel_type": msp_misc.MspToPcs.TaskLinkType[link.Type],
                    }
                pcs_link_attrs = {
                    # PredecessorLink.LinkLag: The amount of lag in tenths of a minute
                    "minimal_gap": int(link.LinkLag) / 60 / 10 / 8,  # days in PCS
                    }

                pcs_link = self.pcs_old_task_links.KeywordQuery(**pcs_link_keys)
                if pcs_link:
                    pcs_link = pcs_link[0]
                    self.modify_pcs_object(pcs_link, pcs_link_attrs, successor)
                    for link in self.pcs_old_task_links:
                        # self.pcs_old_task_links.remove(pcs_link) is not reliable
                        for key, value in pcs_link_keys.items():
                            if link[key] != value:
                                break
                        else:
                            self.pcs_old_task_links.remove(link)
                            break
                else:
                    pcs_link_attrs.update(pcs_link_keys)
                    # much too slow: pcs_link = TaskRelation.createRelation(**pcs_link_attrs)
                    exception = None
                    if not self.dry_run:
                        try:
                            pcs_link = TaskRelation.Create(**pcs_link_attrs)
                        except Exception as exception:
                            misc.log_traceback("")
                            pcs_link = pcs_link_attrs.copy()
                    else:
                        pcs_link = pcs_link_attrs.copy()
                    self.result.add_diff_object(DiffType.ADDED, pcs_link, TaskRelation,
                                                parent=successor, exception=exception)

        still_used_links = []
        for pcs_link in self.pcs_old_external_task_links:
            link_points_outside = (pcs_link.cdb_project_id == self.pcs_project.cdb_project_id)
            linked_task_id = pcs_link.task_id if link_points_outside else pcs_link.task_id2
            for mapped_task in self.mapped_tasks.values():
                if mapped_task["pcs_task"].task_id == linked_task_id:
                    still_used_links.append(pcs_link)
                    break
        for pcs_link in still_used_links:
            self.pcs_old_external_task_links.remove(pcs_link)

    def delete_unmapped_task_objects(self):

        def del_pcs_obj(pcs_object):
            exception = None
            if not self.dry_run and pcs_object.getPersistentObject():
                try:
                    msp_misc.operation_ex(kOperationDelete, pcs_object,
                                          called_from_officelink=self.called_from_officelink)
                except Exception as exception:
                    misc.log_traceback("")
            self.result.add_diff_object(DiffType.DELETED, pcs_object, exception=exception)

        if self.pcs_old_tasks:
            tasks = self.result.tasks.all
            self.result.tasks.all = OrderedDict()
            for pcs_task in self.pcs_old_tasks:
                del_pcs_obj(pcs_task)
            for key, diff_object in tasks.items():
                self.result.tasks.all[key] = diff_object
        for pcs_link in self.pcs_old_task_links + self.pcs_old_external_task_links:
            del_pcs_obj(pcs_link)

    def get_mapped_pcs_attrs(self, attr_mapping, attr_defaults, msp_object, pcs_obj_or_cls):
        """
        Maps an MSP XML object (project or task) and returns a filled PCS attribute dictionary.
        """
        pcs_object_attrs = {}
        exceptions = []
        for msp_attr, pcs_attr in attr_mapping.items():
            try:
                if isinstance(pcs_attr, tuple):
                    function, pcs_attrs = pcs_attr
                    function = getattr(self, function)
                    if not isinstance(pcs_attrs, list):
                        pcs_attrs = [pcs_attrs]
                    for pcs_attr in pcs_attrs:
                        function(msp_object, msp_attr, pcs_object_attrs, pcs_attr, pcs_obj_or_cls)
                else:
                    msp_value = "%s" % getattr(msp_object, msp_attr, "")
                    pcs_object_attrs[pcs_attr] = \
                        msp_misc.MspToPcs.convert_value(pcs_obj_or_cls, pcs_attr, msp_value)
            except Exception as ex:
                misc.log_traceback("")
                exceptions.append("%s" % ex)
        for pcs_attr, default_value in attr_defaults.items():
            if not isinstance(pcs_obj_or_cls, Object):  # new object
                if not pcs_object_attrs.get(pcs_attr):
                    pcs_object_attrs[pcs_attr] = default_value
            else:  # existing object
                if not getattr(pcs_obj_or_cls, pcs_attr, None):
                    pcs_object_attrs[pcs_attr] = default_value
        return pcs_object_attrs, exceptions

    def modify_pcs_object(self, pcs_object, pcs_object_attrs, parent=None, attr_display_order=None):
        """Skips running the 'modify' operation when values don't differ anyway."""
        diffs = OrderedDict()
        classname = msp_misc.get_classname(pcs_object)

        _pcs_object_attrs_ordered = OrderedDict()
        if attr_display_order:
            for attr in attr_display_order:
                if attr in pcs_object_attrs:
                    _pcs_object_attrs_ordered[attr] = pcs_object_attrs.pop(attr)
        _pcs_object_attrs_ordered.update(pcs_object_attrs)
        pcs_object_attrs = _pcs_object_attrs_ordered

        for pcs_attr, new_value in pcs_object_attrs.items():
            value_diff = msp_misc.get_value_diff(pcs_object, pcs_attr, new_value)
            if value_diff:
                log("%s.%s: '%s' -> '%s'" % (classname, pcs_attr, value_diff["old_value"],
                                             value_diff["new_value"]), 9)
                diffs[pcs_attr] = self.modify_value_diff_display(pcs_object, pcs_attr, value_diff)

        if diffs:
            self.result.add_diff_object(DiffType.MODIFIED, pcs_object, classname, diffs=diffs,
                                        parent=parent)
            if not self.dry_run:
                try:
                    msp_misc.operation_ex(kOperationModify, pcs_object, pcs_object_attrs,
                                          self.called_from_officelink)
                except Exception as ex:
                    misc.log_traceback("")
                    self.result.add_diff_object(DiffType.MODIFIED, pcs_object, classname,
                                                exception=ex)

    def modify_value_diff_display(self, pcs_object, pcs_attr, value_diff):
        """Convert internal values (unreadable/non-descriptive for the user) into readable ones"""
        from cs.pcs.projects.tasks import Task
        if isinstance(pcs_object, Task):
            if pcs_attr == "constraint_type":
                _old_value = value_diff["old_value"]
                value_diff["old_value"] = pcs_object.mapped_constraint_type_name
                setattr(pcs_object, pcs_attr, value_diff["new_value"])
                value_diff["new_value"] = pcs_object.mapped_constraint_type_name
                setattr(pcs_object, pcs_attr, _old_value)
        return value_diff

    # Attribute mappings

    #: Dictionary with a mapping between MSP project fields (as keys) and PCS project attributes
    #: (as values). Values can either be single strings, thus the targeted attribute names, or
    #: tuples containing a callback class method name and then the targeted attribute names.
    #: Callback method signature:
    #:
    #:    .. code-block:: python
    #:
    #:       def msp_field_x_to_pcs_attr_x(self, msp_project, msp_attr, pcs_project_attrs, pcs_attr,
    #:                                     pcs_obj_or_cls):
    #:
    PROJECT_MAPPING = {
        "FinishDate": "end_time_fcast",
        "StartDate": "start_time_fcast",
        }
    #: Dictionary with a mapping between PCS project attributes (as keys) and default values. The
    #: default value is only used when no value gets transferred via the PROJECT_MAPPING attribute.
    PROJECT_DEFAULTS = {
        }
    #: The order in which the project attributes are being displayed in the import preview dialog.
    PROJECT_ATTR_ORDER = [
        "start_time_fcast",
        "end_time_fcast",
        ]

    #: Dictionary with a mapping between MSP task fields (as keys) and PCS task attributes
    #: (as values). Values can either be single strings, thus the targeted attribute names, or
    #: tuples containing a callback class method name and then the targeted attribute names.
    #: Callback method signature:
    #:
    #:    .. code-block:: python
    #:
    #:       def msp_field_x_to_pcs_attr_x(self, msp_task, msp_attr, pcs_task_attrs, pcs_attr,
    #:                                     pcs_obj_or_cls):
    #:
    TASK_MAPPING = {
        "Active": ("msp_active_to_pcs_status", None),
        "ConstraintDate": "constraint_date",
        "ConstraintType": "constraint_type",
        "Duration": ("msp_duration_to_pcs_duration", "days_fcast"),
        "Finish": "end_time_fcast",
        "GUID": "msp_guid",
        "Manual": ("msp_flag_to_pcs_flag_inverted", ["auto_update_time", "automatic"]),
        "Milestone": ("msp_milestone_to_pcs_milestone", "milestone"),
        "Name": "task_name",
        # "PercentComplete": "percent_complet",  # importing causes "wrong" diffs for edited tasks
        # "Priority": "priority",  # does this attribute still make sense in PO?
        "Start": "start_time_fcast",
        "Summary": "is_group",
        "Text12": ("msp_text_to_pcs_reference_id", "reference_id"),
        "Text14": ("msp_text_to_pcs_responsible", None),
        "UID": "msp_uid",
        }
    #: Dictionary with a mapping between PCS task attributes (as keys) and default values. The
    #: default value is only used when no value gets transferred via the TASK_MAPPING attribute.
    TASK_DEFAULTS = {
        "subject_type": "PCS Role",
        "subject_id": "Projektmitglied",
        }
    #: The order in which the task attributes are being displayed in the import preview dialog.
    TASK_ATTR_ORDER = [
        "start_time_fcast",
        "end_time_fcast",
        "days_fcast",
        "task_name",
        "constraint_type",
        "constraint_date",
        "automatic",
        "auto_update_time",
        "milestone",
        ]

    #: Dictionary with a mapping between MSP task fields (as keys) and PCS task reference objects.
    #: The dictionary values are callback class method names. Callback method signature:
    #:
    #:    .. code-block:: python
    #:
    #:       def msp_field_x_to_pcs_object_x(self, msp_task, msp_attr, pcs_task):
    #:
    TASK_REFERENCE_MAPPING = {
        "Text13": "msp_text_to_pcs_checklists",
        "Text11": "msp_text_to_pcs_workflows",
        }

    def msp_duration_to_pcs_duration(self, msp_object, msp_attr, pcs_object_attrs, pcs_attr,
                                     pcs_obj_or_cls):
        """
        The MSP data type 'duration':
         A duration of time, provided in the format PnYnMnDTnHnMnS where nY represents the number of
         years, nM the number of months, nD the number of days, T the date/time separator, nH the
         number of hours, nM the number of minutes, and nS the number of seconds.
         For example, to indicate a duration of 1 year, 2 months, 3 days, 10 hours, and 30 minutes,
         you write: P1Y2M3DT10H30M. You could also indicate a duration of minus 120 days as -P120D.
        """
        msp_value = "%s" % getattr(msp_object, msp_attr, "")
        if msp_value:
            match = re.match(r"P"
                             "((?P<years>\d*)Y)?"
                             "((?P<months>\d*)M)?"
                             "((?P<days>\d*)D)?"
                             "T?"
                             "((?P<hours>\d*)H)?"
                             "((?P<minutes>\d*)M)?"
                             "((?P<seconds>\d*)S)?",
                             msp_value)
            hours = int(match.group("hours") if match.group("hours") else 0)
            hours += int(match.group("days") if match.group("days") else 0) * 8
            hours += int(match.group("months") if match.group("months") else 0) * 8 * 20  # <= ???
            hours += int(match.group("years") if match.group("years") else 0) * 8 * 240  # <= ???
            pcs_object_attrs[pcs_attr] = int(math.ceil(hours / 8.0))
        else:
            pcs_object_attrs[pcs_attr] = 0

    def msp_flag_to_pcs_flag_inverted(self, msp_object, msp_attr, pcs_object_attrs, pcs_attr,
                                      pcs_obj_or_cls):
        msp_value = "%s" % getattr(msp_object, msp_attr, "")
        pcs_object_attrs[pcs_attr] = 0 if (msp_value == "1") else 1

    def msp_milestone_to_pcs_milestone(self, msp_task, msp_attr, pcs_task_attrs, pcs_attr,
                                       pcs_obj_or_cls):
        milestone = getattr(msp_task, msp_attr, 0)
        pcs_task_attrs[pcs_attr] = int(milestone)
        # Milestones are specially handled in that the cdb attribute "early_position" gets
        # adjusted here according to the start time of the MSP task
        early_position = 0
        if milestone and msp_task["Start"]:
            task_datetime = datetime.strptime("%s" % msp_task["Start"], "%Y-%m-%dT%H:%M:%S")
            early_datetime = task_datetime.replace(hour=self.DEFAULT_START_HOUR, minute=0, second=0)
            if (task_datetime <= early_datetime):
                early_position = 1
        pcs_task_attrs["early_position"] = early_position

    def msp_active_to_pcs_status(self, msp_task, msp_attr, pcs_task_attrs, pcs_attr,
                                 pcs_obj_or_cls):
        # TODO: change the PCS task status to "discarded" if "deactivated" (and vice versa)
        # if isinstance(pcs_obj_or_cls, type):
            # pcs_task_attrs["status"] = ...
        # else:
            # pcs_obj_or_cls.ChangeState(...
        pass

    def msp_text_to_pcs_reference_id(self, msp_task, msp_attr, pcs_task_attrs, pcs_attr,
                                     pcs_obj_or_cls):
        msp_value = "%s" % getattr(msp_task, msp_attr, "")
        if msp_value:
            # only initially write values from msp to pcs - don't overwrite existing ones
            if isinstance(pcs_obj_or_cls, type) or not getattr(pcs_obj_or_cls, pcs_attr):
                pcs_task_attrs[pcs_attr] = \
                    msp_misc.MspToPcs.convert_value(pcs_obj_or_cls, pcs_attr, msp_value)

    def msp_text_to_pcs_responsible(self, msp_task, msp_attr, pcs_task_attrs, pcs_attr,
                                    pcs_obj_or_cls):
        msp_value = "%s" % getattr(msp_task, msp_attr, "")
        if msp_value:
            subject_type, subject_id = msp_value.split(self.REF_OBJECT_TOKENS_SEPARATOR, 1)
            if subject_type == "Person":
                from cdb.objects.org import Person
                if not Person.ByKeys(subject_id):
                    raise ue.Exception("cdbpcs_person_not_found", subject_id)
            else:
                roles = [r.role_id for r in self.pcs_project.Roles]
                if (subject_type != "PCS Role") or (subject_id not in roles):
                    raise ue.Exception("cdbpcs_role_not_found", subject_type, subject_id)
            # only initially write values from msp to pcs - don't overwrite existing ones
            if isinstance(pcs_obj_or_cls, type) or (not getattr(pcs_obj_or_cls, "subject_type")
                                                    and not getattr(pcs_obj_or_cls, "subject_id")):
                pcs_task_attrs["subject_type"] = \
                    msp_misc.MspToPcs.convert_value(pcs_obj_or_cls, "subject_type", subject_type)
                pcs_task_attrs["subject_id"] = \
                    msp_misc.MspToPcs.convert_value(pcs_obj_or_cls, "subject_id", subject_id)

    def msp_text_to_pcs_checklists(self, msp_task, msp_attr, pcs_task):
        from cs.pcs.checklists import Checklist
        from cs.pcs.projects import Project
        from cs.pcs.projects.tasks import Task

        ref_checklist_ids = "%s" % getattr(msp_task, msp_attr, "")
        if ref_checklist_ids:
            for ref_checklist_id in ref_checklist_ids.split(self.REF_OBJECTS_SEPARATOR):
                ref_checklist_id = ref_checklist_id.strip()

                try:
                    template_project = None
                    if self.REF_OBJECT_TOKENS_SEPARATOR in ref_checklist_id:
                        template_project_id, ref_checklist_id = \
                            ref_checklist_id.split(self.REF_OBJECT_TOKENS_SEPARATOR, 1)
                        args = {
                            self.REF_PROJECT_ID_FIELD: template_project_id,
                            "template": 1
                            }
                        template_project = Project.KeywordQuery(**args)
                        if not template_project:
                            raise ue.Exception("cdbpcs_template_object_not_found", repr(args))
                        template_project = template_project[0]

                    args = {self.REF_CHECKLIST_ID_FIELD: ref_checklist_id}
                    # check if it's either a new task or if the checklist doesn't exist yet
                    if not isinstance(pcs_task, Task) \
                       or not pcs_task.Checklists.KeywordQuery(**args):
                        args["template"] = 1
                        if template_project:
                            args["cdb_project_id"] = template_project.cdb_project_id
                            cl_src = Checklist.KeywordQuery(**args)
                        else:
                            cl_src = self.pcs_project.Checklists.KeywordQuery(**args)
                        if not cl_src:
                            raise ue.Exception("cdbpcs_template_object_not_found", repr(args))
                        cl_src = cl_src[0]

                        args_new = {
                            "cdb_project_id": self.pcs_project.cdb_project_id,
                            "task_id": getattr(pcs_task, "task_id", ""),
                            "template": 0
                            }
                        if not self.dry_run:
                            args_new["checklist_id"] = util.nextval("cdbpcs_checklist")
                            cl_new = msp_misc.operation_ex(kOperationCopy, cl_src, args_new,
                                                           self.called_from_officelink)
                        else:
                            # bogus preview object
                            cl_new = args_new
                            for k, v in cl_src.items():
                                cl_new.setdefault(k, v)

                        icon_name = msp_misc.get_icon_name("cdbpcs_%s" % cl_src.type.lower())
                        self.result.add_diff_object(DiffType.ADDED, cl_new, Checklist, icon_name,
                                                    parent=pcs_task)
                except Exception as ex:
                    misc.log_traceback("")
                    self.result.add_diff_object(DiffType.MODIFIED, pcs_task, Task, exception=ex)

    def msp_text_to_pcs_workflows(self, msp_task, msp_attr, pcs_task):
        from cs.workflow.briefcases import BriefcaseContent
        from cs.workflow.processes import Process
        from cs.pcs.projects import Project
        from cs.pcs.projects.tasks import Task

        ref_workflow_ids = "%s" % getattr(msp_task, msp_attr, "")
        if ref_workflow_ids:
            for ref_workflow_id in ref_workflow_ids.split(self.REF_OBJECTS_SEPARATOR):
                ref_workflow_id = ref_workflow_id.strip()

                try:
                    template_project = None
                    if self.REF_OBJECT_TOKENS_SEPARATOR in ref_workflow_id:
                        template_project_id, ref_workflow_id = \
                            ref_workflow_id.split(self.REF_OBJECT_TOKENS_SEPARATOR, 1)
                        args = {
                            self.REF_PROJECT_ID_FIELD: template_project_id,
                            "template": 1
                            }
                        template_project = Project.KeywordQuery(**args)
                        if not template_project:
                            raise ue.Exception("cdbpcs_template_object_not_found", repr(args))
                        template_project = template_project[0]

                    args = {self.REF_WORKFLOW_ID_FIELD: ref_workflow_id}
                    # check if it's either a new task or if the process doesn't exist yet
                    if not isinstance(pcs_task, Task) \
                       or not pcs_task.Processes.KeywordQuery(**args):
                        args["is_template"] = "1"
                        if template_project:
                            args["cdb_project_id"] = template_project.cdb_project_id
                            proc_src = Process.KeywordQuery(**args)
                        else:
                            proc_src = self.pcs_project.Processes.KeywordQuery(**args)
                        if not proc_src:
                            raise ue.Exception("cdbpcs_template_object_not_found", repr(args))
                        proc_src = proc_src[0]

                        if not self.dry_run:
                            # adapted from cs.workflow.briefcases.BriefcaseContent
                            #  .on_cdbwf_ahwf_new_from_template_now
                            proc_new = Process.CreateFromTemplate(proc_src.cdb_process_id,
                                                                  {"subject_id": auth.persno,
                                                                   "subject_type": "Person"})
                            proc_new.make_attachments_briefcase()
                            BriefcaseContent.setup_ahwf(proc_new, [pcs_task])
                        else:
                            # bogus preview object
                            proc_new = {
                                "cdb_project_id": self.pcs_project.cdb_project_id,
                                "is_template": "0",
                            }
                            for k, v in proc_src.items():
                                proc_new.setdefault(k, v)

                        icon_name = msp_misc.get_icon_name(proc_src.cdb_classname)
                        self.result.add_diff_object(DiffType.ADDED, proc_new, Process, icon_name,
                                                    parent=pcs_task)
                except Exception as ex:
                    misc.log_traceback("")
                    self.result.add_diff_object(DiffType.MODIFIED, pcs_task, Task, exception=ex)
