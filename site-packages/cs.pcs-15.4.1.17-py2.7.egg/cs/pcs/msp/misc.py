#!/usr/bin/env powerscript
# -*- python -*- coding: UTF-8 -*-
#
# Copyright (C) 2017 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

from __future__ import unicode_literals

from datetime import datetime
import hashlib
import inspect
import json

from cdb import CADDOK, misc, ue
from cdb.objects import Object
from cdb.objects.operations import operation, system_args
from cdb.platform.mom.entities import Entity
from cdb.platform.mom.fields import DDCharField, DDDateField, DDFloatField, DDIntegerField, \
    DDPredefinedField

__docformat__ = "restructuredtext en"
__revision__ = "$Id: misc.py 180181 2018-07-06 21:41:52Z kbu $"


MSP_XML_SCHEMA = "http://schemas.microsoft.com/project"
MSP_XML_DATETIME_FORMAT = "%Y-%m-%dT%H:%M:%S"

DEFAULT_START_HOUR = 8
DEFAULT_FINISH_HOUR = 17

REF_OBJECTS_SEPARATOR = ";;"
REF_OBJECT_TOKENS_SEPARATOR = "::"
REF_PROJECT_ID_FIELD = "project_name"
REF_CHECKLIST_ID_FIELD = "checklist_name"
REF_WORKFLOW_ID_FIELD = "title"

DD_FIELD_CACHE = {}


def log(msg, log_level=7, traceback=False):
    caller = inspect.stack()[1][0]
    caller_name = caller.f_code.co_name
    if "self" in caller.f_locals:
        caller_name = "%s.%s" % (caller.f_locals["self"].__class__.__name__, caller_name)
    elif "cls" in caller.f_locals:
        caller_name = "%s.%s" % (caller.f_locals["cls"].__name__, caller_name)
    msg = "cs.pcs.msp.%s: %s" % (caller_name, msg)
    if log_level:
        misc.log(log_level, msg)
    else:
        if traceback:
            misc.log_traceback("cs.pcs.msp")
        misc.log_error(msg)


def get_classname(obj_or_cls_or_clsname):
    if isinstance(obj_or_cls_or_clsname, Object):
        return obj_or_cls_or_clsname.GetClassname()
    elif isinstance(obj_or_cls_or_clsname, type):
        return getattr(obj_or_cls_or_clsname, "__classname__", None) \
            or getattr(obj_or_cls_or_clsname, "__maps_to__")
    return obj_or_cls_or_clsname


def get_icon_name(clsname):
    supported_icons = {
        "cdbpcs_project": "cdbpcs_project",
        "cdbpcs_task": "cdbpcs_task",
        "cdbpcs_taskrel": "cdbpcs_taskrelation",
        "cdbpcs_checklist": "cdbpcs_checklist",
        "cdbpcs_deliverable": "cdbpcs_deliverable",
        "cdbpcs_qualitygate": "cdbpcs_qualitygate",
        "cdbwf_process": "cdbwf_process_class",
        }
    return supported_icons.get(clsname, "")


def get_dd_field(classname, attr):
    """Returns (and caches) the data dictionary type of a PCS field."""
    cached_classname = DD_FIELD_CACHE.setdefault(classname, {})
    if "entity" not in cached_classname:
        cached_classname["entity"] = Entity.ByKeys(classname)
    cached_attributes = cached_classname.setdefault("attributes", {})
    if attr not in cached_attributes:
        cached_attributes[attr] = cached_classname["entity"].getField(attr)
    return cached_attributes[attr]


def get_value_diff(pcs_object, pcs_attr, msp_value):
    pcs_value = getattr(pcs_object, pcs_attr, None)
    classname = get_classname(pcs_object)
    dd_field = _dd_field = get_dd_field(classname, pcs_attr)
    if isinstance(dd_field, DDPredefinedField):
        dd_field = dd_field.ReferencedField
    if isinstance(dd_field, DDCharField):
        if pcs_value is None:
            pcs_value = ""
    elif isinstance(dd_field, DDDateField):
        if pcs_value:
            pcs_value = to_locale_date(pcs_value)
        if msp_value:
            msp_value = to_locale_date(msp_value)
    if isinstance(dd_field, (DDFloatField, DDIntegerField)):
        if pcs_value is None:
            pcs_value = 0
    if pcs_value != msp_value:
        return {
            "label": _dd_field.getLabel(),
            "old_value": pcs_value,
            "new_value": msp_value,
        }
    else:
        return None


def operation_ex(name, target, kwargs=None, called_from_officelink=False):
    """Set special operation context arguments"""
    kwargs = kwargs or {}
    sys_args = {"batch_mode": True}
    if called_from_officelink:
        sys_args["active_integration"] = "OfficeLink"
    return operation(name, target, system_args(**sys_args), **kwargs)


def to_locale_date(date):
    from babel.dates import format_date
    return format_date(date, format="short", locale=CADDOK.ISOLANG)


class MspToPcs(object):

    TaskLinkType = {
        0: "EE",  # pjFinishToFinish
        1: "EA",  # pjFinishToStart
        2: "AE",  # pjStartToFinish
        3: "AA",  # pjStartToStart
        }

    @staticmethod
    def convert_value(pcs_obj_or_cls, pcs_attr, msp_value):
        """Takes an MSP task value (string) and automatically typecasts it for the PCS field."""
        classname = get_classname(pcs_obj_or_cls)
        dd_field = get_dd_field(classname, pcs_attr)
        if isinstance(dd_field, DDPredefinedField):
            dd_field = dd_field.ReferencedField
        if isinstance(dd_field, DDCharField):
            return msp_value[0:dd_field.data_length].rstrip()
        elif isinstance(dd_field, DDDateField):
            return datetime.strptime(msp_value, MSP_XML_DATETIME_FORMAT).date() \
                if msp_value else None
        elif isinstance(dd_field, DDFloatField):
            return float(msp_value) if msp_value else 0
        elif isinstance(dd_field, DDIntegerField):
            return int(msp_value) if msp_value else 0
        raise ue.Exception("The field type for '%s.%s' is not supported yet"
                           % (classname, pcs_attr))  # i18n


class PcsToMsp(object):

    TaskLinkType = {
        "EE": 0,  # pjFinishToFinish
        "EA": 1,  # pjFinishToStart
        "AE": 2,  # pjStartToFinish
        "AA": 3,  # pjStartToStart
        }

    ExtendedAttributes = {
        "Number1": 188743767, "Number2": 188743768, "Number3": 188743769, "Number4": 188743770,
        "Number5": 188743771, "Number6": 188743982, "Number7": 188743983, "Number8": 188743984,
        "Number9": 188743985, "Number10": 188743986, "Number11": 188743987, "Number12": 188743988,
        "Number13": 188743989, "Number14": 188743990, "Number15": 188743991, "Number16": 188743992,
        "Number17": 188743993, "Number18": 188743994, "Number19": 188743995, "Number20": 188743996,
        "Text1": 188743731, "Text2": 188743734, "Text3": 188743737, "Text4": 188743740,
        "Text5": 188743743, "Text6": 188743746, "Text7": 188743747, "Text8": 188743748,
        "Text9": 188743749, "Text10": 188743750, "Text11": 188743997, "Text12": 188743998,
        "Text13": 188743999, "Text14": 188744000, "Text15": 188744001, "Text16": 188744002,
        "Text17": 188744003, "Text18": 188744004, "Text19": 188744005, "Text20": 188744006,
        "Text21": 188744007, "Text22": 188744008, "Text23": 188744009, "Text24": 188744010,
        "Text25": 188744011, "Text26": 188744012, "Text27": 188744013, "Text28": 188744014,
        "Text29": 188744015, "Text30": 188744016,
        }


class KeyObject(object):
    """Hashable dictionary like container class"""

    def __init__(self, *args, **kwargs):
        if args and len(args) and isinstance(args[0], Object):
            self._dict = args[0].KeyDict()
        else:
            self._dict = dict(*args, **kwargs)

    def __setitem__(self, key, value):
        self._dict[key] = value

    def __setattr__(self, name, value):
        if name == "_dict":
            object.__setattr__(self, name, value)
        else:
            self._dict[name] = value

    def __getitem__(self, key):
        try:
            return object.__getitem__(self, key)
        except AttributeError:
            return self._dict[key]

    def __getattribute__(self, name):
        try:
            return object.__getattribute__(self, name)
        except AttributeError:
            return self._dict[name]

    def __delitem__(self, key):
        del self._dict[key]

    def __contains__(self, key):
        return key in self._dict

    def __len__(self):
        return len(self._dict)

    def __iter__(self):
        return iter(self._dict)

    def __repr__(self):
        return self._dict.__repr__()

    def __str__(self):
        return self._dict.__str__()

    def __hash__(self):
        _hash = json.dumps(self._dict, default=str, sort_keys=True)
        _hash = hashlib.sha1(_hash).hexdigest()
        _hash = int(_hash, 16) % (10 ** 8)
        return _hash

    def __eq__(self, other):
        return self.__hash__() == other.__hash__()

    def get(self, key, default=None):
        return self._dict.get(key, default)

    def update(self, *args, **kwargs):
        self._dict.update(dict(*args, **kwargs))

    def setdefault(self, key, default=None):
        return self._dict.setdefault(key, default)

    def keys(self):
        return self._dict.keys()

    def items(self):
        return self._dict.items()

    def values(self):
        return self._dict.values()
