#!/usr/bin/env python
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
# CDB:Browse
# pylint: disable-msg=R0201,R0902,R0903,R0904,E0213,E0203,E0102,W0201,W0212,W0142,W0621

__docformat__ = "restructuredtext en"
__revision__ = "$Id: checklist_status.py 166847 2017-10-18 07:09:48Z via $"

from cdb import util
from cdb.objects import State
from cdb.objects import Transition
from cdb.classbody import classbody
from cs.pcs.checklists import Checklist
from cs.pcs.checklists import ChecklistItem


@classbody
class Checklist(object):
    @classmethod
    def endStatus(cls, full_cls=True):
        """
        returns set of "final" status classes (full_cls True) or integer values
        (full_cls False) and cache them for subsequent access
        """
        if not hasattr(cls, "__end_status_cls__"):
            cls.__end_status_cls__ = set([cls.DISCARDED, cls.COMPLETED])
            cls.__end_status_int__ = set(
                [x.status for x in cls.__end_status_cls__])
        if full_cls:
            return cls.__end_status_cls__
        return cls.__end_status_int__

    class NEW(State):
        status = 0

        def Constraints(state, self):
            from cs.pcs.projects.tasks import Task
            return [("MatchStateList", [[self.Task], [Task.NEW, Task.READY, Task.EXECUTION], "pcscl_wf_rej_2"])]

        def post(state, self, ctx):
            self.Update(rating="", rating_id="")
            self.resetItems()

    class EVALUATION(State):
        status = 20

        def Constraints(state, self):
            from cs.pcs.projects import Project
            from cs.pcs.projects.tasks import Task
            return [
                ("MatchStateList", [[self.Project], [Project.EXECUTION], "pcscl_wf_rej_3"]),
                ("MatchStateList", [[self.Task], [Task.READY, Task.EXECUTION, Task.DISCARDED], "pcscl_wf_rej_2"])
                ]

        def FollowUpStateChanges(state, self):
            from cs.pcs.projects.tasks import Task
            if self.Task and self.Task.status == Task.NEW.status:
                self.Task.ChangeState(Task.READY.status, check_access=0)
            return [(Task.EXECUTION, [task for task in [self.Task] if task and task.status == Task.READY.status], 0, 0)]

    class DISCARDED(State):
        status = 180

        def FollowUpStateChanges(state, self):
            if self.Task:
                target_status = self.Task.getFinalStatus()
                if target_status:
                    return [(target_status, [self.Task], 0, 0)]
            return []

        def post(state, self, ctx):
            self.cancelItems()

    class COMPLETED(State):
        status = 200

        def Constraints(state, self):
            from cs.pcs.projects.tasks import Task

            constraints = [
                ("MatchStateList", [self.ChecklistItems, [ChecklistItem.COMPLETED], "pcscl_wf_rej_0"]),
                ("MatchStateList", [[self.Task], [Task.READY, Task.EXECUTION], "pcscl_wf_rej_0"]),
                ]
            # Bei Deliverables pr√ºfen, ob die zu erstellenden Objekte existieren
            if self.type == "Deliverable":
                constraints.append(("matchRules", [self.Collection]))
            return constraints

        def FollowUpStateChanges(state, self):
            if self.Task:
                target_status = self.Task.getFinalStatus()
                if target_status:
                    return [(target_status, [self.Task], 0, 0)]
            return []

        def post(state, self, ctx):
            # Bewertung aktualisieren
            self.setRating(True)

    class COMPLETED_TO_EVALUATION(Transition):
        transition = (200, 20)

        def Constraints(state, self):
            """ Der uebergeordnete Checkpunkt darf nicht bewertet sein (sofern vorhanden) """
            return [("MatchStateList", [[self.ParentChecklistItem], [ChecklistItem.NEW, ChecklistItem.READY], "pcscl_wf_rej_1"])]

    class NEW_TO_EVALUATION(Transition):
        transition = (0, 20)

        def post(transition, self, ctx):
            self.setItemsWaiting()

    class DISCARDED_TO_EVALUATION(Transition):
        transition = (180, 20)

        def post(transition, self, ctx):
            self.setItemsWaiting()

    class ALL_WF_STEPS(Transition):
        transition = ('*', '*')

        def post(transition, self, ctx):
            self._mirrorState()

    def matchRules(self, objects):
        # Constraint checker for deliverables.
        # Matches assigned rules against a list of given objects.
        # At least one object must match for each rule.
        msg = ""
        not_matching_rules = []
        for ref in self.RuleReferences:
            rule = ref.Rule
            found = False
            for o in objects:
                if o.MatchRule(rule):
                    found = True
                    break
            if not found:
                not_matching_rules.append(rule)
        if not_matching_rules:
            from cdb.platform import gui
            msg = "%s\n - " % (gui.Message.GetMessage("pcs_deliv_mismatch"))
            msg += "\n - ".join(map(lambda r: r.name, not_matching_rules))
        return msg


@classbody
class ChecklistItem(object):
    def prevent_interactive_status_change(self, ctx):
        if not getattr(ctx, "batch", 0) == 1:
            raise util.ErrorMessage("workflow_no_auth")

    class NEW(State):
        status = 0

        def pre_mask(state, self, ctx):
            self.prevent_interactive_status_change(ctx)

    class READY(State):
        status = 20

        def pre_mask(state, self, ctx):
            self.prevent_interactive_status_change(ctx)

    class COMPLETED(State):
        status = 200

        def pre_mask(state, self, ctx):
            self.prevent_interactive_status_change(ctx)

        def post(state, self, ctx):
            if not ctx.error:
                # ggf. Checkliste bewerten
                cl = self.Checklist
                if cl.auto and cl.GetState(Checklist.COMPLETED.status).EvalConstraints(cl, False)[0]:
                    self.Checklist.ChangeState(Checklist.COMPLETED, check_access=0)

    class DISCARDED(State):
        status = 180

        def pre_mask(state, self, ctx):
            self.prevent_interactive_status_change(ctx)

    class COMPLETED_TO_READY(Transition):
        transition = (200, 20)

        def post(state, self, ctx):
            if not ctx.error:
                self.Update(rating="", rating_id="")
