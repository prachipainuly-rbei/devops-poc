#!/usr/bin/env python
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 1990 - 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
# CDB:Browse
# pylint: disable-msg=R0201,R0902,R0903,R0904,E0213,E0203,E0102,W0201,W0212,W0142,W0621

__docformat__ = "restructuredtext en"
__revision__ = "$Id: __init__.py 179011 2018-06-15 06:40:47Z umu $"

from cdb import sqlapi, auth, ue, ddl, util, cdbtime
from cdb.classbody import classbody
from cdb import sig
from cdb import misc

from cdb.constants import kOperationDelete
from cdb.fls import allocate_license
from cdb import transactions
from cdb import ElementsError

from cdb.objects import Reference
from cdb.objects import N
from cdb.objects import Forward
from cdb.objects import Object
from cdb.objects import LocalizedField
from cdb.objects.org import WithSubject
from cdb.objects.operations import operation

from cdb.platform import olc
from cdb.platform import gui
from cdb.objects.common import WithObjectCollection, WithStateChangeNotification
from cdb.platform.mom.entities import Entity

from cs.pcs.checklists.tasks_plugin import ChecklistWithCsTasks
from cs.pcs.checklists.tasks_plugin import ChecklistItemWithCsTasks
from cs.pcs.issues import WithFrozen
from cs.pcs.projects.tasks import Task
from cs.sharing.share_objects import WithSharing

__all__ = ['Checklist', 'ChecklistItem', 'RatingValue', 'RatingSchema',
           'RedGreenYellowRating', 'GermanSchoolmarksRating',
           'ChecklistType', 'RuleReference']

# Forward declarations
Project = Forward("cs.pcs.projects.Project")
fChecklist = Forward("cs.pcs.checklists.Checklist")
ChecklistItem = Forward("cs.pcs.checklists.ChecklistItem")
ChecklistType = Forward("cs.pcs.checklists.ChecklistType")
fRatingSchema = Forward("cs.pcs.checklists.RatingSchema")
fRatingValue = Forward("cs.pcs.checklists.RatingValue")

fRuleReference = Forward(__name__ + ".RuleReference")
fRule = Forward("cdb.objects.Rule")


class Checklist(WithSubject, WithObjectCollection, WithSharing, WithFrozen, ChecklistWithCsTasks):
    __maps_to__ = "cdbpcs_checklst"
    __classname__ = "cdbpcs_checklist"

    Project = Reference(1, Project, fChecklist.cdb_project_id)
    ChecklistItems = Reference(N, ChecklistItem,
                               ChecklistItem.cdb_project_id == fChecklist.cdb_project_id,
                               ChecklistItem.checklist_id == fChecklist.checklist_id,
                               order_by='position')
    ParentChecklistItem = Reference(1, ChecklistItem, fChecklist.parent_cl_item_id, fChecklist.parent_checkl_id, fChecklist.cdb_project_id)
    RatingSchema = Reference(1, fRatingSchema, fChecklist.rating_scheme)
    TypeDefinition = Reference(1, ChecklistType, fChecklist.type)

    Task = Reference(1, Task, fChecklist.cdb_project_id, fChecklist.task_id)

    RuleReferences = Reference(N, fRuleReference,
                               fRuleReference.cdb_project_id == fChecklist.cdb_project_id,
                               fRuleReference.checklist_id == fChecklist.checklist_id
                               )

    Rating = Reference(1, fRatingValue, fChecklist.rating_scheme, fChecklist.rating_id)

    # Methods to attach/detach the Checklist to a Checkpoint as Subchecklist
    def detachFromCheckpoint(self):
        self.parent_checkl_id = 0
        self.parent_cl_item_id = 0

    def attachToCheckpoint(self, cl_item):
        self.parent_checkl_id = cl_item.checklist_id
        self.parent_cl_item_id = cl_item.cl_item_id

    def updateParentCheckpoint(self, ctx=None):
        if ctx and ctx.error:
            return
        # Flag has_sub_cl des übergeordneten Checkpunkts aktualisieren.
        if self.ParentChecklistItem:
            self.ParentChecklistItem.updateSubChecklistsFlag()

    # Methods to handle checklist rating
    def calcRating(self, cdb_project_id, checklist_id, cl_item_id=None):
        for cl_item in self.ChecklistItems:
            if self.RatingSchema.calcRating(cl_item.rating_id, cl_item.weight, cl_item.ko_criterion,
                                            cl_item.cdb_project_id, cl_item.checklist_id, cl_item.cl_item_id) == -1:
                break
        result = self.RatingSchema.getResult()
        if not result:
            return ""
        return result

    def setRating(self, force=False):
        if not force and self.status == Checklist.COMPLETED.status:
            return
        rating_id = self.calcRating(self.cdb_project_id, self.checklist_id, None)
        self.Update(rating_id=rating_id)

        # ggf. Bewertung für übergeordneten Prüfpunkt setzen
        if self.status == Checklist.COMPLETED.status and self.ParentChecklistItem:
            rating_result = self.ParentChecklistItem.calcRating(self.ParentChecklistItem.cdb_project_id,
                                                                self.ParentChecklistItem.checklist_id,
                                                                self.ParentChecklistItem.cl_item_id)
            if rating_result:
                self.ParentChecklistItem.rating_id = rating_result

    # Checkpoint related methods
    def allItemsChecked(self):
        """ Returns True, if all checkpoints have been rated """
        return len(self.ChecklistItems.Query(ChecklistItem.status != self.TypeDefinition.rating_state)) == 0

    def noItemChecked(self):
        """ Returns True, if no checkpoint is rated """
        return len(self.ChecklistItems.Query(ChecklistItem.status == self.TypeDefinition.rating_state)) == 0

    def hasSubChecklists(self):
        """ Returns True, if at least one checkpoint has a subchecklist """
        return len(self.ChecklistItems.Query(ChecklistItem.has_sub_cl == 1)) > 0

    # Utils for copying and resetting checklists
    def Reset(self):
        self.Update(rating_id="",
                    evaluator="",
                    status=Checklist.NEW.status,
                    cdb_status_txt=olc.StateDefinition.ByKeys(Checklist.NEW.status, self.cdb_objektart).StateText[''])
        self.resetItems()

    def resetItems(self):
        for cl_item in self.ChecklistItems:
            cl_item.Reset()
            # reset subchecklists
            for sub_cl in cl_item.SubChecklists:
                sub_cl.Reset()

    def setItemsWaiting(self):
        for ci in self.ChecklistItems:
            ci.ChangeState(ChecklistItem.READY.status)
        self.ChecklistItems.Update(checklist_state=self.status)

    def cancelItems(self):
        items = self.ChecklistItems.Query(ChecklistItem.status != ChecklistItem.COMPLETED.status)
        items.Update(status=ChecklistItem.DISCARDED.status,
                     cdb_status_txt=olc.StateDefinition.ByKeys(ChecklistItem.DISCARDED.status,
                                                               self.TypeDefinition.cli_objektart).StateText[''],
                     checklist_state=self.status)

    def MakeCopy(self, project, assign_to=None, templates_only=False):
        self.checkLicense()
        if templates_only and not self.template:
            return None

        args = {"cdb_project_id": project.cdb_project_id,
                "checklist_id": util.nextval("cdbpcs_checklist"),
                }
        args.update(Checklist.MakeChangeControlAttributes())

        item_args = args
        if assign_to:
            args.update(assign_to.KeyDict())

        new_cl = self.Copy(**args)
        # Langtext mit Beschreibung kopieren
        new_cl.SetText("cdbpcs_cl_txt", self.GetText("cdbpcs_cl_txt"))
        new_cl.SetText("cdbpcs_clr_txt", self.GetText("cdbpcs_clr_txt"))
        # Checkpunkte kopieren
        curr_cl_item_id = 0
        for cl_item in self.ChecklistItems:
            curr_cl_item_id += 1
            item_args["cl_item_id"] = curr_cl_item_id
            new_cl_item = cl_item.Copy(**item_args)
            # Langtext mit Beschreibung kopieren
            new_cl_item.SetText("cdbpcs_cli_txt", cl_item.GetText("cdbpcs_cli_txt"))
            new_cl_item.SetText("cdbpcs_clir_txt", cl_item.GetText("cdbpcs_clir_txt"))
            # Wenn dem Prüfpunkt weitere Checklisten zugeordnet sind, diese auch kopieren
            for sub_cl in cl_item.SubChecklists:
                new_sub_cl = sub_cl.MakeCopy(project=project, templates_only=templates_only)
                if new_sub_cl:
                    new_sub_cl.attachToCheckpoint(new_cl_item)
            cli_docref = ddl.Table("cdbpcs_cli2doctmpl")
            if cli_docref.exists():
                for r in cl_item.TemplateDocRefs:
                    values = new_cl_item.KeyDict()
                    values["created_at"] = None
                    r.Copy(**values)

        # Referenzen auf Dokumentenvorlagen kopieren
        t = ddl.Table("cdbpcs_cl2doctmpl")
        if t.exists():
            for r in self.TemplateDocRefs:
                values = new_cl.KeyDict()
                values["created_at"] = None
                r.Copy(**values)
        # Bei Deliverables Regeln für zu erstellende Arbeitsgegenstände kopieren
        if self.type == "Deliverable":
            for rule in self.RuleReferences:
                rule.Copy(**new_cl.KeyDict())
        return new_cl

    def ForceDelete(self):
        self.Reset()
        for clit in self.ChecklistItems:
            if clit.SubChecklists:
                for cl in clit.SubChecklists:
                    cl.ForceDelete()
            operation(kOperationDelete, clit)
        operation(kOperationDelete, self)

    # Workflow Implementation
    def _mirrorState(self):
        # Den Status der Checkliste in die Stammdaten der Prüfpunkte übernehmen  (cdbpcs_cl_item.checklist_state).
        # Auf dem gespiegelten Status stützt sich das Rechtesystem ab.
        self.ChecklistItems.Update(checklist_state=self.status)

    # Event Map Implementations
    def setChecklistID(self, ctx):
        self.checklist_id = util.nextval("cdbpcs_checklist")
        if not self.checklist_id:
            self.checklist_id = util.nextval("cdbpcs_checklist")

    def checkState(self, ctx):
        if (self.task_id != getattr(ctx.object, "task_id", self.task_id)
                and self.status != self.NEW.status):
            raise ue.Exception("pcs_err_cl_move")
        if self.Task and self.Task.status in self.Task.endStatus(False):
            raise ue.Exception("cdbpcs_err_task_checklist", self.Task.task_name)
        if self.Project and self.Project.status in self.Project.endStatus(False):
            raise ue.Exception("cdbpcs_err_project_checklist", self.Project.project_name)

    # Event Handler Implementations
    def on_create_pre_mask(self, ctx):
        if not self.division:
            self.division = auth.get_department()
        if self.Project:
            ctx.set("project_name", self.Project.project_name)
            # Bei Neuanlage im Kontext eines Checkpunktes weitere Attribute der übergeordneten Checkliste übernehmen
            if ctx.relationship_name == 'cdbpcs_cl_item2checklist':
                parent_cl = Checklist.ByKeys(ctx.parent.cdb_project_id, ctx.parent.checklist_id)
                self.template = parent_cl.template
                self.rating_scheme = parent_cl.rating_scheme
                self.type = parent_cl.type
                ctx.set_readonly("template")
        else:
            # ggf. Übernahme Projektbezug vom Parent Objekt
            if ctx.relationship_name in ['cdbpcs_doc2topchecklists', 'cdbpcs_model2topchecklists']:
                self._preset_project_from_doc(ctx)
            elif ctx.relationship_name == 'cdbpcs_part2topchecklists':
                self._preset_project_from_item(ctx)
            if self.cdb_project_id:
                ctx.set("project_name", Project.ByKeys(self.cdb_project_id).project_name)
        if not self.Project:
            self.subject_id = auth.persno
            self.subject_type = "Person"

        if ctx.dragged_obj:
            self.type = ctx.dragged_obj.type
            self.rating_scheme = ctx.dragged_obj.rating_scheme
            self.subject_id = ctx.dragged_obj.subject_id
            self.subject_type = ctx.dragged_obj.subject_type
            self.auto = ctx.dragged_obj.auto
            self.rating_id = ""

    def on_copy_pre_mask(self, ctx):
        self.checklist_id = ""
        self.rating_id = ""
        self.type = ctx.object.type
        self.subject_id = ctx.object.subject_id
        self.subject_type = ctx.object.subject_type
        self.detachFromCheckpoint()

    def on_relship_copy_post(self, ctx):
        # Prüfpunkte zurücksetzen
        if ctx.relationship_name == "cdbpcs_checklist2cl_items":
            for cl_item in self.ChecklistItems:
                cl_item.has_sub_cl = 0
                cl_item.Reset()

    def on_cdb_show_responsible_now(self, ctx):
        return self.openSubject()

    def on_delete_pre(self, ctx):
        # Checklisten dürfen nur gelöscht werden, wenn die zugehörigen
        # Prüfpunkte keine Unterchecklisten haben
        if self.hasSubChecklists():
            raise ue.Exception("pcs_err_del_cl1")

    def on_delete_post(self, ctx):
        if ctx.error != 0:
            return
        # Dokumentzuordnungen und Statusprotokoll der mitgelöschten Prüfpunkte löschen
        rels = ["cdbpcs_cli_prot", "cdbpcs_doc2cli"]
        for rel in rels:
            sqlapi.SQLdelete("FROM %s WHERE cdb_project_id = '%s' AND checklist_id = '%s'"
                             % (rel, self.cdb_project_id, self.checklist_id))

    def GetDisplayAttributes(self):
        """This method creates and returns a results dictionary, containing the
        necessary information for the html display in the client."""
        results = self.Super(Checklist).GetDisplayAttributes()
        results[u"attrs"].update({u"heading": self["category"]})
        return results

    def copyDraggedChecklists(self, ctx):
        if ctx.dragged_obj:
            dragObj = Checklist.ByKeys(ctx.dragged_obj.cdb_project_id, ctx.dragged_obj.checklist_id)
            for checklistItem in dragObj.ChecklistItems:
                new_cli = checklistItem.Copy(cdb_project_id=self.cdb_project_id,
                                             checklist_id=self.checklist_id,
                                             has_sub_cl=0,
                                             cdb_cpersno=auth.persno,
                                             cdb_cdate=cdbtime.now("%d.%m.%Y %H:%M:%S"),
                                             cdb_mpersno=auth.persno,
                                             cdb_mdate=cdbtime.now("%d.%m.%Y %H:%M:%S"))
                new_cli.Reset()
                # Langtext mit Beschreibung kopieren
                new_cli.SetText("cdbpcs_cli_txt", checklistItem.GetText("cdbpcs_cli_txt"))
                new_cli.SetText("cdbpcs_clir_txt", checklistItem.GetText("cdbpcs_clir_txt"))

                t = ddl.Table("cdbpcs_cli2doctmpl")
                if t.exists():
                    for r in checklistItem.TemplateDocRefs:
                        r.Copy(**self.KeyDict())

            t = ddl.Table("cdbpcs_cl2doctmpl")
            if t.exists():
                for r in dragObj.TemplateDocRefs:
                    r.Copy(**self.KeyDict())

    @classmethod
    def cdbpcs_checklist_assign(cls, obj, ctx):
        template_cl = cls.ByKeys(ctx.dialog.t_cdb_project_id,
                                 ctx.dialog.checklist_id)
        template_cl.checkLicense()
        if "cdb_t_project_id" in ctx.dialog.get_attribute_names():
            project = Project.ByKeys(ctx.dialog.cdb_t_project_id)
        else:
            project = Project.ByKeys(ctx.dialog.cdb_project_id)
        new_checklist = template_cl.MakeCopy(project, obj, False)
        new_checklist.template = 0
        new_checklist.Reset()
        new_checklist.detachFromCheckpoint()
        ctx.url(new_checklist.MakeURL("cdbpcs_checklist"))
        return (project.cdb_project_id, new_checklist.checklist_id)

    def checkLicense(self, ctx=None):
        if self.type == "QualityGate":
            allocate_license("CHECKLISTS_006")
        elif self.type == "Deliverable":
            allocate_license("CHECKLISTS_007")

    def setEvaluator(self, ctx):
        persno = u""
        if self.status in (180, 200):
            persno = self.cdb_mpersno
        self.Update(evaluator=persno)

    def check_project_role_needed(self, ctx):
        self.Project.check_project_role_needed(ctx)

    event_map = {
        (('create', 'modify', 'copy', 'delete', 'wf_step'), 'pre'): ("checkLicense"),
        (('create'), 'pre_mask'): ("checkState"),
        (('copy'), 'pre_mask'): ("checkState"),
        (('create', 'copy'), 'pre'): ("setChecklistID"),
        (('modify'), 'pre_mask'): ("checkState"),
        (('create', 'copy'), 'post_mask'): "checkState",
        (('create'), 'post'): ("updateParentCheckpoint", "copyDraggedChecklists",
                               "check_project_role_needed"),
        (('copy', 'delete'), 'post'): ("updateParentCheckpoint", "check_project_role_needed"),
        (('modify', 'state_change'), 'post'): ("setEvaluator", "check_project_role_needed"),
        }


class ChecklistItem(WithSubject, WithStateChangeNotification, WithSharing, WithFrozen, ChecklistItemWithCsTasks):
    __maps_to__ = "cdbpcs_cl_item"
    __classname__ = "cdbpcs_cl_item"

    Project = Reference(1, Project, ChecklistItem.cdb_project_id)
    RatingSchema = Reference(1, fRatingSchema, ChecklistItem.rating_scheme)
    Rating = Reference(1, fRatingValue,
                       fRatingValue.name == ChecklistItem.rating_scheme,
                       fRatingValue.rating_id == ChecklistItem.rating_id)
    SubChecklists = Reference(N, fChecklist,
                              fChecklist.cdb_project_id == ChecklistItem.cdb_project_id,
                              fChecklist.parent_checkl_id == ChecklistItem.checklist_id,
                              fChecklist.parent_cl_item_id == ChecklistItem.cl_item_id)
    Checklist = Reference(1, fChecklist, ChecklistItem.cdb_project_id, ChecklistItem.checklist_id)

    def calcRating(self, cdb_project_id, checklist_id, cl_item_id=None):
        weight = 1  # Unterchecklisten haben immer die Gewichtung 1
        ko_criterion = 0  # Unterchecklisten können kein k.o. Kriterium sein
        for cl in self.SubChecklists:
            if cl.RatingSchema.name != self.RatingSchema.name or cl.status == Checklist.COMPLETED.status:
                # Checkpunkt ist nicht automatisch bewertbar, weil
                # die Unterchecklisten ein anderes Bewertungsschema haben
                # oder noch nicht alle Unterchecklisten bewertet sind.
                return None
            if self.RatingSchema.calcRating(cl["rating_id"], weight, ko_criterion,
                                            self.cdb_project_id, self.checklist_id, self.cl_item_id) == -1:
                break
        return self.RatingSchema.getResult()

    def clearRating(self):
        if self.status == ChecklistItem.COMPLETED.status:
            self.ChangeState(ChecklistItem.READY.status)

    def tryRating(self, rating_id, update_cl_rating=True, rating_remark=''):
        if not self.setRating(rating_id, update_cl_rating, rating_remark):
            return self.criterion + " (" + u"%s" % self.cl_item_id + ")\n"
        return ""

    def setRating(self, rating_id, update_cl_rating=True, rating_remark=''):
        if self.subChecklistsRated():
            if rating_id == "clear":
                self.clearRating()
                # checklist rating can change when a checklist item's rating becomes 'clear'
                if update_cl_rating:
                    self.Checklist.setRating()
                return True
            self.Update(rating_id=rating_id)
            if rating_remark is not None:
                self.SetText('cdbpcs_clir_txt', rating_remark)
            # Statuswechsel in den Bewertungsstatus
            rating_state = self.Checklist.TypeDefinition.rating_state
            if self.status != rating_state:
                try:
                    self.ChangeState(rating_state)
                except ElementsError, error:
                    misc.cdblogv(misc.kLogErr, 0, "Checklist Item {}: {} (from {} to {})".format(
                        self.GetDescription(),
                        error.message,
                        self.status,
                        rating_state))
                    raise ue.Exception('pcscl_wf_rej_5', self.GetDescription(), error.message)
            if update_cl_rating:
                self.Checklist.setRating()
            return True
        return False

    def Reset(self):
        self.Update(rating_id="",
                    evaluator="",
                    status=ChecklistItem.NEW.status,
                    cdb_status_txt=olc.StateDefinition.ByKeys(ChecklistItem.NEW.status, self.cdb_objektart).StateText[''],
                    checklist_state=self.Checklist.status)

    def subChecklistsRated(self):
        for cl in self.SubChecklists:
            if cl.status != Checklist.COMPLETED.status and \
                cl.status != Checklist.DISCARDED.status:
                return False
        return True

    def updateSubChecklistsFlag(self):
        if self.SubChecklists:
            self.has_sub_cl = 1
        else:
            self.has_sub_cl = 0

    def setID(self, ctx):
        self.cl_item_id = util.nextval("cdbpcs_cl_item")

    def setPosition(self, ctx):
        cl_list = self.Checklist.ChecklistItems
        max_pos = 0
        for cl_item in cl_list:
            pos = cl_item.position
            if pos > max_pos:
                max_pos = pos
        self.position = max_pos + 10

    def on_create_pre_mask(self, ctx):
        # Attribute der Checkliste übernehmen
        attrs = ["subject_id", "subject_type", "division", "target_date", "rating_scheme",
                 "type", "category"]
        for attr in attrs:
            if self.Checklist[attr]:
                self[attr] = self.Checklist[attr]
        ctx.set("template", self.Checklist["template"])
        self.checklist_state = self.Checklist.status
        # Workflow für den Checkpunkt laut Konfiguration in Relation cdbpcs_cl_types setzen.
        self.cdb_objektart = self.Checklist.TypeDefinition.cli_objektart

    def on_copy_pre_mask(self, ctx):
        self.cl_item_id = ""
        self.Reset()

    def on_delete_pre(self, ctx):
        # Prüfpunkte dürfen nur gelöscht werden, wenn es keine Unterchecklisten gibt
        if len(self.SubChecklists) > 0:
            raise ue.Exception("pcs_err_del_cli1")

    def on_modify_pre(self, ctx):
        # Bewertung nur erlauben, wenn alle Unterchecklisten bewertet oder verworfen sind (sofern vorhanden)
        if self.rating_id != ctx.object.rating_id and not self.subChecklistsRated:
            raise ue.Exception("pcs_err_cp_rating2", ctx.object["checklist_name"] + " (" + self.checklist_id + ")")

        # Bewertungsrelevante attribute geändert
        attrs = ["rating_id", "weight", "ko_criterion"]
        for attr in attrs:
            if u"%s" % self[attr] != u"%s" % ctx.object[attr]:
                ctx.keep(attr + "_changed", "1")
                if attr == "rating_id":
                    if self.rating_id in ["", "clear"]:
                        # reset
                        ctx.set("rating_id", "")
                    else:
                        # try to change Checklist status to EVALUATION
                        # Todo: E041505
                        self.change_status_of_checklist(self.Checklist.NEW, self.Checklist.EVALUATION)
                        ctx.refresh_tables(['cdbpcs_checklst'])

    def on_modify_post(self, ctx):
        self.checkLicense()
        ue_args = ctx.ue_args.get_attribute_names()
        if "rating_id_changed" in ue_args:
            if self.rating_id in ["", "clear"]:
                self.clearRating()
                ctx.refresh_tables(['cdbpcs_checklst'])
            else:
                # Be aware:
                # - operation does not call pre_mask
                # - use persistent object here to avoid NotImplementedError
                persistent_object = self.getPersistentObject()
                operation(
                    "cdbpcs_clitem_rating",
                    persistent_object,
                    rating_id=self.rating_id
                )
        if "weight_changed" in ue_args or "ko_criterion_changed" in ue_args:
            self.Checklist.setRating()
            ctx.refresh_tables(['cdbpcs_checklst'])

    def on_cdb_show_responsible_now(self, ctx):
        return self.openSubject()

    def change_status_of_checklist(self, source_status, target_status, check_access=False):
        """
        Changes the status of the assigned checklist
        If the status could not be changed, an exception is raised
        :param source_status: cdb.objects.state
        :param target_status: cdb.objects.state
        :param check_access: Boolean
        :return: True, if status has been changed
        """
        from cdb import ElementsError
        checklist = self.Checklist
        if checklist.status == source_status.status:
            try:
                checklist.ChangeState(target_status.status, check_access=check_access)
                return True
            except ElementsError, error:
                raise ue.Exception('pcscl_wf_rej_4',
                                   olc.StateDefinition.ByKeys(checklist.EVALUATION.status,
                                                              checklist.cdb_objektart).StateText[''],
                                   error.message)
        return False

    @classmethod
    def on_cdbpcs_clitem_rating_pre_mask(cls, ctx):
        if hasattr(ctx, "objects"):
            cl_items = ChecklistItem.PersistentObjectsFromContext(ctx)
            cl = cl_items[0].Checklist
        else:
            cl = Checklist.ByKeys(
                ctx.object.cdb_project_id, ctx.object.checklist_id)
        cl.checkLicense()
        ctx.set("rating_scheme", cl.rating_scheme)
        ctx.set("cdb_project_id", cl.cdb_project_id)
        ctx.set("checklist_id", cl.checklist_id)
        ctx.set("evaluator", auth.persno)

    @classmethod
    def on_cdbpcs_clitem_rating_now(cls, ctx):
        """
        If the assigned checklist is not in the required status, the status will be changed
        The rating is applied to all selected checklist items
        """
        with transactions.Transaction():
            cl_items = ChecklistItem.PersistentObjectsFromContext(ctx)
            if not cl_items:
                return
            for cli in cl_items:
                cli.evaluator = auth.persno
            # Changing the status of the assigned checklist
            first_cl_item = cl_items[0]
            cl = first_cl_item.Checklist
            # If called by modify-operation at call time post,
            # the status has already been changed by modify-operation at call time pre
            cl_status_changed = first_cl_item.change_status_of_checklist(cl.NEW, cl.EVALUATION)
            # Applying the rating to all selected checklist items
            err_string = ""
            rating_id = ctx.dialog["rating_id"]
            for cp in cl_items:
                if cl_status_changed:
                    cp.Reload()
                rating_remark = None
                if "cdbpcs_clir_txt" in ctx.dialog.get_attribute_names():
                    rating_remark = ctx.dialog['cdbpcs_clir_txt']
                err_string += cp.tryRating(rating_id,
                                           False,
                                           rating_remark=rating_remark)
                # err_string += cp.criterion + " (" + str(cp.cl_item_id) + ")\n"
            cl.setRating()
            ctx.refresh_tables(['cdbpcs_checklst', 'cdbpcs_cl_item'])
            if err_string:
                raise ue.Exception("pcs_err_cp_rating", err_string)

    @classmethod
    def on_cl_item_set_position_now(cls, ctx):
        cps_to_move = cls.PersistentObjectsFromContext(ctx)
        checklist = None
        for cp in cps_to_move:
            if not checklist:
                checklist = cp.Checklist
            if cp.Checklist != checklist:
                raise ue.Exception("cdbpcs_cli_pos")
        if not ctx.catalog_selection:
            ctx.start_selection(catalog_name="cdbpcs_cl_item_order", checklist_id=checklist.checklist_id, cdb_project_id=checklist.cdb_project_id)
        else:
            clist = fChecklist.ByKeys(checklist_id=checklist.checklist_id, cdb_project_id=checklist.cdb_project_id)
            done = False

            target_field = int(ctx.catalog_selection[0]["cl_item_id"])
            for f in clist.ChecklistItems:
                if f.cl_item_id == target_field:
                    pos = f.position
                    for mf in cps_to_move:
                        pos += 10
                        mf.position = pos
                    done = True
                elif done and f not in cps_to_move:
                    pos += 10
                    f.position = pos

    def checkState(self, ctx):
        if self.Checklist.status not in [Checklist.NEW.status, Checklist.EVALUATION.status]:
            raise ue.Exception("cdbpcs_err_checklist")
        self.Checklist.checkState(ctx)

    # == Email notification ==

    def getNotificationTitle(self, ctx=None):
        """
        :param ctx:
        :return: title of the notification mail
        :rtype: basestring
        """
        return "{} - Prüfpunkt bereit / Checklist item ready".format(
            gui.Message.GetMessage("branding_product_name")
        )

    def getNotificationTemplateName(self, ctx=None):
        """
        :param ctx:
        :return: template name of the notification mail body
        :rtype: basestring
        """
        return "cdbpcs_clitem_ready.html"

    def getNotificationReceiver(self, ctx=None):
        rcvr = {}
        if self.Subject:
            for pers in self.Subject.getPersons():
                if pers.email_notification_task():
                    tolist = rcvr.setdefault("to", [])
                    tolist.append((pers.e_mail, pers.name))
        return [rcvr]

    # == End email notification ==

    def checkLicense(self, ctx=None):
        self.Checklist.checkLicense()

    def setEvaluator(self, ctx):
        persno = u""
        if self.status in (180, 200):
            persno = self.cdb_mpersno
        self.Update(evaluator=persno)

    def check_project_role_needed(self, ctx):
        self.Project.check_project_role_needed(ctx)

    event_map = {
        (('modify', 'delete', 'wf_step'), 'pre'): ("checkLicense"),
        (('create', 'copy'), 'pre'): ("checkLicense", "setID", "setPosition"),
        (('create', 'copy', 'modify'), 'pre_mask'): "checkState",
        (('create', 'copy'), 'post_mask'): "checkState",
        (('modify', 'delete', 'state_change'), 'post'): ("setEvaluator", "check_project_role_needed"),
        (('create', 'copy'), 'post'): ("check_project_role_needed"),
        }


class RatingValue(Object):
    __maps_to__ = "cdbpcs_rat_val"

    Value = LocalizedField("rating_value")


class RatingSchema(Object):
    """
    Base class of evaluation schemes used by Checklist and Checklist Items

    Derived classes need to be specialized using the __match__ property and the getResult method similar to this:

        class OkOrNotOk(RatingSchema):

            __match__ = RatingSchema.name == 'OkOrNotOk'

            def getResult(self):
                '''
                :return: type: unicode, valid evaluation scheme value (cdbpcs_rat_val.rating_id) or empty string
                '''
                # Place your specialized code here...
                return <my_rating_id>

    The prerequisite is that the evaluation scheme has been configured and assigned to a checklist type in the database.
    To visualize the evaluation values, you must define your own icons and integrate them into the existing icon
    definitions
    """

    __maps_to__ = "cdbpcs_rat_def"
    __classname__ = "cdbpcs_rat_def"

    RatingValues = Reference(N, fRatingValue, fRatingValue.name == fRatingSchema.name)

    def calcRating(self, rating_id, weight, ko_criterion, cdb_project_id, checklist_id, cl_item_id=None):
        """
        A method of this name is currently used by default schemes. In derived classes, this method must exist but
        does not have to be used.
        :param: All parameters match the names of the class's Checklist Item (cdbpcs_cl_item) attributes.
        :return: No value is expected
        """
        pass

    def getResult(self):
        """
        This method must be customized in derived classes. This method is the only method that must exist in derived
        classes. The method provides the evaluation value of the checklist. Each evaluation scheme requires its own
        calculation algorithm to determine the evaluation value of the checklist.
        :return: type: unicode, valid evaluation scheme value (cdbpcs_rat_val.rating_id) or empty string
        """
        return ''


class RedGreenYellowRating(RatingSchema):
    __match__ = RatingSchema.name == 'RedGreenYellow'

    __result = ""
    __memory = {}
    __colors = {0: "",
                1: "gruen",
                2: "gelb",
                3: "rot"}

    def _get_rating(self, cdb_project_id, checklist_id):
        result = 0
        for k, v in self.__memory.items():
            if k[0] == cdb_project_id and k[1] == checklist_id:
                if v == self.__colors[3] and result < 3:
                    result = 3
                elif v == self.__colors[2] and result < 2:
                    result = 2
                elif v == self.__colors[1] and result < 1:
                    result = 1
        return self.__colors[result]

    def calcRating(self, rating_id, weight, ko_criterion, cdb_project_id, checklist_id, cl_item_id=None):
        # for proper icon display
        if rating_id == 'clear':
            rating_id = ''
        self.__memory[(cdb_project_id, checklist_id, cl_item_id)] = rating_id
        if rating_id == 'rot':
            self.__result = 'rot'
            return -1  # break
        else:
            self.__result = self._get_rating(cdb_project_id, checklist_id)

    def getResult(self):
        return self.__result


class GermanSchoolmarksRating(RatingSchema):
    __match__ = RatingSchema.name == 'GermanSchoolmarks'

    __rating_sum = 0
    __rating_weight_sum = 0
    __result = ""
    __memory_ratings = {}
    __memory_weights = {}

    def _get_rating(self):
        self.__rating_sum = 0
        self.__rating_weight_sum = 0
        ratings = []
        weights = []
        for v in self.__memory_ratings.itervalues():
            ratings.append(v)
        for v in self.__memory_weights.itervalues():
            weights.append(v)
        for i in range(len(ratings)):
            self.__rating_sum += ratings[i] * weights[i]
            self.__rating_weight_sum += weights[i]

    def calcRating(self, rating_id, weight, ko_criterion, cdb_project_id, checklist_id, cl_item_id=None):
        try:
            rating_id = int(rating_id)
            weight = int(weight)
        except ValueError:
            try:
                del self.__memory_ratings[(cdb_project_id, checklist_id, cl_item_id)]
                del self.__memory_weights[(cdb_project_id, checklist_id, cl_item_id)]
            except KeyError:
                pass
            return 0
        self.__memory_ratings[(cdb_project_id, checklist_id, cl_item_id)] = rating_id
        self.__memory_weights[(cdb_project_id, checklist_id, cl_item_id)] = weight

        # Checkliste wird mit 6 Bewertet, wenn mindestens ein k.o. Kriterium mit 6 bewertet ist
        if ko_criterion and rating_id == 6:
            self.__result = "6"
            return -1  # break

    def getResult(self):
        self._get_rating()
        if self.__rating_sum == 0:
            self.__result = ""
        else:
            self.__result = u"%s" % (int(round(self.__rating_sum / self.__rating_weight_sum)))
        return self.__result


def fieldExists(cls, attr):
    rat_val_fields = Entity.ByKeys(classname=cls).DDAllFields
    attr_list = []
    for t in rat_val_fields:
        attr_list.append(t.field_name)
    if not attr in attr_list:
        return False
    else:
        return True


class ChecklistType(Object):
    __maps_to__ = "cdbpcs_cl_types"


class RuleReference(Object):
    __maps_to__ = "cdbpcs_deliv2rule"
    __classname__ = "cdbpcs_deliv2rule"

    Rule = Reference(1, fRule, fRuleReference.rule_id)
    Checklist = Reference(1, fChecklist, fRuleReference.cdb_project_id, fRuleReference.checklist_id)


@classbody
class Task(object):

    @sig.connect(Task, "cdbpcs_checklist_assign", "now")
    def _assign_item_checklist(self, ctx):
        Checklist.cdbpcs_checklist_assign(self, ctx)
