/*
 * Copyright (C) 2014 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact.de/
 *
 * Revision "$Id: schedule_content.js 172556 2018-01-30 13:13:52Z heg $"
 */
App.RelationsArray = Ember.ArrayProxy.extend({ 
  content: null,
  init: function() {
    this.set("content", Ember.A([]));
  },
  _toString: function() {
    var predIndex = 0;
    return this.get('content').reduce(function(previousValue, item, index, enumerable) {
      return previousValue + item.get("_toString").call(item) + ", ";
    }, "");
  }
});

App.TimeScheduleContent = Ember.Object.extend(Ember.Evented, {

  init: function() {
    this._super();
    this.resetStructure();
  },

  updateObjectSync: function(props) {
    this.setProperties($.extend({"asyncDataLoaded": false}, props));
  },
  
  updateObjectAsync: function(props) {
    this.setProperties($.extend({"asyncDataLoaded": true}, props));
  }, 
  
  resetStructure: function() {
    this.set('structureObjects', Ember.A([]));
  },

  asyncDataLoaded: false,
  disableBarComputations: false,
  barWidth: 0,
  
  drawBold: function() {
    var bold = this.get('class_name');
    return bold == 'drawBold';
  }.property('drawBold'),

  setBarWidth: function() {
    if (!this.get('disableBarComputations')) {
      this.set(
        'barWidth',
        this.get('settings.scale').computeDatesWidth(
          this.get('startDate'),
          this.get('endDate')
        )
      );
    }
  }.observes(
      'startDate',
      'endDate',
      'settings.scale.pixelsPerDay',
      'disableBarComputations'
   ).on('init'),

  barPosition: 0,

  setBarPosition: function() {
    if (!this.get('disableBarComputations')) {
      this.set(
        'barPosition',
        this.get('settings.scale').computeDatePosition(this.get('startDate'))
      );
    }
  }.observes(
     'startDate',
     'settings.scale.startDateView',
     'settings.scale.pixelsPerDay',
     'disableBarComputations'
  ).on('init'),

  barEnd: function() {
    return this.get('barPosition') + this.get('barWidth');
  }.property(
      'barPosition',
      'barWidth'
  ),

  disablePlanBarComputations: false,

  barPlanWidth: 0,

  setBarPlanWidth: function() {
    if (!this.get('disablePlanBarComputations')) {
      this.set(
        'barPlanWidth',
        this.get('settings.scale').computeDatesWidth(
          this.get('startPlanDate'),
          this.get('endPlanDate')
        )
      );
    }
  }.observes(
      'startPlanDate',
      'endPlanDate',
      'settings.scale.pixelsPerDay',
      'disablePlanBarComputations'
   ).on('init'),

   barPlanPosition: 0,

   setBarPlanPosition: function() {
     if (!this.get('disablePlanBarComputations')) {
       this.set(
         'barPlanPosition',
         this.get('settings.scale').computeDatePosition(this.get('startPlanDate'))
       );
     }
   }.observes(
      'startPlanDate',
      'settings.scale.startDateView',
      'settings.scale.pixelsPerDay',
      'disablePlanBarComputations'
   ).on('init'),
   
   barStyle: function() {
     return this.get('hasDates') ?
              'width:' + this.get('barWidth') + 'px;' +
                'left:' + this.get('barPosition') + 'px;' :
              'display: none';
   }.property('hasDates', 'barWidth', 'barPosition'),

  _createDeleteObject: function() {
    var _delete = this.get('delete');
    if (! (_delete instanceof Ember.Object)) {
      this.set('delete', Ember.Object.create(_delete));
    }
  }.observes('delete').on('init'),

  _createStatusObject: function() {
    var status_color = this.get('status_color');
    if (! (status_color instanceof Ember.Object)) {
      this.set('status_color', Ember.Object.create(status_color));
    }
  }.observes('status_color').on('init'),

  _createPredecessorsRelationsObject: function() {
    this.beginPropertyChanges('predecessorsRelations');
    this.set('predecessorsRelations', App.RelationsArray.create());
    var predecessors_relations = this.get('predecessors_relations'),
        predecessorsRelations = this.get('predecessorsRelations');
    $.each(predecessors_relations, function (index, _relation) {
      predecessorsRelations.pushObject(App.Relation.create($.extend(_relation, {'is_successor': true})));
    });
    this.endPropertyChanges('predecessorsRelations');
  }.observes('predecessors_relations').on('init'),

  _createSuccessorsRelationsObject: function() {
    this.beginPropertyChanges('successorsRelations');
    this.set('successorsRelations', App.RelationsArray.create());
    var successors_relations = this.get('successors_relations'),
        successorsRelations = this.get('successorsRelations');
    $.each(successors_relations, function (index, _relation) {
      successorsRelations.pushObject(App.Relation.create($.extend(_relation, {'is_successor': false})));
    });
    this.endPropertyChanges('successorsRelations');
  }.observes('successors_relations').on('init'),

  backupAttributes: ['start_date', 'end_date', 'start_date', 'end_date'],
  isBarDragging: false,
  isPlanBarDragging: false,
  structureObjects: null,

  setBackupAttributes: function() {
    var self = this;
        backupAttributes = this.get('backupAttributes');
    backupAttributes.forEach(function(item, index, enumerable) {
      self.set('backup_' + item, self.get(item));
    });
  },

  predecessorsConflict: function() {
    if (!this.get('predecessorsRelations.length')) {
      return -1;
    } else {
      return this.get('predecessorsRelations').reduce(function(previousValue, item, index, enumerable) {
        return previousValue || item.get('conflict');
      }, 0);
    }
  }.property('predecessorsRelations.@each.conflict'),

  multipleWorkdays: function(){
      if (this.duration < 2) return false;
      return true;
  }.property('duration'),

   multiplePlanWorkdays: function(){
      if (this.duration_plan < 2) return false;
      return true;
  }.property('duration_plan'),

  successorsConflict: function() {
    if (!this.get('successorsRelations.length')) {
      return -1;
    } else {
      return this.get('successorsRelations').reduce(function(previousValue, item, index, enumerable) {
        return previousValue || item.get('conflict');
      }, 0);
    }
  }.property('successorsRelations.@each.conflict'),

  startDate: function() {
    return UTCToDate(this.get('start_date'));
  }.property('start_date'),

  endDate: function() {
    return UTCToDate(this.get('end_date'));
  }.property('end_date'),

  startPlanDate: function() {
    return UTCToDate(this.get('start_date_plan'));
  }.property('start_date_plan'),

  endPlanDate: function() {
    return UTCToDate(this.get('end_date_plan'));
  }.property('end_date_plan'),

  startDateStr: function() {
    return dateToStr(this.get('startDate'));
  }.property('startDate'),

  endDateStr: function() {
    return dateToStr(this.get('endDate'));
  }.property('endDate'),
  
  constraintDate: function() {
    return UTCToDate(this.get('constraint_date'));
  }.property('constraint_date'),
  
  constraintDateStr: function() {
    return dateToStr(this.get('constraintDate'));
  }.property('constraintDate'),

  startPlanDateStr: function() {
    return dateToStr(this.get('startPlanDate'));
  }.property('startDate'),

  endPlanDateStr: function() {
    return dateToStr(this.get('endPlanDate'));
  }.property('endDate'),

  earlyStart: function() {
    return UTCToDate(this.get('early_start')).subtract('days', 1);
  }.property('early_start'),

  lateFinish: function() {
    return UTCToDate(this.get('late_finish')).add('days', 1);
  }.property('late_finish'),

  hasDates: false,

  setHasDates: function() {
    if (!this.get('disableBarComputations')) {
      var newHasDates = this.get('start_date') && this.get('end_date');
      if (this.get('hasDates') !== newHasDates) {
        this.set('hasDates', newHasDates);
      }
    }
  }.observes(
     'start_date',
     'end_date',
     'disableBarComputations'
  ).on('init'),

  performDoubleClickOperation: function() {
    window.open(this.get('modifyOperationUrl'), '_self');
    this.trigger('dataChanged');
  },

  saveStartEndDates: function(inTable) {
    var data = {},
        self = this;
    if (self.get('start_date') !== self.get('backup_start_date')) {
      data.start_date = self.get('start_date');
    }
    if (self.get('end_date') !== self.get('backup_end_date')) {
      data.end_date = self.get('end_date');
    }
    if (Object.keys(data).length) {
      data.cdb_object_id = this.get('objCdbObjectId');
      data.drag = this.get('isBarDragging');
      data.in_table = inTable;
      asyncPost(
        window.appSettings.timeChartData + '/update_start_end_dates/post',
        data
      ).then(function(data) {
        self.trigger('dataChanged');
        if (data && Object.keys(data).indexOf('error') !== -1) {
          self.set('start_date', self.get('backup_start_date'));
          self.set('end_date', self.get('backup_end_date'));
        }
      });
    }
  },

  saveStartEndPlanDates: function() {
    var data = {},
        self = this;
    if (self.get('start_date_plan') !== self.get('backup_start_date_plan')) data.start_date_plan = self.get('start_date_plan');
    if (self.get('end_date_plan') !== self.get('backup_end_date_plan')) data.end_date_plan = self.get('end_date_plan');
    if (Object.keys(data).length) {
      data.cdb_object_id = this.get('objCdbObjectId');
      asyncPost(
        window.appSettings.timeChartData + '/update_start_end_plan_dates/post',
        data
      ).then(function(data) {
        self.trigger('dataChanged');
      });
    }
  },
  
  saveConstraintDate: function() {
    var data = {},
        self = this;
    data.constraint_date = self.get('constraint_date');
    data.cdb_object_id = this.get('objCdbObjectId');
    asyncPost(
      window.appSettings.timeChartData + '/update_constraint_date/post',
      data
    ).then(function(data) {
      self.trigger('dataChanged');
    });
  },

  saveSingleParameter: function(value, paramName) {
    var self = this,
        oldValue = self.get(paramName);
        data = {'cdb_object_id': self.get('objCdbObjectId')};
    data[paramName] = value;
    self.set(paramName, value);
    asyncPost(
      window.appSettings.timeChartData + '/update_' + paramName + '/post',
      data
    ).then(function(data) {
      self.trigger('dataChanged');
    });
  }
});

App.TimeScheduleContents = Ember.ArrayProxy.extend(Ember.Evented, {

  content: Ember.A([]),

  loadedTimeStamp: null,

  _all: function() { //all
    return this.get('content');
  },

  onDataChanged: function() {
    this.trigger('dataChanged');
  },

  addScheduleContent: function(data) {
    var _scheduleContent = $.extend(data, {
      settings: this.get('settings')
    });
    var scheduleContent = App.TimeScheduleContent.create(_scheduleContent);
    scheduleContent.on('dataChanged', this, this.onDataChanged);
    return this.pushObject(scheduleContent);
  },

  resetStructures: function() {
    this.get('content').forEach(function(item) {
      item.resetStructure();
    });
  }
});

Ember.Application.initializer({
  name: 'time_schedule_contents',
  after: ['time_settings'],

  initialize: function(container, application) {
    container.register('ScheduleContent:timeChart', App.TimeScheduleContents,  { instantiate: true, singleton: true });
    application.inject('ScheduleContent:timeChart', 'settings', 'Settings:timeChart');
  }
});

App.TimeScheduleContentStructure = Ember.Object.extend({
  init: function() {
    this._super();
    this.get('scheduleContent.structureObjects').pushObject(this);
  },

  scheduleContent: null,
  level: 0,
  parent: null,
  _isHiddenByAncestor: false,
  isExpanded: false,
  isHiddenByClone: false,

  hovered: false,
  selected: false,

  hiddenByCloneFunction: function() {
    var model = this;
    if (model.get('scheduleContent.structureObjects').length < 2) {
      model.set('isHiddenByClone', false);
    } else {
      var maxLevel = -1,
        visibleStructureObject = null,
        structureObjects = model.get('scheduleContent.structureObjects');
      structureObjects = structureObjects.filter(function(content, index) {
        return !content.get('isHiddenByAncestor');
      });
      if (!structureObjects.length) return;
      $.each(structureObjects, function (index, content) {
        if (content.get('level') > maxLevel) {
          maxLevel = content.get('level');
          visibleStructureObject = content;
        }
        content.set('isHiddenByClone', true);
      });
      visibleStructureObject.set('isHiddenByClone', false);
    }
  }.observes('scheduleContent.structureObjects.length', 'scheduleContent.structureObjects.@each.isHiddenByAncestor'),


  isHiddenByAncestor: function(key, value) {
    var model = this,
      parent = null;
    if (value === undefined) {
      // property being used as a getter
      parent = model.get('parent');
      if (model.get('level')) {
        if (parent === null ) {
          model.set('_isHiddenByAncestor', false);
        } else {
          if (!parent.get('isExpanded')) {
            model.set('_isHiddenByAncestor', true);
          } else {
            //model.set('isExpanded', false);
            model.set('_isHiddenByAncestor', model.get('parent.isHiddenByAncestor') || model.get('parent.isHiddenByClone'));
          }
        }
      } else {
        model.set('_isHiddenByAncestor', false);
      }
      return model.get('_isHiddenByAncestor');
    } else {
      // property being used as a setter
      model.set('_isHiddenByAncestor', value);
      return value;
    }
  }.property('parent.isExpanded', 'parent.isHiddenByAncestor', '_isHiddenByAncestor', 'parent.isHiddenByClone')
});


App.TimeScheduleContentsStructure = Ember.ArrayProxy.extend(Ember.Evented, {

  recomputeChartDates: false,
  selectionStatus: null,
  content: Ember.A([]),
  filteredContent: Ember.A([]),
  additionalContent: Ember.A([]), //for relations with objects not in schedule
  filterMessage: '',

  load: function() {
    this.get('_scheduleContents').set('loadedTimeStamp', null);
    this.refresh();
  },

  _all: function() { //all
    return this.get('content');
  }.observes('content'),

  all: function() { //filtered
    return this.get('filteredContent');
  }.observes('filteredContent'),

  _allLevel0: function() {
    return this.get('content').filter(function(content, index) {
      return content.get('level') === 0;
    });
  }.observes('content'),

  _pushParent4Filter: function(__filteredContents, item) {
    if (!item) return;
    this._pushParent4Filter(__filteredContents, item.get('parent'));
    if (__filteredContents.indexOf(item) === -1) __filteredContents.pushObject(item);
  },

  filter: function() {
    var self = this,
        text = self.get('filterMessage'),
        timeScheduleContentsStructure = this._all(),
        filterColumns = this.get('settings').get('columns').filter(function(item, index, enumerable) {
          return ['text', 'number', 'date', 'float'].indexOf(item.get('format')) !== -1;
        }),
        textArr = text.trim().split(' ').map(function(item, index, enumerable) {
          return item.length ? item.toUpperCase() : null;}).filter(function(item, index, enumerable){
            return item!==null});
    if (textArr.length) {
      var scrollBarView = self.get('scrollBarView');
      if (scrollBarView) {
        scrollBarView.$('.scroll-bar-parent').scrollTop(0);
      }
    }
    var _filteredContents = timeScheduleContentsStructure.filter(
          function(cnt, idx){
            return (
                  (self._filterFunction(filterColumns, cnt.get('scheduleContent'), textArr) &&
                  !cnt.get('isHiddenByAncestor') &&
                  !cnt.get('isHiddenByClone')
                  ) ? cnt : null);
    });
    //add parents even thought they may not meet the condition
    var __filteredContents = Ember.A([]),
        _item = null;
    _filteredContents.forEach(function(item, index, enumerable) {
      self._pushParent4Filter(__filteredContents, item);
    });
    timeScheduleContentsStructure.setEach('index', null);
    __filteredContents.forEach(function(item, index, enumerable) {
      item.set('index', index + 1);
    });
    self.beginPropertyChanges('filteredContent');
    self.get('filteredContent').clear();
    self.get('filteredContent').pushObjects(__filteredContents);
    self.endPropertyChanges('filteredContent');
  },

  _filterFunction: function(filterColumns, element, textArr) {
    var matchFound = false,
        attr = null,
        str = '';
    var stringsToFilter = $.map(filterColumns, function(column, indexColumn) {
      if (column.get('format') === 'date') {
        str = UTCToDate(element.get(column.get('name'))).format(cdb.elink.cdbDateFormat);
      } else {
        str = element.get(column.get('name'));
      }
      if (typeof str === 'object') {
        if (str && 'search_value' in str) {
          str = str.search_value;
        } else {
          str = '';
        }
      }
      return str.toString().toUpperCase();
    });
    var textFound = $.map(textArr, function(text, indexText) {
      return text.length ?
          stringsToFilter.filter(function(str, index, enumerable) {
            return text.length ? str.indexOf(text) !== -1 : true;
          }).length > 0 :
          true;
    });
    return textFound.indexOf(false) === -1;
  },

  deleteModel: function(model) {
    model.get('scheduleContent.structureObjects').removeObject(model);
    this.get('content').removeObject(model);
    this.get('filteredContent').removeObject(model);
  },

  toggleInScheduleAction: function(oid, inSchedule) {
    var self = this;
    asyncPost(
      window.appSettings.timeChartData + '/toggle_ts_obj/post',
      {'oid': oid, 'inSchedule': inSchedule}
    ).then(function() {
        self.refresh(true)
    });
  },

  saveSelectionStatus: function() {
    var selection = this.get('settings.selection'),
        lastHovered = selection.get('lastHovered'),
        selectedArray = selection.get('selectedArray');
    this.set('selectionStatus', {
      'lastHovered': (lastHovered) ?
          {
            'id': lastHovered.get('scheduleContent.objCdbObjectId'),
            'hovered': lastHovered.get('hovered')
          } :
          null,
      'selectedArray': (selectedArray.length) ?
          selectedArray.map(function(item, index, enumerable) {
            return {
              'id': item.get('scheduleContent.objCdbObjectId'),
              'selected': item.get('selected')
            };
          }) :
          []
    });
  },

  redoSelectionStatus: function() {
    var structureContents = this.all(),
        selection = this.get('settings.selection'),
        selectionStatus = this.get('selectionStatus'),
        item = null;
    selection.set('_lastHovered', null);
    selection.get('selectedArray').clear();
    if (selectionStatus.lastHovered) {
      item = structureContents.findBy('scheduleContent.objCdbObjectId', selectionStatus.lastHovered.id);
      if (item) {
        selection.set('lastHovered', item);
        item.set('hovered', selectionStatus.lastHovered.hovered);
      }
    }
    if (selectionStatus.selectedArray.length) {
      $.each(selectionStatus.selectedArray, function(index, content) {
        item = structureContents.findBy('scheduleContent.objCdbObjectId', content.id);
        if (item) {
          selection.set('lastSelected', item);
          item.set('selected', content.selected);
        }
      });
    }
  },

  setScaleDates: function() {
    var start_timestamp = this.computeEarliestDate(),
        end_timestamp = this.computeLatestDate();
    // this is only needed due to a curent bug in backend
    if (start_timestamp > end_timestamp) {
        var tmp = start_timestamp;
        start_timestamp = end_timestamp;
        end_timestamp = tmp;
    }
    var start = UTCToDate(start_timestamp),
        end = UTCToDate(end_timestamp),
        daysDisplayed = end.diff(start, 'days'),
        additionalDaysStart = Math.ceil(daysDisplayed * 2 / 100),
        additionalDaysEnd = Math.ceil(daysDisplayed * 5 / 100); // account for scrollbar
    this.get('settings.scale').moveStartEnd(
        start.subtract('days', additionalDaysStart).startOf('day'),
        end.add('days', additionalDaysEnd + 1).endOf('day')
    );
  },
  
  loadTempTooltipObj: function(id, callback) {
      var self = this;
      asyncPost(
          window.appSettings.timeChartData + '/get_one_object',
          {"cdb_object_id": id}
      ).then(function(data) {
          var scheduleContent = App.TimeScheduleContent.create($.extend(
              data, 
              {settings: self.get('settings')}
          ));
          self.get('additionalContent').pushObject(App.TimeScheduleContentStructure.create({
              'scheduleContent': scheduleContent,
              'level': -1
          }));
          callback();
      });
  },
  
  loadAsyncData: function(sCSObjs) {
    var self = this,
        onSuccess = function(data) {
          var self = this,
              _scheduleContents = self.get('_scheduleContents');
          Object.keys(data).forEach(function(key) {
            var sC = _scheduleContents.findBy('objCdbObjectId', key);
            if (sC) {
              sC.updateObjectAsync(data[key]);
            }
          });
        };
    Ember.$.ajax({
        url: window.appSettings.timeChartData + '/load_async_data',
        data: {'obj_ids': JSON.stringify(
                sCSObjs.mapBy('scheduleContent').filterBy('asyncDataLoaded', false).mapBy("objCdbObjectId").uniq()
                )
        },
        async: true,
        type: 'GET',
        dataType: 'json'
    }).then(
        function(data) {
          if (data && (typeof data === 'object')) {
            var keys = Object.keys(data);
            if (keys.length === 1 && keys[0] === 'error') {
              alertCDBMessage(data.error);
              App.set("errorHappened", true);
            }
          }
          Ember.RSVP.resolve(data).then(onSuccess.bind(self));
        },
        function(data) {
          alertCDBMessage(data.responseText);
          App.set("errorHappened", true);
        }
    );
  },

  refresh: function(serverSideSettings) {
    var self = this;
    var onSuccess = function(data) {
      var newTScContent = Ember.A([]),
          newTScContentLastObject = null,
          _scheduleContents = self.get('_scheduleContents'),
          model = null;

      _scheduleContents.set('loadedTimeStamp', data.loaded_time_stamp);
      self.get("additionalContent").clear(); //make sure additional content is always up to date
      self.beginPropertyChanges('content');
      _scheduleContents.beginPropertyChanges('content');
      self.get('content').clear();
      _scheduleContents.resetStructures();
      $.each(data.scheduleContents, function(index, _content) {
        modelId = Object.keys(_content)[0];
        dataValues = _content[modelId];
        if (!dataValues.obj) {
          newTScContentLastObject = _scheduleContents.findBy('objCdbObjectId', modelId);
        } else {
          newTScContentLastObject = _scheduleContents.findBy('objCdbObjectId', modelId);
          if (newTScContentLastObject) {
            newTScContentLastObject.updateObjectSync(dataValues.obj);
          } else {
            newTScContentLastObject = _scheduleContents.addScheduleContent(dataValues.obj);
          }
        }
        model = self.get('content').pushObject(App.TimeScheduleContentStructure.create({
          'scheduleContent': newTScContentLastObject,
          'level': 0
        }));
        self._recursivelyAddChildrenToStructure(model, dataValues.children);
      });
      _scheduleContents.forEach(function(item, index, enumerable) {
        item.setBackupAttributes();
      });
      self.get('_scheduleContents').endPropertyChanges('content');
      self.endPropertyChanges('content');
      if (self.get('recomputeChartDates')) {
        self.setScaleDates();
        self.set('recomputeChartDates', false);
      }
      Ember.run.scheduleOnce('sync', self, function() {
        self.trigger('resumeRowUpdate');
        self.filter();
        self.redoSelectionStatus();
      });
    };

    var filterMessage = self.get('filterMessage'),
        loadedTimeStamp = self.get('_scheduleContents.loadedTimeStamp');
    self.set('filterMessage', '');
    self.trigger('delayRowUpdate');
    self.filter();
    Ember.run.sync();
    var scheduleContents = self.get('_scheduleContents')._all(),
        timeContents = self._all(),
        ids_client = $.map(timeContents, function(cnt) {
          return cnt.get('scheduleContent.objCdbObjectId');
        }),
        timeContentsDisplayed = self.all(),
        timeContentsExpandedIds = timeContentsDisplayed.filterBy('isExpanded').mapBy('scheduleContent.objCdbObjectId');
    self.saveSelectionStatus();
    self.set('filterMessage', filterMessage);

    asyncPost(
        window.appSettings.timeChartData + '/refresh_data',
        {'loaded_time_stamp': loadedTimeStamp,
         'ids_client': JSON.stringify(ids_client),
         'expanded_ids': JSON.stringify(timeContentsExpandedIds),
         'use_serverside_settings': (!loadedTimeStamp || (serverSideSettings === true)) 
        },
        'POST').then(onSuccess.bind(self));
  },

  addChildrenToStructure: function(model, childrenData) {
    if (!model) return;
    var self = this,
        index = self.indexOf(model),
        scheduleContent = null,
        modelLevel = model.get('level'),
        _scheduleContent = null,
        child = self.objectAt(index + 1),
        _scheduleContents = self.get('_scheduleContents');
    do {
      if (child &&
         (child.get('level') > modelLevel)) {
        self.deleteModel(child);
      } else {
        break;
      }
      child = self.objectAt(index + 1);
    } while(child);

    $.each(childrenData, function(idx, _item) {
      index++;
      id = Object.keys(_item)[0];
      _scheduleContent = _item[id];
      if (!_scheduleContent) {
        scheduleContent = _scheduleContents.findBy('objCdbObjectId', id);
      } else { //put in self._scheduleContents if not there
        scheduleContent = _scheduleContents.findBy('objCdbObjectId', id);
        if (scheduleContent) {
          scheduleContent.updateObjectSync(_scheduleContent);
        } else {
          scheduleContent = _scheduleContents.addScheduleContent(_scheduleContent);
        }
      }
      //add to structure;
      self.get('content').insertAt(index, App.TimeScheduleContentStructure.create({
        'scheduleContent': scheduleContent,
        'level': model.get('level') + 1,
        'parent': model
      }));
    });
    model.set('childrenLoaded', true);
    model.set('isExpanded', true);
  },
  
  fullyExpandSCS: function(id) {
    var self = this;
    asyncPost(
      window.appSettings.timeChartData + '/fully_expand_id/post',
      {'id': id}
    ).then(function() {
      self.refresh(true);
    });
  },

  toggleChildren: function(model) {
    var self = this;
    if (!model.get('isExpanded')) {
      model.set('isExpanded', true);
      self.refresh();
    } else {
      var modelLevel = model.get('level'),
          index = self.indexOf(model),
          child = self.objectAt(index + 1);
      model.set('isExpanded', false);
      while(child) {
        if (child.get('level') > modelLevel) {
          child.set('isExpanded', false);
        } else {
          break;
        }
        index++;
        child = self.objectAt(index + 1);
      };
      self.filter();
      var timeContentsExpandedIds = self.all().filterBy('isExpanded').mapBy('scheduleContent.objCdbObjectId');
      asyncPost(
        window.appSettings.timeChartData + '/save_expanded_ids/post',
        {'expanded_ids': JSON.stringify(timeContentsExpandedIds)}
      ).then(function() {
         if (App.get("errorHappened")) {
             self.refresh(true);
         }
      });
    }
  },

  _getNextObjectWithId: function(model, id) {
    var self = this,
        content = self._all(),
        slicedContent = content.slice(content.indexOf(model));
    return slicedContent.findBy('scheduleContent.objCdbObjectId', id);
  },

  _recursivelyAddChildrenToStructure: function(model, childrenData) {
    if (!childrenData.length) return;
    var self = this,
        key = null,
        obj = null,
        childModel = null;
        _childrenData = $.map(childrenData,
            function(cnt, idx){
              key = Object.keys(cnt)[0];
              obj = {};
              obj[key] = cnt[key].obj;
              return obj;
            }
        );
    self.addChildrenToStructure(model, _childrenData);
    $.each(childrenData, function (index, content) {
      key = Object.keys(content)[0];
      childModel = self._getNextObjectWithId(model, key);
      self._recursivelyAddChildrenToStructure(childModel, content[key].children);
    });
  },

  switchItems: function(id1, id2) {
    var self = this,
        timeContentsLevel0 = self._allLevel0(),
        timeContents = self._all(),
        item1 = timeContentsLevel0.find(function(item, index, enumerable) {
          return item.get('scheduleContent.objCdbObjectId') === id1;
        }),
        item2 = timeContentsLevel0.find(function(item, index, enumerable) {
          return item.get('scheduleContent.objCdbObjectId') === id2;
        }),
        ids = $.map(timeContentsLevel0, function(cnt) {
          return cnt.get('scheduleContent.objCdbObjectId');
        });
    ids.splice(ids.indexOf(id1), 1);
    if (id2) {
      ids.splice(ids.indexOf(id2), 0, id1);
    } else {
      ids.push(id1);
    }

    asyncPost(
      window.appSettings.timeChartData + '/change_position/post',
      {'ids': JSON.stringify(ids)},
      "POST"
    ).then(self.refresh.bind(self));
  },

  revealUpToId: function(id) {
    var self = this;
    asyncPost(
      window.appSettings.timeChartData + '/reveal_id/post',
      {'id': id}
    ).then(function() {
      self.refresh(true);
    });
  },
  
  createRelations: function(relationsData) {
    var self = this;
    asyncPost(
      window.appSettings.timeChartData + '/create_relations/post',
      {'relations_data': JSON.stringify(relationsData)}
    ).then(function() {
      self.refresh();
    });
  },

  deleteRelations: function(relations) {
    var self = this;
    asyncPost(
      window.appSettings.timeChartData + '/delete_relations/post',
      {'primary_keys': JSON.stringify(relations.map(function(item) {return item.primary_keys}))}
    ).then(self.refresh.bind(self));
  },
  
  moveRelations: function(relations) {
    var self = this;
    asyncPost(
      window.appSettings.timeChartData + '/move_relations/post',
      {'primary_keys': JSON.stringify(
        relations.map(function(rel, index) {
          return $.extend(rel.relation.primary_keys, {'minimal_gap': rel.minimal_gap});
        })
      )}
    ).then(self.refresh.bind(self));
  },

  computeEarliestDate: function() {
    var all = this._all(),
        timestamps = $.map(all,
          function(cnt, idx){
            var date = cnt.get('scheduleContent.start_date');
            return (date) ? date.valueOf() : null;
          }
        ).concat($.map(all,
            function(cnt, idx){
              var date = cnt.get('scheduleContent.start_date_plan');
              return (date) ? date.valueOf() : null;
            }
          )
        );
    timestamps = timestamps.filter(function(cnt){return cnt;});
    return timestamps.length ? Math.min.apply(Math, timestamps) : App.momentConstructor().startOf('month').valueOf();
  },

  computeLatestDate: function() {
    var all = this._all(),
        timestamps = $.map(all,
          function(cnt, idx){
            var date = cnt.get('scheduleContent.isMilestone') ? cnt.get('scheduleContent.start_date') : cnt.get('scheduleContent.end_date');
            return (date) ? date.valueOf() : null;
          }
        ).concat(
            $.map(all,
              function(cnt, idx){
                var date = cnt.get('scheduleContent.isMilestone') ?
                    cnt.get('scheduleContent.start_date_plan') :
                    cnt.get('scheduleContent.end_date_plan');
                return (date) ? date.valueOf() : null;
              }
            )
        );
    timestamps = timestamps.filter(function(cnt){return cnt;});
    return timestamps.length ? Math.max.apply(Math, timestamps) : App.momentConstructor().endOf('month').startOf('day').add('days', 1).valueOf();
  },

  setDataChangedObserver: function() {
    this.get('_scheduleContents').on('dataChanged', this, this.refresh);
  }.on('init')
});

App.Relation = Ember.Object.extend({
  contentsStructure: null,
  _contentsStructure: null,
  labels: null,
  tempTooltipObj: null,
  is_successor: null,
  minimalGapInDays: function() {
    var minimal_gap = this.get('minimal_gap'),
        dayAbbreviation = (cdb.elink.currentLanguage == "de" ? "t" : "d");
    return (minimal_gap >= 0 ? "+" : "") + minimal_gap + dayAbbreviation;
  }.property('minimal_gap'),
  
  _toString: function() {
    var index = this.get("is_successor") ? this.get("predecessor.index") : this.get("successor.index");
    return this.get("type_label") + (index ? index : "") + this.get("minimalGapInDays");
  },
  
  init: function() {
    this._super();
    this.set('contentsStructure', App.__container__.lookup('ScheduleContent:timeChartStructure').all());
    this.set('_contentsStructure', App.__container__.lookup('ScheduleContent:timeChartStructure')._all());
    this.set('additionalContentsStructure', 
        App.__container__.lookup('ScheduleContent:timeChartStructure').get("additionalContent"));
    this.set('labels', App.__container__.lookup('labels:main'));
  },
  
  getTempTooltipObj: function(id) {
      if (id === this.get("successor.scheduleContent.objCdbObjectId")) {
          this.set("tempTooltipObj", this.get("successor"))
      }else if (id === this.get("predecessor.scheduleContent.objCdbObjectId")) {
          this.set("tempTooltipObj", this.get("predecessor"))
      } else {
          var hiddenContent = this.get('_contentsStructure').findBy('scheduleContent.objCdbObjectId', id);
          if (hiddenContent) {
              this.set("tempTooltipObj", hiddenContent)
          } else {
              var additionalContent = this.get('additionalContentsStructure').findBy('scheduleContent.objCdbObjectId', id)
              if (additionalContent) {
                  // already loaded
                  this.set("tempTooltipObj", additionalContent)
              } else {
                  //must load
                  var self = this,
                      setTempTooltipObj = function() {
                          var additionalContent = self.get('additionalContentsStructure').findBy('scheduleContent.objCdbObjectId', id)
                          if (additionalContent) {
                              // already loaded
                              self.set("tempTooltipObj", additionalContent)
                          }
                  };
                  App.__container__.lookup('ScheduleContent:timeChartStructure').loadTempTooltipObj(id, setTempTooltipObj.bind(self))
              }
          }
      }
  },
  
  preDelTitle: function() {
    return this.get('labels.pcs_rel_pre') + ' "' +
      this.get('predecessor.scheduleContent.title') + '" ' +
      this.get('labels.pcs_delete_lc');
  }.property('predecessor'),

  sucDelTitle: function() {
    return this.get('labels.pcs_rel_suc') + ' "' +
      this.get('successor.scheduleContent.title') + '" ' +
      this.get('labels.pcs_delete_lc');
  }.property('successor'),

  predecessor: function() {
    return this.get('contentsStructure').findBy('scheduleContent.objCdbObjectId', this.get('predecessorID'));
  }.property('contentsStructure.[]'),

  successor: function() {
    return this.get('contentsStructure').findBy('scheduleContent.objCdbObjectId', this.get('successorID'));
  }.property('contentsStructure.[]')
});

Ember.Application.initializer({
  name: 'time_schedule_structure',
  after: ['time_schedule_contents'],

  initialize: function(container, application) {
    container.register('ScheduleContent:timeChartStructure',
                       App.TimeScheduleContentsStructure,
                       { instantiate: true, singleton: true });
    application.inject('ScheduleContent:timeChartStructure', '_scheduleContents', 'ScheduleContent:timeChart');
    application.inject('ScheduleContent:timeChartStructure', 'settings', 'Settings:timeChart');
  }
});
