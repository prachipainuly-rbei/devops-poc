App.TimeChartPluginComponent = Ember.Component.extend(App.ChartPluginComponentMixin, {
    noDeselectClickElements: '#time_info_dropdown_menu, .column-widget, .left-panel > .ui-resizable-handle'
});


App.TimeChartTopComponent = Ember.Component.extend({
  classNames: ['top-panel'],

  _waitInterval: 500,
  _testInterval: 450,
  _filterMessage: '',
  _lastChanged: new Date(0),
  button_task_type_code: [0, 2, 3],

  filterMessage: function(key, value){
    if (value === undefined) {
      return this.get('_filterMessage');
    } else {
      this.set('_filterMessage', value);
      this.set('_lastChanged', new Date());
      return value;
    }
  }.property('_filterMessage'),

  _filter: function(self){
    var now = new Date();
    if (now - self.get('_lastChanged') > self.get('_testInterval')) {
      var contentsStructure = self.get('model.contentsStructure');
      contentsStructure.set('filterMessage', self.get('filterMessage'));
      contentsStructure.get('filter').call(contentsStructure);
    }
  },

  filter: function(){
    var self = this;
    setTimeout(function(){
      self.get('_filter')(self);
    }, self._waitInterval);
  }.observes('filterMessage'),

  hideInfoMenuOnDelete : function() {
    if (!this.get('settings.selection.oneSelected')) {
      var menu = this.$('#time_info_dropdown_menu .elink-button-dropdown');
      if (menu && menu.length) menu.removeClass('open');
    }
  }.observes('settings.selection.oneSelected'),

  didInsertElement: function() {
    this.$('input').placeholder();
  },

  actions: {
    run_operation: function(op_url) {
      $(document).trigger('click.dropdown.data-api');
      window.open(op_url, '_self');
      var contentsStructure = this.get('model.contentsStructure');
      contentsStructure.get('refresh').call(contentsStructure);
    },

    expandAction: function() {
      var lastSelected = this.get('settings.selection.lastSelected');
      if (lastSelected) {
        var scheduleContent = lastSelected.get('scheduleContent'),
            contentsStructure = this.get('model.contentsStructure');
        if (scheduleContent && contentsStructure) {
          contentsStructure.get('fullyExpandSCS').call(contentsStructure, scheduleContent.get('objCdbObjectId'));
        }
      }
    },
    
    revealAction: function() {
      var lastSelected = this.get('settings.selection.lastSelected');
      if (lastSelected) {
        var scheduleContent = lastSelected.get('scheduleContent'),
            contentsStructure = this.get('model.contentsStructure');
        if (scheduleContent && contentsStructure) {
          contentsStructure.get('revealUpToId').call(contentsStructure, scheduleContent.get('objCdbObjectId'));
        }
      }
    },

    timeAction: function() {
      var contentsStructure = this.get('model.contentsStructure');
      contentsStructure.get('setScaleDates').call(contentsStructure);
    },

    jumpAction: function() {
      if (this.get('settings.selection.selectedArray').length === 1){
        var scheduleContent = this.get('settings.selection.lastSelected.scheduleContent');
        if (scheduleContent) {
          var startDate = scheduleContent.get('startDate');
          if (startDate.isValid()) {
            this.get('settings.scale').moveStart(scheduleContent.get('startDate'));
          }
        }
      }
    },

    refreshAction: function() {
      var contentsStructure = this.get('model.contentsStructure');
      contentsStructure.get('refresh').call(contentsStructure);
    }
  }
});


App.TimeChartComponent = Ember.Component.extend({
  classNames: ['chart-body'],
  attributeBindings: ['style:style'],

  todayBarStyle: function() {
    var ppd = this.get('settings.scale.pixelsPerDay');
    return 'left: ' + (
                this.get('settings.scale.todayCell').pxLeft(App.momentConstructor().startOf('day').add('hours', 12)) + ppd / 2 - 3) +
           'px;';
  }.property('settings.scale.todayCell', 'settings.scale.pixelsPerDay', 'settings.scale.startDateView'),

  selectedAreaDefaultStyle: "left: 0px; width: 0px",
  
  selectedAreaStyle: function() {
    var lastSelected = this.get('settings.selection.lastSelected');
    if (lastSelected) {
      return lastSelected.get('scheduleContent.barStyle')
    } else {
      return this.get('selectedAreaDefaultStyle');
    }
  }.property('settings.selection.lastSelected.scheduleContent.barStyle'),
  
  style: function() {
    return 'width: ' + this.get('settings.scale.viewportWidth') + 'px';
  }.property('settings.scale.viewportWidth')
});


App.TimeChartRowComponent = Ember.Component.extend({
  classNames: ['time-bar-row'],
  classNameBindings: ['viewingContent.scheduleContent.isDiscarded:draw-transparent'],
  dragStart: 0,
  gridStep: 0,
  viewingContent: Ember.computed.alias('model.referencedObject'),

  displayPlanBar: function() {
    return (
      !this.get('viewingContent.scheduleContent.isMilestone') &&
      this.get('viewingContent.scheduleContent.start_date_plan') &&
      this.get('viewingContent.scheduleContent.end_date_plan') &&
      this.get('viewingContent.scheduleContent.displayPlanBar') &&
      this.get('viewingContent.scheduleContent.hasChildren')
      );
    }.property(
      'viewingContent.scheduleContent.isMilestone',
      'viewingContent.scheduleContent.start_date_plan',
      'viewingContent.scheduleContent.end_date_plan',
      'viewingContent.scheduleContent.displayPlanBar',
      'viewingContent.scheduleContent.hasChildren'
  ),

  leftIntervalBorderStyle: function() {
    var timeScaleModel = this.get('settings.scale');
    return 'left:' +
              (
                  timeScaleModel.get('computeDatePosition').call(
                      timeScaleModel,
                      this.get('viewingContent.scheduleContent.earlyStart')
                  ) +
                  timeScaleModel.get('pixelsPerDay') -
                  20
              ) + 'px;' +
           'width: 20px';
  }.property('viewingContent.scheduleContent.earlyStart', 'settings.scale.startDateView', 'settings.scale.pixelsPerDay'),

  rightIntervalBorderStyle: function() {
    var timeScaleModel = this.get('settings.scale');
    return 'left:' +
              timeScaleModel.get('computeDatePosition').call(
                  timeScaleModel,
                  this.get('viewingContent.scheduleContent.lateFinish')
              ) + 'px;' +
            'width: 20px';
  }.property('viewingContent.scheduleContent.lateFinish', 'settings.scale.startDateView', 'settings.scale.pixelsPerDay'),

  leftIntervalBorderClass: function() {
    var className = 'interval-borders left',
        scheduleContent = this.get('viewingContent.scheduleContent');
    if (scheduleContent) {
      var conflict = scheduleContent.get('startDate') <= scheduleContent.get('earlyStart');
      className += (conflict) ? ' violated' : '';
      className += (this.get('viewingContent.selected') || this.get('viewingContent.hovered')) ? '' : ' hidden';
    }
    return className;
  }.property('viewingContent.scheduleContent.earlyStart', 'viewingContent.scheduleContent.startDate', 'viewingContent.selected', 'viewingContent.hovered'),

  rightIntervalBorderClass: function() {
    var className = 'interval-borders right',
        scheduleContent = this.get('viewingContent.scheduleContent');
    if (scheduleContent) {
      var conflict = scheduleContent.get('endDate') >= scheduleContent.get('lateFinish');
      className += (conflict) ? ' violated' : '';
      className += (this.get('viewingContent.selected') || this.get('viewingContent.hovered')) ? '' : ' hidden';
    }
    return className;
  }.property('viewingContent.scheduleContent.endDate', 'viewingContent.scheduleContent.lateFinish', 'viewingContent.selected', 'viewingContent.hovered'),
});

function _getTimeChartBarTooltipView() {
  var _timeChartBarTooltipView = App.__container__.lookup('router:main')._activeViews['timeChartBarTooltip'];
  if (_timeChartBarTooltipView !== undefined) {
    return _timeChartBarTooltipView[0]
  } else {
    return {'tooltipShow': function(){},
            'tooltipTurnoff': function(){}
    }
  }
}

App.TimeChartBarComponent = Ember.Component.extend(App.SelectionMixin, {
  classNameBindings: ['viewingContent.scheduleContent.customBarClass',
                      'viewingContent.scheduleContent.objPermission::readonly',
                      ':chart-bar',
                      'viewingContent.selected:selected',
                      'viewingContent.hovered:gantt-hover'],
  attributeBindings: ['style'],
  style: Ember.computed.alias('viewingContent.scheduleContent.barStyle'),
  gridStep: Ember.computed.alias('settings.scale.pixelsPerDay'),
  viewingContent: Ember.computed.alias('model.referencedObject'),
  
  objCdbObjectId: null,
  dragStart: 0,
  mouseover: false,
  
  percentCompleteStr: function(){
    var width = this.get('viewingContent.scheduleContent.percentComplete') ? this.get('viewingContent.scheduleContent.percentComplete') : 0;
    return "width: " + width + "%";
  }.property('viewingContent.scheduleContent.percentComplete'),

  mouseEnter: function(e) {
    this._super();
    this.mouseover=true;
    _getTimeChartBarTooltipView().tooltipShow(this, e);
  },

  mouseLeave: function() {
    this._super();
    _getTimeChartBarTooltipView().tooltipTurnoff(this);
  },

  didInsertElement: function() {
    this.createUIwidgets();
  },
  
  willDestroyElement: function() {
    this.destroyUIwidgets();
  },

  onAsyncLoaded: function() {
    var newId = this.get('viewingContent.scheduleContent.objCdbObjectId');
    if (this.get('viewingContent.scheduleContent.asyncDataLoaded')) {
      if (newId !== this.get('objCdbObjectId')) {
          this.set('objCdbObjectId', newId);
          Ember.run.schedule('afterRender', this, function(){
            this.destroyUIwidgets();
            this.createUIwidgets();
          });
      }
    } else {
        //schedule content has been changed, widgets need to be rerendered
        this.set('objCdbObjectId', null);
    }
  }.observes('viewingContent.scheduleContent.asyncDataLoaded'),

  createUIwidgets: function() {
    var self = this,
        bar = self.$();
    if (!self.get('viewingContent') || !bar || !bar.length) {
      return;
    }
    var parent = bar.parent(),
        minLeft = parent.offset().left,
        maxRight = minLeft + parent.width();
    //drag bar
    if (self.get('viewingContent.scheduleContent.dragableFcast')) {
      bar.draggable({
        axis: 'x',
        //containment: 'window', 
        start: function (event, ui) {
          var width = ui.helper.width();
          //problems since the milestone looks like a 16px element, but when time frame is large
          //and the milestone is 1 day long, the html element can be much smaller than the displayed picture
          width = (width < 16 && self.get('viewingContent.scheduleContent.isMilestone')) ? 16 : width;
          if ((ui.helper.offset().left + width) < event.pageX){
            //click on outside text element is also registered
            //this should not drag the bar
            return false;
          }
          self.set('dragStart', ui.position.left);
          self.set('viewingContent.scheduleContent.isBarDragging', true);
          //self.set('viewingContent.scheduleContent.disableBarComputations', true);
          _getTimeChartBarTooltipView().tooltipShow(self, event);
        },
        stop: function (event, ui) {
          if (!self.get('viewingContent')) {
            return;
          }
          // persist changes
          //self.set('viewingContent.scheduleContent.disableBarComputations', false);
          self.get('viewingContent.scheduleContent').saveStartEndDates(false);
          self.set('viewingContent.scheduleContent.isBarDragging', false);
          _getTimeChartBarTooltipView().tooltipTurnoff(self);
          self.rerender();
        },
        drag: function (event, ui) {
          if (!self.get('viewingContent')) {
            return;
          }
          //change css of selected area, without going through ember framework, which is too slow
          if (self.get('viewingContent.selected')) {
            self.$().closest('.chart-body').children('#selected_area').attr('style', ui.helper.attr('style')).css('top', '0');
          }
          //manual containment to allow for negative left value, which are not supported
          if (event.pageX <= minLeft || event.pageX >= maxRight) {
            return false;
          }
          var offset = ui.position.left - self.get('dragStart'),
              gridStep = self.get('gridStep'),
              isMilestone = self.get('viewingContent.scheduleContent.isMilestone'),
              dragAttr = isMilestone ? 'end_date' : 'start_date',
              attrValue = self.get('viewingContent.scheduleContent').get(dragAttr),
              offsetSteps = Math.round(offset / gridStep);
          if (gridStep) {
            if (Math.abs(offsetSteps) >= 1) {
              self.dragBar(offsetSteps * 24 * 3600);
              self.set('dragStart', self.get('dragStart') + offsetSteps * gridStep);
            }
          }
        }
      });
    } else {
      if (bar.data('ui-draggable')) bar.draggable('destroy');
    }
    //resize bar
    if (self.get('viewingContent.scheduleContent.resizableFcast')) {
      bar.resizable({
        //containment: 'window',
        handles: (self.get('viewingContent.scheduleContent.end_plan_fix')) ? "w" : "e,w",
        minWidth: 0,
        minHeight: 0,
        animate: false,
        start: function (event, ui) {
          if (!self.get('viewingContent')) {
            return;
          }
          if (bar.data('ui-draggable')) bar.draggable('disable');
          self.set('viewingContent.scheduleContent.disableBarComputations', true);
          self.set('resizeStartLeft', ui.position.left);
          self.set('resizeStartWidth', ui.size.width);
          _getTimeChartBarTooltipView().tooltipShow(self, event);
        },
        stop: function (event, ui) {
          if (!self.get('viewingContent')) {
            return;
          }
          self.set('viewingContent.scheduleContent.disableBarComputations', false);
          // persist changes)
          self.get('viewingContent.scheduleContent').saveStartEndDates(false);
          if (bar.data('ui-draggable')) bar.draggable('enable');
          _getTimeChartBarTooltipView().tooltipTurnoff(self);
          self.rerender();
        },
        resize: function (event, ui) {
          if (!self.get('viewingContent')) {
            return;
          }
          //change css of selected area, without going through ember framework, which is too slow
          if (self.get('viewingContent.selected')) {
            self.$().closest('.chart-body').children('#selected_area').attr('style', ui.helper.attr('style')).css('top', '0');
          }
          //manual containment to allow for negative left value, which are not supported
          if (event.pageX <= minLeft || event.pageX >= maxRight) {
            return false;
          }
          
          var offsetLeft = ui.position.left - self.get('resizeStartLeft'),
            offsetRight = ui.size.width - self.get('resizeStartWidth'),
            gridStep = self.get('gridStep'),
            dragAttr = (offsetLeft !== 0) ? 'start_date' : 'end_date',
            attrValue = self.get('viewingContent').get(dragAttr);
          if (gridStep) {
            var roundOffset;
            if (dragAttr === 'start_date') {
              roundOffset = Math.floor(offsetLeft / gridStep);
              if (roundOffset !== 0) {
                self.resizeBar(roundOffset * 24 * 3600, dragAttr);
                self.set('resizeStartLeft', self.get('resizeStartLeft') + roundOffset * gridStep);
                self.set('resizeStartWidth', self.get('resizeStartWidth') + roundOffset * gridStep);
              }
            }else{
              roundOffset = Math.ceil(offsetRight / gridStep);
              if (roundOffset !== 0) {
                self.resizeBar(roundOffset * 24 * 3600, dragAttr);
                self.set('resizeStartWidth', self.get('resizeStartWidth') + roundOffset * gridStep);
              }
            }
          }
        }
      });
    } else {
      if (bar.data('ui-resizable')) bar.resizable('destroy');
    }
  },

  destroyUIwidgets: function() {
    var bar = this.$();
      viewingContent = this.get('viewingContent');
    if (!this.get('viewingContent.scheduleContent.objPermission')) return;
    if (bar && bar.length && viewingContent) {
      //TODO any non-stupid way to find if widget is initialized?
      if (bar.data('ui-draggable')) bar.draggable('destroy');
      if (bar.data('ui-resizable')) bar.resizable('destroy');
    }
  },

  dragBar: function(offset) {
    if (!this.get('viewingContent')) {
      return;
    }
    var start = this.get('viewingContent.scheduleContent.start_date'),
        end = this.get('viewingContent.scheduleContent.end_date');
    this.get('viewingContent.scheduleContent').set('start_date', App.momentConstructor(start).add('second', offset).valueOf());
    this.get('viewingContent.scheduleContent').set('end_date', App.momentConstructor(end).add('second', offset).valueOf());
  },

  resizeBar: function(offset, corner) {
    if (!this.get('viewingContent')) {
      return;
    }
    if (corner === 'start_date'){
      var start = this.get('viewingContent.scheduleContent.start_date');
      this.get('viewingContent.scheduleContent').set('start_date', App.momentConstructor(start).add('second', offset).valueOf());
    }else {
      var end = this.get('viewingContent.scheduleContent.end_date');
      this.get('viewingContent.scheduleContent').set('end_date', App.momentConstructor(end).add('second', offset).valueOf());
    }
  }
});


App.TimeChartPlanBarComponent = Ember.Component.extend(App.SelectionMixin, {
  classNameBindings: ['viewingContent.scheduleContent.customBarClass',
                      'viewingContent.scheduleContent.objPermission::readonly',
                      ':chart-bar',
                      ':lower-bar',
                      'viewingContent.hovered:gantt-hover',
                      'viewingContent.selected:selected'],
  attributeBindings: ['style'],
  gridStep: Ember.computed.alias('settings.scale.pixelsPerDay'),
  viewingContent: Ember.computed.alias('model.referencedObject'),

  objCdbObjectId: null,
  dragStart: 0,

  style: function() {
  return 'width:' + this.get('viewingContent.scheduleContent.barPlanWidth') + 'px;' +
         'left:' + this.get('viewingContent.scheduleContent.barPlanPosition') + 'px;';
  }.property('viewingContent.scheduleContent.barPlanWidth', 'viewingContent.scheduleContent.barPlanPosition'),

  mouseEnter: function(e) {
    this._super();
    this.mouseover=true;
    _getTimeChartBarTooltipView().tooltipShow(this, e);
  },

  mouseLeave: function() {
    this._super();
    _getTimeChartBarTooltipView().tooltipTurnoff(this);
  },
  
  onAsyncLoaded: function() {
    var newId = this.get('viewingContent.scheduleContent.objCdbObjectId');
    if (this.get('viewingContent.scheduleContent.asyncDataLoaded') && 
        (newId !== this.get('objCdbObjectId'))) {
      this.set('objCdbObjectId', newId);
      Ember.run.schedule('afterRender', this, function(){
        this.destroyUIwidgets();
        this.createUIwidgets();
      });
    }
  }.observes('viewingContent.scheduleContent.asyncDataLoaded'),

  didInsertElement: function() {
    this.createUIwidgets();
  },
  
  willDestroyElement: function() {
    this.destroyUIwidgets();
  },

  createUIwidgets: function() {
    var self = this,
        planBar = this.$();
    if (!self.get('viewingContent') || !planBar || !planBar.length) {
      return;
    }
    var parent = planBar.parent(),
        minLeft = parent.offset().left,
        maxRight = minLeft + parent.width();
    if (self.get('viewingContent.scheduleContent.dragablePlan')) {
      //drag planned bar
      planBar.draggable({
        axis: 'x',
        containment: 'window',
        start: function (event, ui) {
          var width = ui.helper.width();
          self.set('dragStart', ui.position.left);
          self.set('viewingContent.scheduleContent.disablePlanBarComputations', true);
          self.set('viewingContent.scheduleContent.isPlanBarDragging', true);
          _getTimeChartBarTooltipView().tooltipShow(self, event);
        },
        stop: function (event, ui) {
          if (!self.get('viewingContent')) {
            return;
          }
          // persist changes
          self.set('viewingContent.scheduleContent.disablePlanBarComputations', false);
          self.get('viewingContent.scheduleContent').saveStartEndPlanDates();
          self.set('viewingContent.scheduleContent.isPlanBarDragging', false);
          _getTimeChartBarTooltipView().tooltipTurnoff(self);
          self.rerender();
        },
        drag: function (event, ui) {
          if (!self.get('viewingContent')) {
            return;
          }
          //manual containment to allow for negative left value, which are not supported
          if (event.pageX <= minLeft || event.pageX >= maxRight) {
            return false;
          }
          var offset = ui.position.left - self.get('dragStart'),
              gridStep = self.get('gridStep'),
              dragAttr = 'start_date_plan',
              attrValue = self.get('viewingContent').get(dragAttr);
          if (gridStep) {
            if (Math.abs(offset) > gridStep) {
              self.dragPlanBar(offset / gridStep * 24 * 3600);
              self.set('dragStart', self.get('dragStart') + offset);
            }
          }
        }
      });
    } else {
      if (planBar.data('ui-draggable')) planBar.draggable('destroy');
    }
},

  destroyUIwidgets: function() {
    var bar = this.$();
      viewingContent = this.get('viewingContent');
    if (!this.get('viewingContent.scheduleContent.objPermission')) return;
    if (bar && bar.length && viewingContent) {
      //TODO any non-stupid way to find if widget is initialized?
      if (bar.data('ui-draggable')) bar.draggable('destroy');
    }
  },

  dragPlanBar: function(offset) {
    if (!this.get('viewingContent')) {
      return;
    }
    var start = this.get('viewingContent.scheduleContent.start_date_plan'),
        end = this.get('viewingContent.scheduleContent.end_date_plan');
    this.get('viewingContent.scheduleContent').set('start_date_plan', App.momentConstructor(start).add('second', offset).valueOf());
    this.get('viewingContent.scheduleContent').set('end_date_plan', App.momentConstructor(end).add('second', offset).valueOf());
  }
});


App.TimeChartRelationsComponent = Ember.Component.extend({
  classNameBindings: [':chart-relations'],
  viewingContent: Ember.computed.alias('model.referencedObject')
});


App.TimeChartRelationComponent = Ember.Component.extend({
  attributeBindings: ['style'],
  classNameBindings: ['isRelationValid::hidden', ':relation-container', 'horizontalBackwards', 'verticalBackwards:verti-backwards', 'typeClass', 'colorClass'],
  relationClass: '',
  minWidth: 20,
  refTable: null,
  predecessorViewingContent: Ember.computed.alias('model.predecessor'),
  predecessorViewIndex: Ember.computed.alias('predecessorViewingContent.refRowIndex'),

  rowHeightFactor: function() {
    var rowHeight = this.get('settings.ppdHeight');
    return rowHeight / (rowHeight - 1);
  }.property('settings.ppdHeight'),

  successorViewingContent: Ember.computed.alias('model.successor'),
  successorViewIndex: Ember.computed.alias('successorViewingContent.refRowIndex'),

  isRelationValid: function() {
    return this.get('predecessorViewingContent.scheduleContent.hasDates') && 
           this.get('successorViewingContent.scheduleContent.hasDates') &&
           (this.get('predecessorViewingContent.refRowIndex') !== null) && 
           (this.get('successorViewingContent.refRowIndex') !== null);
  }.property('predecessorViewingContent.scheduleContent.hasDates', 'successorViewingContent.scheduleContent.hasDates'),
  
  isRelationVisible: function() {
    return this.get('predecessorViewIndex') !== undefined &&
           this.get('predecessorViewIndex') !== null &&
           this.get('successorViewIndex') !== undefined &&
           this.get('successorViewIndex') !== null;
  }.property('predecessorViewIndex', 'successorViewIndex'),

  styles: function() {
    var rType = this.get('model.type'),
        pIndex = this.get('predecessorViewIndex'),
        sIndex = this.get('successorViewIndex'),
        pStart = this.get('predecessorViewingContent.scheduleContent.barPosition'),
        pEnd = this.get('predecessorViewingContent.scheduleContent.barEnd'),
        sStart = this.get('successorViewingContent.scheduleContent.barPosition'),
        sEnd = this.get('successorViewingContent.scheduleContent.barEnd'),
        left = 0,
        width = 0,
        top = 0.5,
        height = Math.abs(sIndex - pIndex),
        horiBackwards = false,
        vertiBackwards = false,
        ppd = this.get('settings.scale.pixelsPerDay');
    if (this.get('predecessorViewingContent.scheduleContent.isMilestone')) {
      pStart = pStart + ppd / 2 - 8;
      pEnd = pEnd - ppd / 2  + 8;
    }
    if (this.get('successorViewingContent.scheduleContent.isMilestone')) {
      sStart = sStart + ppd / 2 - 8;
      sEnd = sEnd - ppd / 2 + 8;
    }
    // horizontal dimension
    if (rType == 'EA') {
      if (sStart >= pEnd) {
        left = pEnd;
        width = sStart - left;
      } else {
        left = sStart;
        width = pEnd - left;
        horiBackwards = true;
      }
    } else if (rType == 'AA') {
      if (sStart >= pStart) {
        left = pStart;
        width = sStart - left;
      } else {
        left = sStart;
        width = pStart - left;
        horiBackwards = true;
      }
    } else if (rType == 'AE') {
      if (sEnd >= pStart) {
        left = pStart;
        width = sEnd - left;
      } else {
        left = sEnd;
        width = pStart - left;
        horiBackwards = true;
      }
    } else if (rType == 'EE') {
      if (sEnd >= pEnd) {
        left = pEnd;
        width = sEnd - left;
      } else {
        left = sEnd;
        width = pEnd - left;
        horiBackwards = true;
      }
    }

    // vertical
    if (pIndex > sIndex) {
      vertiBackwards = true;
      top = top + sIndex - pIndex;
    }
    width = width < 1e-5 ? 0 : width;
    var style = {
        left: left,
        width: width,
        top: top * 100 * this.get('rowHeightFactor'),
        height: height * 100.0 * this.get('rowHeightFactor'),
        bottomHeight: height === 0 ? 0 : 0.5 / height * 100.0
    };
    return [style, horiBackwards, vertiBackwards, rType];
  }.property('model.type', 'successorViewIndex', 'predecessorViewIndex',
      'successorViewingContent.scheduleContent.barPosition','successorViewingContent.scheduleContent.barEnd',
      'predecessorViewingContent.scheduleContent.barPosition', 'predecessorViewingContent.scheduleContent.barEnd', 'rowHeightFactor'),

  style: function() {
    var style = this.get('styles')[0];
    return 'left:' + style.left + 'px;' +
           'width:' + style.width + 'px;' +
           'top:' + style.top + '%;' +
           'height:' + style.height + '%;';
  }.property('styles'),

  styleBottom: function() {
    var style = this.get('styles')[0];
    return 'height:' + (100.0 - style.bottomHeight) + '%;';
  }.property('styles'),

  horizontalBackwards: function() {
    var style = this.get('styles')[0],
        horiBackwards = this.get('styles')[1],
        minWidth = this.get('minWidth'),
        rType = this.get('styles')[3],
        classname = '';
    //  ensure place for connector
    if (rType == 'EA' && ! horiBackwards && style.width < minWidth * 2) {
      horiBackwards = style.width < minWidth;
      classname = 'connector-narrow';
    } else if (rType == 'AE' && horiBackwards && style.width < minWidth * 2) {
      classname = 'connector-narrow';
      horiBackwards = style.width > minWidth;
    }
    return horiBackwards ? 'hori-backwards ' + classname : classname;
  }.property('styles', 'minWidth'),

  verticalBackwards: function() {
    return this.get('styles')[2];
  }.property('styles'),

  typeClass: function() {
    return 'type-' + this.get('styles')[3];
  }.property('styles'),

  colorClass: function() {
    var color = (this.get('model.conflict')) ? 'warning' : 'ok';
    return 'relation-' + color;
  }.property()
});