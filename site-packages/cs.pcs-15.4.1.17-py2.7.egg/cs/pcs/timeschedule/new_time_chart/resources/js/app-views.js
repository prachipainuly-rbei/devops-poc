App.TimeChartBarTooltipView = Ember.View.extend({
  classNameBindings: [':bar-tooltip'],
  attributeBindings: ['style:style'],
  viewName: 'timeChartBarTooltip',
  style: '',
  clientX: 0,
  clientY: 0,
  ctx: null,
  showTooltip: false,

  templateName: function() {
    var ctx = this.get('ctx'),
        templateName = 'time_default-bar-tooltip';
    if (ctx && ctx.get('mouseover')) {
      var scheduleContent = ctx.get('viewingContent.scheduleContent'),
          className = scheduleContent.get('class_name');
      if(className == 'cdbpcs_task' && !scheduleContent.get('isMilestone'))
        templateName = 'time_task-bar-tooltip';
      if(className == 'cdbpcs_task' && scheduleContent.get('isMilestone'))
        templateName = 'time_milestone-bar-tooltip';
      if(className == 'cdbpcs_project' && ctx.get('templateName') != 'chartplanbar')
        templateName = 'time_project-bar-tooltip';
      if(className == 'cdbpcs_project' && ctx.get('templateName') == 'chartplanbar')
        templateName = 'time_project-planbar-tooltip';
    }
    return templateName;
  // changing ctx doesn't trigger templateName anymore
  // most likely since ctx is an ember component and 
  // there have been changes somewhere, so trigger manually 
  //}.property('ctx').cacheable(),
  }.property(),
    
  _templateChanged: function() {
    this.rerender();
  }.observes('ctx'),

  _tooltipShow: function() {
    if (this.get("showTooltip")) {
      this.set("clientX", this.get('_clientX'));
      this.set("clientY", this.get('_clientY'));
      this.set("controller.model", this.get('_model'));
      this.set("ctx", this.get('_ctx'));
      this.notifyPropertyChange('templateName');
    }
  },

  tooltipShow: function(ctx, event) {
    this.set("_clientX", event.pageX);
    this.set("_clientY", event.pageY);
    this.set("_model", ctx.get("viewingContent"));
    this.set("_ctx", ctx);
    this.set("showTooltip", true);
    Ember.run.debounce(this, '_tooltipShow', 1000);
  },

  _tooltipTurnoff: function() {
    //Only TurnOff Tooltip, if there is no Bar dragged and the Event occured over the Bar the tooltip is shown for.-
    var ctx = this.get('ctx');
    if(ctx &&
    !ctx.get('viewingContent.scheduleContent.isBarDragging') &&
    !ctx.get('viewingContent.scheduleContent.isPlanBarDragging')) {
      ctx.set('mouseover', false);
      this.set("controller.model", null);
      this.set('ctx', null);
      this.notifyPropertyChange('templateName');
    }
  },

  tooltipTurnoff: function(ctx) {
    this.set("showTooltip", false);
    Ember.run.debounce(this, '_tooltipTurnoff', 100);
  },

  _registerActiveView: function() {
    var router = App.__container__.lookup('router:main'),
        registeredName = 'timeChartBarTooltip';
    function disconnectActiveView() {
      delete router._activeViews[registeredName];
    }

    router._activeViews[registeredName] = [this, disconnectActiveView];
    this.one('willDestroyElement', router, disconnectActiveView);
  },
  
  didInsertElement: function() {
    //register view manually since it's done by template name which changes
    this._registerActiveView();
    
    var menu = this.$('.chart-tooltip'),
        ctx = this.get('ctx');
    if (!menu.length || !ctx) return;
    var left = this.get('clientX'),
        top = this.get('clientY'),
        menuWidth = menu.outerWidth(true),
        menuHeight = menu.outerHeight(true),
        rightPanel = menu.closest('.right-panel'),
        containerHeight = rightPanel.height(),
        containerOffset = rightPanel.offset(),
        containerOffsetTop = containerOffset.top,
        ppdHeight = this.get('controller.model.scheduleContent.settings.ppdHeight'),
        styleTop = top,
        styleLeft = left - menuWidth / 2;
    //overflow bottom
    if (menuHeight + top > containerHeight + containerOffsetTop) {
      menu.addClass('top');
      styleTop -= menuHeight + ppdHeight;
    } else {
      styleTop += ppdHeight;
      menu.addClass('bottom');
    }
    this.set('style',
        'display: block; ' +
        'top: ' + styleTop + 'px; ' +
        'left: ' + styleLeft + 'px');

  }
});

App.TimeRelationTooltipView = Ember.View.extend({
    classNameBindings: [':relation-tooltip', 'arrowTop:arrow-top:arrow-bottom'],
    viewName: 'timeRelationTooltip',
    templateName: "time_relation-tooltip",
    arrowTop: true,
    
    classLabel: function() {
        var labels = this.get("controller.labels"),
            tempTooltipObj = this.get("controller.relation.tempTooltipObj");
        return tempTooltipObj ? labels.get(tempTooltipObj.get("scheduleContent.class_name")) : "";
    }.property("controller.relation.tempTooltipObj"),
    
    tempTooltipObj: function() {
        var rel = this.get("controller.relation");
        return rel ? rel.get("tempTooltipObj") : null
    }.property("controller.relation.tempTooltipObj"),
    
    _changeStyle: function() {
        style = 'display: none;'
        var domEl = this.get("controller.domEl"),
            ul = this.$("ul"); 
        if (domEl && ul) {
            var offset = domEl.offset(),
                leftPanelTop = this.$().closest(".left-panel").offset().top,
                tableTop = offset.top - leftPanelTop,
                styleTop = tableTop;
            if (tableTop > ((window.innerHeight - leftPanelTop)) / 2) {
                styleTop = styleTop - ul.outerHeight() + domEl.height();
                this.set("arrowTop", false);
            } else {
                this.set("arrowTop", true);
            }
            style = 'display: block; ' +
                'top: ' + styleTop + 'px; ' +
                'left: ' + (offset.left + domEl.width() + 10) + 'px'; 
        } else {
            style = 'display: none; top: 0; left: 0;'
        }
        this.set("style", style);
    },
    
    changeStyle: function() {
        Ember.run.scheduleOnce('afterRender', this, '_changeStyle');
    }.observes("controller.domEl"),
    
    style: 'display: none; top: 0; left: 0;',
    
    _cleanOnRelationDelete: function() {
        if (this.get("controller.relation.__willDeleteSoon")) {
            this.get("controller").setProperties({"relation": null, "domEl": null});
        }
    }.observes("controller.relation.__willDeleteSoon")
});

App.TimeStartEndDatePickerView = Ember.View.extend(App.BaseDatePickerView, {
  saveDate: function() {
    this.get('content').saveStartEndDates(true);
  },
  
  clearDate: function() {
    var content = this.get('content')
    content.set('start_date', null);
    content.set('end_date', null);
    content.saveStartEndDates(true);
  }
});

App.TimeConstraintDatePickerView = Ember.View.extend(App.BaseDatePickerView, {
  saveDate: function() {
    this.get('content').saveConstraintDate();
  },
  
  clearDate: function() {
    var content = this.get('content')
    content.set('constraint_date', null);
    content.saveConstraintDate();
  }
});

///////////////////////////
//Table Cell Views   //
//////////////////////////

App.TimeObj_iconView = App.BaseIconView.extend({});

App.TimeStatus_colorView = Ember.View.extend(App.TableCellBaseView, {
  disabled: false,
  templateName: 'table-cell-views/time-status_color',

  description: function() {
    return this.get('value.description');
  }.property('value.description'),

  style: function() {
    return this.get('value.style');
  }.property('value.style'),

  url: function() {
    return this.get('value.url');
  }.property('value.url'),

  doubleClick: function(evt) {
    evt.stopPropagation();
  },

  actions: {
    changeStatus: function() {
      if (this.get('content.scheduleContent.objPermission') && this.get('url')) {
        window.open(this.get('url'), '_self');
        var contentsStructure = this.get('refTable.contentsStructure');
        contentsStructure.get('refresh').call(contentsStructure);
      }
    }
  }
});

App.TimeTotal_rating_iconView = App.BaseIconView.extend({});

App.TimePspView = Ember.View.extend(App.TableCellBaseView, {});

App.TimeDeleteView = App.BaseDeleteView.extend({
  localRes: window.appSettings.timeChartLocalRes
});

App.TimeTime_signal_iconView = App.BaseIconView.extend({});

App.TimeRelations_buttonsView = Ember.View.extend(App.TableCellBaseView, {
  templateName: 'table-cell-views/time-relations-buttons',

  predecessorsTitle: function() {
    switch(this.get('content.scheduleContent.predecessorsConflict')) {
      case 1:
        return this.get('controller.labels.pcs_pre_conflicts_yes');
      case 0:
        return this.get('controller.labels.pcs_pre_conflicts_no');
      default:
        return this.get('controller.labels.pcs_pre_none');
    }
  }.property('content.scheduleContent.predecessorsConflict'),

  successorsTitle: function() {
    switch(this.get('content.scheduleContent.successorsConflict')) {
      case 1:
        return this.get('controller.labels.pcs_suc_conflicts_yes');
      case 0:
        return this.get('controller.labels.pcs_suc_conflicts_no');
      default:
        return this.get('controller.labels.pcs_suc_none');
    }
  }.property('content.scheduleContent.successorsConflict'),

  predecessorsConflictClass: function() {
    switch(this.get('content.scheduleContent.predecessorsConflict')) {
      case 1:
        return 'conflict';
      case 0:
        return 'no-conflict';
      default:
        return '';
    }
  }.property('content.scheduleContent.predecessorsConflict'),

  successorsConflictClass: function() {
    switch(this.get('content.scheduleContent.successorsConflict')) {
      case 1:
        return 'conflict';
      case 0:
        return 'no-conflict';
      default:
        return '';
    }
  }.property('content.scheduleContent.successorsConflict'),

  actions: {
    openRelationsLeft: function(model) {
      var settings = this.get('settings');
      settings.get('saveColumnVisibility').call(
        settings,
        'predecessorsRelations',
        !settings.get('_columns').findBy('name', 'predecessorsRelations').get('visible')
      );
    },

    openRelationsRight: function(model) {
      var settings = this.get('settings');
      settings.get('saveColumnVisibility').call(
        settings,
        'successorsRelations',
        !settings.get('_columns').findBy('name', 'successorsRelations').get('visible')
      );
    }
  }
});

App.TimeStart_dateView = Ember.View.extend(App.TableCellBaseView, {
  templateName: 'table-cell-views/time-start_date'
});

App.TimeEnd_dateView = Ember.View.extend(App.TableCellBaseView, {
  templateName: 'table-cell-views/time-end_date'
});

App.TimeDurationView = App.BaseEditableView.extend({
  testParsedInput: function(val) {
      return this.get('isInteger').call(this, val);
  },

  parseInput: function(val) {
      return this.get('asInteger').call(this, val);
  },

  disabled: function() {
    return !this.get('content.scheduleContent.isDurationEditable');
  }.property('content.scheduleContent.isDurationEditable'),

  attr: 'duration'
});

App.TimeEffort_fcastView = App.BaseEditableView.extend({
  testParsedInput: function(val) {
    return this.get('isFloat').call(this, val);
  },

  parseInput: function(val) {
      return this.get('asFloat').call(this, val);
  },

  disabled: function() {
    return !this.get('content.scheduleContent.isEffortEditable');
  }.property('content.scheduleContent.isEffortEditable'),

  attr: 'effort_fcast'
});

App.TimeEffort_actView = App.BaseEditableView.extend({
  testParsedInput: function(val) {
    return this.get('isFloat').call(this, val);
  },

  parseInput: function(val) {
      return this.get('asFloat').call(this, val);
  },

  disabled: function() {
    return !this.get('content.scheduleContent.isEffortActEditable');
  }.property('content.scheduleContent.isEffortActEditable'),

  attr: 'effort_act'
});

App.TimeEffort_fcast_dView = App.BaseEditableView.extend({
  testParsedInput: function(val) {
    return this.get('isFloat').call(this, val);
  },

  parseInput: function(val) {
      return this.get('asFloat').call(this, val);
  },

  disabled: function() {
    return !this.get('content.scheduleContent.isEffortDemandEditable');
  }.property('content.scheduleContent.isEffortDemandEditable'),

  attr: 'effort_fcast_d'
});

App.TimeEffort_fcast_aView = App.BaseEditableView.extend({
  testParsedInput: function(val) {
    return this.get('isFloat').call(this, val);
  },

  parseInput: function(val) {
      return this.get('asFloat').call(this, val);
  },

  disabled: function() {
    return !this.get('content.scheduleContent.isEffortAssignmentEditable');
  }.property('content.scheduleContent.isEffortAssignmentEditable'),

  attr: 'effort_fcast_a'
});

App.TimePositionView = App.BaseEditableView.extend({
  testParsedInput: function(val) {
      return this.get('isInteger').call(this, val);
  },

  parseInput: function(val) {
      return this.get('asInteger').call(this, val);
  },

  disabled: function() {
    return !this.get('content.scheduleContent.isPositionEditable');
  }.property('content.scheduleContent.isPositionEditable'),

  attr: 'position'
});

App.TimeRelationsView = Ember.View.extend(App.TableCellBaseView, {
  templateName: '',
  editMode: false,
  hasRelations: function() {
    return this.get('content.scheduleContent.hasRelations');
  }.property('content', 'hasRelations'),
  
  actions: {
    openEditMode: function() {
      this.set('editMode', true);
    }
  }
});

App.TimePredecessorsRelationsView = App.TimeRelationsView.extend({
  disabled: false,
  is_successor: true,
  templateName: 'table-cell-views/time-relations-pre'
});

App.TimeSuccessorsRelationsView = App.TimeRelationsView.extend({
  disabled: false,
  is_successor: false,
  templateName: 'table-cell-views/time-relations-suc'
});

App.TimeRelationsDisplayView = Ember.Mixin.create({
  templateName: '',
  disabled: false
});

App.TimePredecessorsRelationsDisplayView = Ember.View.extend(App.TimeRelationsDisplayView, {
  is_successor: true,
  templateName: 'time_relations-pre-display'
});

App.TimeSuccessorsRelationsDisplayView = Ember.View.extend(App.TimeRelationsDisplayView, {
  is_successor: false,
  templateName: 'time_relations-suc-display'
});

App.TimeRelationsEditView = Ember.Mixin.create({
  templateName: '',
  disabled: false,
  inputValue: "",
  _throwParseErrorMessage: 'parseError',
  _breakRelationsRegExp: new RegExp(/[\+|\-]/),
  
  click: function(evt) {
    evt.stopPropagation();
  },
  
  doubleClick: function(evt) {
    evt.stopPropagation();
  },
  
  keyPress: function(evt) {
    evt.stopPropagation();
    switch (evt.keyCode) {
      case 13: //enter
        //save
        this.$('input').trigger('blur');
        break;
      case 27: //esc
        //revert
        this.get('parentView').set('editMode', false);
        break;
      default:
    }
  },
  
  focusOut: function(evt) {
    var ok = this.parseNewRelations();
    this.get('parentView').set('editMode', false);
  },
  
  _makeRelObj: function(type, index, minimal_gap) {
    return {
      'type': type,
      'index': index,
      'minimal_gap': minimal_gap
    }
  },
  
  _parseRelationStr: function(relStr) {
    var index = relStr.search(this._breakRelationsRegExp);
        relTypeAndIndex = (index !== -1) ? relStr.slice(0, index).trim() : relStr.trim(),
        relGap = (index !== -1) ? parseInt(relStr.slice(index).trim(), 10) : null,
        relType = "",
        relIndex = -1;
    if (/^[0-9]+$/.test(relTypeAndIndex)) {
      relType = this.get('settings.rel_default');
      relIndex = parseInt(relTypeAndIndex, 10);
    } else {
      var relTypeMatch = relTypeAndIndex.match(this.get('_getTypeRelationsRegExp'));
      if (relTypeMatch === null) {
        relType = null;
        relIndex = parseInt(relTypeAndIndex, 10);
      } else {
        relType = relTypeMatch[0];
        relIndex = parseInt(relTypeAndIndex.slice(relType.length), 10);
      }
    }
    return this._makeRelObj(relType, relIndex, relGap);
  },
  
  _searchRelInArr: function(type, index, arr) {
    var l = arr.length,
        tempObj = {};
    for(i = 0; i < l; i++) {
      tempObj = arr[i];
      if (tempObj.type === type && 
            (tempObj.index === index ||
                (Number.isNaN(tempObj.index) && Number.isNaN(index))
            )
          ) {
        return i;
      }
    }
    return -1
  },
  
  parseNewRelations: function() {
    var self = this,
        relations = this.get('relations'),
        oldRelationsArray = relations._toString().split(","),
        re = new RegExp(/\,/),
        newRelationsArray = this.$("input")[0].value.toUpperCase().split(",");
        newRelationsArray = newRelationsArray.map(function(item) {
          return item.trim().replace(re, "");
        }).filter(function(item) {
          return item.length;
        });
        oldRelObjs = [],
        newRelObjs = [],
        deletedRelations = [], 
        movedRelations = [],
        newRelations = [],
        newIndex = 0,
        oldIndex = 0,
        contentsStructure = this.get('context.refTable.contentsStructure'),
        sCSs = contentsStructure.get('all').call(contentsStructure);
    oldRelationsArray.pop() // remove "" due to trailing coma
    oldRelObjs = oldRelationsArray.map(function(rel) {
      return self._parseRelationStr(rel);
    });
    newRelObjs = newRelationsArray.map(function(rel) {
      return self._parseRelationStr(rel);
    });
    oldRelObjs.forEach(function(obj, index) {
      newIndex = self._searchRelInArr(obj.type, obj.index, newRelObjs);
      if (newIndex === -1) {
        //deleted relation
        deletedRelations.push(relations.objectAt(index));
      } else {
        // changed relation ?
        if (oldRelObjs[index].minimal_gap !== newRelObjs[newIndex].minimal_gap) {
          movedRelations.push({'relation': relations.objectAt(index), 'minimal_gap': newRelObjs[newIndex].minimal_gap})
        }
      }
    });
    newRelObjs.forEach(function(obj, index) {
      oldIndex = self._searchRelInArr(obj.type, obj.index, oldRelObjs);
      if (oldIndex === -1) {
        //new relation
        newRelations.push(obj)
      }
    });
    try {
      newRelations.forEach(function(relObj) {
        self._validateNewRelation(relObj, sCSs);
      });
    } catch(ex) {
      if (ex.message === this._throwParseErrorMessage) {
        return false;
      };
    }
    this.deleteRelations(deletedRelations);
    this.moveRelations(movedRelations);
    this.createRelations(newRelations);
    return true;
  },
  
  _validateNewRelation: function(rel, sCSs) {
    var contentIndex = this.get('content.index');
    if (this.get('settings.rel_types').indexOf(rel.type) === -1) {
      alertCDBMessage(
        this.get('controller.labels.cdbpcs_gantt_invalid_relation_type'), 
        'cdbpcs_gantt_invalid_relation_type');
      throw new Error(this._throwParseErrorMessage);
    }
    if (!Number.isInteger(rel.index) ||
        rel.index < 0 ||
        rel.index > sCSs.length)
    {
      alertCDBMessage(
        this.get('controller.labels.cdbpcs_gantt_relation_successor_existance'), 
        'cdbpcs_gantt_relation_successor_existance');
      throw new Error(this._throwParseErrorMessage);
    }
    if (rel.index === this.get('content.index')) {
      alertCDBMessage(
        this.get('controller.labels.cdbpcs_gantt_create_relations_error_same'), 
        'cdbpcs_gantt_create_relations_error_same');
      throw new Error(this._throwParseErrorMessage);
    }
    var is_successor = this.get('is_successor')
        predSCC = is_successor ? sCSs[rel.index-1] : sCSs[contentIndex-1],
        succSCC = is_successor ? sCSs[contentIndex-1] : sCSs[rel.index-1];
    if (!predSCC.get('scheduleContent.hasRelations') || 
        !succSCC.get('scheduleContent.hasRelations')) {
      alertCDBMessage(
        this.get('controller.labels.cdbpcs_gantt_create_relations_error_tasks'), 
        'cdbpcs_gantt_create_relations_error_tasks');
      throw new Error(this._throwParseErrorMessage);
    } else {
        if (succSCC.get('scheduleContent.is_group') && 
            this.get('settings.allowed_task_group_dependecies').indexOf(rel.type) === -1) 
        {
            alertCDBMessage(
                this.get('controller.labels.cdbpcs_task_group_rel_not_allowed'), 
                'cdbpcs_task_group_rel_not_allowed');
            throw new Error(this._throwParseErrorMessage);
        }
        
    }
  },
  
  deleteRelations: function(deletedRelations) {
    if (deletedRelations.length) {
      var contentsStructure = this.get('context.refTable.contentsStructure');
      contentsStructure.get('deleteRelations').call(contentsStructure, deletedRelations);
    }
  },
  
  moveRelations: function(movedRelations) {
    if (movedRelations.length) {
      var contentsStructure = this.get('context.refTable.contentsStructure');
      contentsStructure.get('moveRelations').call(
        contentsStructure, 
        movedRelations
      );
    }
  },
  
  createRelations: function(newRelations) {
    if (newRelations.length) {
      var self = this,
          contentsStructure = this.get('context.refTable.contentsStructure'),
          is_successor = this.get('is_successor'),
          sCSs = contentsStructure.get('all').call(contentsStructure),
          thisID = this.get('content.scheduleContent.objCdbObjectId'),
          otherID = "";
      contentsStructure.get('createRelations').call(
        contentsStructure,
        newRelations.map(function(rel) {
          otherID = sCSs.objectAt(rel.index - 1).get('scheduleContent.objCdbObjectId');
          return {
            'successorID': (is_successor) ? thisID : otherID,
            'predecessorID': (is_successor) ? otherID : thisID,
            'type': rel.type,
            'minimal_gap': rel.minimal_gap,
          }
        })
      );
    }
  },
  
  didInsertElement: function() {
    Ember.run.schedule('afterRender', this, function(){
      this.$('input').focus();
      this.set('inputValue', this.get('relations')._toString()); //set value after focus such that cursor is at the end!
      this.set('_getTypeRelationsRegExp', new RegExp(this.get('settings.rel_types').join('|')));
    });
  }
});

App.TimePredecessorsRelationsEditView = Ember.View.extend(App.TimeRelationsEditView, {
  is_successor: true,
  templateName: 'time_relations-pre-edit'
});

App.TimeSuccessorsRelationsEditView = Ember.View.extend(App.TimeRelationsEditView, {
  is_successor: false,
  templateName: 'time_relations-suc-edit'
});

App.TimeRelationView = Ember.View.extend({
    templateName: '',
    is_successor: null,
    mouseIsIn: false,
    tooltipTimeDelay: 500,
    
    fixLabel: function() {
      return (this.get('is_successor')) ?
          this.get('controller.labels.pcs_predecessor') + ' '  + this.get('controller.labels.pcs_show') :
          this.get('controller.labels.pcs_successor') + ' '  + this.get('controller.labels.pcs_show');
    }.property('is_successor'),

    doubleClick: function(evt) {
      evt.stopPropagation();
    },
    
    mouseEnter: function(evt) {
        var self = this;
        self.set('mouseIsIn', true);
        Ember.run.later(self, function() {
            if (self.get('mouseIsIn')) {
                var timeRelationTooltipView = App.__container__.lookup('router:main')._activeViews['timeRelationTooltip'][0];
                if (timeRelationTooltipView) {
                    var relation = self.get('model');
                    if (relation) {
                      var tempTooltipObjID = self.get('is_successor') ? relation.get('predecessorID') : relation.get('successorID');
                      relation.getTempTooltipObj(tempTooltipObjID);
                      timeRelationTooltipView.get('controller').setProperties({'relation': relation, 'domEl': self.$()});
                    }
                }
            }
        }, self.get("tooltipTimeDelay"));
    },
    
    mouseLeave: function(evt) {
        var self = this;
        self.set('mouseIsIn', false);
        Ember.run.later(self, function() {
          var timeRelationTooltipView = App.__container__.lookup('router:main')._activeViews['timeRelationTooltip'][0];
            if (timeRelationTooltipView) {
                timeRelationTooltipView.get('controller').setProperties({'relation': null, 'domEl': null});
            }
        }, self.get("tooltipTimeDelay"));
    },

    actions: {
      deleteRelation: function(relation) {
        relation.set('__willDeleteSoon', true);
        var contentsStructure = this.get('context.refTable.contentsStructure'),
            parentView = this.get('parentView');
        contentsStructure.get('deleteRelations').call(contentsStructure, [relation]);
      },

      fixOther: function(relation) {
        var contentsStructure = this.get('context.refTable.contentsStructure'),
            parentView = this.get('parentView');
        contentsStructure.get('toggleInScheduleAction').call(
          contentsStructure,
          this.get('is_successor') ?
            relation.get('predecessorID'):
            relation.get('successorID'),
          true
        );
        if (this.get('is_successor')) {
          var predecessor = relation.get('predecessor');
          if (predecessor) {
            predecessor.get('scheduleContent.delete').toggleProperty('inSchedule');
          } else {
            //data loaded but not displayed (collapsed or scrollbar)
            var scheduleContent = contentsStructure.get('_scheduleContents.content').findBy(
                'objCdbObjectId', 
                relation.get('predecessorID')
            );
            if (scheduleContent) scheduleContent.get('delete').toggleProperty('inSchedule');
          }
        } else {
          var is_successor = relation.get('is_successor');
          if (is_successor) {
            successor.get('scheduleContent.delete').toggleProperty('inSchedule');
          } else {
            //data loaded but not displayed (collapsed or scrollbar)
            var scheduleContent = contentsStructure.get('_scheduleContents.content').findBy(
                'objCdbObjectId', 
                relation.get('successorID')
            );
            if (scheduleContent) scheduleContent.get('delete').toggleProperty('inSchedule');
          }
        }
      }
    }
});

App.TimeRelationPreView = App.TimeRelationView.extend({
  is_successor: true,
  templateName: 'time_relation-pre'
});

App.TimeRelationSucView = App.TimeRelationView.extend({
  is_successor: false,
  templateName: 'time_relation-suc'
});

App.TimeEarly_positionView = App.BaseCheckboxView.extend({

    visible: function() {
        return this.get('content.scheduleContent.isEarlyPositionVisible');
    }.property('content.scheduleContent.isEarlyPositionVisible'),
  
    disabled: function() {
        return !this.get('content.scheduleContent.isEarlyPositionEditable');
    }.property('content.scheduleContent.isEarlyPositionEditable'),

    attrName: 'early_position'
});

App.TimeTitleView = App.BaseTitleView.extend({});

App.TimeAutomaticView = App.BaseCheckboxView.extend({

    visible: function() {
        return this.get('content.scheduleContent.isAutomaticVisible');
    }.property('content.scheduleContent.isAutomaticVisible'),
    
    disabled: function() {
        return !this.get('content.scheduleContent.isAutomaticEditable');
    }.property('content.scheduleContent.isAutomaticEditable'),

    attrName: 'automatic'
});

App.TimeAuto_update_timeView = App.BaseCheckboxView.extend({

    visible: function() {
        return this.get('content.scheduleContent.isAutoUpdateTimeVisible');
    }.property('content.scheduleContent.isAutoUpdateTimeVisible'),
    
    disabled: function() {
        return !this.get('content.scheduleContent.isAutoUpdateTimeEditable');
    }.property('content.scheduleContent.isAutoUpdateTimeEditable'),

    attrName: 'auto_update_time'
});

App.TimeConstraint_dateView = Ember.View.extend(App.TableCellBaseView, {
  templateName: 'table-cell-views/time-constraint_date'
});

App.TimeOperationsView = App.BaseOperationsView.extend({});