/**
 * components
 */

App.BaseTableCellComponent = Em.Component.extend({
  chartType: null,
  column: null,
  viewingContent: null,
  refTable: null,

  classNameBindings: [':schedule-table-column',
                      'column.format',
                      'column.name',
                      'column.clickable:clickable'],

  attributeBindings: ['style'],
  style: Ember.computed.alias('column.columnStyle'),
  
  cellView: function() {
    var format = this.get('column.format');
    view = App.get(this.get('chartType').capitalize() + this.get('column.name').capitalize() + 'View');
    if (!view && format) {
      view = App.get('Base' + format.capitalize() + 'View');
    }
    return view ? view : App.BaseDefaultTextView;
  }.property('column')
});

/* Components to be used in handlebars templates */
App.BaseTimeScaleControlComponent = Ember.Component.extend({

    classNames: ['btn-toolbar'],

    actions: {
        left: function() {
          this.get('model').moveLeft();
        },
        today: function() {
          this.get('model').centerOnToday();
        },
        right: function() {
          this.get('model').moveRight();
        },
        zoomin: function() {
          if (!this.get('model.zoomInDisabled')) this.get('model').zoomIn();
        },
        zoomout: function() {
          if (!this.get('model.zoomOutDisabled')) this.get('model').zoomOut();
        }
    }

});

App.BaseTimeScaleHeaderComponent = Ember.Component.extend({
  classNames: ['time-scale-header-viewport'],
  minHeaderWidth: 500,
  firstRender: true,

  didInsertElement: function() {
    var self = this;
    Ember.run.scheduleOnce('afterRender', this, 'runAfterRender');
    if (self.get('firstRender')) {
      Ember.$(window).on('resize', function(evt) {
        if (evt.isManuallyTriggered || (evt.originalEvent && evt.originalEvent.target === window)) {
            self.handleResizeDebounce();
        }
      });
      self.set('firstRender', false);
    }
  },

  willDestroyElement: function() {
    this.destroyUIwidgets(this.$('.time-scale-header'));
  },

  destroyUIwidgets: function(hdrDiv) {
    if (hdrDiv.data('ui-draggable')) hdrDiv.draggable('destroy');
    if (hdrDiv.data('ui-droppable')) hdrDiv.draggable('destroy');
  },

  runAfterRender: function() {
    var self = this;
    self.handleResize();
    // Drag
    var hdrDiv = self.$('.time-scale-header');
    this.destroyUIwidgets(hdrDiv);
    self.$().droppable({
        accept: hdrDiv
    });
    hdrDiv.draggable({
      axis: "x",
      helper: "clone",
      scroll: false,
      start: function() {
        hdrDiv.addClass('hide-trick');
      },
      stop: function(event, ui) {
        hdrDiv.removeClass('hide-trick');
        self.get('model').scrollByPixels(ui.position.left);
      }
    });
  },
  
  handleResize: function() {
    var containerWidth = 0,
        viewport_width = this.$().width(),
        old_viewport_width = this.get('model.viewportWidth'),
        minHeaderWidth = this.get('minHeaderWidth'),
        container = this.$().closest('#elink_page_content'),
        leftPanelWidth = this.get('settings.globalSettings.leftPanelWidth'),
        pageTitleAndContainer = container.add($('#elink_page_title'));
    if (leftPanelWidth > $(window).width()) { //condition true when too many columns are displayed !
      containerWidth = leftPanelWidth + minHeaderWidth + 1;
      pageTitleAndContainer.css({
        'width': containerWidth,
      });
      viewport_width = minHeaderWidth;
    } else {
      if (viewport_width <= minHeaderWidth) {
        containerWidth = minHeaderWidth - viewport_width + container.width();
        pageTitleAndContainer.css({
          'width': containerWidth,
        });
        viewport_width = minHeaderWidth;
      } else {
        pageTitleAndContainer.css({
          'width': '100%',
          'overflow-x': 'hidden'
        });
      }
    }
    if (old_viewport_width !== viewport_width) {
        this.get('model').resizeTo(viewport_width);
    }
  },

  handleResizeDebounce: function() {
      // use debounce, so that the refresh after resize happens only when the
      // user stops changing the window size.
    //width of this.$() is auto
    //browser can take very long to update it
    //if the next 2 lines seem stupid and you make changes, test if going from large page to small page (viewport_width < minHeaderWidth) and back is correct!!
    Ember.run.debounce(this, this.rerender, 150);
    Ember.run.debounce(this, this.handleResize, 150);
  },

  actions: {
      zoom_to: function(cell) {
          this.get('model').zoomTo(cell.get('startOfPeriod'), cell.get('nextStartDate'));
      }
  }

});

App.SelectionMixin = Ember.Mixin.create({
  chartType: null,
  lastClickTimestamp: 0,
  dblClickMaxInterval: 300,

  openDialog: function() {
    this.get('viewingContent.scheduleContent').performDoubleClickOperation();
  },

  //https://bugzilla.mozilla.org/show_bug.cgi?id=238041
  //evt.timeStamp useless in FF
  doubleClick: function(evt){
    if (this.get('viewingContent')) evt.stopPropagation();
    this.set('lastClickTimestamp', (new Date()).getTime() + this.get('dblClickMaxInterval'));
    var viewingContent = this.get('viewingContent'),
        selection = this.get('settings.selection');
    if (viewingContent && selection) {
      //select
      selection.deselectItems();
      selection.set('lastSelected', viewingContent);
      viewingContent.toggleProperty('selected');
      //operation
      Ember.run.scheduleOnce('afterRender', this, 'openDialog');
    }
  },

  click: function(evt) {
    if (this.get('viewingContent')) evt.stopPropagation();
    var self = this,
      timeStamp = (new Date()).getTime();
    Ember.run.debounce(self, function(){
      if (timeStamp === self.get('lastClickTimestamp')) {
        self.send('selectItem', evt, self);
      }
    }, self.get('dblClickMaxInterval'));
    if (timeStamp > self.get('lastClickTimestamp')) {
      self.set('lastClickTimestamp', timeStamp);
    }
  },

  mouseEnter: function(evt) {
    this.send('hoverItem', evt, this);
  },

  mouseLeave: function(evt) {
    this.send('stopHoveringItem', evt, this);
  },

  actions:{
    selectItem: function(evt, view) {
      var selection = this.get('settings.selection');
      if (!evt.ctrlKey) {
          selection.deselectItems();
      }
      var structObj = this.get('viewingContent');
      selection.set('lastSelected', structObj);
      if(structObj !== undefined) {
          structObj.toggleProperty('selected');
      }
    },
    hoverItem: function(evt, view) {
      var selection = this.get('settings.selection'),
          viewingContent = this.get('viewingContent');
      if (selection && viewingContent) {
        viewingContent.set('hovered', true);
        selection.set('lastHovered', viewingContent);
      }
    },
    stopHoveringItem: function(evt, view) {
      var selection = this.get('settings.selection'),
          viewingContent = this.get('viewingContent');
      if (selection && viewingContent) {
        viewingContent.set('hovered', false);
        selection.set('lastHovered', null);
      }
    }
  }
});

App.ChartPluginComponentMixin = Ember.Mixin.create({
    model: null,
    disabledClickElements: '#search_filter',
    noDeselectClickElements: '',
    
    didInsertElement: function() {
      var self = this,
          container = self.$();
      Ember.$(window).on('resize', function(evt) {
        if (evt.originalEvent && (evt.originalEvent.target === window || evt.originalEvent.type == 'chartRatioModified')) {
            Ember.run.once(self, 'handleResizeDebounce');
        }
      });
      self.handleResize();
      $('body').on('click', '#elink_page_content', function(e) {
        if (e.originalEvent && !e.originalEvent.noDeselect) {
          self.get('settings.selection').deselectItems();
        }
      });
      container.on('click', self.get('disabledClickElements'), function(e) {
        e.stopPropagation();
      });
      container.on('click', self.get('noDeselectClickElements'), function(e) {
        if (e.originalEvent) e.originalEvent.noDeselect= true;
      });
    },

    handleResizeDebounce: function() {
        Ember.run.debounce(this, this.handleResize, 150);
    },
    
    handleResize: function() {
      var rightPanel = this.$().find('.right-panel'),
          rightPanelHeight = rightPanel.height(),
          chartBodyHeight = rightPanelHeight -
            $.makeArray(rightPanel.children(':not(.chart-body)')).map(
                function(content, index) {
                  return $(content).outerHeight(true);
                }
            ).reduce(
                function(a,b) {
                  return a+b;
                },
                0
            ),
          ppdHeight = this.get('settings.ppdHeight'),
          numRows = Math.floor(chartBodyHeight / ppdHeight);
      numRows = numRows < 0 ? 0 : numRows;
      this.get('model').setProperties({
        'numRows': numRows
      });
    }
});

App.BaseScheduleTableComponent = Ember.Component.extend({
  classNames: ['schedule-table'],
  attributeBindings: ["style"],
  height: 0,
  _insertbeforeID: null,
  chartType: null,
  
  redoColumnResizableAfterRerender: function() {
      Ember.run.schedule('afterRender', this, function(){
          this.destroyColumnsResizable();
          this.columnsResizable();
      });
  }.observes('settings.columns'),
  
  columnsResizable: function() {
      var self = this,
          columns = this.$('.schedule-table-header > .schedule-table-header-column:not(.order)');
      columns.resizable({
          handles: "e",
          animate: false, 
          stop: function (event, ui) {
              var el = $(ui.element),
                  settings = self.get('settings');
              settings.get('updateColumnWidth').call(settings, el.attr('name'), el.width());
          }
      })
  },
  
  destroyColumnsResizable: function() {
      var columns = this.$('.schedule-table-header > .schedule-table-header-column:not(.order)');
      if (columns.data('ui-resizable')) {
          columns.resizable('destroy');
      }
  },

  rowsSortable: function() {
      var self = this;
      self.$().sortable({
          items: ".schedule-table-row.root-content",
          cancel: ".schedule-table-row:not(.root-content), .schedule-table-row.dummy-element",
          axis: "y",
          containment: "parent",
          cursor: "move",
          delay: 100,
          distance: 5,
          tolerance: "pointer",
          forceHelperSize: true,
          appendTo: 'parent',
          helper: function(event, rootElement) {
            var dummy = $('<div/>').append(rootElement.clone()),
              element = rootElement.next();
            while (!element.hasClass('root-content') && !element.hasClass('dummy-element') && element.length) {
              dummy.append(element.clone());
              element.hide();
              element = element.next();
            }
            return dummy;
          }
      }).on("sortstart", function(event, ui) {
          ui.helper.css('height', 'auto');
          ui.placeholder.height(ui.helper.height());
      }).on("sortbeforestop", function(event, ui) {
          //cannot call 'cancel' here: http://bugs.jqueryui.com/ticket/6054
          //however in stop we don't have placeholder anymore
          //so we save the id here
          var nextRows = ui.placeholder.nextAll('.schedule-table-row.root-content');
          self.set('_insertbeforeID', nextRows.length ? nextRows[0].attributes["data-objcdbobjectid"].value : undefined);
      }).on("sortstop", function(event, ui) {
          var contentsStructure = self.get('model.contentsStructure');
          contentsStructure.get('switchItems').call(
            contentsStructure,  
            ui.item.attr('data-objCdbObjectId'), 
            self.get('_insertbeforeID')
          );
          $(this).sortable('cancel');
          self.$().find('.schedule-table-row').each(function() {
            $(this).css('display', 'block');
          });
      });
  },
  
  didInsertElement: function() {
      Ember.run.scheduleOnce('afterRender', this, 'calculateHeight');
      this.rowsSortable();
      this.columnsResizable();
  },

  willDestroyElement: function() {
    this.$().sortable('destroy');
    this.destroyColumnsResizable();
  },

  calculateHeight: function() {
    var parent = this.$().parent(),
        height = parent.height(),
        width = parent.width(),
        sibling = null;
    this.$().siblings().each(function() {
      sibling = $(this);
      if (sibling.contents().length && sibling.width() === width) height -= sibling.height(); //remove resizable handle and stuff
    });
    this.set('height', height);
  }.observes('App.windowHeight'),

  style: function() {
    var width = this.get('settings.totalColumnsWidth'),
        leftPanelWidth = this.get('settings.globalSettings.leftPanelWidth');
    width = width >= leftPanelWidth ? width : leftPanelWidth;
    return 'height:' + this.get('height') + 'px; ' +
           'width:' + width + 'px;';
  }.property('height', 'settings.totalColumnsWidth', 'settings.globalSettings.leftPanelWidth'),

  tableContentHeight: function() {
    return this.get('height'); // - this.$('.schedule-table-header').height();
  }.property('height')
});

App.BaseScheduleTableRowComponent = Ember.Component.extend(App.SelectionMixin, {
  chartType: null,
  classNameBindings: ['viewingContent.selected:selected',
                      'viewingContent.hovered:gantt-hover',
                      'isMarked:globally-marked',
                      ':schedule-table-row',
                      'isRoot:root-content',
                      'viewingContent::dummy-element',
                      'viewingContent.scheduleContent.planning_status',
                      'viewingContent.scheduleContent.cssClass',
                      'viewingContent.scheduleContent.drawBold:draw-bold',
                      'viewingContent.scheduleContent.isDiscarded:draw-transparent'],

  viewingContent: Ember.computed.alias('model.referencedObject'),
  attributeBindings: ['objCdbObjectId:data-objCdbObjectId', 'style:style'],
  objCdbObjectId: Ember.computed.alias('viewingContent.scheduleContent.objCdbObjectId'),
  
  isRoot: function() {
    var content = this.get('viewingContent');
    return content && !content.get('level');
  }.property('viewingContent'),

  isMarked: function() {
    var obj = this.get('viewingContent.scheduleContent'),
        markedObjects = this.get('settings.selection.markedObjects');
    // time selection
    if (obj && $.isArray(markedObjects)) {
      return (markedObjects.contains) ? this.get('settings.selection.markedObjects').contains(obj.get('objCdbObjectId')) : false;
    }
    // resource selection
    if (obj && markedObjects.get('constructor').toString() === "Ember.Object") {
        var marked_objects_attrs = window.appSettings.resources_marked_objects_attrs.findBy("classname", obj.get('class_name'));
        if (marked_objects_attrs) {
            return markedObjects.get(marked_objects_attrs.attr_name).contains(obj.get(marked_objects_attrs.key));
        } else {
            return false;
        }
    }
    return false;
    
  }.property('viewingContent.scheduleContent.objCdbObjectId', 'settings.selection.markedObjects')
});

App.WithScrollMixin = Ember.Mixin.create({
  scrollBarView: Ember.computed.alias('model.contentsStructure.scrollBarView'),
  
  scrollOn: function() {
    var scrollBarView = this.get('scrollBarView');
    this.$().on('wheel', function(e) {
      //don't handle event twice, here and scrollBarView
      if (e.target !== scrollBarView.get('scrollableElement')[0]) {
        if (e.originalEvent.deltaY > 0) {
          scrollBarView.incrementProperty('scrollTicks');
        } else {
          scrollBarView.decrementProperty('scrollTicks');
        };
        Ember.run.debounce(scrollBarView, scrollBarView.get('externalScrollFunction'), scrollBarView.get('scrollDelay'));
      }
    });
  },
  
  scrollOff: function() {
    this.$().off('wheel');
  }
});

App.BaseChartLeftPanelComponent = Ember.Component.extend(App.WithScrollMixin, {
  classNames: ['left-panel'],
  attributeBindings: ['style'],

  style: function() {
    return 'width: ' + this.get('settings.globalSettings.leftPanelWidth') + 'px';
  }.property('settings.globalSettings.leftPanelWidth'),

  didInsertElement: function() {
    var self = this,
        leftPanel = self.$();
    leftPanel.resizable({
      axis: 'x',
      containment: 'parent',
      handles: "e",
      minWidth: this.get('settings.globalSettings.collapsed_left_panel_width'),
      animate: false,
      ghost: true,
      stop: function (event, ui) {
        var globalSettings = self.get('settings.globalSettings');
        globalSettings.get('updateLeftPanelWidth').call(globalSettings, Math.round(ui.size.width));
        if (globalSettings.get('columns_collapsed')) globalSettings.updateColumnsCollapsed();
        self.notifyPropertyChange('style');
      }
    });
    self.scrollOn();
  },

  willDestroyElement: function() {
    var leftPanel = this.$();
    if (leftPanel.data('ui-resizable')) leftPanel.resizable('destroy');
    this.scrollOff();
  }
});

App.BaseChartRightPanelComponent = Ember.Component.extend(App.WithScrollMixin, {
  classNames: ['right-panel'],
  didInsertElement: function() {
    this.scrollOn();
  },
  willDestroyElement: function() {
    this.scrollOff();
  }
});

App.BaseScrollBarComponent = Ember.Component.extend({
  classNameBindings: [':scroll-bar-container', 'displayScrollBar::hidden'],
  numRows: Ember.computed.alias('model.numRows'),
  numEntries: Ember.computed.alias('model.numEntries'),
  ppdHeight: Ember.computed.alias('settings.ppdHeight'),
  indexTop: Ember.computed.alias('model.indexTop'),
  scrollDelay: 100,
  scrollSensitivity: 1,
  scrollableElement: null,

  displayScrollBar: function() {
    return (this.get('model.numRows') < this.get('model.numEntries'));
  }.property('model.numRows', 'model.numEntries'),

  _scrollTop: function() {
    if (!this.get('displayScrollBar') && this.get('indexTop')) this.set('indexTop', 0);
  }.observes('displayScrollBar'),

  parentHeight: function() {
    return this.get('ppdHeight') * (this.get('numRows') + 2);
  }.property('numRows', 'ppdHeight'),

  contentHeight: function() {
    return this.get('ppdHeight') * (this.get('numEntries') + 3);
  }.property('numEntries', 'ppdHeight'),

  scrollParentStyle: function() {
    var scrollableElement = this.get('scrollableElement');
    var additionalStyle = '';
    if (scrollableElement) {
      var topPosition = scrollableElement.parents('.left-panel').offset().top;
      additionalStyle = ';top:' + topPosition + 'px';
    }
    return 'height: ' + this.get('parentHeight') + 'px' + additionalStyle;
  }.property('parentHeight'),

  scrollContentStyle: function() {
    return 'height: ' + this.get('contentHeight') + 'px';
  }.property('contentHeight'),

  externalScrollFunction: function() {
    var newIndexTop = this.get('indexTop') + this.get('scrollTicks') * this.get('scrollSensitivity');
    newIndexTop = Math.min(Math.max(newIndexTop, 0), this.get('numEntries'));
    if (newIndexTop !== this.get('indexTop')) {
      //Set indexTop here and scrollbar is not scrolled.
      //Scoll bar manually and the scroll event handler scrollFunction is called.
      //No good way to distinguish in handler between .scrollTop(x) and user scroll,
      //so we leave all scrolling for one function
      this.get('scrollableElement').scrollTop((newIndexTop + 0.5) * this.get('ppdHeight'));
    }
    this.set('scrollTicks', 0);
  },
  
  scrollFunction: function() {
    var pxOffset = Math.max(0, this.get('scrollableElement').scrollTop() - 2),
        newIndexTop = Math.floor(pxOffset / this.get('ppdHeight'));
    if (newIndexTop !== this.get('indexTop')) {
      this.get('model').set('indexTop', newIndexTop);
    }
  },

  didInsertElement: function() {
    var self = this,
        scrollableElement = self.$('.scroll-bar-parent');
    self.set('scrollableElement', scrollableElement);
    scrollableElement.on('scroll', function(e) {
      e.stopPropagation();
      Ember.run.debounce(self, self.get('scrollFunction'), self.get('scrollDelay'));
    });
    self.get('model.contentsStructure').set('scrollBarView', self);
  },

  willDestroyElement: function() {
    self.get('scrollableElement').off('scroll');
    this.get('model.contentsStructure').set('scrollBarView', null);
  }
});


App.BaseColumnSelectorComponent = Ember.Component.extend({
  classNames: ['column-widget', 'clickable'],
  ulStyle: '',
  setUlStyle: function() {
    var self = this,
        elem = self.$();
    self.set('ulStyle', 'max-height: ' + (
        App.get('chartHeight') - 160
      ) + 'px'
    );
  }.observes('App.chartHeight'),

  didInsertElement: function() {
    var self = this,
      element = self.$(),
      dropdownMenu = element.find('ul.dropdown-menu.columns-list');

    //disable bootstrap events, but keep checkbox click
    element.on('click.dropdown.data-api', '.column-selector input', function(e) {
      e.stopPropagation();
    }).on('wheel', function(e) {
      e.stopPropagation();
    }).on('click.dropdown.data-api', '.column-selector a', function(e) {
      e.preventDefault();
      e.stopPropagation();
    });

    element.sortable({
      items: ".column-selector.moveable",
      axis: "y",
      containment: "parent",
      cursor: "move",
      delay: 100,
      distance: 5,
      tolerance: "intersect",
      forceHelperSize: true,
      start: function( event, ui ) {
        //when largest list item is dragged and therefore hidden,
        //the width of the dropdown menu changes if not set
        dropdownMenu.width(dropdownMenu.width());
      }
    });
    self.setUlStyle();
  },

  willDestroyElement: function() {
    var self = this,
        element = self.$(),
        dropdownMenu = element.find('ul.dropdown-menu.column-list');
    element.off('click.dropdown.data-api', '.column-selector input')
      .off('click.dropdown.data-api', '.column-selector a')
      .off('wheel');
    this.$().sortable('destroy');
  },

  actions: {
    saveColumns: function() {
      var listDOMItems = this.$().find('.column-selector'),
        columnNames = listDOMItems.map(function(){return $(this).data('name');}),
        columnVisibilities = listDOMItems.map(function(){return this.firstElementChild.firstElementChild.checked;});
      this.$('.dropdown-toggle').dropdown('toggle');
      this.get('model').saveColumns($.makeArray(columnNames), $.makeArray(columnVisibilities));
    },

    cancelChanges: function() {
      this.$('.dropdown-toggle').dropdown('toggle');
      this.rerender();
    },

    expandHideColumnsAction: function() {
      this.get('model.globalSettings').updateColumnsCollapsed();
    }
  }
});
