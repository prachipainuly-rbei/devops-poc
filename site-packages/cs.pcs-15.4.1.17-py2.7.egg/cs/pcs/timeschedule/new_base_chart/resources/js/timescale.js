/*
 * Copyright (C) 2014 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact.de/
 *
 * Revision "$Id: timescale.js 163847 2017-08-24 08:59:03Z via $"
 */

App.TimeScale = Ember.Object.extend(Ember.Evented, {
  personal_start_date: null,
  personal_end_date: null,
  pixelsPerDay: null,
  onRender: Ember.$.noop,
  viewportWidth: 0,
  minZoomFactor: 0.2,
  maxZoomFactor: 200,
  
  set_personal_end_date: function() {
      var self = this,
          endDateView = null,
          pixelsPerDay = self.get('pixelsPerDay'),
          viewportWidth = self.get('viewportWidth');
      if (self.get('personal_start_date') && pixelsPerDay && viewportWidth) {
          //new moment instance to not change startDateView
          endDateView = UTCToDate(self.get('startDateView')).add('days', Math.ceil(viewportWidth / pixelsPerDay));
          var new_personal_end_date = endDateView.valueOf(),
              new_pixelsPerDay = viewportWidth / endDateView.diff(self.get('startDateView'), 'days');
          if (new_pixelsPerDay !== pixelsPerDay || new_personal_end_date !== self.get('personal_end_date')) {
              self.beginPropertyChanges();
              Ember.changeProperties(function() {
                  self.set('personal_end_date', new_personal_end_date);
                  self.set('pixelsPerDay', new_pixelsPerDay);
              });
              self.endPropertyChanges();
          }
      }
  }.observes('personal_start_date', 'viewportWidth', 'pixelsPerDay'),
  
  startDateView: function() {
    var personal_start_date = this.get('personal_start_date'),
    startDateView = null;
    if (personal_start_date) {
      startDateView = UTCToDate(personal_start_date);
    }
    return startDateView;
  }.property('personal_start_date'),

  endDateView: function() {
    var personal_end_date = this.get('personal_end_date'),
    endDateView = null;
    if (personal_end_date) {
      endDateView = UTCToDate(personal_end_date);
    }
    return endDateView;
  }.property('personal_end_date'),

  setStartScale: function(start, ppd) {
    var self = this,
        startMoment = null;
    if (!start || !ppd) return;
    if (App.moment.isMoment(start)) startMoment = start
    if (typeof start === 'number') startMoment = UTCToDate(start);
    start = startMoment.startOf('day').valueOf();
    Ember.changeProperties(function() {
        self.set('pixelsPerDay', ppd);
        self.set('personal_start_date', start);
    });
  },

  init: function() {
    this.upperRow = Ember.A([]);
    this.lowerRow = Ember.A([]);
    /*
     * see http://emberjs.com/guides/object-model/observers/#toc_unconsumed-computed-properties-do-not-trigger-observers
     */
    this.get('timeUnits');
  },

  todayCell: function() {
    return App.TimeUnit.create({'timeScale': this});
  }.property('startDateView', 'endDateView'),

  _setViewportWidth: function(width) {
      var self = this;
      self.beginPropertyChanges();
      Ember.changeProperties(function() {
          self.set('viewportWidth', width);
          var pixelsPerDay = self.get('pixelsPerDay'),
              startDate = self.get('startDateView'),
              endDate = self.get('endDateView');
          //when start & end are not saved but computed and set before viewportWidth has been set
          if (!pixelsPerDay && endDate && endDate.isValid()) {
              self.set('pixelsPerDay', width / endDate.diff(startDate, 'days'));
          }
      });
      self.endPropertyChanges();
  },

  _resizeTo: function() {
      this._setViewportWidth(this.get('newViewportWidth'));
  },

  resizeTo: function(width) {
    //there is already a debounce before this call, in BaseTimeScaleHeaderComponent.handleResizeDebouce,
    //but when both charts are displayed, there are 2 different instances of BaseTimeScaleHeaderComponent
    //so resizeTo is called 2 times for no reason and this caused ResourceScheduleContentsStructure.refresh
    //to be called 2 times, which is a really slow function
    this.set('newViewportWidth', width);
    Ember.run.debounce(this, this._resizeTo, 150, true);
  },

  timeUnits: function() {
    var ppd = this.get('pixelsPerDay'),
        globalSettings = this.get('globalSettings'),
        init_params = {
            timeScale: this, 
            calendar_exceptions: globalSettings.get('calendar_exceptions'), 
            workdays: globalSettings.get('workdays')},
        result;
    if (!ppd) return;
    if(ppd > 30) {
        result = Ember.Object.create({
            upper: App.TimeUnitMonth.create(init_params),
            lower: App.TimeUnitDay.create(init_params)});
    }
    else if(ppd > 7) {
        result = Ember.Object.create({
            upper: App.TimeUnitMonth.create(init_params),
            lower: App.TimeUnitWeek.create(init_params)});
    }
    else if(ppd > 4) {
        result = Ember.Object.create({
            upper: App.TimeUnitQuarter.create(init_params),
            lower: App.TimeUnitMonth.create(init_params)});
    }
    else if(ppd > 2) {
        result = Ember.Object.create({
            upper: App.TimeUnitHalfYear.create(init_params),
            lower: App.TimeUnitMonth.create(init_params)});
    }
    else if(ppd > 1.25) {
        result = Ember.Object.create({
            upper: App.TimeUnitYear.create(init_params),
            lower: App.TimeUnitQuarter.create(init_params)});
    }
    else {
        result = Ember.Object.create({
            upper: App.TimeUnitYear.create(init_params),
            lower: App.TimeUnitHalfYear.create(init_params)});
    }
    return result;
  }.property('pixelsPerDay'),

  displayChanged: function() {
      /* Give the function name as a string, not as an anonymous function!
       * Otherwise, if displayChanged is called twice, the function is also
       * triggered twice.
       */
      var startDateView = this.get('startDateView'),
          endDateView = this.get('endDateView');
      if (typeof this.get('timeUnits') !== 'undefined' &&
          startDateView && startDateView.isValid() &&
          endDateView && endDateView.isValid()
      ) {
          Ember.run.once(this, '_onDisplayChanged');
      }
  }.observes('personal_end_date', 'timeUnits'),

  _onDisplayChanged: function() {
      this.updateTimeUnits();
      this.initStyleProperties();
      this.trigger('timeFrameChanged');
  },

  updateTimeUnits: function() {
      var timeUnits = this.get('timeUnits');
      this.updateTimeUnitsRow(timeUnits.upper, this.get('upperRow'), this.get('startDateView'), this.get('endDateView'));
      this.updateTimeUnitsRow(timeUnits.lower, this.get('lowerRow'), this.get('startDateView'), this.get('endDateView'));
  },

  updateTimeUnitsRow: function(timeUnit, row, start, end) {
      var cell, d, idx, props;
      for(d = App.momentConstructor(start), idx = 0; d.isBefore(end); d = timeUnit.nextStartDate(d), idx++) {
          props = {timeUnit: timeUnit, startDate: App.momentConstructor(d), isVisible: true};
          if(idx >= row.length) {
              cell = App.TimeScaleHeaderCell.create(props);
              row.pushObject(cell);
          }
          else {
              cell = row.objectAt(idx);
              cell.setProperties(props);
          }
      }
      for(; idx < row.length; idx++) {
          row.objectAt(idx).set('isVisible', false);
      }
  },

  displayInterval: function() {
    return this.get('timeUnits.lower').displayInterval;
  }.property('timeUnits.lower'),

  initStyleProperties: function() {
    var diff = this.get('endDateView').diff(this.get('startDateView'), 'days');
    this.set('rowStyle', "width: " + Math.ceil(diff * this.get('pixelsPerDay')) + "px;");
  },

  scrollByPixels: function(delta) {
    var ppd = this.get('pixelsPerDay');
    var dt = Math.round(24 * 60 * 60 * delta / ppd);
    var sd = App.momentConstructor(this.get('startDateView')).subtract('seconds', dt);
    var ed = App.momentConstructor(this.get('endDateView')).subtract('seconds', dt);
    this.moveStartEnd(sd, ed);
  },

  moveLeft: function() {
    var sd = this.get('startDateView');
    var ed = this.get('endDateView');
    var tf = (ed.diff(sd, 'days') + 1) / 2;
    sd.subtract('days', tf);
    ed.subtract('days', tf);
    this.moveStartEnd(sd, ed);
  },

  moveRight: function() {
    var sd = this.get('startDateView');
    var ed = this.get('endDateView');
    var tf = (ed.diff(sd, 'days') + 1) / 2;
    sd.add('days', tf);
    ed.add('days', tf);
    this.moveStartEnd(sd, ed);
  },

  moveStart: function(startDate) {
    var sd = this.get('startDateView');
    var ed = this.get('endDateView');
    var tf = sd.diff(startDate, 'days');
    tf = (tf < 0) ? tf + 1 : tf + 2;
    sd.subtract('days', tf);
    ed.subtract('days', tf);
    this.moveStartEnd(sd, ed);
  },

  moveStartEnd: function(startDate, endDate) {
    var self = this;
    self.beginPropertyChanges();
    var start = startDate.startOf('day').valueOf(),
        end = endDate.startOf('day').valueOf();
    Ember.changeProperties(function() {
      self.set('personal_start_date', start);
      self.set('personal_end_date', end);
      var viewportWidth = self.get('viewportWidth');
      if (viewportWidth) {
          self.set('pixelsPerDay', viewportWidth / endDate.diff(startDate, 'days'));
      }
    });
    self.endPropertyChanges();
  },

  centerOnToday: function() {
    var today = App.momentConstructor().startOf('day');
    var sd = this.get('startDateView');
    var ed = this.get('endDateView');
    var tf = (ed.diff(sd, 'days') + 1) / 2;
    sd = App.momentConstructor(today).subtract('days', tf);
    ed = App.momentConstructor(today).add('days', tf);
    this.moveStartEnd(sd, ed);
  },

  zoomInDisabled: function() {
    return this.get('pixelsPerDay') * 2 > this.get('maxZoomFactor');
  }.property('pixelsPerDay'),

  zoomOutDisabled: function() {
    return this.get('pixelsPerDay') / 2 < this.get('minZoomFactor');
  }.property('pixelsPerDay'),

  setZoomFactor: function(target_zf) {
    var old_zf = this.get('pixelsPerDay');
    if(old_zf) {
      if ((target_zf > this.get('maxZoomFactor') && target_zf > old_zf) ||
          (target_zf < this.get('minZoomFactor') && target_zf < old_zf)) {
        return;
      }
      var factor = old_zf / target_zf;
      var sd = App.momentConstructor(this.get('startDateView'));
      var ed = App.momentConstructor(this.get('endDateView'));
      var old_diff = ed.diff(sd, 'days');
      var new_diff = old_diff * factor;
      var _delta = (old_diff - new_diff) / 2;
      var delta = Math.sign(_delta) * Math.ceil(Math.abs(_delta));
      sd.add('days', delta);
      ed.subtract('days', delta);
      this.moveStartEnd(sd, ed);
      this.set('pixelsPerDay', this.get('viewportWidth') / ed.diff(sd, 'days'));
    }
    else {
      this.beginPropertyChanges();
      this.set('pixelsPerDay', target_zf);
      this.endPropertyChanges();
    }
  },

  zoomIn: function() {
    this.setZoomFactor(this.get('pixelsPerDay') * 2);
  },

  zoomOut: function() {
    this.setZoomFactor(this.get('pixelsPerDay') / 2);
  },

  zoomTo: function(start, end) {
    var viewport_width = Ember.$('.time-scale-header-viewport').width();
    var num_days = end.diff(start, 'days');
    var zf = Math.max(Math.min(viewport_width / num_days, this.get('maxZoomFactor')), this.get('minZoomFactor'));
    var actual_end = App.momentConstructor(start).add('days', viewport_width / zf);
    this.moveStartEnd(start, actual_end);
    this.set('pixelsPerDay', zf);
  },

  computeDatesWidth: function(startDate, endDate) {
    return (startDate && endDate && startDate.isValid() && endDate.isValid()) ?
        (Math.round(endDate.diff(startDate, 'days', true)) + 1) * this.get('pixelsPerDay') :
        0;
  },

  computeDatePosition: function(startDate) {
      return (startDate && startDate.isValid()) ?
        Math.round(startDate.diff(this.get('startDateView'), 'days', true)) * this.get('pixelsPerDay') :
        0;
  }
});

/* A single cell in the header. Holds a start date and a reference to an actual
 * time unit, and serves as the model for the header cell views. This way,
 * changing the time unit does not trigger a complete rebuild of the DOM.
 */
App.TimeScaleHeaderCell = Ember.Object.extend({
    startDate: null,
    timeUnit: null,

    timeScale: Ember.computed.oneWay('timeUnit.timeScale').readOnly(),

    isWeekendDay: function() {
        return this.get('timeUnit').isWeekendDay(this.get('startDate'));
    }.property('startDate', 'timeUnit'),

    startOfPeriod: function() {
        return this.get('timeUnit').startOfPeriod(this.get('startDate'));
    }.property('startDate', 'timeUnit'),

    nextStartDate: function() {
        return this.get('timeUnit').nextStartDate(this.get('startDate'));
    }.property('startDate', 'timeUnit'),

    str: function() {
        return this.get('timeUnit').str(this.get('startDate'));
    }.property('startDate', 'timeUnit'),

    title: function() {
        return this.get('timeUnit').title(this.get('startDate'));
    }.property('startDate', 'timeUnit'),

    pxLeft: function() {
        return this.get('timeUnit').pxLeft(this.get('startDate'));
    }.property('startDate', 'timeUnit'),

    pxRight: function() {
        return this.get('timeUnit').pxRight(this.get('startDate'));
    }.property('startDate', 'timeUnit'),

    style: function() {
        var width = "width: " + (this.get('pxRight') - this.get('pxLeft')) + "px;";
        var display = this.get('isVisible') ? "display: inline;" : "display: none;";
        return width + display;
    }.property('pxLeft', 'pxRight', 'isVisible')
});

/* Create a single TimeScale instance, that gets injected as 'timeScaleModel'
 * into every Ember controller and component on the page.
 */
Ember.Application.initializer({
    name: 'timescale',
    after: ['settings'],

    initialize: function(container, application) {
        application.register('timescale:main', App.TimeScale, { instantiate: true, singleton: true });
        application.inject('timescale:main', 'globalSettings', 'Settings:global');
    }
});

/* Classes that represent the various time intervals that can be displayed.
 * The computations that differ with the displayed time interval are located
 * here.
 */
App.TimeUnit = Ember.Object.extend({
    timeScale: null,

    startDateView: Ember.computed.oneWay('timeScale.startDateView').readOnly(),
    endDateView: Ember.computed.oneWay('timeScale.endDateView').readOnly(),
    pixelsPerDay: Ember.computed.oneWay('timeScale.pixelsPerDay').readOnly(),

    isWeekendDay: function(aMoment) {
        return false;
    },

    title: function(aMoment) {
        return this.str(aMoment);
    },

    pxLeft: function(aMoment) {
        // left offset of this object in pixels
        return Math.round(aMoment.diff(this.get('startDateView'), 'days') * this.get('pixelsPerDay'));
    },

    pxRight: function(aMoment) {
        // right border of this object in pixels, bounded by the TimeScale's max. date
        var nextStart = this.nextStartDate(aMoment),
            endDateView = this.get('endDateView');
        var rightDate = nextStart.isBefore(endDateView) ? nextStart : endDateView;
        return Math.round(rightDate.diff(this.get('startDateView'), 'days') * this.get('pixelsPerDay'));
    }
});

App.TimeUnitDay = App.TimeUnit.extend({
    displayInterval: 'day',
    
    isWeekendDay: function(aMoment) {
        var wkDay = aMoment.isoWeekday(),
            momStr = aMoment.format(cdb.elink.cdbDateFormat),
            calendar_exceptions = this.get('calendar_exceptions');
        return !(Object.keys(calendar_exceptions).indexOf(momStr) === -1 ? 
            this.get('workdays')[wkDay]: 
            calendar_exceptions[momStr]);
    },          

    startOfPeriod: function(aMoment) {
        return App.momentConstructor(aMoment).startOf('day');
    },

    nextStartDate: function(aMoment) {
        return App.momentConstructor(this.startOfPeriod(aMoment)).add('days', 1);
    },

    str: function(aMoment) {
        return aMoment.format('DD');
    },

    title: function(aMoment) {
        return this.startOfPeriod(aMoment).format('dddd, DD MMMM YYYY');
    }
});

App.TimeUnitWeek = App.TimeUnit.extend({
    displayInterval: 'week',

    startOfPeriod: function(aMoment) {
        return App.momentConstructor(aMoment).startOf('isoWeek');
    },

    nextStartDate: function(aMoment) {
        return App.momentConstructor(this.startOfPeriod(aMoment)).add('weeks', 1);
    },

    str: function(aMoment) {
        return "W" + aMoment.format('WW');
    },

    title: function(aMoment) {
        return this.str(aMoment) + this.startOfPeriod(aMoment).format(', MMMM YYYY');
    }
});

App.TimeUnitMonth = App.TimeUnit.extend({
    displayInterval: 'month',

    startOfPeriod: function(aMoment) {
        return App.momentConstructor(aMoment).startOf('month');
    },

    nextStartDate: function(aMoment) {
        return App.momentConstructor(this.startOfPeriod(aMoment)).add('months', 1);
    },

    str: function(aMoment) {
        var ppd = this.get('timeScale.pixelsPerDay');
        if(ppd < 1) {
            return aMoment.format('MM');
        }
        else if(ppd < 2) {
            return aMoment.format('MMM');
        }
        else if(ppd < 5) {
            return aMoment.format('MMMM');
        }
        else {
            return aMoment.format('MMMM YYYY');
        }
    }
});

App.TimeUnitQuarter = App.TimeUnit.extend({
    displayInterval: 'quarter',

    startOfPeriod: function(aMoment) {
        var sop = App.momentConstructor(aMoment).startOf('month');
        var month = sop.month(); // 0 .. 11
        sop.month(month - (month % 3));
        return sop;
    },

    nextStartDate: function(aMoment) {
        return App.momentConstructor(this.startOfPeriod(aMoment)).add('months', 3);
    },

    str: function(aMoment) {
        var sd = aMoment;
        return "Q" + sd.quarter() + "/" + sd.year();
    }
});

App.TimeUnitHalfYear = App.TimeUnit.extend({
    displayInterval: 'half-year',

    startOfPeriod: function(aMoment) {
        var sop = App.momentConstructor(aMoment).startOf('month');
        sop.month(((sop.month() < 6) ? 0 : 6));
        return sop;
    },

    nextStartDate: function(aMoment) {
        return App.momentConstructor(this.startOfPeriod(aMoment)).add('months', 6);
    },

    str: function(aMoment) {
        var sd = aMoment;
        var result = "H" + ((sd.month() < 6) ? 1 : 2);
        if(this.get('timeScale').get('pixelsPerDay') >= 0.4) {
            result += ("/" + sd.year());
        }
        return result;
    }
});

App.TimeUnitYear = App.TimeUnit.extend({
    displayInterval: 'year',

    startOfPeriod: function(aMoment) {
        return App.momentConstructor(aMoment).startOf('year');
    },

    nextStartDate: function(aMoment) {
        return App.momentConstructor(this.startOfPeriod(aMoment)).add('years', 1);
    },

    str: function(aMoment) {
        return aMoment.format('YYYY');
    }
});
