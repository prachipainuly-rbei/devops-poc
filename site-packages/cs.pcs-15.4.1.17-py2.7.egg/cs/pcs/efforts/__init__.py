#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
# vim: set fileencoding=latin1:
# -*- Python -*-
# $Id: __init__.py 154136 2017-02-19 23:14:52Z heg $
#
# Copyright (C) 1990 - 2006 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
# CDB:Browse
# File:     TimeSheets.py
# Author:   aki
# Creation: 19.07.06
# Purpose:

__all__ = ['TimeSheet', 'WithEffortReport']

from cdb import sqlapi, auth, ue, cdbtime, CADDOK
from cdb.objects import Reference, Forward, Object, LocalizedField
import os
import time

# Forward declarations
fTimeSheet = Forward("cs.pcs.efforts.TimeSheet")
fActivityType = Forward("cs.pcs.efforts.ActivityType")
Task = Forward("cs.pcs.projects.tasks.Task")
Project = Forward("cs.pcs.projects.Project")

BOOKABLE_TASK_RULE = "cdbpcs: TimeSheet: Bookable Tasks (All/All)"
BOOKABLE_PROJECT_RULE = "cdbpcs: TimeSheet: Bookable Projects (All)"


class TimeSheet(Object):
    __maps_to__ = "cdbpcs_time_sheet"
    __classname__ = "cdbpcs_effort"

    Project = Reference(1, Project, fTimeSheet.cdb_project_id)
    Task = Reference(1, Task, fTimeSheet.cdb_project_id, fTimeSheet.task_id)
    ActivityType = Reference(1, fActivityType, fTimeSheet.activity_type_object_id)

    # How many hours per person per day are allowed to be booked.
    # Set it to 0 to disable the check.
    MAX_HOURS_PER_DAY = 24

    def checkTask(self, ctx):
        if not self.Task:
            raise ue.Exception("pcs_err_task_id", self.task_id, self.cdb_project_id)
        # subtask check? Use the object rules in checkTaskState
#        # Aufwände dürfen nicht auf Sammelaufgaben und Meilensteinen gebucht werden
#        if len(self.Task.SubTasks) or self.Task.milestone:
#            raise ue.Exception("pcs_err_effort3")
        if self.Task.milestone:
            # TODO: to correct "pcs_err_effort3": remove task group check
            raise ue.Exception("pcs_err_effort3")

    def on_create_pre_mask(self, ctx):
        # Defaults anhand des letzten Eintrages zur selben Aufgabe setzen
        t = sqlapi.SQLselect("max(effort_id) from cdbpcs_time_sheet where cdb_project_id='%s'"
                             " and task_id='%s' and cdb_cpersno = '%s'" % (self.cdb_project_id, self.task_id, auth.persno))
        last_ts_id = sqlapi.SQLstring(t, 0, 0)
        if len(last_ts_id) > 0:
            last_ts = TimeSheet.ByKeys(last_ts_id)
            attrs = ["category", "description", "location", "billable"]
            for attr in attrs:
                self[attr] = last_ts[attr]

    def checkTaskState(self, ctx):
        # Aufwände können nur auf die Aufgaben eingetragen werden,
        # die in bestimmten Objektregeln definiert sind.
        if self.Task and (not self.Project.MatchRule(BOOKABLE_PROJECT_RULE) or
                          not self.Task.MatchRule(BOOKABLE_TASK_RULE)):
            raise ue.Exception("pcs_err_effort1")

    def checkEffort(self, ctx):
        if self.Task:
            # Aufwände dürfen eingetragen werden, wenn an der Aufgabe keine Aufwände manuell
            # im Aufwandsfeld 'effort_act' erfasst wurden
            if self.Task.effort_act and not self.Task.is_group and not len(self.Task.TimeSheets):
                raise ue.Exception("pcs_err_effort2")

    def _saveTaskProjectIDs(self, ctx):
        if ctx.object:
            ctx.keep("_task_id", ctx.object.task_id)
            ctx.keep("_cdb_project_id", ctx.object.cdb_project_id)

    def adjustEfforts(self, ctx):
        if ctx and ctx.mode == "final":
            return
        if self.Task:
            self.Task.effort_act = ''
            self.Task.adjust_values(adjust_parents=True, effort_act=True)
            self.Task.updateStatusSignals(effort=True)
            if '_task_id' in ctx.ue_args.get_attribute_names() and ctx.ue_args["_task_id"] != self.task_id:
                old_task = Task.ByKeys(task_id=ctx.ue_args["_task_id"])
                if old_task:
                    old_task.effort_act = ''
                    old_task.adjust_values(adjust_parents=True, effort_act=True)
                    old_task.updateStatusSignals(effort=True)
        elif self.Project:
            self.Project.adjust_values(adjust_parents=True, effort_act=True)
            self.Project.updateStatusSignals(effort=True)
            if '_cdb_project_id' in ctx.ue_args.get_attribute_names() and ctx.ue_args["_cdb_project_id"] != self.cdb_project_id:
                old_project = Project.ByKeys(cdb_project_id=ctx.ue_args["_cdb_project_id"])
                if old_project:
                    old_project.adjust_values(adjust_parents=True, effort_act=True)
                    old_project.updateStatusSignals(effort=True)

    @classmethod
    def on_cdbpcs_timesheet_elink_now(cls, ctx):
        if(ctx.relationship_name == "cdbpcs_project2effort"):
            ctx.url("powerscript/cs.pcs.efforts.timesheet.app/start?" + "projid=" + ctx.parent["cdb_project_id"], icon="cdbpcs_effort_entry")
        elif(ctx.relationship_name == "cdbpcs_task2efforts"):
            ctx.url("powerscript/cs.pcs.efforts.timesheet.app/start?" + "projid=" + ctx.parent["cdb_project_id"] + "&taskid=" + ctx.parent["task_id"], icon="cdbpcs_effort_entry")
        else:
            ctx.url("powerscript/cs.pcs.efforts.timesheet.app/start", icon="cdbpcs_effort_entry")

    def check_booked_pre_mask(self, ctx):
        if self.status != 200:
            ctx.set_readonly("booked")
        if ctx.action == "copy":
            ctx.set("booked", "")

    def checkPersonEfforts(self, ctx):
        if self.MAX_HOURS_PER_DAY:
            sheets = TimeSheet.KeywordQuery(day=self.day,
                                            person_id=self.person_id).hours
            hsum = reduce(lambda x, y: x + y, sheets, 0.0)
            if ctx.action == "modify":
                try:
                    orival = float(ctx.object.hours)
                except Exception:
                    orival = 0.0
                hsum -= orival
            if self.hours:
                hsum += self.hours
            if hsum > self.MAX_HOURS_PER_DAY:
                raise ue.Exception("pcs_err_effort5")

    def setTaskProgress(self, ctx):
        if self.Task.effort_act and not self.Task.percent_complet:
            self.Task.percent_complet = 1

    event_map = {
        (('create', 'copy'), 'pre'): ("checkTask", "checkTaskState", "checkEffort", "checkPersonEfforts"),
        (('modify'), 'pre'): ("checkTask", "checkTaskState", "checkPersonEfforts"),
        (('delete'), 'pre'): ("checkTaskState"),
        (('modify'), 'pre'): ("_saveTaskProjectIDs"),
        (('create', 'copy', 'modify', 'delete'), 'post'): ("adjustEfforts", "setTaskProgress"),
        (('create', 'copy', 'modify'), 'pre_mask'): ("check_booked_pre_mask")
        }


class WithEffortReport(object):
    @classmethod
    def on_cdbpcs_effort_report_now(cls, ctx):
        project = Project.ByKeys(ctx.dialog.cdb_project_id)
        task = Task.ByKeys(ctx.dialog.cdb_project_id, ctx.dialog.task_id)
        report_file = cls.GenerateEffortReport(project, task, ctx.dialog.person_id,
                                               ctx.dialog.billable, ctx.dialog.fromdate, ctx.dialog.to, ctx.dialog.ordercode)
        if os.path.isfile(report_file):
            ctx.file(report_file)
        else:
            raise ue.Exception("cdbpcs_effort_report_failed", report_file)

    @classmethod
    def on_cdbpcs_effort_report_pre_mask(cls, ctx):
        # fromdate auf monatsanfang setzen
        day = int(time.strftime('%d', time.localtime(time.time())))
        if day != 1:
            fromdate = "01." + time.strftime('%m.%Y', time.localtime(time.time()))
            ctx.set("fromdate", fromdate)

    @classmethod
    def GenerateEffortReport(cls, project, task=None, persno=None, billable=None, from_date=None, to_date=None, order_by=None, layoutFile=None):
        # Select efforts
        cond = "cdb_project_id = '%s'" % project.cdb_project_id
        if billable:
            cond += " AND billable = '%s'" % billable
        if persno:
            cond += " AND person_id = '%s'" % persno
        if not to_date:
            to_date = cdbtime.now()
        cond += " AND day <= %s" % sqlapi.SQLdbms_date(to_date)
        if from_date:
            cond += " AND day >= %s" % sqlapi.SQLdbms_date(from_date)
        if task:
            cond += " AND (task_id = '%s'" % task.task_id
            for sub_task in task.AllSubTasks:
                cond += " OR task_id = '%s'" % sub_task.task_id
            cond += ")"
        if not order_by:
            order_by = "effort_id"
        efforts = sqlapi.RecordSet2("cdbpcs_time_sheet",
                                   condition=cond,
                                   addtl="order by %s" % order_by)
        # Find layout file and setup output file
        if not layoutFile:
            xml_template = "layout_cdbpcs_effort_report.xml"
            layoutFile = os.path.join(CADDOK.BASE, 'reports', xml_template)
            if not os.path.isfile(layoutFile):
                layoutFile = os.path.join(os.path.dirname(__file__), xml_template)
        resultFile = os.path.join(CADDOK.TMPDIR,
                                  "effreport-" + auth.login + "-" +
                                  cdbtime.now("%a-%d-%b-%Y-%H-%M-%S") + ".xml")
        # Generate Report
        from cdb.reportutils import xmlDataSourceCreator, xmlReportCreator
        dataFile = None
        rds = xmlDataSourceCreator.ReportDataSourceCreator(layoutFile, dataFile)
        rds.fillWithRecordset([project])
        rds.fillWithRecordset(efforts, {}, "cdbpcs_time_sheet_v")
        rep = xmlReportCreator.ReportCreator(layoutFile, dataFile, resultFile)
        rep.setDatas(rds.getDatas())
        rep.createReport()
        rep.output()
        return resultFile


class ActivityType(Object):
    __maps_to__ = "cdbpcs_effort_activity_type"
    __classname__ = "cdbpcs_effort_activity_type"

    Name = LocalizedField('name')
