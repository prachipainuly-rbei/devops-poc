#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2010 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
# File:     __init__.py
# Author:   yzh
# Creation: 06.04.2010

import datetime
import time
from cdb import misc
from cdb import auth
from cdb import sqlapi
from cdb import util
from cdb import elink
from cdb import cdbuuid
from cdb import ue

from cdb.constants import kOperationNew
from cdb.constants import kOperationModify
from cdb.constants import kOperationDelete

from cdb.objects import org
from cdb.objects import Rule
from cs import calendar as cdbcalendar

from cs.pcs.projects import Project
from cs.pcs.projects import kProjectManagerRole
from cs.pcs.projects.tasks import Task
from cs.pcs.issues import Issue
from cs.pcs.checklists import Checklist
from cs.pcs.checklists import ChecklistItem
from cs.pcs.efforts import TimeSheet
from cs.pcs.efforts import ActivityType

from cdb.objects.operations import operation
from cdb.objects.operations import form_input

from cdb.platform import olc
from cdb.platform.mom.fields import DDField


def log(txt):
    misc.cdblogv(misc.kLogMsg, 7, txt)


# Exported objects
__all__ = ["app"]

WORKDAY_TABLE = "cdb_worktime"
DEFAUTL_WEEKDAY_HOURS = 8

USE_RULES = {
    "all_projects": "cdbpcs: TimeSheet: Bookable Projects (All)",
    "team_projects": "cdbpcs: TimeSheet: Bookable Projects (Team)",
    "all_open_tasks": "cdbpcs: TimeSheet: Bookable Tasks (All/Open)",
    "all_all_tasks": "cdbpcs: TimeSheet: Bookable Tasks (All/All)",
    "resp_open_tasks": "cdbpcs: TimeSheet: Bookable Tasks (Mine/Open)",
    "resp_all_tasks": "cdbpcs: TimeSheet: Bookable Tasks (Mine/All)",
    "my_issues": "cdbpcs: TimeSheet: My Issues",
    "active_issues": "cdbpcs: TimeSheet: Active Issues",
    "my_checkpoints": "cdbpcs: TimeSheet: My Checkpoints",
    "active_checkpoints": "cdbpcs: TimeSheet: Active Checkpoints",
    "active_checklists": "cdbpcs: TimeSheet: Active Checklists"
}

TIMESHEET_LABELS = {}


def ts_mandatory_fields():
    result = ["cdb_project_id", "task_id", "hours", "description"]
    if DDField.ByKeys("cdbpcs_effort", "activity_type_object_id") and \
       getattr(DDField.ByKeys("cdbpcs_effort", "activity_type_object_id"), "is_mandatory", 0):
        result.append("activity_type_object_id")
    return result


def decode_js_text(txt):
    if type(txt) == str:
        return u"%s" % txt
    return txt


def encode_js_text(txt):
    if type(txt) == str:
        return u"%s" % txt
    return txt


def get_label(name):
    return TIMESHEET_LABELS.setdefault(name, encode_js_text(util.get_label(name)))


def get_work_day(cdb_person_id, day):
    rset = sqlapi.RecordSet2(WORKDAY_TABLE,
                             "person_id='%s' and day=%s" % (cdb_person_id, sqlapi.SQLdbms_date(day)))
    if len(rset) > 0:
        return rset[0]
    return None


def get_timesheets(cdb_person_id, day, filters):
    qry = {"person_id": cdb_person_id,
           "day": day
           }
    if filters["project"]:
        qry["cdb_project_id"] = filters["project"]
    if filters["task"]:
        qry["task_id"] = filters["task"]
    shts = TimeSheet.KeywordQuery(order_by='effort_id desc', **qry)
    # result = map(dict, shts)
    results = []
    for sht in shts:
        if sht.CheckAccess("read"):
            results.append(sht)
    return results


def timesheetClosed(tsht):
    return tsht["booked"] or tsht["status"] == 200


def get_day_hours_default(firstday, lastday, cdb_person_id):
    return cdbcalendar.getPersonalCapacities(firstday, lastday, list_of_persnr=[cdb_person_id]).get(cdb_person_id, [])


def get_day_hours(firstday, lastday, cdb_person_id):
    """
    Interface to get the working hours of each day in a given period for a certain person.
    :Parameters:
        - `firstday` : A python datetime object which represents the first date of the period.
        - `lastday` : A python datetime object which represents the last date of the period.
        - `cdb_person_id` : The person id.
    :returns: A list object which lists the working hours of each day in the given period.
    """
    return get_day_hours_default(firstday, lastday, cdb_person_id)


def add_custom_data(form_data):
    """
    Interface to add additional customized data to create or update a time sheet object.
    :Parameters:
        - `form_data` : The form data from the elink page as a dictionary.
    :returns: A dictionary contains the required additional data.
    """
    return {}


def get_work_days(cdb_person_id, mon, showdays=5, filters={}):
    days = 7
    workdays = []
    weeksum = 0.0
    weekhours = 0.0
    lastday = mon + datetime.timedelta(days=days)
    day_hours0 = get_day_hours(mon, lastday, cdb_person_id)
    day_hours = day_hours0 + [DEFAUTL_WEEKDAY_HOURS] * days
    for i in range(0, days):
        day = mon + datetime.timedelta(days=i)
        workday = get_work_day(cdb_person_id, day.strftime("%d.%m.%Y"))
        weekday_hours = day_hours[i]
        if filters["open"] or filters["incompl"]:
            if workday and workday.ts_closed:
                continue

        tsht_objs = get_timesheets(cdb_person_id, day.strftime("%d.%m.%Y"), filters)
        # Nur Mo.-So. anzeigen?
        if i >= showdays and len(tsht_objs) < 1:
            continue

        timesheets = []
        fsum = 0.0  # gefilterte Summe
        sum_total = 0.0  # tatsaechliche Summe
        for obj in tsht_objs:
            tsht = dict(obj)
            try:
                sum_total += tsht.get("hours", 0.0)
            except Exception:
                pass
            if filters["project"] and filters["project"] != tsht["cdb_project_id"]:
                continue
            elif filters["task"] and filters["task"] != tsht["task_id"]:
                continue

            timesheets.append(tsht)
            try:
                fsum += tsht.get("hours", 0.0)
            except Exception:
                pass
            proj = Project.ByKeys(cdb_project_id=tsht["cdb_project_id"])
            proj = proj if proj.CheckAccess("read") else None
            if proj:
                tsht["project_name"] = proj.project_name
                tsht["project_href"] = proj.MakeURL(plain=0)
            else:
                from cdb.util import get_label
                tsht["project_name"] = get_label("cdb_uuid_no_access")
                tsht["project_href"] = "#"

            task = Task.ByKeys(cdb_project_id=tsht["cdb_project_id"],
                               task_id=tsht["task_id"])
            task = task if task.CheckAccess("read") else None
            if task:
                tsht["task_name"] = task.task_name
                tsht["task_href"] = task.MakeURL(plain=0)
            else:
                from cdb.util import get_label
                tsht["task_name"] = get_label("cdb_uuid_no_access")
                tsht["task_href"] = "#"

            act_type = obj.ActivityType
            if act_type:
                tsht["activity_type"] = act_type.Name['']

            tsht["ts_href"] = obj.MakeURL(plain=0)
            tsht["ts_closed"] = timesheetClosed(tsht)

        if filters["incompl"]:
            if sum_total >= weekday_hours:
                continue

        weeksum += fsum
        weekhours += weekday_hours
        workdays.insert(0, {"date": day.strftime("%d.%m.%Y"),
                            "day_object": workday,
                            "timesheets": timesheets,
                            "weekdayname": util.Labels()["weekday_%i_short" %
                                                         day.isoweekday()],
                            "weekday_hours": weekday_hours,
                            "sum": fsum,
                            "sum_total": sum_total})
    return workdays, weeksum, weekhours


def update_timesheet(effort_id, new_ts_day, new_proj, new_task, new_hours,
                     new_desc, new_atype, cdb_person_id, person_name, **kwargs):
    if (not new_ts_day
        or not new_proj
        or not new_task
        or not new_hours
        or not cdb_person_id
        or ("description" in ts_mandatory_fields()
            and not new_desc)
        or ("activity_type_object_id" in ts_mandatory_fields()
            and not new_atype)):
        return

    if not effort_id:
        # nur PL darf Aufwandseintrag fuer andere Leute anlegen
        if cdb_person_id != auth.persno:
            cond = False
            projobj = Project.ByKeys(new_proj)
            if projobj:
                plrole = projobj.RolesByID[kProjectManagerRole]
                if plrole:
                    if plrole.isOwner(auth.persno):
                        cond = True
            if not cond:
                raise ue.Exception("pcs_err_effort7")
        eff_id = u"%s" % util.nextval("cdbpcs_effort")
        arglist = {}
        from cdb import cdbtime
        arglist.update(effort_id=eff_id,
                       cdb_project_id=new_proj,
                       task_id=new_task,
                       day=new_ts_day,
                       hours=new_hours,
                       description=new_desc,
                       activity_type_object_id=new_atype,
                       person=person_name,
                       person_id=cdb_person_id,
                       status='0',
                       booked='',
                       cdb_status_txt=olc.StateDefinition.ByKeys(0, "cdbpcs_effort").StateText[''],
                       cdb_objektart="cdbpcs_effort",
                       **kwargs)
        # call the system operation to create a new object
        operation(kOperationNew, TimeSheet, form_input(TimeSheet, **arglist))
    else:
        newts = TimeSheet.ByKeys(effort_id=effort_id)
        if newts and newts.CheckAccess("save"):
            arglist = {}
            arglist.update(cdb_project_id=new_proj,
                           task_id=new_task,
                           hours=new_hours,
                           description=new_desc,
                           activity_type_object_id=new_atype,
                           **kwargs)
            operation(kOperationModify, newts, form_input(TimeSheet, **arglist))


def delete_timesheet(effort_id):
    delts = TimeSheet.ByKeys(effort_id=effort_id)
    if delts:
        operation(kOperationDelete, delts)


def switch_day(day, cdb_person_id):
    cond = "person_id='%s' and day=%s" % (cdb_person_id, sqlapi.SQLdbms_date(day))
    sqlstr = "select ts_closed from %s where %s" % (WORKDAY_TABLE, cond)
    rset = sqlapi.RecordSet2(sql=sqlstr)
    if len(rset) > 0:
        closed = rset[0]["ts_closed"]
        try:
            closed = int(closed)
            if closed == 0:
                closed = 1
            else:
                closed = 0
        except Exception:
            closed = 0
        sqlstr = "%s set ts_closed=%d where %s" % (WORKDAY_TABLE, closed, cond)
        result = sqlapi.SQLupdate(sqlstr)
    else:
        closed = 1
        sqlstr = "into %s (person_id, day, ts_closed, cdb_object_id) "\
                 "values('%s', %s, 1, '%s')" % (WORKDAY_TABLE, cdb_person_id, sqlapi.SQLdbms_date(day), cdbuuid.create_uuid())
        result = sqlapi.SQLinsert(sqlstr)
    # Alle Aufwandseintraege abschliessen/oeffnen
    if cdb_person_id == auth.persno:
        tshts = get_timesheets(cdb_person_id, day, {"project": "", "task": ""})
        for tsht in tshts:
            try:
                if closed == 1:
                    tsht.ChangeState(200, check_access=True)
                else:
                    tsht.ChangeState(0, check_access=True)
            except Exception:
                pass
    return result


@elink.using_template_engine("chameleon")
class TimeSheetElinkAPP(elink.Application):
    def setup(self):
        # super(TimeSheetElinkAPP, self).__init__("CDB Time Sheet")
        self.custom_chrome = ""
        self.custom_csss = []
        self.custom_jss = []
        self.add("start", TimeSheetElinkPage())
        self.add("get_task_structure", GetTaskStructure())
        self.add("get_cpoi_structure", GetCPOIStructure())
        self.addJSON(self.get_persons)
        self.addJSON(self.get_projects)
        self.addJSON(self.get_tasks)
        self.addJSON(self.has_cpoi)
        self.addJSON(self.get_activity_types)
        self.addJSON(self.delete_timesheet)
        self.addJSON(self.switch_day)
        self.addJSON(self.update_timesheet)
        self.addJSON(self.save_rule)
        self.addJSON(self.load_rule)

    def save_rule(self, **varkw):
        try:
            util.PersonalSettings().setValue("elink.apps.timesheet.rules",
                                             "",
                                             varkw["rule_values"])
        except RuntimeError, e:
            misc.cdblogv(misc.kLogErr,
                         7,
                         "Error by saving personal setting: %s" % e)

    def load_rule(self, **varkw):
        return util.PersonalSettings().getValueOrDefault(
            "elink.apps.timesheet.rules", "", "")

    def get_persons(self, **varkw):
        q_contains = int(varkw.get("q_contains", 0))
        q = varkw.get("q", "")
        q = decode_js_text(q)
        limit = int(varkw.get("limit", 0))
        qstr = ""
        if q:
            if q_contains:
                qstr = "lower(name) like lower('%%%s%%')" % q
            else:
                qstr = "lower(name) like lower('%s%%')" % q
        if qstr:
            persons = org.User.Query(qstr, access="read", access_persno=auth.persno)
        else:
            persons = org.User.Query(access="read", access_persno=auth.persno)
        resultlist = []
        if limit:
            persons = persons[:limit]
        for pers in persons:
            v1 = encode_js_text(pers.name)
            v2 = encode_js_text(pers.personalnummer)
            resultlist.append([v1, v2])
        return resultlist

    def _find_task_rule(self, **varkw):
        use_rule = USE_RULES["resp_open_tasks"]
        all_status = varkw.get("filter_all_status", "")
        all_task = varkw.get("filter_all_tasks", "")
        if u"%s" % all_task == u"1":
            if u"%s" % all_status == u"1":
                use_rule = USE_RULES["all_all_tasks"]
            else:
                use_rule = USE_RULES["all_open_tasks"]
        elif u"%s" % all_status == u"1":
            use_rule = USE_RULES["resp_all_tasks"]
        return use_rule

    def get_projects(self, **varkw):
        """
        Get projects from object rules. In standard only projects with bookable tasks
        would be showed.
        """
        q_contains = int(varkw.get("q_contains", 0))
        q_exact = int(varkw.get("q_exact", 0))
        q = varkw.get("q", "")
        q = decode_js_text(q)
        limit = int(varkw.get("limit", 0))
        cdb_person_id = varkw.get("cdb_person_id", "")
        by_name = bool(int(varkw.get("by_name", 1)))

        rule_args = {"persno": cdb_person_id}
        use_rule = USE_RULES["team_projects"]
        all_proj = varkw.get("filter_all_projects", "")
        if u"%s" % all_proj == u"1":
            use_rule = USE_RULES["all_projects"]
        task_rule = self._find_task_rule(**varkw)

        qstr = "1=1 "
        favstr = "select count(t.cdb_project_id) cnt, t.cdb_project_id, max(day) daymax "
        favstr += " from cdbpcs_time_sheet t, cdbpcs_project p"
        favstr += " where t.person_id='%s' and t.cdb_project_id=p.cdb_project_id" % cdb_person_id
        if q:
            q = sqlapi.quote(q)
            attr2search = "project_name" if by_name else "cdb_project_id"
            if q_contains:
                qstr = "lower({0}) like lower('%%{1}%%') ".format(attr2search, q)
                favstr += " and lower(p.{0}) like lower('%%{1}%%')".format(attr2search, q)
            elif q_exact:
                qstr = "lower({0}) = lower('{1}') ".format(attr2search, q)
                favstr += " and lower(p.{0}) = lower('{1}') ".format(attr2search, q)
            else:
                qstr = "lower({0}) like lower('{1}%%') ".format(attr2search, q)
                favstr += " and lower(p.{0}) like lower('{1}%%')".format(attr2search, q)

        favstr += " group by t.cdb_project_id order by daymax desc"

        rset = sqlapi.RecordSet2(sql=favstr)
        resultlist = []
        use_rule = Rule.ByKeys(use_rule)
        if use_rule:
            task_rule = Rule.ByKeys(task_rule)
            if task_rule:
                task_rule._aliases.clear()
                stmt = task_rule.stmt(Task, **rule_args)
                qstr += " and cdb_project_id in (select subsel1.cdb_project_id from (%s) subsel1) " % stmt
            projects = use_rule.getObjects(Project, add_expr=qstr, max_result=limit, order_by="cdb_project_id", **rule_args)
            favids = []
            projids = [p.cdb_project_id for p in projects]
            favlimit = 5
            favcnt = 1
            favprojs = []
            for favp in rset:
                if favp.cdb_project_id in projids:
                    proj = projects[projids.index(favp.cdb_project_id)]
                    favprojs.append((favp.cnt, proj.project_name, proj.cdb_project_id))
                    favids.append(proj.cdb_project_id)
                    favcnt += 1
                    if favcnt > favlimit:
                        break
            favprojs.sort()
            favprojs.reverse()
            for favproj in favprojs:
                v1 = encode_js_text(favproj[1])
                v2 = encode_js_text(favproj[2])
                resultlist.append([v1, v2])

            if resultlist:
                resultlist.append(["", ""])

            if limit and len(resultlist) < limit:
                for proj in projects:
                    if proj.cdb_project_id not in favids:
                        v1 = encode_js_text(proj.project_name)
                        v2 = encode_js_text(proj.cdb_project_id)
                        resultlist.append([v1, v2])
                    if limit and len(resultlist) >= limit:
                        break
            if resultlist:
                if resultlist[-1] == ["", ""]:
                    resultlist = resultlist[:-1]
            # nothing is found => still display the "-" option
            if not resultlist:
                resultlist.append(["", ""])
        return resultlist

    def get_tasks(self, **varkw):
        resultlist = []
        cdb_project_id = varkw.get("cdb_project_id", "")
        if not cdb_project_id:
            return resultlist
        limit = int(varkw.get("limit", 0))
        cdb_person_id = varkw.get("cdb_person_id", "")
        withdesc = varkw.get("withdesc", "")
        no_structure = int(varkw.get("no_structure", 0))

        rule_args = {"persno": cdb_person_id}
        use_rule = self._find_task_rule(**varkw)

        use_rule = Rule.ByKeys(use_rule)
        if use_rule:
            favstr = "select count(t.task_id) cnt, t.task_id, max(day) daymax "
            favstr += " from cdbpcs_time_sheet t, cdbpcs_task p"
            favstr += " where t.person_id='%s' " % cdb_person_id
            favstr += " and t.cdb_project_id='%s' and t.cdb_project_id=p.cdb_project_id" % cdb_project_id
            favstr += " and t.task_id=p.task_id"
            favstr += " group by t.task_id order by daymax desc"

            rset = sqlapi.RecordSet2(sql=favstr)

            favlimit = 5
            if favlimit > limit:
                favlimit = limit
            favcnt = 1
            favtasks = []
            for favt in rset:
                tsk = Task.ByKeys(cdb_project_id, favt.task_id)
                if tsk and use_rule.match(tsk, **rule_args):
                    dftdesc = ""
                    dftact_type_id = ""
                    dftact_type_name = ""
                    if withdesc:
                        tshts = tsk.TimeSheets.Query(condition="person_id='%s'" % cdb_person_id,
                                                     order_by="day desc, effort_id desc",
                                                     access="read")
                        if len(tshts) > 0:
                            dftdesc = tshts[0].description
                            if not dftdesc:  # E035578, but should not happen since description is mandatory..
                                dftdesc = ""
                            if tshts[0].ActivityType:
                                dftact_type_id = tshts[0].activity_type_object_id
                                dftact_type_name = tshts[0].ActivityType.Name['']
                    favtasks.append((favt.cnt, tsk.task_name, tsk.task_id, dftdesc, dftact_type_name, dftact_type_id))
                    favcnt += 1
                    if favcnt > favlimit:
                        break

            favtasks.sort()
            favtasks.reverse()
            for favtask in favtasks:
                v1 = encode_js_text(favtask[1])
                v2 = encode_js_text(favtask[2])
                v3 = encode_js_text(favtask[3])
                v4 = encode_js_text(favtask[4])
                v5 = encode_js_text(favtask[5])
                resultlist.append([v1, v2, v3, v4, v5])
            if not no_structure:
                if resultlist:
                    resultlist.append(["", "", "", "", ""])
                resultlist.append([util.Labels()["cdbpcs_timesheet_show_more"], "cdbpcs_timesheet_show_more", "", "", ""])
        return resultlist

    def has_cpoi(self, **varkw):
        cdb_project_id = varkw.get("cdb_project_id", "")
        task_id = varkw.get("task_id", "")
        cdb_person_id = varkw.get("cdb_person_id", "")

        qstr = "cdb_project_id='%s' and task_id='%s' " % (cdb_project_id, task_id)
        rule_args = {"persno": cdb_person_id}

        arule = Rule.ByKeys(USE_RULES["active_issues"])
        result = 0
        if arule:
            arule._aliases.clear()
            stmt = arule.stmt(Issue, add_expr=qstr, count=True, **rule_args)
            rset = sqlapi.RecordSet2(sql=stmt)
            if len(rset) > 0:
                rcrd = rset[0]
                try:
                    if int(rcrd[rcrd.keys()[0]]) > 0:
                        result = 1
                except Exception:
                    pass
        if not result:
            arule = Rule.ByKeys(USE_RULES["active_checklists"])
            if arule:
                arule._aliases.clear()
                stmt = arule.stmt(Checklist, add_expr=qstr, count=True, **rule_args)
                rset = sqlapi.RecordSet2(sql=stmt)
                if len(rset) > 0:
                    rcrd = rset[0]
                    try:
                        if int(rcrd[rcrd.keys()[0]]) > 0:
                            result = 1
                    except Exception:
                        pass
        return result

    def get_activity_types(self, **varkw):
        resultlist = []
        for atype in ActivityType.Query(access="read"):
            resultlist.append([encode_js_text(atype.Name['']), atype.cdb_object_id])
        return resultlist

    def delete_timesheet(self, **varkw):
        effort_id = varkw.get("delete_effort_id", None)
        try:
            delete_timesheet(effort_id)
        except Exception, e:
            raise util.ErrorMessage("just_a_replacement", "%s" % e)
        response = {'id': effort_id}
        return response

    def switch_day(self, **varkw):
        cdb_person_id = varkw.get("cdb_person_id", "")
        if not cdb_person_id:
            cdb_person_id = auth.persno
        day = varkw.get("close_workday", None)
        if day:
            try:
                switch_day(day, cdb_person_id)
            except Exception, e:
                raise util.ErrorMessage("just_a_replacement", "%s" % e)
            response = {'day': day}
        return response

    def update_timesheet(self, **varkw):
        idflag = varkw.get("update_effort", "")
        if idflag:
            try:
                cdb_person_id = varkw.get("cdb_person_id", "")
                if not cdb_person_id:
                    cdb_person_id = auth.persno
                person_name = ""
                cdbperson = org.User.ByKeys(personalnummer=cdb_person_id)
                if cdbperson:
                    person_name = cdbperson.name
                effort_id = varkw.get("effort_id__%s" % idflag, None)
                new_ts_day = varkw.get("day__%s" % idflag, None)
                new_proj = varkw.get("cdb_project_id__%s" % idflag, None)
                new_task = varkw.get("task_id__%s" % idflag, None)
                new_hours = varkw.get("hours__%s" % idflag, None)
                new_desc = decode_js_text(varkw.get("description__%s" % idflag, ""))
                new_atype = varkw.get("activity_type_object_id__%s" % idflag, "")
                custom_data = add_custom_data(varkw)
                update_timesheet(effort_id, new_ts_day, new_proj, new_task,
                                 new_hours, new_desc, new_atype, cdb_person_id, person_name, **custom_data)
                multiday = varkw.get("multi_day__" + idflag, None)
                if multiday and new_ts_day:
                    day1 = datetime.datetime.strptime(new_ts_day, "%d.%m.%Y")
                    day2 = datetime.datetime.strptime(multiday, "%d.%m.%Y")
                    if day2 > day1:
                        drange = range(1, (day2 - day1).days + 1)
                    else:
                        drange = range((day2 - day1).days, 0)
                    for daystep in drange:
                        new_m_day = day1 + datetime.timedelta(days=daystep)
                        if new_m_day.weekday() not in [5, 6]:
                            newdate_str = new_m_day.strftime("%d.%m.%Y")
                            update_timesheet(None, newdate_str, new_proj, new_task,
                                             new_hours, new_desc, new_atype, cdb_person_id, person_name, **custom_data)
            except Exception, e:
                raise util.ErrorMessage("just_a_replacement", "%s" % e)
        response = {'id': idflag}
        return response


class TimeSheetElinkPage(elink.Template):
    __template__ = "cdb_timesheet_elink.htm"
    __macros__ = {"elink_translation": "translations.html"}

    def render(self, context, projid=None, taskid=None, *args, **varkw):
        self.content_type("text/html")
        context.custom_css_files = self.application.custom_csss
        context.custom_js_files = self.application.custom_jss
        context.call_time = time.time()
        cdb_person_id = varkw.get("cdb_person_id", auth.persno)
        context.cdb_person_id = cdb_person_id
        context.person_is_self = cdb_person_id == auth.persno
        person_name = ""
        cdbperson = org.User.ByKeys(personalnummer=cdb_person_id)
        if not cdbperson.CheckAccess("read"):
            cdbperson = None
            context.cdb_person_id = cdb_person_id = ""
        if cdbperson:
            person_name = cdbperson.name
            context.person_name = person_name

        if "sel_date" in self.request.form_data:
            sel_date = datetime.datetime.strptime(self.request.form_data["sel_date"], "%d.%m.%Y")
            context.sel_date = self.request.form_data["sel_date"]
        else:
            sel_date = datetime.date.today()

        # Setze auf Montag
        mon = sel_date - datetime.timedelta(days=sel_date.weekday())
        sun = mon + datetime.timedelta(days=6)
        if mon.month == sun.month:
            context.week_begin = mon.strftime("%d.")
        else:
            context.week_begin = mon.strftime("%d.%m")
        context.week_end = sun.strftime("%d.%m.%Y")
        last_mon = mon - datetime.timedelta(days=7)
        context.last_week = last_mon.strftime("%d.%m.%Y")
        next_mon = mon + datetime.timedelta(days=7)
        context.next_week = next_mon.strftime("%d.%m.%Y")
        today = datetime.date.today()
        this_week_end = today + datetime.timedelta(days=6 - today.weekday())
        context.curr_day = today.strftime("%d.%m.%Y")
        if not hasattr(context, "sel_date"):
            context.sel_date = context.curr_day
        curr_week = False
        if this_week_end.strftime("%d.%m.%Y") == context.week_end:
            context.disable_curr_week_button = "disabled"
            curr_week = True
        else:
            context.disable_curr_week_button = None
        context.req = self.request

        # Aufwaender abfragen
        # Default: Mo.-Fr.
        days = 5
        # Falls heute Sa. oder So. auch Sa. u. So. anzeigen
        if today.weekday() > 4:
            days = 7

        filter_incompl = self.request.form_data.get("filter_incompl", None)
        context.filter_incompl = filter_incompl

        filter_open = self.request.form_data.get("filter_open", None)
        context.filter_open = filter_open

        dft_filter_wd = ""
        if days == 7:
            dft_filter_wd = 1
        filter_weekday = self.request.form_data.get("filter_weekday", dft_filter_wd)
        if filter_weekday:
            days = 7
        else:
            days = 5
        context.filter_weekday = filter_weekday

        filter_project = self.request.form_data.get("filter_project", None)
        filter_task = self.request.form_data.get("filter_task", None)

        filters = {"incompl": filter_incompl,
                   "open": filter_open,
                   "project": filter_project,
                   "task": filter_task
                   }

        # Aktuelle Woche: nur bis Heute anzeigen (falls weitere Tage unbebucht werden)
        if days < 7 and curr_week:
            days = today.weekday() + 1

        context.workdays, context.weeksum, context.weekhours = get_work_days(cdb_person_id, mon, days, filters)
        context.ts_mandatory_fields = "%s" % ts_mandatory_fields()

        if filter_project:
            fproj = Project.ByKeys(cdb_project_id=filter_project)
            fproj = fproj if fproj.CheckAccess("read") else None
            if fproj:
                context.filter_project = filter_project
                context.filter_project_name = fproj.project_name
                if filter_task:
                    ftask = fproj.Tasks.KeywordQuery(task_id=filter_task)
                    if len(ftask) > 0 and ftask[0].CheckAccess("read"):
                        context.filter_task = filter_task
                        context.filter_task_name = ftask[0].task_name

        # context.collapse_state_filter_area1 = self.request.form_data.get("collapse_state_filter_area1", "hide")

        data = {
            "date": time.strftime("%d_%m_%Y"),
            "date_for_calendar": time.strftime("%d-%m-%Y"),
            "project_id": "",
            "project_name": "",
            "task_name": "",
            "task_id": "",
        }

        # default value if required
        if projid:
            qfilters = self.application.load_rule()
            qdata = {"cdb_person_id": context.cdb_person_id,
                     "q_exact": 1,
                     "limit": 999}
            # collects the filter rules
            if qfilters:
                for flt in qfilters.split(","):
                    qdata[flt.strip()] = 1
            pname = Project.ByKeys(projid).project_name
            qdata["q"] = unicode(pname)
            presults = self.application.get_projects(**qdata)
            pids = []
            if presults:
                pids = zip(*presults)[1]
            # the project is visible
            if projid in pids:
                data["project_id"] = projid
                data["project_name"] = pname
                if taskid:
                    qdata["cdb_project_id"] = projid
                    qdata["withdesc"] = 1
                    qdata["no_structure"] = 1
                    tresults = self.application.get_tasks(**qdata)
                    if tresults:
                        zipped = zip(*tresults)
                        tids = zipped[1]
                        if taskid in tids:
                            idx = tids.index(taskid)
                            data["task_id"] = taskid
                            data["task_name"] = zipped[0][idx]
                            data["default_description"] = zipped[2][idx]
                            data["default_activity_type"] = \
                                zipped[3][idx]
                            data["default_activity_type_object_id"] = \
                                zipped[4][idx]
                    if not data["task_id"]:
                        trule = self.application._find_task_rule(**qdata)
                        taskrule = Rule.ByKeys(trule)
                        taskobj = Task.ByKeys(projid, taskid)
                        rule_args = {"persno": context.cdb_person_id}
                        if taskobj and taskrule and \
                           taskrule.match(taskobj, **rule_args):
                            data["task_id"] = taskid
                            data["task_name"] = taskobj.task_name
                    if not data["task_id"]:
                        data["no_default_task"] = "no_default_task"
        return data


class GetTaskStructure(elink.Template):
    __template__ = "task_structure.htm"

    def render(self, context, *args, **varkw):
        self.request.charset = "utf-8"
        limit = int(varkw.get("limit", 0))
        if limit == 0:
            limit = None
        cdb_project_id = varkw.get("cdb_project_id", "")
        cdb_person_id = varkw.get("cdb_person_id", "")

        projobj = Project.ByKeys(cdb_project_id)
        context.tmaps = {}
        context.toptasks = []
        context.project_object = None
        if projobj:
            context.project_object = {"cdb_project_id": projobj.cdb_project_id,
                                      "project_name": encode_js_text(projobj.GetDescription()),
                                      "icon": projobj.GetObjectIcon()}
            rule_args = {"persno": cdb_person_id}
            use_rule = USE_RULES["resp_open_tasks"]
            all_status = varkw.get("filter_all_status", "")
            if u"%s" % all_status == u"1":
                use_rule = USE_RULES["resp_all_tasks"]
            qstr = "cdb_project_id='%s' " % cdb_project_id
            use_rule = Rule.ByKeys(use_rule)
            if use_rule:
                tasks = use_rule.getObjects(Task, add_expr=qstr, max_result=limit, order_by="position", **rule_args)

                def gen_parent_struct(tobj):
                    if tobj.task_id not in context.tmaps:
                        context.tmaps[tobj.task_id] = {"task_name": encode_js_text(tobj.task_name),
                                                       "task_desc": encode_js_text(tobj.GetDescription()),
                                                       "icon": tobj.GetObjectIcon(),
                                                       "is_group": tobj.is_group,
                                                       "children": []}
                    tdata = (tobj.position, tobj.task_id)
                    if tobj.parent_task:
                        gen_parent_struct(tobj.ParentTask)
                        if tdata not in context.tmaps[tobj.parent_task]["children"]:
                            context.tmaps[tobj.parent_task]["children"].append(tdata)
                    elif tdata not in context.toptasks:
                        context.toptasks.append(tdata)

                for tobj in tasks:
                    gen_parent_struct(tobj)
                    context.tmaps[tobj.task_id]["highlight"] = 1

                all_task = varkw.get("filter_all_tasks", "")
                if u"%s" % all_task == u"1":
                    use_rule = USE_RULES["all_open_tasks"]
                    if u"%s" % all_status == u"1":
                        use_rule = USE_RULES["all_all_tasks"]
                    use_rule = Rule.ByKeys(use_rule)
                    if use_rule:
                        tasks = use_rule.getObjects(Task, add_expr=qstr, max_result=limit, order_by="position", **rule_args)
                        for tobj in tasks:
                            if tobj.task_id not in context.tmaps:
                                gen_parent_struct(tobj)


class GetCPOIStructure(elink.Template):
    __template__ = "cpoi_structure.htm"

    def render(self, context, *args, **varkw):
        self.request.charset = "utf-8"
        cdb_project_id = varkw.get("cdb_project_id", "")
        task_id = varkw.get("task_id", "")
        cdb_person_id = varkw.get("cdb_person_id", "")

        taskobj = Task.ByKeys(cdb_project_id, task_id)
        context.tmaps = {}
        context.issues = []
        context.cls = []
        context.task_object = None
        if taskobj:
            context.task_object = {"cdb_project_id": taskobj.cdb_project_id,
                                   "task_id": taskobj.task_id,
                                   "task_name": encode_js_text(taskobj.GetDescription()),
                                   "icon": taskobj.GetObjectIcon()}

            qstr = "cdb_project_id='%s' and task_id='%s' " % (cdb_project_id, task_id)

            rule_args = {"persno": cdb_person_id}

            arule = Rule.ByKeys(USE_RULES["active_issues"])
            mrule = Rule.ByKeys(USE_RULES["my_issues"])
            if arule and mrule:
                issues = arule.getObjects(Issue, add_expr=qstr, order_by="cdb_project_id, issue_id ", **rule_args)
                for iobj in issues:
                    idata = {"id": iobj.issue_id,
                             "name": encode_js_text(iobj.GetDescription()),
                             "icon": iobj.GetObjectIcon()}
                    if mrule.match(iobj, **rule_args):
                        idata["highlight"] = 1
                    context.issues.append(idata)
            arule = Rule.ByKeys(USE_RULES["active_checklists"])
            arule1 = Rule.ByKeys(USE_RULES["active_checkpoints"])
            mrule1 = Rule.ByKeys(USE_RULES["my_checkpoints"])
            if arule and arule1 and mrule1:
                cls = arule.getObjects(Checklist, add_expr=qstr, **rule_args)
                for clobj in cls:
                    cldata = {"id": clobj.checklist_id,
                              "name": encode_js_text(clobj.GetDescription()),
                              "icon": clobj.GetObjectIcon(),
                              "is_group": 1,
                              "children": []}
                    qstr1 = "cdb_project_id='%s' and checklist_id='%s' " % (cdb_project_id, clobj.checklist_id)
                    cps = arule1.getObjects(ChecklistItem, add_expr=qstr1, **rule_args)
                    for cpobj in cps:
                        cpdata = {"id": cpobj.cl_item_id,
                                  "name": encode_js_text(cpobj.GetDescription()),
                                  "icon": cpobj.GetObjectIcon()}
                        if mrule1.match(cpobj, **rule_args):
                            cpdata["highlight"] = 1
                        cldata["children"].append(cpdata)
                    context.cls.append(cldata)

app = elink.AppMaker(TimeSheetElinkAPP)
