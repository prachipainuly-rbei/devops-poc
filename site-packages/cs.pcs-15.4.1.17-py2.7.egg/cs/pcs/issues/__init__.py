#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
# vim: set fileencoding=latin1 :
# -*- Python -*-
# $Id: __init__.py 179011 2018-06-15 06:40:47Z umu $
# CDB:Browse
# Copyright (C) 1990 - 2006 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
# File:     Issues.py
# Author:   aki
# Creation: 19.07.06
# Purpose:

# pylint: disable-msg=R0201,R0904,R0913,R0914,E0213,E0102,W0621,W0142,W0201

__all__ = ['Issue', 'IssueChangeLog', 'IssueRemark',
           'ActionReference', 'WithIssueReport']

from cdb import sqlapi, auth, util, ue, cdbtime, CADDOK
from cdb.objects import Reference, N, Forward, Object, State, Transition
from cdb.objects import ReferenceMethods_N
from cdb.objects.org import WithSubject
from cdb.objects.common import WithStateChangeNotification
from cdb.platform import gui
import os
from cs.pcs.issues.tasks_plugin import IssueWithCsTasks
from cs.sharing.share_objects import WithSharing

# Forward declarations
Project = Forward("cs.pcs.projects.Project")
Task = Forward("cs.pcs.projects.tasks.Task")
Issue = Forward("cs.pcs.issues.Issue")
IssueChangeLog = Forward("cs.pcs.issues.IssueChangeLog")
IssueRemark = Forward("cs.pcs.issues.IssueRemark")
fAction = Forward("cs.actions.Action")
fActionReference = Forward(__name__ + ".ActionReference")


class WithFrozen(object):
    """
    mixin to update cdbpcs_frozen after create/copy operations
    to prevent circular imports, this has to be implemented here
    """
    def set_frozen(self, ctx):
        if hasattr(self, "cdbpcs_frozen"):
            project = getattr(self, "Project", None)
            if project:
                newFrozen = int(project.status == project.FROZEN.status)
                if newFrozen != self.cdbpcs_frozen:
                    self.cdbpcs_frozen = newFrozen

    event_map = {
        (('create', 'copy'), 'pre'): "set_frozen",
        }


class Issue(WithSubject, WithStateChangeNotification, WithSharing, WithFrozen, IssueWithCsTasks):

    __maps_to__ = "cdbpcs_issue"
    __classname__ = "cdbpcs_issue"

    _change_log_attrs = ["reason", "category", "priority", "subject_id",
                         "target_date", "effort_plan", "material_cost", "waiting_for", "currency_object_id"]

    Project = Reference(1, Project, Issue.cdb_project_id)
    Task = Reference(1, Task, Issue.cdb_project_id, Issue.task_id)
    ChangeLogs = Reference(N, IssueChangeLog,
                           IssueChangeLog.cdb_project_id == Issue.cdb_project_id,
                           IssueChangeLog.issue_id == Issue.issue_id)

    ActionReferences = Reference(N, fActionReference,
                                 fActionReference.cdb_project_id == Issue.cdb_project_id,
                                 fActionReference.issue_id == Issue.issue_id)

    IssueActions = ReferenceMethods_N(fAction, lambda self: [ref.Action for ref in self.ActionReferences])

    def setDone(self, comment=""):
        sc = self.GetStateChange()
        sc.step(Issue.COMPLETED.status)

    def remarksAsText(self):
        t = sqlapi.SQLselect("distinct a.cdb_cpersno, a.cdb_cdate, b.remark_id, b.zeile, b.text from cdbpcs_iss_rem a,"
                             "cdbpcs_issr_txt b where b.issue_id = %s and b.cdb_project_id = '%s' and a.issue_id=b.issue_id "
                             "and a.cdb_project_id = b.cdb_project_id and a.remark_id = b.remark_id "
                             "order by b.remark_id desc, b.zeile asc"
                             % (self.issue_id, self.cdb_project_id))
        text = ""
        curr_remark_id = ""
        for i in range(sqlapi.SQLrows(t)):
            remark_id = sqlapi.SQLstring(t, 2, i)
            if curr_remark_id != remark_id:
                if len(text) > 0:
                    text = text + "\n%s\n" % (70 * "=")
                text = (text + "*** " + sqlapi.SQLstring(t, 0, i) + ", "
                        + sqlapi.SQLstring(t, 1, i) + "\n\n")
                curr_remark_id = remark_id
            text = text + sqlapi.SQLstring(t, 4, i).replace("\\n", "\n")
        return text

    def fillRemarksLongtext(self, ctx):
        ctx.set("cdbpcs_iss_comments", self.remarksAsText())

    def newChangeLog(self, ctx):
        if ctx.error != 0:
            return
        valdict = self._key_dict()
        valdict["id"] = util.nextval("cdbpcs_iss_log")
        valdict["changed_by"] = auth.persno
        valdict["changed_at"] = self.cdb_mdate
        if len(self.ChangeLogs) == 0:
            # 1. Eintrag -> Alle Attribute einfuegen
            for attr in self._change_log_attrs:
                valdict[attr] = self[attr]
            IssueChangeLog.Create(**valdict)
        else:
            # nur die geaenderten Attribute einfuegen
            changed_attrs = ctx.sys_args["changed_attrs"]
            if changed_attrs:
                for attr in changed_attrs.split(','):
                    valdict[attr] = ctx.dialog[attr]
                IssueChangeLog.Create(**valdict)

    def setIssueID(self, ctx):
        self.issue_id = util.nextval("cdbpcs_issue")

    def on_modify_pre(self, ctx):
        # Keep the changed attributes to create the change log entry in the modify post user exit
        changed_attrs = []
        for attr in self._change_log_attrs:
            if hasattr(ctx.dialog, attr) and ctx.dialog[attr] != ctx.object[attr]:
                changed_attrs.append(attr)
        ctx.set("cdb::argument.changed_attrs", ','.join(changed_attrs))

    def on_copy_pre_mask(self, ctx):
        self.issue_id = ""

    def on_cdb_show_responsible_now(self, ctx):
        return self.openSubject()

    def on_delete_post(self, ctx):
        self.ChangeLogs.Delete()

    def GetDisplayAttributes(self):
        """This method creates and returns a results dictionary, containing the
        necessary information for the html display in the client."""
        results = self.Super(Issue).GetDisplayAttributes()
        results[u"attrs"].update({u"heading": unicode(self["mapped_category_name"])})
        return results

    # == Email notification ==

    def getNotificationTitle(self, ctx=None):
        """
        :param ctx:
        :return: title of the notification mail
        :rtype: basestring
        """
        return "{} - Offener Punkt bereit / Issue ready".format(
            gui.Message.GetMessage("branding_product_name")
        )

    def getNotificationTemplateName(self, ctx=None):
        """
        :param ctx:
        :return: template name of the notification mail body
        :rtype: basestring
        """
        return "cdbpcs_issue_ready.html"

    def getNotificationReceiver(self, ctx=None):
        rcvr = {}
        if self.Subject:
            for pers in self.Subject.getPersons():
                if pers.email_notification_task():
                    tolist = rcvr.setdefault("to", [])
                    tolist.append((pers.e_mail, pers.name))
        return [rcvr]

    # == End email notification ==

    # ########################### Utils for copying and resetting checklists ######################

    def Reset(self):
        from cdb.platform import olc

        self.Update(status=Issue.NEW.status,
                    cdb_status_txt=olc.StateDefinition.ByKeys(Issue.NEW.status, self.cdb_objektart).StateText[''])

    def MakeCopy(self, project, task):
        args = {"cdb_project_id": project.cdb_project_id,
                "issue_id": project.makeID("issue_id", self)
                }
        if task:
            args.update({"task_id": task.task_id})

        new_issue = self.Copy(**args)

        # Langtexts kopieren
        new_issue.SetText("cdbpcs_iss_txt", self.GetText("cdbpcs_iss_txt"))
        new_issue.SetText("cdbpcs_isss_txt", self.GetText("cdbpcs_isss_txt"))

        return new_issue

    def GetActivityStreamTopics(self, posting):
        """
        Activity Stream postings should be assigned
        to the project and the object itself.
        """
        return [self, self.Project]

    def on_wf_step_pre_mask(self, ctx):
        # Set info fields of the status Waiting For (70) readonly
        # The fields must only be editable if the target status Waiting For (70) is selected.
        ctx.set_fields_readonly(["waiting_for_name", "waiting_reason"])

    def on_wf_step_dialogitem_change(self, ctx):
        # if target status is Waiting For (70) set the
        # info fields writeable, otherwise readonly
        if self.status == 70:
            ctx.set_fields_writeable(["waiting_for_name", "waiting_reason"])
        else:
            ctx.set_fields_readonly(["waiting_for_name", "waiting_reason"])

    def setFields(self, ctx):
        ctx.set_fields_readonly(self.getReadOnlyFields(action=ctx.action))

    def getReadOnlyFields(self, action=u"modify", avoid_check=False):
        return ["cdb_project_id", "project_name"]

    def check_project_role_needed(self, ctx):
        self.Project.check_project_role_needed(ctx)

    event_map = {
        (('create', 'copy'), 'pre'): ("setIssueID"),
        (('create', 'copy', 'modify'), 'post'): ("newChangeLog", "check_project_role_needed"),
        (('modify', 'info'), 'pre_mask'): ("setFields", "fillRemarksLongtext"),
        (('delete', 'state_change'), 'post'): ("check_project_role_needed"),
        }


class IssueChangeLog(Object):
    __maps_to__ = "cdbpcs_iss_log"


class IssueRemark(Object):
    __maps_to__ = "cdbpcs_iss_rem"

    Issue = Reference(1, Issue, IssueRemark.issue_id, IssueRemark.cdb_project_id)

    def setID(self, ctx):
        self.remark_id = util.nextval("cdbpcs_iss_rem")

    def setDefaults(self, ctx):
        ctx.set("cdbpcs_iss_comments", self.Issue.remarksAsText())

    def setShortText(self, ctx):
        self.short_text = ctx.dialog.cdbpcs_issr_txt[:255].replace("\n", " ")

    event_map = {
        (('create', 'copy'), 'pre_mask'): "setDefaults",
        (('create', 'copy'), 'pre'): ("setID", "setShortText"),
        }


class ActionReference(Object):
    __maps_to__ = "cdb_action2issue"
    __classname__ = "cdb_action2issue"

    Action = Reference(1, fAction, fActionReference.action_object_id)


class WithIssueReport(object):
    @classmethod
    def on_cdbpcs_issue_report_now(cls, ctx):
        project = Project.ByKeys(ctx.dialog.cdb_project_id)
        task = Task.ByKeys(ctx.dialog.cdb_project_id, ctx.dialog.task_id)
        report_file = cls.GenerateIssueReport(project, task, ctx.dialog.close_flag,
                                              ctx.dialog.priority, ctx.dialog.fromdate, ctx.dialog.to)
        if os.path.isfile(report_file):
            ctx.file(report_file)
        else:
            raise ue.Exception("cdbpcs_issue_report_failed", report_file)

    @classmethod
    def GenerateIssueReport(cls, project, task=None, close_flag=None, priority=None, from_date=None, to_date=None, layoutFile=None):
        # Select Issues
        cond = "cdb_project_id = '%s'" % project.cdb_project_id
        if close_flag:
            cond += " AND close_flag = '%s'" % close_flag
        if priority:
            cond += " AND priority = '%s'" % priority
        if task:
            cond += " AND task_id = '%s'" % task.task_id
        if not to_date:
            to_date = cdbtime.now()
        cond += " AND reported_at <= %s" % sqlapi.SQLdbms_date(to_date)
        if from_date:
            cond += " AND reported_at >= %s" % sqlapi.SQLdbms_date(from_date)
        issues = sqlapi.RecordSet2("cdbpcs_issue", condition=cond, addtl="order by issue_id")
        # Find layout file and setup output file
        if not layoutFile:
            xml_template = "layout_cdbpcs_issue_report.xml"
            layoutFile = os.path.join(CADDOK.BASE, 'reports', xml_template)
            if not os.path.isfile(layoutFile):
                layoutFile = os.path.join(os.path.dirname(__file__), xml_template)
        resultFile = os.path.join(CADDOK.TMPDIR,
                                  "issreport-" + auth.login + "-" +
                                  cdbtime.now("%a-%d-%b-%Y-%H-%M-%S") + ".xml")
        # generate Report
        from cdb.reportutils import xmlDataSourceCreator, xmlReportCreator
        dataFile = None
        rds = xmlDataSourceCreator.ReportDataSourceCreator(layoutFile, dataFile)
        rds.fillWithRecordset([project])
        rds.fillWithRecordset(issues, {}, "cdbpcs_issue")
        rep = xmlReportCreator.ReportCreator(layoutFile, dataFile, resultFile)
        rep.setDatas(rds.getDatas())
        rep.createReport()
        rep.output()
        return resultFile
