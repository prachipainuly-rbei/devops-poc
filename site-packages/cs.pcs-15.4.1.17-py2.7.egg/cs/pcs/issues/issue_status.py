#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: set fileencoding=latin1 :
# -*- Python -*-
# $Id: issue_status.py 166847 2017-10-18 07:09:48Z via $
# CDB:Browse
# Copyright (C) 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

# pylint: disable-msg=R0201,R0904,R0913,R0914,E0213,E0102,W0621,W0142,W0201

from cdb import ue
from cdb.classbody import classbody
from cdb.objects import State, Transition
from cs.pcs.issues import Issue


@classbody
class Issue(object):
    @classmethod
    def endStatus(cls, full_cls=True):
        """
        returns set of "final" status classes (full_cls True) or integer values
        (full_cls False) and cache them for subsequent access
        """
        if not hasattr(cls, "__end_status_cls__"):
            cls.__end_status_cls__ = set([cls.DISCARDED, cls.COMPLETED])
            cls.__end_status_int__ = set(
                [x.status for x in cls.__end_status_cls__])
        if full_cls:
            return cls.__end_status_cls__
        return cls.__end_status_int__

    class NEW(State):
        status = 0

    class EVALUATION(State):
        status = 30

    class EXECUTION(State):
        status = 50

        def Constraints(transition, self):
            from cs.pcs.projects.tasks import Task
            return [("MatchStateList", [[self.Task], [Task.READY, Task.NEW, Task.EXECUTION], "pcstask_wf_rej_1"])]

    class DEFERRED(State):
        status = 60

    class WAITINGFOR(State):
        status = 70

        def pre(state, self, ctx):
            # Die Felder 'Warten auf' und 'Grund' muessen ausgefuellt sein
            if ctx.dialog["waiting_reason"] == "" or ctx.dialog["waiting_for_name"] == "":
                from cdb.platform import gui
                masks = gui.Mask.ByName('cdbpcs_issue_state')
                attrs = "'%s', '%s'" % (masks[0].AttributesByName["waiting_for_name"][0].Label[''],
                                        masks[0].AttributesByName["waiting_reason"][0].Label[''])
                raise ue.Exception("pcs_err_iss_state", ctx.dialog["zielstatus"], attrs)

        def post(state, self, ctx):
            # 'Warten auf' und 'Grund' aus der Statuswechselmaske uebernehmen.
            if not ctx.error:
                self.reason = ctx.dialog["waiting_reason"]
                self.waiting_for = ctx.dialog["waiting_for_persno"]

    class REVIEW(State):
        status = 100

    class DISCARDED(State):
        status = 180

        def FollowUpStateChanges(state, self):
            if self.Task:
                target_status = self.Task.getFinalStatus()
                if target_status:
                    return [(target_status, [self.Task], 0, 0)]
            return []

    class COMPLETED(State):
        status = 200

        def FollowUpStateChanges(state, self):
            if self.Task:
                target_status = self.Task.getFinalStatus()
                if target_status:
                    return [(target_status, [self.Task], 0, 0)]
            return []

    class FROM_WAITINGFOR(Transition):
        transition = (70, '*')

        def post(state, self, ctx):
            # Felder 'warten auf' und 'Grund' leeren
            if not ctx.error:
                self.reason = ""
                self.waiting_for = ""

    # Flag setzen, ob der Offene Punkt abgeschlossen ist.
    # {angelegt, Analyse, in Bearbeitung, Pruefung, Wartet auf jemand anders} => nein
    # {abgeschlossen, gestrichen} => ja
    # {zurueckgestellt} => offen
    class TO_DISCARDED_OR_COMPLETED(Transition):
        transition = ('*', (180, 200))

        def post(state, self, ctx):
            if not ctx.error:
                self.close_flag = 'ja'

    class TO_DEFERRED(Transition):
        transition = ('*', 60)

        def post(state, self, ctx):
            if not ctx.error:
                self.close_flag = 'offen'

    class TO_NOT_COMPLETED(Transition):
        transition = ('*', (0, 30, 50, 70, 100))

        def post(state, self, ctx):
            if not ctx.error:
                self.close_flag = 'nein'
