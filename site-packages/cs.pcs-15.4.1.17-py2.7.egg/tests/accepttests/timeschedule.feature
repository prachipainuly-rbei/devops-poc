# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

@windows
Feature: timeschedule
In order to get an overview of all dates or deadlines and dependencies related to
one or more projects. As a project manager, I want to be able to create a timeschedule.
That timeschedule is necessary, when I want to attach valid timeschedule objects,
like projects or tasks.

	Background: I am logged in in Web Client
	Given I am logged in in Web Client


	Scenario: Create new timeschedule
	In order to get a plain timeschedule which I can fill later, I need to create
	a new timeschedule without any context. That means I create the timeschedule
	manually by hand.

	When User creates a new timeschedule
	Then a new timeschedule is created


	Scenario Outline: Create a new timeschedule with a primary project
	In order to get a timeschedule with a related project I create a
	new timeschedule with a primary project, where I decline either
	the project-name or the project-id.

	Given a project exists
	When User creates a new timeschedule with project and <given_attr>
	Then a new timeschedule is created
	And the project is attached to the timeschedule

	Examples:
  	| given_attr |
  	| id         |
	| name       |


	Scenario: Attach timeschedule to project
	In order to make a timeschedule of a first project available to a second project
	I attach it to the second one.

	Given a project exists
	And a timeschedule exists
	When Projektleiter attaches a timeschedule to a project
	Then the timeschedule is attached to the project

    
	Scenario Outline: Add a valid object to a timeschedule
	A valid timeschedule object is any project element, which offers the
	possibility to set start and end date or in case of milestones just to
	set an end date.
	In order to add more content to a timeschedule I attach a valid timeschedule object(s)
	to a timeschedule.

	Given a project exists
	And a timeschedule exists
	When Projektleiter attaches <element> to a timeschedule
	Then the <element> is attached to the timeschedule
	And all previous elements are still attached

	Examples:
	| element |
	| task    |
	| project |


#	Scenario Outline: Move a timeschedule object by dragging it to the new date
#	In order to change the time-frame of a timeschedule object I set a new start date.
#
#	Given a timeschedule object of type <element> exists
#	And that <element> has the start date <start> and the end date <end>
#	And that <element> has days and days_fcast set to <days>
#	When Projektleiter moves <element> and sets startdate to <newstart> with <expectedend>
#	Then the start date is <newstart>
#	And the end date is <expectedend>
#	And the duration is <days>
#
#	Examples:
#    | element | start      | end        | days | newstart   | expectedend |
#    | task    | 02.01.2014 | 10.01.2014 | 7    | 15.01.2014 | 23.01.2014  | Over a weekend
#    | project | 02.01.2014 | 10.01.2014 | 7    | 15.01.2014 | 23.01.2014  | Over a weekend
#    | task    | 05.12.2013 | 08.01.2014 | 25   | 10.12.2013 | 13.01.2014  | Over new Year
#    | project | 05.12.2013 | 08.01.2014 | 25   | 10.12.2013 | 13.01.2014  | Over new Year
#    | task    | 04.01.2014 | 11.01.2014 | 5    | 13.01.2014 | 17.01.2014  | Start Date at a weekend
#    | project | 04.01.2014 | 11.01.2014 | 5    | 13.01.2014 | 17.01.2014  | Start Date at a weekend
#    | task    | 27.02.2012 | 02.03.2012 | 5    | 28.02.2012 | 05.03.2012  | Task over a leapyear
#    | project | 22.02.2012 | 03.03.2012 | 8    | 28.02.2012 | 08.03.2012  | Project over a leapyear


	Scenario Outline: Alternate a timeschedule object by changing the start
	In order to change the time-frame of a timeschedule object I set a new start by dragging the start of it.

	Given a timeschedule object of type <element> exists
	And that <element> has the start date <start> and the end date <end>
	And that <element> has days and days_fcast set to <days>
	When Projektleiter moves <element> and sets start to <newstart>
	Then the start date is <newstart>
	And the end date is <end>
	And the duration is <expecteddays>

	Examples:
    | element | start      | end        | days | expecteddays | newstart   |
    | task    | 07.06.2014 | 16.06.2014 | 6    | 4            | 11.06.2014 | Start Date at a weekend
    | project | 07.06.2014 | 16.06.2014 | 6    | 4            | 11.06.2014 | Start Date at a weekend
    | task    | 24.02.2012 | 05.03.2012 | 7    | 4            | 29.02.2012 | Over a leapyear
    | task    | 16.12.2013 | 03.01.2014 | 15   | 5            | 30.12.2013 | Over new Year
    | project | 16.12.2013 | 03.01.2014 | 15   | 5            | 30.12.2013 | Over new Year
    | task    | 05.05.2014 | 09.05.2014 | 5    | 3            | 07.05.2014 |
   	| project | 05.05.2014 | 09.05.2014 | 5    | 3            | 07.05.2014 |

    

#	Scenario Outline: Move timeschedule objects which are depended at each other
#	In order to realize dependency violations when I move depended timeschedule objects
#	I move depended objects by number of days in different directions causing either
#	violations or not.
#
#	Given 3 <element> exist
#	And first element has start date <start_date>
#	And each element has duration of <duration> days
#	And <element> dates are in row with a gap of <gap> days
#	And first element is predecessor and last element is successor of second element
#	When Projektleiter moves second <element> by <mdays> days to the <direction>
#	Then dependencies still exist
#	And dependency between first and second element is <violation_first>
#	And dependency between second and third element is <violation_third>
#
#  	# Note: used days and mdays are calendar days (weekends included) and not workdays
#	Examples:
#    | element   | start_date | duration | gap | mdays | direction | violation_first | violation_third |
#    | task      | 01.01.2014 | 4        | 1   | 4     | left      | violated        | not_violated    | Move middle element left with the result that the dependency to predecessor is violated
#    | task      | 02.01.2014 | 4        | 1   | 4     | right     | not_violated    | violated        | Move middle element right with the result that the dependency to successor is violated
#    | task      | 01.01.2014 | 4        | 2   | 1     | left      | not_violated    | not_violated    | Move middle element left with the result that the dependency to predecessor is not violated
#    | task      | 02.01.2014 | 4        | 2   | 1     | right     | not_violated    | not_violated    | Move middle element right with the result that the dependency to successor is not violated
#    | milestone | 01.04.2014 | 0        | 5   | 4     | left      | not_violated    | not_violated    | Move middle element left with the result that the dependency to predecessor is not violated
#    | milestone | 01.04.2014 | 0        | 5   | 4     | right     | not_violated    | not_violated    | Move middle element right with the result that the dependency to successor is not violated
#    | milestone | 01.04.2014 | 0        | 1   | 4     | left      | violated        | not_violated    | Move middle element left with the result that the dependency to predecessor is violated
#    | milestone | 01.04.2014 | 0        | 1   | 4     | right     | not_violated    | violated        | Move middle element right with the result that the dependency to successor is violated


  Scenario Outline: Create relations between tasks, which are allowed

  GIVEN 2 <element> exist
  AND first element has start date <start_date>
  WHEN Projektleiter creates relation <relation> between the 2 tasks
  THEN relation <relation> creation is <success>

  Examples:
    | element   | start_date | relation | success    |
    | task      | 01.01.2014 | EA       | successful |
    | task      | 01.01.2014 | AA       | successful |
    | task      | 01.01.2014 | AE       | successful |
    | task      | 01.01.2014 | AA       | successful |


  Scenario Outline: Create relations between tasks, which are not allowed and also test exception handling

  GIVEN 2 <element> exist
  AND first element has start date <start_date>
  AND there is an <relation1> relation between the second and the first task
  WHEN Projektleiter creates relation <relation2> between the 2 tasks
  THEN relation <relation> creation is <success>

  Examples:
    | element   | start_date | relation1 | relation2 | success |
    | task      | 01.01.2014 | EA        | EA        | failed  |
    | task      | 01.01.2014 | EA        | AA        | failed  |
    | task      | 01.01.2014 | EA        | AE        | failed  |
    | task      | 01.01.2014 | EA        | AA        | failed  |


  Scenario Outline: Delete relations between tasks

  GIVEN 2 <element> exist
  AND first element has start date <start_date>
  AND there is an <relation1> relation between the second and the first task
  WHEN Projektleiter deletes relation <relation2> between the 2 tasks
  THEN relation <relation2> deletion is <success>

  Examples:
    | element   | start_date | relation1 | relation2 | success     |
    | task      | 01.01.2014 | EA        | EA        | successful  |
    | task      | 01.01.2014 | AA        | AA        | successful  |
    | task      | 01.01.2014 | AE        | AE        | successful  |
    | task      | 01.01.2014 | AA        | AA        | successful  |
    | task      | 01.01.2014 | AA        | EA        | failed      |
    | task      | 01.01.2014 | EA        | AA        | failed      |
    | task      | 01.01.2014 | EA        | AE        | failed      |
    | task      | 01.01.2014 | EA        | AA        | failed      |
