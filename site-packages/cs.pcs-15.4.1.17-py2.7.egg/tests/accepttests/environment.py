#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbHfor behave
# All rights reserved.
# http://www.contact.de/
#
import sys
import requests
import cdbwrapc

from cdb import util, sqlapi
from cdb.objects import org
from cdb.validationkit import generateUser
from cdb.uberserver import usutil
from cdb.uberserver.management import Management
from cdb.plattools import killableprocess
from cdb import testcase
from cs.pcs.projects.tasks import TaskRelation


__docformat__ = "restructuredtext en"
__revision__ = "$Id: environment.py 155587 2017-03-16 20:12:38Z kbu $"


def ensure_running_service_daemon(context):
    """If a service daemon isn't already running,
    then a temporary one gets started"""
    svc = Management()
    if svc._check_if_its_up(usutil.UBERSERVER):
        context.temp_service_daemon = None
    else:
        svc.start()
        context.temp_service_daemon = svc


def terminate_temp_service_daemon(context):
    if context.temp_service_daemon:
        try:
            context.temp_service_daemon.shutdown()
        except Exception as ex:
            print ex
            if sys.platform == "win32":
                # workaround for shutdown method not functioning properly (on
                # windows)
                killableprocess.call(
                    ['taskkill', '/f', '/t', '/im', 'cdbsvcd.exe'])


def get_server_url():
    """Returns the url under which extern (and intern)
    users can access the portal"""
    srv = testcase.require_service("cdb.uberserver.services.apache.Apache")
    return srv.get_url(withuserandpass=False)


class MiniDriver(object):
    cookie = None
    server_url = None
    logged_in = False

    def login_webdriver(self, context, username="behave_test", password=""):
        r = requests.post(context.server_url + "cdbgate/logon",
                          data={"username": username,
                                "password": password,
                                "language": "D"})
        context.cookies = r.cookies
        self.cookie = r.cookies
        self.server_url = context.server_url
        self.logged_in = True
        return r

    def logout_webdriver(self):
        if self.server_url is not None:
            r = requests.post(self.server_url + "cdbgate/__quit__",
                              cookies=self.cookie, data={})
            return r

    def do_request(self, url, data='', headers={}, params={}):
        r = requests.get(url, cookies=self.cookie, data=data, headers=headers, params=params)
        return r

    def post(self, sub_url, data=None, json=None, **kwargs):
        url = "%s%s" % (self.server_url, sub_url)
        return requests.post(url, data, json, cookies=self.cookie, **kwargs)


class EventListener(util.DBEventListener):
    __listener = None

    def __init__(self):
        super(EventListener, self).__init__()
        self.__events = []

    def notify(self, relation, event):
        self.__events.append(
            (event.m_event,
             relation,
             event.m_keys.items()))

    def rollback(self):
        def generateWhere(keys):
            where = ""
            for key, value in keys:
                where += "%s='%s' AND " % (key, value)
            return where[:-5]

        try:
            self.doUnregister()
            self.__events.reverse()
            for t, relation, keys in self.__events:
                if t == util.kRecordInserted and relation != "cdb_global_subj":
                    sqlapi.SQLdelete("FROM %s where %s" % (relation,
                                                           generateWhere(keys)))
        finally:
            self.clear()
            self.doRegister()

    def clear(self):
        self.__events = []

    @classmethod
    def getListener(cls):
        if not EventListener.__listener:
            EventListener.__listener = EventListener()
        return EventListener.__listener


def before_scenario(context, scenario):
    listener = EventListener.getListener()
    listener.doRegister()


def after_scenario(context, scenario):
    persno = getattr(getattr(context, "person", None), "personalnummer", None)
    listener = EventListener.getListener()
    [t.Delete() for t in TaskRelation.Query()]
    listener.rollback()
    listener.doUnregister()
    if persno:
        sqlapi.SQLdelete("FROM cdb_global_subj WHERE subject_id='{}'".format(
            persno))


def before_all(context):
    # Create a new User to use for testing and login as this one
    users = org.User.KeywordQuery(personalnummer="behave_test")
    if len(users) > 0:
        context.user = users[0]
    else:
        context.user = generateUser("behave_test")

    # Log him in
    assert cdbwrapc.set_user(context.user.personalnummer), \
        "The User couldn't be logged in"
    # run CDB server
    ensure_running_service_daemon(context)
    # setup webdriver
    context.server_url = get_server_url()
    context.webdriver = MiniDriver()
    context.webdriver.login_webdriver(context)


def after_all(context):
    # Logout Elink Session
    context.webdriver.logout_webdriver()
    terminate_temp_service_daemon(context)

    # Delete the created user
    if hasattr(context, "user"):
        sqlapi.SQLdelete("FROM cdb_global_subj WHERE subject_id='{}'".format(
            context.user.personalnummer))
        context.user.Delete()

    # temp. workaround: kill orphaned cdbsrv processes, which
    # the test execution may leak.
    if sys.platform == "win32":
        killableprocess.call(["taskkill", "/IM", "cdbsrv.exe", "/F"])
