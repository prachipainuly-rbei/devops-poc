#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
import datetime
import json

from cdb.validationkit import run_with_added_roles
from cdb.validationkit import run_with_project_roles
from cdb.validationkit import operation
from cdb.validationkit import given
from cdb.validationkit import when
from cdb.validationkit import then
from cdb.validationkit import log
from cs.pcs.timeschedule import TimeSchedule, Project2TimeSchedule, TSHelper
from common import generateProject, generateProjectTask
from cs.pcs.projects.tasks import Task, TaskRelation
from cdb import cdbtime
from cdb import auth

standard_header = {}


def do_request(context, timeschedule_id, ajax_method_name, params):
    url = "%scdbgate/powerscript/cs.pcs.timeschedule.new_time_chart/time_api/%s/%s/post" % (
        context.server_url, timeschedule_id, ajax_method_name)
    return context.webdriver.do_request(url=url, params=params)


# -------------------------------------------------------------
# Background: I am logged in in Web Client
#
# -------------------------------------------------------------
@given("I am logged in in Web Client")
@run_with_added_roles(["Documentation", "Administrator"])
# All the necessary roles must be there at login
def step(context):
    if not context.webdriver.logged_in:
        context.webdriver.login_webdriver(context, username=auth.persno)


# ------------------------------------------------------------
# Scenario Outline: Create new timeschedule
#
# ------------------------------------------------------------
@when("User creates a new timeschedule$")
def step(context):
    @run_with_added_roles(["Administrator"])
    def create(context):
        context.ts_len = len(TimeSchedule.Query())
        preset = {"subject_id": auth.persno,
                  "subject_type": "Person"}
        try:
            context.ts_obj = operation("CDB_Create", TimeSchedule,
                                       user_input={"name": "Testplan"}, preset=preset)
        except Exception, e:
            log("Error creating the timeschedule, details: %s" % e)

    create(context)


@then("^a new timeschedule is created$")
def step(context):
    assert TimeSchedule.KeywordQuery(cdb_object_id=context.ts_obj.cdb_object_id), \
        "No timeschedule was generated"


# ------------------------------------------------------------
# Scenario Outline:  Create a new timeschedule with a primary project
#
# ------------------------------------------------------------
@when("^User creates a new timeschedule with project and (?P<given_attr>.*?)$")
def step(context, given_attr):
    def create(context):
        context.ts_len = len(TimeSchedule.Query())
        context.project = generateProject()

        if given_attr == "id":
            preset = {"project_name": context.project.project_name}
            try:
                context.ts_obj = operation("CDB_Create",
                                           TimeSchedule,
                                           user_input={"name": "Testplan",
                                                       "cdb_project_id": context.project.cdb_project_id},
                                           preset=preset)
            except Exception, e:
                log("Error creating new timeschedule with primary project, details: %s" % e)

        elif given_attr == "name":
            preset = {"cdb_project_id": context.project.cdb_project_id}
            try:
                context.ts_obj = operation("CDB_Create", TimeSchedule,
                                           user_input={"name": "Testplan",
                                                       "project_name": context.project.project_name},
                                           preset=preset)
            except Exception, e:
                log("Error creating new timeschedule with primary project, details: %s" % e)

    create(context)


# ------------------------------------------------------------
# Scenario Outline:  Attach timeschedule to project
#
# ------------------------------------------------------------
@given("^a timeschedule exists$")
def step(context):
    @run_with_added_roles(["Administrator"])
    def create(context):
        context.ts_obj = operation("CDB_Create", TimeSchedule, user_input={"name": "Testplan"})

    create(context)
    context.attached = context.ts_obj.TimeScheduleContents


@when("^(?P<role>.*?) attaches a timeschedule to a project$")
def step(context, role):
    @run_with_project_roles(context.project, role.split(","))
    def create(context):
        preset = {"time_schedule_oid": context.ts_obj.cdb_object_id,
                  "cdb_project_id": context.project.cdb_project_id,
                  "project_name": context.project.project_name}
        try:
            context.ts2proj = operation("CDB_Create", Project2TimeSchedule, preset=preset)
        except Exception, e:
            log("Error attaching a timeschedule to a project, details: %s" % e)

    create(context)


@then("^the timeschedule is attached to the project$")
def step(context):
    assert (context.ts2proj.time_schedule_oid == context.ts_obj.cdb_object_id) and (
        context.ts2proj.cdb_project_id == context.project.cdb_project_id), \
        "No timeschedule was attached to a project"


# ------------------------------------------------------------
# Scenario Outline:  Add a valid object to a timeschedule
#
# ------------------------------------------------------------
@when("^(?P<role>.*?) attaches (?P<element>.*?) to a timeschedule$")
def step(context, role, element):
    @run_with_project_roles(context.project, role.split(","))
    def create(context):
        preset = {"time_schedule": context.ts_obj.cdb_object_id}
        if element == "project":
            try:
                context.ts2proj = operation("cdbpcs_ts_add_obj", context.project, preset=preset)
            except Exception, e:
                log("Error creating new timeschedule with primary project, details: %s" % e)
        if element == "task":
            if len(Task.Query()) >= 1:
                context.task = Task.Query()[0]
            else:
                context.task = generateProjectTask(context.project)
            try:
                log(context.task)
                context.ts2task = operation("cdbpcs_ts_add_obj", context.task, preset=preset)
            except Exception, e:
                log("Error add an element to timeschedule, details: %s" % e)

    create(context)


@then("^the (?P<element>.*?) is attached to the timeschedule$")
def step(context, element):
    result = False
    if element == u"task":
        for content in context.ts_obj.TimeScheduleContents:
            if context.task.cdb_object_id == content.getContentObject().cdb_object_id:
                result = True
                break
        assert result, "No task was attached to timeschedule"

    if element == u"project":
        for content in context.ts_obj.TimeScheduleContents:
            if context.project.cdb_object_id == content.getContentObject().cdb_object_id:
                result = True
                break
        assert result, "No project was attached to timeschedule"


@then("^all previous elements are still attached$")
def step(context):
    result = True
    for content in context.attached:
        if content not in context.ts_obj.TimeScheduleContents:
            result = False
    assert result, "Not all previous attached elements of the timeschedule are still attached."


# ------------------------------------------------------------
# Scenario Outline: Move a timeschedule object by dragging it to the new date
#
# ------------------------------------------------------------
@given("a timeschedule object of type (?P<element>.*?) exists")
@run_with_added_roles(["Administrator"])
def step(context, element):
    context.project = generateProject()
    context.element = context.project
    if element == "task":
        context.task = generateProjectTask(context.project)
        context.element = context.task
    if element == "milestone":
        context.task = generateProjectTask(context.project)
        context.task.milestone = True
        context.element = context.task


@given("^that (?P<element>.*?) has the start date (?P<start>.*?) and the end date (?P<end>.*?)$")
def step(context, element, start, end):
    context.element = operation("CDB_Modify", context.element,
                                user_input={"start_time_fcast": start,
                                            "end_time_fcast": end}).getPersistentObject()


@given("^that (?P<element>.*?) has days and days_fcast set to (?P<days>.*?)$")
def step(context, element, days):
    if not context.element.days:
        context.element = operation("CDB_Modify", context.element,
                                    user_input={"days": days, "days_fcast": days}).getPersistentObject()
        context.element.Reload()
        context.days = days


@when("^Projektleiter moves (?P<element>.*?) and sets startdate to (?P<newstart>.*?) with (?P<expectedend>.*?)$")
@run_with_added_roles(["Administrator"])
def step(context, element, newstart, expectedend):
    dateobj = datetime.datetime.strptime(newstart, "%d.%m.%Y")
    timestamp = TSHelper.date2utc(dateobj)
    enddate = datetime.datetime.strptime(expectedend, "%d.%m.%Y")
    endstamp = TSHelper.date2utc(enddate)
    data = {"cdb_object_id": context.element.cdb_object_id,
            "end_date": endstamp,
            "drag": "true",
            "start_date": timestamp,
            "in_table": "false"}
    context.result = do_request(
        context,
        context.project.TimeSchedules[0].cdb_object_id,
        "update_start_end_dates",
        data
    )
    context.element.Reload()


@then("^the start date is (?P<newstart>.*?)$")
def step(context, newstart):
    actual_date = cdbtime.Time(context.element.start_time_fcast)
    expected_date = cdbtime.Time(newstart)
    assert actual_date == expected_date, \
        "start %s was expected but %s was calculated" % (expected_date, actual_date)


@then("^the end date is (?P<expectedend>.*?)$")
def step(context, expectedend):
    actual_date = cdbtime.Time(context.element.end_time_fcast)
    expected_date = cdbtime.Time(expectedend)
    assert actual_date == expected_date, \
        "end %s was expected but %s was calculated" % (expected_date, actual_date)


@then("^the duration is (?P<expecteddays>.*?)$")
def step(context, expecteddays):
    assert context.element.days_fcast == int(expecteddays), \
        "duration of %s was expected but %s was calculated" % (expecteddays, context.element.days_fcast)


# ------------------------------------------------------------
# Scenario Outline: Alternate a timeschedule object by changing the start
#
# ------------------------------------------------------------
@when("^Projektleiter moves (?P<element>.*?) and sets start to (?P<newstart>.*?)$")
@run_with_added_roles(["Administrator"])
def step(context, element, newstart):
    uinput = {"start_time_fcast": newstart,
              "end_time_fcast": context.element.end_time_fcast}
    context.element = operation("CDB_Modify", context.element, user_input=uinput).getPersistentObject()

    context.element.Reload()


# ------------------------------------------------------------
# Scenario Outline: Move timeschedule objects which are depended at each other
#
# ------------------------------------------------------------
@given("^(?P<number>.*?) (?P<element>.*?) exist$")
@run_with_added_roles(["Administrator"])
def step(context, number, element):
    object_list = []
    number = int(number)
    context.project = generateProject()
    context.element_type = element
    if element == "milestone":
        for each in range(number):
            milestone = generateProjectTask(context.project)
            milestone.milestone = True
            object_list.append(milestone)
    if element == "task":
        for each in range(number):
            object_list.append(generateProjectTask(context.project))
    context.object_list = object_list


@given("^first element has start date (?P<start_date>.*?)$")
def step(context, start_date):
    operation("CDB_Modify", context.object_list[0], user_input={"start_time_fcast": start_date})
    if context.element_type == "milestone":
        operation("CDB_Modify", context.object_list[0], user_input={"end_time_fcast": start_date})


@given("^each element has duration of (?P<duration>.*?) days$")
def step(context, duration):
    duration = int(duration)
    for obj in context.object_list:
        operation("CDB_Modify", obj, user_input={"days_fcast": duration})


@given("^(?P<element>.*?) dates are in row with a gap of (?P<gap>.*?) days$")
def step(context, element, gap):
    gap = int(gap) + 1
    for obj in context.object_list[1:]:
        previous_obj = context.object_list[context.object_list.index(obj) - 1]
        previous_obj_end_date = cdbtime.Time(previous_obj.end_time_fcast).date()
        new_start = previous_obj_end_date + datetime.timedelta(days=gap)
        new_start = cdbtime.date_to_str(new_start)
        if context.element_type == "milestone":
            operation("CDB_Modify", obj, user_input={"end_time_fcast": new_start})
        elif context.element_type == "task":
            operation("CDB_Modify", obj, user_input={"start_time_fcast": new_start})
    uinput = {"start_time_fcast": context.object_list[0].start_time_fcast,
              "end_time_fcast": context.object_list[-1].end_time_fcast}
    operation("CDB_Modify", context.project, user_input=uinput)


@given("^first element is predecessor and last element is successor of second element$")
def step(context):
    relobj_list = []
    preset_1 = {"cdb_project_id2": context.project.cdb_project_id,
                "task_id2": context.object_list[0].task_id,
                "rel_type": "EA",
                "cdb_project_id": context.project.cdb_project_id,
                "task_id": context.object_list[1].task_id}

    preset_2 = {"cdb_project_id2": context.project.cdb_project_id,
                "task_id2": context.object_list[1].task_id,
                "rel_type": "EA",
                "cdb_project_id": context.project.cdb_project_id,
                "task_id": context.object_list[2].task_id}

    relobj_list.append(operation("CDB_Create", TaskRelation, preset=preset_1))
    relobj_list.append(operation("CDB_Create", TaskRelation, preset=preset_2))
    context.relobj_list = relobj_list


@when("^Projektleiter moves second (?P<element>.*?) by (?P<mdays>.*?) days to the (?P<direction>.*?)$")
def step(context, element, mdays, direction):
    mdays = int(mdays)
    if element == "milestone":
        date = cdbtime.Time(context.object_list[1].end_time_fcast).date()
        if direction == "left":
            new_start = date - datetime.timedelta(days=mdays)
        elif direction == "right":
            new_start = date + datetime.timedelta(days=mdays)
    elif element == "task":
        date_start = cdbtime.Time(context.object_list[1].start_time_fcast).date()
        date_end = cdbtime.Time(context.object_list[1].end_time_fcast).date()
        if direction == "left":
            new_start = date_start - datetime.timedelta(days=mdays)
            new_end = date_end - datetime.timedelta(days=mdays)
        elif direction == "right":
            new_start = date_start + datetime.timedelta(days=mdays)
            new_end = date_end + datetime.timedelta(days=mdays)

    if element == "milestone":
        timestamp = TSHelper.date2utc(new_start)
        data = {"cdb_object_id": context.object_list[1].cdb_object_id,
                "end_date": timestamp,
                "drag": "true",
                "start_date": timestamp,
                "in_table": "false"}
        context.result = do_request(
            context,
            context.project.TimeSchedules[0].cdb_object_id,
            "update_start_end_dates",
            data
        )
    elif element == "task":
        timestamp_start = TSHelper.date2utc(new_start)
        timestamp_end = TSHelper.date2utc(new_end)
        data = {"cdb_object_id": context.object_list[1].cdb_object_id,
                "end_date": timestamp_end,
                "drag": "true",
                "start_date": timestamp_start,
                "in_table": "false"}
        context.result = do_request(
            context,
            context.project.TimeSchedules[0].cdb_object_id,
            "update_start_end_dates",
            data
        )


@then("^dependencies still exist$")
def step(context):
    result = True
    for obj in context.relobj_list:
        if not TaskRelation.ByKeys(cdb_project_id=obj.cdb_project_id,
                                   task_id=obj.task_id,
                                   cdb_project_id2=obj.cdb_project_id2,
                                   task_id2=obj.task_id2,
                                   rel_type=obj.rel_type):
            result = False
    assert result, "Dependencies has changed after date modification of elements."


@then("^dependency between first and second element is (?P<violation>.*?)$")
def step(context, violation):
    obj = TaskRelation.ByKeys(cdb_project_id=context.relobj_list[0].cdb_project_id,
                              task_id=context.relobj_list[0].task_id,
                              cdb_project_id2=context.relobj_list[0].cdb_project_id2,
                              task_id2=context.relobj_list[0].task_id2,
                              rel_type=context.relobj_list[0].rel_type)
    if violation == "violated":
        assert obj.violation, "Expected dependency to predecessor to be violated but it isn't."
    elif violation == "not_violated":
        assert not obj.violation, "Expected dependency  to predecessor not to be violated but it is."


@then("^dependency between second and third element is (?P<violation>.*?)$")
def step(context, violation):
    obj = TaskRelation.ByKeys(cdb_project_id=context.relobj_list[1].cdb_project_id,
                              task_id=context.relobj_list[1].task_id,
                              cdb_project_id2=context.relobj_list[1].cdb_project_id2,
                              task_id2=context.relobj_list[1].task_id2,
                              rel_type=context.relobj_list[1].rel_type)
    obj.Reload()
    if violation == "violated":
        assert obj.violation, "Expected dependency to successor to be violated but it isn't."
    elif violation == "not_violated":
        assert not obj.violation, "Expected dependency to successor not to be violated but it is."


# ------------------------------------------------------------
# Scenario Outline: Move timeschedule objects which are depended at each other
#   In order to check the movement of the depended objects
# ------------------------------------------------------------


@given("^the elements are depended with (?P<dependency_type>.*?)$")
def step(context, dependency_type):
    relobj_list = []
    preset_1 = {"cdb_project_id2": context.project.cdb_project_id,
                "task_id2": context.object_list[0].task_id,
                "rel_type": dependency_type,
                "cdb_project_id": context.project.cdb_project_id,
                "task_id": context.object_list[1].task_id}

    relobj_list.append(operation("CDB_Create", TaskRelation, preset=preset_1))
    context.relobj_list = relobj_list


# ------------------------------------------------------------
# Scenario Outline: Move timeschedule objects which are depended at each other
#   In order to check the movement of the depended objects
# ------------------------------------------------------------


@given("^first two elements are predecessors of the third which is predecessors to the last two tasks$")
def step(context):
    relobj_list = []
    preset_1 = {"cdb_project_id2": context.project.cdb_project_id,
                "task_id2": context.object_list[0].task_id,
                "rel_type": "EA",
                "cdb_project_id": context.project.cdb_project_id,
                "task_id": context.object_list[2].task_id}

    relobj_list.append(operation("CDB_Create", TaskRelation, preset=preset_1))
    preset_1 = {"cdb_project_id2": context.project.cdb_project_id,
                "task_id2": context.object_list[1].task_id,
                "rel_type": "EA",
                "cdb_project_id": context.project.cdb_project_id,
                "task_id": context.object_list[2].task_id}

    relobj_list.append(operation("CDB_Create", TaskRelation, preset=preset_1))
    preset_1 = {"cdb_project_id2": context.project.cdb_project_id,
                "task_id2": context.object_list[2].task_id,
                "rel_type": "EA",
                "cdb_project_id": context.project.cdb_project_id,
                "task_id": context.object_list[3].task_id}

    relobj_list.append(operation("CDB_Create", TaskRelation, preset=preset_1))
    preset_1 = {"cdb_project_id2": context.project.cdb_project_id,
                "task_id2": context.object_list[2].task_id,
                "rel_type": "EA",
                "cdb_project_id": context.project.cdb_project_id,
                "task_id": context.object_list[4].task_id}

    relobj_list.append(operation("CDB_Create", TaskRelation, preset=preset_1))
    context.relobj_list = relobj_list


@then("^the third tasks should have early start (?P<earlystart>.*?) and late finish (?P<latefinish>.*?)$")
def step(context, earlystart, latefinish):
    context.object_list[2].Reload()
    estart = context.object_list[2].early_start.strftime("%d.%m.%Y")
    lfinish = context.object_list[2].late_finish.strftime("%d.%m.%Y")
    assert earlystart == estart and latefinish == lfinish, "The dates did not match the expectation T1 %s, expected %s;  T2 %s expected %s" % (estart, earlystart, lfinish, latefinish)


# ------------------------------------------------------------
# Scenario Outline: Create relations between tasks, which are allowed
#
# ------------------------------------------------------------
@when("^Projektleiter creates relation (?P<relation>.*?) between the 2 tasks$")
def step(context, relation):
    data = [{"predecessorID": context.object_list[0].cdb_object_id,
             "successorID": context.object_list[1].cdb_object_id,
             "type": relation}]
    context.result = do_request(
        context,
        context.project.TimeSchedules[0].cdb_object_id,
        "create_relations",
        {"relations_data": json.dumps(data)}
    )


@then("^relation (?P<relation>.*?) creation is (?P<success>.*?)$")
def step(context, relation, success):
    created = False
    if TaskRelation.ByKeys(pred_task_oid=context.object_list[0].cdb_object_id,
                           succ_task_oid=context.object_list[1].cdb_object_id,
                           rel_type=relation):
        created = True
    if success == "successful" and not context.result.json():
        assert created, "Relation was not created"
    elif success == "failed" and "error" in context.result.json().keys():
        assert not created, "Impossible relation has been created"


# ------------------------------------------------------------
# Scenario Outline: Create relations between tasks, which are not allowed and also test exception handling
#
# ------------------------------------------------------------
@given("^there is an (?P<relation>.*?) relation between the second and the first task$")
def step(context, relation):
    pred_task = context.object_list[1]
    pred_proj = pred_task.Project
    succ_task = context.object_list[0]
    succ_proj = succ_task.Project
    rel_data_dict = {'cdb_project_id': succ_proj.cdb_project_id,
                     'task_id': succ_task.task_id,
                     'cdb_project_id2': pred_proj.cdb_project_id,
                     'task_id2': pred_task.task_id,
                     'rel_type': relation,
                     'pred_project_oid': pred_proj.cdb_object_id,
                     'pred_task_oid': pred_task.cdb_object_id,
                     'succ_project_oid': succ_proj.cdb_object_id,
                     'succ_task_oid': succ_task.cdb_object_id}
    TaskRelation.createRelation(**rel_data_dict)


# ------------------------------------------------------------
# Scenario Outline: Delete relations between tasks
#
# ------------------------------------------------------------
@when("^Projektleiter deletes relation (?P<relation>.*?) between the 2 tasks$")
def step(context, relation):
    pred_task = context.object_list[1]
    pred_proj = pred_task.Project
    succ_task = context.object_list[0]
    succ_proj = succ_task.Project
    data = [{"rel_type": relation,
            "task_id2": pred_task.task_id,
            "cdb_project_id2": pred_proj.cdb_project_id,
            "task_id": succ_task.task_id,
            "cdb_project_id": succ_proj.cdb_project_id}]
    context.result = do_request(
        context,
        context.project.TimeSchedules[0].cdb_object_id,
        "delete_relations",
        {"primary_keys": json.dumps(data)}
    )


@then("^relation (?P<relation>.*?) deletion is (?P<success>.*?)$")
def step(context, relation, success):
    deleted = True
    if TaskRelation.ByKeys(pred_task_oid=context.object_list[0].cdb_object_id,
                           succ_task_oid=context.object_list[1].cdb_object_id,
                           rel_type=relation):
        deleted = False
    if success == "successful" and not context.result.json():
        assert deleted, "Relation was not deleted"
    # no error shown as per specifications
    elif success == "failed" and context.result.status_code == 200 and not context.result.json():
        assert deleted, "Error shown"
