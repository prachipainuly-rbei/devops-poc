#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

from datetime import datetime
from cdb.validationkit import given
from cdb.validationkit import log
from cdb.validationkit import operation
from cdb.validationkit import run_with_project_roles
from cdb.validationkit import run_with_roles
from cdb.validationkit import then
from cdb.validationkit import when
from common import generateProjectTask
from common import remove_task_descriptions
from cs.pcs.projects.tasks import Task
from cs.pcs.projects.tasks import TaskRelation


# -------------------------------------------------------------
# Scenario Create New Task
#
# -------------------------------------------------------------
@when("^(?P<role>.*?) creates a new task$")
def step(context, role):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, role.split(","))
    def create(context):
        try:
            context.task_len = len(Task.Query())
            context.task = operation(
                "CDB_Create",
                Task,
                user_input={
                    "task_name": "Task",
                    "subject_type": "PCS Role"},
                preset={
                    "subject_id": "Projektmitglied",
                    "cdb_project_id": context.project.cdb_project_id})

        except Exception, e:
            log("Error creating the task, details: %s" % e)

    return create(context)


@then("^a new task is (?P<creation>(?:not )?generated)$")
def step(context, creation):
    if creation == "generated":
        assert len(Task.Query()) - context.task_len == 1, (
            "No new task has been created")
    elif creation == "not generated":
        assert len(Task.Query()) - context.task_len == 0, (
            "A new task has been created")


# ------------------------------------------------------------
# Scenario Create New Task With Constraint Type
#
# ------------------------------------------------------------
@when("^(?P<role>.*?) creates a new task with constraint type$")
def step(context, role):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, role.split(","))
    def create(context):
        try:
            context.task_len = len(Task.Query())
            context.task = operation(
                "CDB_Create",
                Task,
                user_input={
                    "task_name": "Task",
                    "subject_type": "PCS Role",
                    "automatic": False,
                    # "start_time_fcast": datetime(2018, 10, 8),
                    # "end_time_fcast": datetime(2018, 10, 12),
                    "mapped_constraint_type_name": "Start no earlier than",
                    "constraint_type": 4,
                    # "constraint_date": datetime.now()
                    },
                preset={
                    # "start_time_fcast": datetime(2018, 10, 8),
                    # "end_time_fcast": datetime(2018, 10, 12),
                    "subject_id": "Projektmitglied",
                    "cdb_project_id": context.project.cdb_project_id}
            )

        except Exception, e:
            log("Error creating the task, details: %s" % e)

    return create(context)


# ------------------------------------------------------------
# Scenario Create New Task As Mile Stone
#
# ------------------------------------------------------------
@when("^(?P<role>.*?) creates a new milestone$")
def step(context, role):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, role.split(","))
    def create(context):
        context.task_len = len(Task.Query())
        try:
            context.task = operation(
                "CDB_Create",
                Task,
                user_input={
                    "task_name": "Task",
                    "subject_type": "PCS Role",
                    "milestone": 1},
                preset={
                    "subject_id": "Projektmitglied",
                    "cdb_project_id": context.project.cdb_project_id})

        except Exception, e:
            log("Error creating the milestone, details: %s" % e)

    return create(context)


@then("^a new milestone is (?P<creation>(?:not )?generated)$")
def step(context, creation):
    context.execute_steps(u"THEN a new task is %s" % creation)
    if creation == "generated":
        assert context.task.milestone == 1, "The task is not a milestone"


# ------------------------------------------------------------
# Scenario Create New Task As Task Group
#
# ------------------------------------------------------------
@when("^(?P<role>.*?) assigns another task to it$")
def step(context, role):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, role.split(","))
    def create(context):
        try:
            operation(
                "CDB_Create",
                Task,
                user_input={
                    "subject_type": "PCS Role",
                    "task_name": "SubTask"},
                preset={
                    "subject_id": "Projektmitglied",
                    "cdb_project_id": context.project.cdb_project_id,
                    "parent_task_name": context.task.task_name,
                    "parent_task": context.task.task_id})
        except Exception, e:
            log("Error creating the taskgroup, details: %s" % e)

    return create(context)


@then("^a new taskgroup is (?P<creation>(?:not )?generated)$")
def step(context, creation):
    # context.execute_steps(u"THEN a new task is %s" % creation)
    if creation == "generated":
        context.task.Reload()
        assert context.task.is_group == 1 and len(
            Task.Query()) - context.task_len > 1, "The task is not a taskgroup"

    if creation == "not generated":
        assert len(Task.Query()) - context.task_len < 1, (
            "There were tasks created but should not")


# ------------------------------------------------------------
# Scenario Create New Task As Subtask To A Mile Stone
#
# ------------------------------------------------------------
@given("^a milestone exists$")
def step(context):
    context.parent_task = generateProjectTask(
        context.project, user_input_custom={"milestone": 1})

    context.task_len = len(Task.Query())


@when("^(?P<role>.*?) creates a new subtask to it$")
def step(context, role):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, role.split(","))
    def create(context):
        try:
            context.task = operation(
                "CDB_Create",
                Task,
                user_input={
                    "subject_type": "PCS Role",
                    "task_name": "Task"
                },
                preset={
                    "subject_id": "Projektmitglied",
                    "cdb_project_id": context.project.cdb_project_id,
                    "parent_task": context.parent_task.task_id})
        except Exception, e:
            log("Error creating the subtask, details: %s" % e)

    return create(context)


@then("^it is (?P<allocation>(?:not )?allocated) to the milestone$")
def step(context, allocation):
    if allocation == "allocated":
        assert context.task in context.parent_task.SubTasks
    elif allocation == "not allocated":
        if hasattr(context, "task"):
            assert context.task not in context.parent_task.SubTasks


# ------------------------------------------------------------
# Scenario Change Task
#
# ------------------------------------------------------------
def getTaskAttributesToChange():
    return {"task_name": "Changed"}


@given("^a task exists$")
def step(context):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, ["Projektleiter"])
    def generateTask():
        context.task = generateProjectTask(context.project)

    generateTask()
    context.task_len = len(Task.Query())


@when("^(?P<role>.*?) changes this task$")
def step(context, role):
    @run_with_project_roles(context.project, role.split(","))
    def change(context):
        try:
            operation("CDB_Modify",
                      context.task,
                      user_input=getTaskAttributesToChange())
        except Exception, e:
            log("Error changing the task, details: %s" % e)

    return change(context)


@then("^the changed task is (?P<status>(?:not )?saved)$")
def step(context, status):
    context.task.Reload()
    s_attrs = set(getTaskAttributesToChange().items())
    if status == "saved":
        assert s_attrs.issubset(
            set(context.task.items())
        ), "The attributes differ"
    elif status == "not saved":
        assert not s_attrs.issubset(
            set(context.task.items())
        ), "The attributes don't differ"


# ------------------------------------------------------------
# Scenario Change Subtask
#
# ------------------------------------------------------------


@given("^a parent task exists$")
def step(context):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, ["Projektleiter"])
    def generateTask():
        context.parent_task = generateProjectTask(context.project)

    generateTask()
    context.task_len = len(Task.Query())


@given("^a task exists to it$")
def step(context):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, ['Projektleiter'])
    def create(context):
        try:
            context.task = operation(
                "CDB_Create",
                Task,
                user_input={
                    "subject_type": "PCS Role",
                    "task_name": "Task"
                },
                preset={
                    "subject_id": "Projektmitglied",
                    "cdb_project_id": context.project.cdb_project_id,
                    "parent_task": context.parent_task.task_id})
        except Exception, e:
            log("Error creating the subtask, details: %s" % e)

    return create(context)

# ------------------------------------------------------------
# Scenario Copy Task
#
# ------------------------------------------------------------


@given("^the description of the task is (?P<description>(?:not )?set)$")
def step_impl(context, description):
    """
    :param description: unicode
    :type context: behave.runner.Context
    """
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, ["Projektleiter"])
    def change(context, description):
        context.task_description = value = ""
        if description == "set":
            context.task_description = "task description"
            value = context.task_description
        try:
            operation("CDB_Modify",
                      context.task,
                      user_input={"cdbpcs_task_txt": value})
        except Exception, e:
            log("Error changing the task, details: %s" % e)

    return change(context, description)


@when("^(?P<role>.*?) copies this task$")
def step(context, role):
    @run_with_project_roles(context.project, role.split(","))
    def copy(context):
        try:
            context.copy = operation("CDB_Copy", context.task)
        except Exception, e:
            log("Error coping the task, details: %s" % e)

    return copy(context)


@when("^(?P<role>.*?) copies this task (?P<wwo>.*?) description$")
def step(context, role, wwo):
    @run_with_project_roles(context.project, role.split(","))
    def copy(context, wwo):
        user_input = dict()
        if wwo == "with":
            context.task_description = "copy of {}".format(context.task_description)
            user_input["cdbpcs_task_txt"] = context.task_description
        try:
            context.copy = operation("CDB_Copy",
                                     context.task,
                                     preset=user_input)
        except Exception, e:
            log("Error coping the task, details: %s" % e)

    return copy(context, wwo)


@then("^the task is (?P<creation>(?:not )?copied|(?:not )?deleted)$")
def step(context, creation):
    if creation == "copied":
        assert len(Task.Query()) - context.task_len == 1, (
            "The task has not been copied")
    elif creation == "not copied":
        assert len(Task.Query()) - context.task_len == 0, (
            "The task has been copied")
    elif creation == "deleted":
        assert len(Task.Query()) - context.task_len == -1, (
            "The task has not been deleted")
    elif creation == "not deleted":
        assert len(Task.Query()) - context.task_len == 0, (
            "The task has been deleted")


@then("^the new task has a description$")
def step_impl(context):
    """
    :type context: behave.runner.Context
    """
    curr_descr = context.copy.GetText("cdbpcs_task_txt")
    remove_task_descriptions([context.task, context.copy])
    assert curr_descr == context.task_description, "Task description has not been copied"

# ------------------------------------------------------------
# Scenario Delete Task
#
# ------------------------------------------------------------


@when("^(?P<role>.*?) deletes this task$")
def step(context, role):
    @run_with_project_roles(context.project, role.split(","))
    def delete(context):
        try:
            operation("CDB_Delete", context.task)
        except Exception, e:
            log("Error deleting the task, details: %s" % e)

    return delete(context)


# ------------------------------------------------------------
# Scenario Change Status Of A Task
#
# ------------------------------------------------------------


# ------------------------------------------------------------
# Scenario Create two tasks dependend at each other
#
# ------------------------------------------------------------

@when("^(?P<role>.*?) creates a (?P<reltype1>.*?) and a (?P<reltype2>.*?) "
      "dependency between the tasks, where the first is the predecessor "
      "for the first relation and the second one for the second relation.$")
def step(context, role, reltype1, reltype2):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, role.split(","))
    def change(context):

        context.error = None
        context.old_rels = len(TaskRelation.Query())
        args = {"pred_project_oid": context.project.cdb_object_id,
                "cdb_project_id2": context.project.cdb_project_id,
                "pred_task_oid": context.task.cdb_object_id,
                "task_id2": context.task.task_id,
                "succ_project_oid": context.project.cdb_object_id,
                "cdb_project_id": context.project.cdb_project_id,
                "succ_task_oid": context.second_task.cdb_object_id,
                "task_id": context.second_task.task_id,
                "rel_type": reltype1
        }

        try:
            operation("CDB_Create", TaskRelation,
                      preset=args)
            args["pred_task_oid"] = context.second_task.cdb_object_id
            args["task_id2"] = context.second_task.task_id
            args["succ_task_oid"] = context.task.cdb_object_id
            args["task_id"] = context.task.task_id
            args["rel_type"] = reltype2
            operation("CDB_Create", TaskRelation,
                      preset=args)
        except Exception, e:
            context.error = e
            log("Error creating task dependencies, details: %s" % e)
    return change(context)


@then("^there should be no dependency and an error$")
def step(context):
    rels = len(TaskRelation.Query()) - context.old_rels
    assert rels == 1 and context.error, (
        "Did not abort creation of dependencies, "
        "number of relations created %s " % rels)


# ------------------------------------------------------------
# Scenario Create two tasks dependend at each other
#
# ------------------------------------------------------------


@when("^(?P<role>.*?) creates a (?P<reltype1>.*?) and a (?P<reltype2>.*?) "
      "dependency between the tasks, where the first is the predecessor "
      "for the first relation and also for the second relation.$")
def step(context, role, reltype1, reltype2):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, role.split(","))
    def change(context):

        context.error = None
        context.old_rels = len(TaskRelation.Query())
        args = {"pred_project_oid": context.project.cdb_object_id,
                "cdb_project_id2": context.project.cdb_project_id,
                "pred_task_oid": context.task.cdb_object_id,
                "task_id2": context.task.task_id,
                "succ_project_oid": context.project.cdb_object_id,
                "cdb_project_id": context.project.cdb_project_id,
                "succ_task_oid": context.second_task.cdb_object_id,
                "task_id": context.second_task.task_id,
                "rel_type": reltype1
        }

        try:
            operation("CDB_Create", TaskRelation,
                      preset=args)
            args["rel_type"] = reltype2
            operation("CDB_Create", TaskRelation,
                      preset=args)
        except Exception, e:
            context.error = e
            log("Error creating task dependencies, details: %s" % e)
    return change(context)


@then("^the result should be (?P<expected_result>.*?)$")
def step(context, expected_result):
    rels = len(TaskRelation.Query()) - context.old_rels
    result = None
    if expected_result == "Success":
        assert context.error is None, (
            "Did abort creation of dependencies, "
            "number of relations created %s " % rels)
    else:
        assert context.error, (
            "There wasn't an error, but creation should have been canceled.")


# ------------------------------------------------------------
# Scenario Create two tasks dependend at each other
#
# ------------------------------------------------------------


@when("^(?P<role>.*?) creates a (?P<reltype1>.*?) and a (?P<reltype2>.*?) "
      "dependency between the tasks, where the second is the predecessor "
      "for the second relation and also for the second relation.$")
def step(context, role, reltype1, reltype2):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, role.split(","))
    def change(context):
        context.error = None
        context.old_rels = len(TaskRelation.Query())
        args = {"pred_project_oid": context.project.cdb_object_id,
                "cdb_project_id2": context.project.cdb_project_id,
                "pred_task_oid": context.second_task.cdb_object_id,
                "task_id2": context.second_task.task_id,
                "succ_project_oid": context.project.cdb_object_id,
                "cdb_project_id": context.project.cdb_project_id,
                "succ_task_oid": context.task.cdb_object_id,
                "task_id": context.task.task_id,
                "rel_type": reltype1
        }

        try:
            operation("CDB_Create", TaskRelation,
                      preset=args)
            args["rel_type"] = reltype2
            operation("CDB_Create", TaskRelation,
                      preset=args)
        except Exception, e:
            context.error = e
            log("Error creating task dependencies, details: %s" % e)
    return change(context)


@when("^(?P<role>.*?) creates a (?P<reltype>.*?) dependency between the tasks$")
def step(context, role, reltype):
    @run_with_roles(["public"])
    @run_with_project_roles(context.project, role.split(","))
    def add_taskrel(context):
        context.error = None
        context.old_rels = len(TaskRelation.Query())
        args = {"pred_project_oid": context.project.cdb_object_id,
                "cdb_project_id2": context.project.cdb_project_id,
                "pred_task_oid": context.task.cdb_object_id,
                "task_id2": context.task.task_id,
                "succ_project_oid": context.project.cdb_object_id,
                "cdb_project_id": context.project.cdb_project_id,
                "succ_task_oid": context.second_task.cdb_object_id,
                "task_id": context.second_task.task_id,
                "rel_type": reltype
        }
        try:
            operation("CDB_Create", TaskRelation, preset=args)
        except Exception, e:
            context.error = e
            log("Error creating task dependency, details: %s" % e)

    return add_taskrel(context)
