# coding: utf-8
from cdb.validationkit import given
from cdb.validationkit import operation
from cdb.validationkit import run_with_project_roles
from cdb.validationkit import then
from cdb.validationkit import when
from cdb.validationkit import log

from common import getContextObject
from common import getDate
from common import test_to_python_rep
from common import test_to_user_repr_date_format
from cs.pcs.projects import tasks_schedule
from cs.pcs.projects.tasks import Task
from cs.pcs.projects.tasks import TaskRelation

DATE_RE = "[0-9]{4}-[0-9]{2}-[0-9]{2}"
MODE_RE = "manually|ASAP|ALAP"
MODE_DATE_RE = "MSO|MFO|SNET|SNLT|FNET|FNLT"
LINKS_RE = "AA|AE|EA|EE"

# attributes
START_ATTR = tasks_schedule.SO
END_ATTR = tasks_schedule.EO
DURATION_ATTR = "days_fcast"
COMPLETION_ATTR = "percent_complet"
AUTO_ATTR = "automatic"
AUTO_TIME_ATTR = "auto_update_time"
CONSTRAINT_ATTR = "constraint_type"
CONSTRAINT_DATE_ATTR = "constraint_date"

# constraint types
MODES = {
    "ASAP": tasks_schedule.ASAP,
    "ALAP": tasks_schedule.ALAP,
    "MSO": tasks_schedule.MSO,
    "MFO": tasks_schedule.MFO,
    "SNET": tasks_schedule.SNET,
    "SNLT": tasks_schedule.SNLT,
    "FNET": tasks_schedule.FNET,
    "FNLT": tasks_schedule.FNLT,
}


def name2ctx(name):
    return name.lower().replace(" ", "_")


def generateProjectTask(project, **kwargs):
    # WARNING: uses .Create because CDB_Create triggers rescheduling the project
    vals = {
        "cdb_project_id": project.cdb_project_id,
        "task_id": Task.makeTaskID(project.cdb_project_id),
        "subject_id": "Projektmitglied",
        "subject_type": "PCS Role",
        "task_name": "Task",
        "start_time_fcast": "01.01.2014",
        "end_time_fcast": "01.01.2014",
        CONSTRAINT_ATTR: tasks_schedule.ASAP,
    }
    vals.update(Task.MakeChangeControlAttributes())
    vals.update(kwargs)
    return Task.Create(**vals)


def task_links(task, indent=0):

    if not isinstance(task, Task):
        return ''

    i = " " * indent

    def _task_str(task):
        return "{}{}\t[{} - {}]".format(
            i, task.GetDescription(), task[START_ATTR], task[END_ATTR])

    def _link(link, ref):
        return "{}{}+{}\n{}{}\n".format(
            2 * i, link.rel_type, link.minimal_gap, 3 * i, _task_str(
                getattr(link, ref)))

    def _plinks(task):
        return "".join(
            _link(l, "PredecessorTask")
            for l in task.PredecessorTaskRelations.KeywordQuery(violation=1))

    def _slinks(task):
        return "".join(
            _link(l, "SuccessorTask")
            for l in task.SuccessorTaskRelations.KeywordQuery(violation=1))

    return ("\n{}{}----\n{}".format(_plinks(task), i, _slinks(task)))


def task_debug(task, indent=0):
    import pprint
    result = {x: task[x] for x in tasks_schedule.CALCULATION_ATTRIBUTES if getattr(task, x, None)}

    if getattr(task, 'PredecessorTaskRelations', None):
        result["violated_links"] = [
            dict(p) for p in task.PredecessorTaskRelations.KeywordQuery(
                violation=1)]

    if getattr(task, 'SuccessorTaskRelations', None):
        result["violated_links"] += [
            dict(s) for s in task.SuccessorTaskRelations.KeywordQuery(
                violation=1)]

    return pprint.pformat(result, indent=4 + indent, width=1)


def createTask(project, name, parent='', position=None, **kwargs):

    args = {
        "task_name": name,
        "parent_task": parent,
        "position": position if position else 10,
        "early_position": 1,  # TODO also test for 0
        AUTO_TIME_ATTR: 1,  # TODO also test for 0
        "automatic": 0,
        "days_fcast": 1,
        "status": 0,
        "cdb_objektart": "cdbpcs_task",
        "is_group": 0,
        "milestone": 0
    }

    args.update(kwargs)

    new_task = generateProjectTask(project, **args)

    if new_task.ParentTask and not new_task.ParentTask.is_group:
        new_task.ParentTask.is_group = 1

    return new_task


@given(u'^the (?P<name>.*) (?P<mode>is|is not) automatically rescheduled$')
def set_project_or_task_update_mode(context, name, mode):
    obj = getContextObject(context, name2ctx(name))

    if mode == "is":
        obj.Update(**{AUTO_TIME_ATTR: 1})
    elif mode == "is not":
        obj.Update(**{AUTO_TIME_ATTR: 0})


@given(u'^a task named "(?P<name>.*)" exists$')
def create_task(context, name):
    obj_name = name2ctx(name)
    if getattr(context, obj_name, None):
        raise RuntimeError("object named '{}' already exists".format(obj_name))

    setattr(context, obj_name, createTask(context.project, name))


@given(u'^the (?P<parent>.*) has (?P<amount>a|two|three) child tasks?$')
def create_children(context, parent, amount):
    names = ["First Child", "Second Child", "Third Child"]

    parent_task = getContextObject(context, parent)

    def create_tasks(task_names):
        p = 10
        for name in task_names:
            setattr(context, name2ctx(name), createTask(
                context.project, name, parent=parent_task.task_id, position=p))
            p += 10

    if amount == "a":
        name = "%s Child" % parent.capitalize()
        setattr(context, name2ctx(name), createTask(
            context.project, name, parent=parent_task.task_id))
    elif amount == "two":
        create_tasks(names[:2])
    elif amount == "three":
        create_tasks(names[:3])


@given(u"^a related task exists$")
def create_related_task(context):
    assert context.task, "task is missing in context"
    context.related_task = createTask(context.task.Project, "Related Task")


@given(u"^the (?P<obj>.*) starts on (?P<start>{0}) "
        "and ends on (?P<end>{0})$".format(DATE_RE))
def set_dates(context, obj, start, end):
    projectOrTask = getContextObject(context, obj)

    projectOrTask.Update(**{
        START_ATTR: getDate(start),
        END_ATTR: getDate(end),
    })


@given(u'^the (?P<task>.*) is a milestone$')
def set_milestone(context, task):
    milestone = getContextObject(context, name2ctx(task))
    return operation("CDB_Modify", milestone, user_input={"milestone": 1,
                                                          "early_position": 0})


@then(u"^the (?P<obj>.*) starts on (?P<start>{0}) "
        "and ends on (?P<end>{0})$".format(DATE_RE))
def assert_dates(context, obj, start, end):
    projectOrTask = getContextObject(context, obj)
    expectedStart = getDate(start)
    expectedEnd = getDate(end)

    matching = (
        projectOrTask[START_ATTR] == expectedStart and
        projectOrTask[END_ATTR] == expectedEnd
    )
    assert matching, (
        "\n\n{}:"
        "\n    starts on {}, ends on {}"
        "\n    expected {} and {}"
        "\n\n    values:"
        "\n    {}"
        "\n\n    violated links:"
        "\n    {}".format(
            projectOrTask.GetDescription(),
            projectOrTask[START_ATTR],
            projectOrTask[END_ATTR],
            expectedStart,
            expectedEnd,
            task_debug(projectOrTask, 4),
            task_links(projectOrTask, 4),
        ))


@given(u"^an (?P<rel>{0})(?:(?P<gap>\+?-?[0-9]+)d)? "
        "link exists between (?P<pred>.*) and (?P<succ>.*)$".format(LINKS_RE))
def create_link(context, rel, gap, pred, succ):
    predTask = getContextObject(context, pred)
    succTask = getContextObject(context, succ)

    vals = {
        "rel_type": rel,
        "minimal_gap": int(gap) if gap else 0,

        # predecessor/source
        "pred_project_oid": context.project.cdb_object_id,
        "cdb_project_id2": context.project.cdb_project_id,
        "pred_task_oid": predTask.cdb_object_id,
        "task_id2": predTask.task_id,

        # successor/target
        "succ_project_oid": context.project.cdb_object_id,
        "cdb_project_id": context.project.cdb_project_id,
        "succ_task_oid": succTask.cdb_object_id,
        "task_id": succTask.task_id,
    }
    context.link = TaskRelation.Create(**vals)


@given(u"^the (?P<obj>.*)'s duration is (?P<days>[0-9]+) days?$")
def set_duration(context, obj, days):
    getContextObject(context, obj).Update(**{DURATION_ATTR: int(days)})


@given(u"^the (?P<obj>.+)'s completion is (?P<percent>[0-9]+)$")
def set_completion(context, obj, percent):
    getContextObject(context, obj).Update(**{COMPLETION_ATTR: int(percent)})


@given(u"^the (?P<obj>.+) is scheduled (?P<mode>{0})$".format(MODE_RE))
def set_scheduling(context, obj, mode):
    if mode == "manually":
        vals = {
            AUTO_ATTR: 0,
            CONSTRAINT_ATTR: MODES["ASAP"],  # default, should be irrelevant
            CONSTRAINT_DATE_ATTR: None,
        }
    else:  # ASAP or ALAP
        vals = {
            AUTO_ATTR: 1,
            CONSTRAINT_ATTR: MODES[mode],
            CONSTRAINT_DATE_ATTR: None,
        }
    getContextObject(context, obj).Update(**vals)


@given(u"^the (?P<obj>.+) is scheduled (?P<mode>{0}) (?P<date>{1})$".format(
    MODE_DATE_RE, DATE_RE))
def set_scheduling_with_date(context, obj, mode, date):
    getContextObject(context, obj).Update(**{
        AUTO_ATTR: 1,
        CONSTRAINT_ATTR: MODES[mode],
        CONSTRAINT_DATE_ATTR: getDate(date),
    })


@when(u"^the project's tasks are rescheduled$")
def reschedule(context):
    context.project.recalculate()


@given("^(?P<role>.*) changes the (?P<task>.*)'s (?P<attr>.*) attribute to (?P<val>.*)$")
@when("^(?P<role>.*) changes the (?P<task>.*)'s (?P<attr>.*) attribute to (?P<val>.*)$")
def change_object(context, role, task, attr, val):

    t = getContextObject(context, task)

    @run_with_project_roles(t, [role])
    def _change():
        operation("CDB_Modify", t, user_input={attr: test_to_python_rep(t, attr, val)})

    _change()


@then(u"^the (?P<task>.*)'s (?P<attr>.*) attribute is (?P<val>.*)$")
def verify_task(context, task, attr, val):
    t = getContextObject(context, task)
    # TODO handle date formatting
    assert t[attr] == val, (
        "expected {}'s '{}' attribute to be '{}', is '{}'".format(
            task, attr, val, t[attr]))


@when("the (?P<obj>.*) start moves to (?P<move_start>.+)")
def step(context, obj, move_start):
    """
    :type context: behave.runner.Context
    :type object: str
    :type move_start: str
    """
    @run_with_project_roles(context.project, ["Projektleiter"])
    def move_object(obj):

        new_date = test_to_user_repr_date_format(move_start)

        user_input = {
            'start_time_new': new_date
        }
        operation('cdbpcs_prj_reset_start_time', obj, user_input=user_input)

    projectOrTask = getContextObject(context, obj)

    move_object(projectOrTask)


@given(u'^the task is set to automatic$')
def set_task_automatic(context):
    return operation(u"CDB_Modify", context.task, user_input={u"automatic": 1,
                                                              u"auto_update_time": 1})


@given(u'^the task is set to manual$')
def set_task_manual(context):
    return operation(u"CDB_Modify", context.task, user_input={u"automatic": 0,
                                                              u"auto_update_time": 0})


@when(u'^(?P<role>.*?) sets the task to (?P<automatic>.*?)$')
def set_the_task_to(context, role, automatic):
    @run_with_project_roles(context.project, role.split(u","))
    def activating(context, automatic):
        try:
            if automatic == u"activated":
                context.activated = operation(u"activate_automatic", context.task)
            elif automatic == u"deactivated":
                context.activated = operation(u"deactivate_automatic", context.task)
        except Exception, e:
            log(u"Error activating the task, details: %s" % e)

    return activating(context, automatic)


@then(u'^the task is set to (?P<automatic>.*?)$')
def set_task_is_set_to(context, automatic):
    context.task.Reload()
    if automatic == u"activated":
        assert context.task.automatic == 1, (
            u"The task has not been set automatic")
    elif automatic == u"deactivated":
        assert context.task.automatic == 0, (
            u"The task has not been set manual")
