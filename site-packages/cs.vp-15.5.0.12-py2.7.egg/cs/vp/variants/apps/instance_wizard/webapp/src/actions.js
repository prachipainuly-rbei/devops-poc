// jshint esversion:6

import {
    fetchRelship,
    referencedObjects,
    createObject
} from 'cs-web-components-base';
import Immutable from 'immutable';
import {BOMTreeActions, PropertyRestTreeActions,
         BOMRestTreeActions, BOMTreeContainerId,
         ToDoListActions, ToDoListContainerId, namespace} from './init';
import {bomTreeSearchResyncAction, bomTreePredicateSearchAction} from './searches';
import {constants as tableConstants} from 'cs-vp-table-component';
import {getParentId, receivedObject, receivedRelship} from 'cs-vp-rest-tree-component';


export function setConfig(config) {
    return {
        type: 'SET_CONFIG',
        config
    };
}

export function setContext(context) {
    return {
        type: 'SET_CONTEXT',
        context
    };
}

export function setTitle() {
    return (dispatch, getState) => {
        const state = getState();
        const {config, context} = state[namespace];
        const product = state.objectsById.get(
            config.getIn(['links', 'base_urls', 'product']) + '/' + context.product_object_id);
        const product_desc = product.get('system:description');
        const title = product_desc + ' (' + config.get('title') + ')';
        document.title = title;
    };
}

export function loadPartListForTreeNode(row) {
    return (dispatch, getState) => {
        const state = getState();
        const {objectsById, relshipsById, fetchingById} = state;
        const {context} = state[namespace];
        const todoListRow = row;
        const segments = todoListRow.get(tableConstants.ROW_ID).split(';');
        const obj = objectsById.get(segments.pop());
        const item = getItem(state, obj);
        const relshipId = item.getIn(['system:relships', 'relships', 'Instantiations']);
        if (relshipsById.get(relshipId)) {
            dispatch(setPartList(relshipId, todoListRow)());
        } else if (!fetchingById.some((_, url) => url.includes(relshipId))) {
            dispatch(fetchRelship(
                relshipId,
                'variant',
                context, [
                    setPartList(relshipId, todoListRow)
                ]));
        }
    };
}

export function getItem(state, obj) {
    const {objectsById, relshipsById} = state;
    const {config} = state[namespace];
    if (obj.get('@type') === config.getIn(['links', 'type_urls', 'part'])) {
        return obj;
    } else {
        const itemId = relshipsById.get(obj.getIn(['system:relships', 'relships', 'Item']));
        return objectsById.get(itemId);
    }
}

export function setPartList(relshipId, todoListRow) {
    return () => (dispatch, getState) => {
        const state = getState();
        const {relshipsById, objectsById} = state;
        const {config} = state[namespace];
        const relship = relshipsById.get(relshipId);
        const firstEntry = Immutable.Map({
            _text: config.getIn(['labels', 'cdbvp_variants_new_article']),
            _id: 'NEW'
        });
        if (relship) {
            const objects = relship.map(id => objectsById.get(id));
            const options = Immutable.List(objects).map(obj => obj.merge({
                _text: obj.get('system:description'),
                _id: obj.get('@id')
            })).insert(0, firstEntry);
            dispatch(editTodoListCell(todoListRow, '_item_list', options));
        } else {
            dispatch(editTodoListCell(todoListRow, '_item_list', Immutable.List([firstEntry])));
        }
    };
}

export function initToDoList(searchId, matchedNodeIds) {
    return (dispatch, getState) => {
        const state = getState();
        const {objectsById} = state;
        const {config} = state[namespace];

        const tableState = state[namespace][ToDoListContainerId];
        if (!tableState.get('initialised') && searchId === 'backend-bom-predicate-search') {
            const items = Immutable.fromJS(
                matchedNodeIds.map(nodePath => {
                    const nodeId = nodePath.split(';').pop();
                    const obj = objectsById.get(nodeId);
                    let item_obj = undefined;

                    if (obj && obj.get('@type') === config.getIn(['links', 'type_urls', 'part'])) {
                        item_obj = obj;
                    } else if (
                        obj && obj.get('@type') === config.getIn(['links', 'type_urls', 'bom_item'])
                    ) {
                        item_obj = referencedObjects(state, obj, 'Item');
                    } else {
                        //
                    }

                    return {
                        assembly: item_obj.get('system:description'),
                        item: config.getIn(['labels', 'cdbvp_variants_new_article']),
                        _item_id: 'NEW',
                        _id: nodePath,
                        _selected: nodePath === matchedNodeIds[0]
                    };
                })
            );
            dispatch(ToDoListActions['setContent'](items));
        }
    };
}


export function updateToDoEntry(id) {
    return (dispatch, getState) => {
        const state = getState();
        const {objectsById} = state;
        const {config} = state[namespace];

        const description = (() => {
            if (id === 'NEW') {
                return config.getIn(['labels', 'cdbvp_variants_new_article']);
            } else {
                const item = objectsById.get(id);
                return item.get('system:description');
            }
        })();

        const tableState = state[namespace][ToDoListContainerId];
        const rows = tableState.get('rows');
        const selectedRowId =
            rows.filter(row => row.get('_selected')).map(row => row.get('_id')).get(0);
        const newContent = rows.map(row => {
            if (row.get('_selected') === true) {
                return row.merge({
                    item: description,
                    _item_id: id
                });
            } else {
                if (row.get('_id').indexOf(selectedRowId) !== -1) {
                    // reset and hide children of an item currently choosen
                    return row.merge({
                        item: config.getIn(['labels', 'cdbvp_variants_new_article']),
                        _item_id: 'NEW',
                        _visible: id === 'NEW'
                    });
                } else {
                    return row;
                }
            }
        });
        dispatch(ToDoListActions['setContent'](newContent));
        if (selectedRowId) {
            dispatch(ToDoListActions['selectRow'](selectedRowId));
        }
    };
}

function _getAssignedPartTreeIdFromRowInTodoList(state, row) {
    if (row) {
        const RowItemId = row.get('_item_id');
        const RowId = row.get(tableConstants.ROW_ID);
        const RowIdSegments = RowId.split(';');
        RowIdSegments.pop();
        if (RowItemId !== 'NEW') {
            return RowIdSegments.length > 0 ? RowIdSegments.join(';') + ';' + RowItemId : RowItemId;
        }
    }
    return undefined;
}

export function updateTreeNode(action) {
    return (dispatch, getState) => {
        if (action.key === '_item_id') {
            const state = getState();
            const {objectsById} = state;
            const row = action.row;
            const newRowItemId = action.value;
            const rowId = row.get('_id');
            const item = newRowItemId !== 'NEW' ?
                objectsById.get(newRowItemId) : objectsById.get(rowId.split(';').pop());
            if (newRowItemId === 'NEW') {
                const resetAction =
                    BOMRestTreeActions['resetReplacedNodeById'](BOMTreeContainerId, rowId);
                dispatch(resetAction);
            } else {
                const updateAction =
                    BOMRestTreeActions['setReplacedNodeById'](BOMTreeContainerId, rowId, item);
                dispatch(updateAction);
            }
            setTimeout(() => {
                dispatch(bomTreeSearchResyncAction(item, getParentId(rowId)));
            }, 1);
        }
    };
}

export function syncTodoListSelectionToTree(id) {
    return (dispatch, getState) => {
        const state = getState();
        const todoListState = state[namespace][ToDoListContainerId];
        const rows = todoListState.get('rows');
        let newSelectedRow = undefined;
        let resetNeeded = true;
        if (id && todoListState.get('initialised')) {
            rows.forEach(row => {
                if (row.get('_selected') && row.get('_id') === id) { // actual selection - do nothing
                    resetNeeded = false;
                } else if (!row.get('_selected') && row.get('_id') === id) { // select matching row (not selected before)
                    newSelectedRow = row;
                } else if (row.get('_item_id')) {
                    const idSegments = row.get('_id').split(';');
                    idSegments.pop();
                    const alternativeId = idSegments.concat(row.get('_item_id')).join(';');
                    if (row.get('_selected') && alternativeId === id) {// actual selection - do nothing
                        resetNeeded = false;
                    } else if (!row.get('_selected') && alternativeId === id) { // select matching row (based on assigned object)
                        newSelectedRow = row;
                    }
                }
            });
            if (newSelectedRow) {
                // important need to be done async
                setTimeout(() => {
                    dispatch(ToDoListActions['selectRow'](newSelectedRow));
                }, 1);
            }
            else if (resetNeeded) {
                // important need to be done async
                setTimeout(() => {
                    dispatch(ToDoListActions['resetRowSelection']());
                }, 1);
            }
        }
    };
}

export function selectBOMTreeNode(row) {
    return (dispatch, getState) => {
        if (row !== undefined) {
            const state = getState();
            const bomTreeState = state[namespace][BOMTreeContainerId];
            // use assigned part tree id if a part is selected (otherwise nothing will be found in tree)
            const selectedItemTreeId = _getAssignedPartTreeIdFromRowInTodoList(state, row);
            const baseId = selectedItemTreeId ? selectedItemTreeId : row.get(tableConstants.ROW_ID);
            if (bomTreeState.get('selectedId') !== baseId) {
                const idSegments = baseId.split(';');
                const object_id = idSegments.pop();
                const obj = state.objectsById.get(object_id);
                const parentId = idSegments.join(';').replace(object_id, '');
                if (parentId) {
                    dispatch(BOMTreeActions['expandTreeNode'](parentId));
                }
                dispatch(selectBomTreeNodeById(baseId, obj));
            }
        }
    };
}

export function instantiatePart() {
    return (dispatch, getState) => {
        const state = getState();
        const {objectsById} = state;
        const {context, config, todoList} = state[namespace];
        const base_urls = config.getIn(['links', 'base_urls']);

        const values = Object.assign({
            data: todoList.get('rows').map(row => (
                {
                    path: row.get('_id').split(';').map(id => objectsById.get(id)),
                    id: row.get('_item_id'),
                    obj: objectsById.get(row.get('_item_id'))
                }
            )).toJS()
        }, context);

        const url = base_urls.get('part');
        dispatch(startLoading());
        dispatch(createObject(url + '/+instance', [values], [])).then(data => {
            dispatch(instanceCreated(data));
            dispatch(stopLoading());
        });
    };
}

export function startLoading() {
    return {
        type: 'START_LOADING'
    };
}

export function stopLoading() {
    return {
        type: 'STOP_LOADING'
    };
}

export function instanceCreated(data) {
    return {
        type: 'INSTANCE_CREATED',
        payload: data
    };
}

export function openDropdown() {
    return (table, row, col) => {
        return (dispatch) => {
            const openKey = col.get(tableConstants.KEY) + '_opened';
            dispatch(editTodoListCell(row, openKey, true));
        };
    };
}

export function fetchProduct(data) {
    return dispatch => {
        for (const obj of data.objects) {
            dispatch(receivedObject(obj["@id"], obj));
        }
        for (const relship of data.relships) {
            dispatch(receivedRelship(relship));
        }
        dispatch(PropertyRestTreeActions['buildTree'](data));
        dispatch(BOMRestTreeActions['buildTree'](data));
        dispatch(bomTreePredicateSearchAction(data));
        dispatch(setTitle(data));
    };
}


export function searchBomTree(searchCondition, searchId, search, idFieldPath) {
    return dispatch => {
        const action = BOMTreeActions['searchTree'](searchCondition, searchId, search, idFieldPath);
        const matchedNodeIds = dispatch(action);
        dispatch(initToDoList(searchId, matchedNodeIds));
    };
}


export function selectBomTreeNodeById(id, content) {
    return dispatch => {
        const action = BOMTreeActions['selectTreeNodeById'](id, content);
        dispatch(action);
        dispatch(syncTodoListSelectionToTree(action.id));
    };
}


export function editTodoListCell(row, key, value) {
    return dispatch => {
        const action = ToDoListActions.editCell(row, key, value);
        dispatch(action);
        dispatch(updateTreeNode(action));
    };
}
