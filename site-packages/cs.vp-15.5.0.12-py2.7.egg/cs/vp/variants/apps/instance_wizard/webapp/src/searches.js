import $ from 'jquery';
import Immutable from 'immutable';

import {constants as tableConstants} from 'cs-vp-table-component';
import {receivedRelship} from 'cs-vp-rest-tree-component';

import {
    BOMRestTreeActions, BOMTreeContainerId, ToDoListContainerId, namespace
} from './init';
import {getItem, startLoading, stopLoading, searchBomTree} from './actions';
import {TreeTools} from 'cs-vp-utils';


export const propertyTreeSimpleSearch = {
    'simple-text-search': {
        cssclass: 'simple-text-search-match',
        match: (node, searchCondition) => {
            if (
                searchCondition !== '' &&
                node.getIn(['content', 'system:description']).indexOf(searchCondition) !== -1
            ) {
                return true;
            } else {
                return false;
            }
        },
        resultCnt: 0,
        navigatedIdx: 0,
        navigationCSSClasses: 'simple-text-search-navigated',
        matchedNodeIds: [],
        idFieldPathList: ['id']
    }
};

export const bomTreeSimpleSearch = {
    'simple-backend-text-search': {
        cssclass: 'simple-backend-text-search-match',
        match: (node, searchCondition) => {
            const {matched} = searchCondition;
            if (matched.length > 0 &&
                (
                    matched.indexOf(node.getIn(['content', 'cdb_object_id'])) !== -1 ||
                    matched.indexOf(
                        node.getIn(['additional_content', 'Item', 'cdb_object_id'])) !== -1
                )
            ) {
                return true;
            } else {
                return false;
            }
        },
        resultCnt: 0,
        navigatedIdx: 0,
        navigationCSSClasses: 'simple-backend-text-search-navigated',
        matchedNodeIds: [],
        idFieldPathList: ['id']
    }
};

export const bomTreePredicateSearch = {
    'backend-bom-predicate-search': {
        cssclass: 'backend-bom-predicate-search-match',
        match: (node, searchCondition) => {
            if (searchCondition.length > 0 &&
                (
                    searchCondition.indexOf(node.getIn(['content', 'cdb_object_id'])) !== -1 ||
                    searchCondition.indexOf(
                        node.getIn(['additional_content', 'Item', 'cdb_object_id'])) !== -1
                )
            ) {
                return true;
            } else {
                return false;
            }
        },
        resultCnt: 0,
        navigatedIdx: 0,
        navigationCSSClasses: 'backend-bom-predicate-search-navigated',
        matchedNodeIds: [],
        idFieldPathList: ['id']
    }
};

export const searchAction = (url, params, performSearchAction, updateAction) => {
    return (dispatch, getState) => {
        const {objectsById} = getState();
        dispatch(startLoading());
        $.getJSON(url, params).then((data) => {
            // data.expanded -> relships -> each -> receivedRelship with data objects within
            // data.matched -> search condition -> list of matching id's

            const {expanded, matched} = data;

            expanded.relships.forEach(relship => dispatch(receivedRelship(relship)));
            expanded.ids.forEach(nodeId => {
                const obj = objectsById.get(nodeId);
                if (obj) {
                    dispatch(updateAction(nodeId, obj));
                }
            });
            dispatch(performSearchAction(matched));
            dispatch(stopLoading());
        }, () => {
            // put error information to the user
        });
    };
};

const convertIds = (state, idString) => {
    return idString.split(';').map(elemId => {
        const obj = state.objectsById.get(elemId);
        const item = getItem(state, obj);
        if (item) {
            return item.get('cdb_object_id');
        } else {
            return undefined;
        }
    }).filter(elem => elem !== undefined);
};

const getPartMapping = (state) => {
    const todoListState = state[ToDoListContainerId];
    const rows = todoListState.get(tableConstants.ROWS);
    const mapping = {};
    rows.forEach(row => {
        const assignedPart = row.get('_item_id');
        if (assignedPart !== 'NEW') {
            mapping[convertIds(state, row.get(tableConstants.ROW_ID))] =
                convertIds(state, assignedPart);
        }
    });
    return mapping;
};

export const bomTreeSimpleSearchAction =
    (searchCondition, searchId, teileNummer, teileIndex, previousResult, parentNodeId) =>
        (dispatch, getState) => {
            const state = getState();
            const {context, config} = state[namespace];

            if (searchCondition === '') {
                dispatch(searchBomTree({matched: [], text: ''}, searchId));
                return undefined;
            }

            const request_url = config.getIn(["links", "util_urls", "bom_text_search"]);
            let request_data = Immutable.Map(context);
            request_data = request_data.set('text', searchCondition);
            const mapping = getPartMapping(state[namespace]);
            request_data = request_data.set('mapping', JSON.stringify(mapping));
            if (teileNummer !== undefined) {
                request_data = request_data.set('teilenummer', teileNummer);
            }
            if (teileIndex !== undefined) {
                request_data = request_data.set('t_index', teileIndex);
            }
            const performSearchAction = (matched) => {
                let matchedIds = matched;
                if (previousResult !== undefined) {
                    matchedIds = Immutable.Set(matched.concat(previousResult)).toJS();
                }
                return searchBomTree({matched: matchedIds, text: searchCondition}, searchId);
            };
            const updateAction = (id, obj) => {
                let nodeId = id;
                let nodeObj = obj;
                if (parentNodeId !== undefined) {
                    // find the right nodeId to update
                    const gen = TreeTools.walkTopDownDepthFirst(
                        state[namespace][BOMTreeContainerId].get('node'));

                    for (const node of gen) {
                        if (
                            node.getIn(['content', '@id']) === obj.get('@id') ||
                            node.getIn(['additional_content', 'Item', '@id']) === obj.get('@id')
                        ) {
                            nodeId = node.get('id');
                            nodeObj = node.get('content');
                            break;
                        }
                    }
                }
                return BOMRestTreeActions['updateTreeNodeById'](
                    BOMTreeContainerId, nodeId, nodeObj);
            };
            return searchAction(
                request_url, request_data.toJS(), performSearchAction, updateAction
            )(dispatch, getState);
        };

export const bomTreePredicateSearchAction = () => {
    return (dispatch, getState) => {
        const {config, context} = getState()[namespace];

        const request_url = config.getIn(['links', 'util_urls', 'bom_predicate_search']);

        const performSearchAction = matched =>
            searchBomTree(matched, 'backend-bom-predicate-search');
        const updateAction = (id, obj) =>
            BOMRestTreeActions['updateTreeNodeById'](BOMTreeContainerId, id, obj);

        return searchAction(
            request_url, context, performSearchAction, updateAction
        )(dispatch, getState);
    };
};

export const bomTreeSearchResyncAction = (item, parentNodeId) => {
    return (dispatch, getState) => {
        const predicateSearchId = 'backend-bom-predicate-search';
        const simpleBackendTextSearch = 'simple-backend-text-search';
        const bomTreeState = getState()[namespace][BOMTreeContainerId];
        const predicateSearchCondition =
            bomTreeState.getIn(['searches', predicateSearchId, 'searchCondition']);
        const simpleBackendTextSearchCondition =
            bomTreeState.getIn(['searches', simpleBackendTextSearch, 'searchCondition']);
        if (predicateSearchCondition) {
            dispatch(searchBomTree(predicateSearchCondition, predicateSearchId));
        }
        if (simpleBackendTextSearchCondition && simpleBackendTextSearchCondition.text) {
            dispatch(bomTreeSimpleSearchAction(simpleBackendTextSearchCondition.text,
                                               simpleBackendTextSearch,
                                               item ? item.get('teilenummer') : undefined,
                                               item ? item.get('t_index') : undefined,
                                               simpleBackendTextSearchCondition.matched,
                                               parentNodeId));
        }
    };
};

export const mergeSearches = function(...searches) {
    return Object.assign({}, ...searches);
};
