// jshint esversion:6

import React from 'react';
import PropTypes from 'prop-types';

import Immutable from 'immutable';
import {ImmutablePropTypes} from 'cs-web-components-externals';

import jQuery from 'jquery';

import {
    Button,
    DropdownButton,
    Glyphicon,
    Checkbox,
    MenuItem,
    SplitButton
} from 'react-bootstrap';

import {constants as listConstants} from 'cs-vp-list-component';
import {
    constants as tableConstants,
    walkTableRows
} from 'cs-vp-table-component';

import {RestObjectRenderer} from 'cs-vp-utils';

import {
    IS_VARIANT_VALID
} from './actions';

import {
    FILTER_KEY,
    FILTER_VALUE_KEY,
    FILTER_VALUES_KEY
} from './initialStates';

import {
    activateCheckboxes,
    getValueFromPropertyValue,
    variantFilterCallback
} from './tools';


class OperationDropDown extends React.Component {
    perform(operation) {
        window.open(operation.get('href'), '_blank');
    }

    activate(operation) {
        const {setListContext} = this.props;
        setListContext(Immutable.Map({activeOp: operation.get('name')}));

        this.perform(operation);
    }

    renderOperation(operation) {
        return (
            <div>
                <img src={operation.get('iconUrl')} />
                {operation.get('label')}
            </div>
        );
    }

    render() {
        const {operations, listContext} = this.props;
        const activeOp = listContext.get('activeOp');
        const active = operations.find(operation => operation.get('name') === activeOp);

        return (
            <SplitButton bsSize="xsmall" id="dropdown"
                onClick={() => this.perform(active ? active : operations.get(0))}
                pullRight title={this.renderOperation(active ? active : operations.get(0))}
            >
                {operations.map(operation => (
                    <MenuItem id={operation.get('name')}
                        key={operation.get('name')}
                        onClick={() => this.activate(operation)}
                    >
                        {this.renderOperation(operation)}
                    </MenuItem>
                ))}
            </SplitButton>
        );

    }
}
OperationDropDown.propTypes = {
    listContext: ImmutablePropTypes.map.isRequired,
    operations: ImmutablePropTypes.list.isRequired,
    setListContext: PropTypes.func.isRequired
};


export class PartListRenderer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            hover: false
        };
    }

    mouseOver() {
        this.setState({hover: true});
    }

    mouseLeave() {
        this.setState({hover: false});
    }

    render() {
        const {item} = this.props;
        const text = this.props.item.get(listConstants.ROW_TEXT);
        const is_selected = this.props.item.get(listConstants.ROW_SELECTED, false);

        const css_classes = ['list-entry-part'];
        if (is_selected) {
            css_classes.concat('list-entry-selected');
        } else {
            css_classes.concat('list-entry-not-selected');
        }

        const operations = item.get('system:variant_matrix_operations');
        const showDropdown = this.state.hover; // is-selected;
        const dropdown = (showDropdown) ? (
            <OperationDropDown {...this.props} operations={operations}/>
        ) : undefined;

        const iconSrc = item.get('system:icon_link');
        const statusColor = item.getIn(['system:current_status', 'color']);

        return (
            <div className={css_classes.join(' ')}
                onMouseLeave={event => this.mouseLeave(event)}
                onMouseOver={event => this.mouseOver(event)}
            >
                <RestObjectRenderer
                    cssClasses="part-list-text"
                    description={text}
                    iconSrc={iconSrc}
                    statusIcon={{fillColor: statusColor}}
                />
                <span className="part-list-dropdown pull-right">
                    {dropdown}
                </span>
            </div>
        );
    }
}
PartListRenderer.propTypes = {
    item: ImmutablePropTypes.map.isRequired
};

export const shallUpdateTableCellPropertyValueRenderer = () => {
    return true;
};

export class TableCellPropertyValueRenderer extends React.Component {

    shouldComponentUpdate(nextProps) {
        return shallUpdateTableCellPropertyValueRenderer(this.props, nextProps);
    }

    componentDidUpdate() {
        const {row, col, hasFocus, table} = this.props;
        const is_focused = hasFocus &&
            table.getIn([tableConstants.TABLE, tableConstants.FOCUSED_COL_KEY]) ===
                col.get(tableConstants.KEY) &&
            table.getIn([tableConstants.TABLE, tableConstants.FOCUSED_ROW_ID]) ===
                row.get(tableConstants.ROW_ID);

        if (is_focused) {
            const openValue = row.get(col.get(tableConstants.KEY) + '_opened');
            const reactInput = this.dropDown;
            if (openValue) {
                const domSelect = jQuery(reactInput).find('.dropdown-menu li a').first();
                if (domSelect) {
                    domSelect.focus();
                    this.props.setGrabFocus(false);
                }
            }
        }
    }
    onSelect(eventKey, event) {
        const keyValuePairs = {};
        keyValuePairs[FILTER_VALUE_KEY] = eventKey;
        if (eventKey !== undefined) {
            keyValuePairs[FILTER_KEY] = true;
        }
        this.props.editCells(this.props.row, keyValuePairs);

        if (eventKey !== undefined) {
            activateCheckboxes(this.props.table, this.props.row, this.props.editCell);
        }
        const colFilterField = this.props.table.get(tableConstants.FILTER_FIELD_COL);
        const filterText = colFilterField.get('value');
        this.props.filterColumnChange(variantFilterCallback(filterText), filterText);

        event.stopPropagation();
    }
    onToggle(isOpen) {
        if (false === isOpen) {
            this.props.setGrabFocus(true);
        }
        this.props.editCell(
            this.props.row, this.props.col.get(tableConstants.KEY) + '_opened', isOpen);
    }
    render() {
        const {row, col, hasFocus, table} = this.props;
        const propertyValues = row.get(FILTER_VALUES_KEY);
        const emptyValue = '';
        const is_focused = hasFocus &&
            table.getIn([tableConstants.TABLE, tableConstants.FOCUSED_COL_KEY]) ===
                col.get(tableConstants.KEY) &&
            table.getIn([tableConstants.TABLE, tableConstants.FOCUSED_ROW_ID]) ===
                row.get(tableConstants.ROW_ID);

        const openValue = row.get(col.get(tableConstants.KEY) + '_opened');
        const opend = (is_focused && openValue) ? (is_focused && openValue) : undefined;
        const value = row.get(col.get(tableConstants.KEY));
        const enumval = propertyValues.find(pv => pv.get('value') === value);

        const dropDownTitle = enumval ? enumval.get('system:description') : emptyValue;

        const dropDown = (propertyValues && propertyValues.size > 0) ? (
            <DropdownButton bsSize="xsmall"
                id="dropdown"
                key="dropdown"
                onSelect={(eventKey, event) => {this.onSelect(eventKey, event)}}
                onToggle={(isOpen) => {this.onToggle(isOpen)}}
                open={opend}
                pullRight
                ref={dropDown => this.dropDown = dropDown}
                title={dropDownTitle}
            >
                <MenuItem eventKey={emptyValue}
                    id="emptyValue"
                    key="emptyValue"
                >
                    &nbsp;
                </MenuItem>
                {
                    propertyValues.map(
                        pv => (
                            <MenuItem eventKey={pv.get('value')}
                                id={'option ' + pv.get('@id')}
                                key={pv.get('value')}
                                title={pv.get('system:description')}
                            >
                                {pv.get('system:description')}
                            </MenuItem>
                        )
                    )
                }
            </DropdownButton>
        ) : undefined;
        return (
            <div className="table-cell-content">
                {dropDown}
            </div>
        );
    }
}
TableCellPropertyValueRenderer.propTypes = {
    col: ImmutablePropTypes.map.isRequired,
    containerId: PropTypes.string,
    editCell: PropTypes.func.isRequired,
    editCells: PropTypes.func.isRequired,
    filterColumnChange: PropTypes.func.isRequired,
    hasFocus: PropTypes.bool,
    row: ImmutablePropTypes.map.isRequired,
    setGrabFocus: PropTypes.func.isRequired,
    table: ImmutablePropTypes.map.isRequired
};


export class TableCellPropertyCheckRenderer extends React.Component {

    changeValue(value) {
        const keyValuePairs = {};
        keyValuePairs[FILTER_KEY] = value;
        if (false === value) {
            keyValuePairs[FILTER_VALUE_KEY] = '';
        }
        this.props.editCells(this.props.row, keyValuePairs);
        if (value) {
            activateCheckboxes(this.props.table, this.props.row, this.props.editCell);
        }
        else {
            // walk down and flush values and checkboxes ...
            const startRows = [this.props.row];
            const childRows = Array.from(walkTableRows(startRows));
            for (const currentRow of childRows) {
                this.props.editCells(currentRow, keyValuePairs);
            }
        }
        // filter table ...
        const colFilterField = this.props.table.get(tableConstants.FILTER_FIELD_COL);
        const filterText = colFilterField.get('value');
        this.props.filterColumnChange(variantFilterCallback(filterText), filterText);
    }
    render() {
        const cssClasses = 'checkbox';
        const {row, col} = this.props;

        const checkbox = (
            <Checkbox bsSize="medium" checked={row.get(col.get(tableConstants.KEY))}
                className={cssClasses}
                onChange={(e) => {this.changeValue(e.target.checked)}}
                type="checkbox"
            />
        );
        return (
            <div>{checkbox}</div>
        );
    }
}
TableCellPropertyCheckRenderer.propTypes = {
    col: ImmutablePropTypes.map.isRequired,
    containerId: PropTypes.string,
    editCell: PropTypes.func.isRequired,
    editCells: PropTypes.func.isRequired,
    filterColumnChange: PropTypes.func.isRequired,
    hasFocus: PropTypes.bool,
    row: ImmutablePropTypes.map.isRequired,
    table: ImmutablePropTypes.map.isRequired
};

export class TableCellValueRenderer extends React.Component {
    render() {
        const {row, col} = this.props;
        const propertValue = row.get(col.get(tableConstants.KEY));
        const value = getValueFromPropertyValue(propertValue);

        const cellContent = (() => {
            if (value === false) {
                return '';
            }
            if (value === true) {
                return (
                    <Glyphicon glyph="check"/>
                );
            }
            const propertyValues = row.get(FILTER_VALUES_KEY);
            const enumval = propertyValues.find(
                val => val.get('value') === value
            );
            if (enumval !== undefined) {
                return enumval.get('system:description');
            }
            // this should actually never happen
            return '';
        })();

        return (
            <div className="variant-cell-content" title={cellContent}>{cellContent}</div>
        );
    }
}
TableCellValueRenderer.propTypes = {
    col: ImmutablePropTypes.map.isRequired,
    editCell: PropTypes.func.isRequired,
    row: ImmutablePropTypes.map.isRequired
};

export class TableHeaderNewVariantRenderer extends React.Component {
    constructor(props) {
        super(props);
    }
    newVariantCallback() {
        this.props.newVariant(true);
    }
    render() {
        const {variantContext, labels, col} = this.props;

        const enabled = variantContext.get(IS_VARIANT_VALID, false);
        const title = labels !== undefined ? (
            enabled ?
            labels.get('cdbvp_variants_web_new_variant_enabled') :
            labels.get('cdbvp_variants_web_new_variant_disabled')
        ) : undefined;

        const divClass = enabled ?
            'new-variant-div new-variant-div-enabled' :
            'new-variant-div new-variant-div-disabled';
        return (
            <div className="new-variant-header">
                <span className="new-variant-header-label">{col.get(tableConstants.LABEL)}</span>
                <Button bsSize="sm"
                    className="new-variant-button pull-right"
                    disabled={!enabled}
                    id="add-variant-button"
                    key="add-variant-button"
                    onClick={() => this.newVariantCallback()}
                    tabIndex={37}
                    title={title}
                >
                    <div className={divClass}/>
                </Button>
            </div>
        );
    }
}
TableHeaderNewVariantRenderer.propTypes = {
    col: ImmutablePropTypes.map.isRequired,
    labels: ImmutablePropTypes.map,
    newVariant: PropTypes.func.isRequired,
    variantContext: ImmutablePropTypes.map.isRequired
};
