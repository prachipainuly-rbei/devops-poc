// jshint esversion:6

import Immutable from 'immutable';

import {
    fetchCollection,
    fetchObject,
    fetchRelship,
    fetchRelships,
    referencedObjects,
    createObject,
    postJSON
} from 'cs-web-components-base';

import {
    VariantTableContainerId,
    VariantTableActions,
    ArticleListActions,
    namespace
} from './init';

import {
    FILTER_KEY,
    FILTER_VALUE_KEY,
    createInitialVariantTableState,
    makeVariantCol
} from './initialStates';

import {
    constants as tableConstants,
    walkTableRows,
    walkVisibleTableRows
} from 'cs-vp-table-component';

import {
    variantFilterCallback
} from './tools';


export const SET_CONFIG = 'SET_CONFIG';
export const SET_CONTEXT = 'SET_CONTEXT';
export const START_LOADING = 'START_LOADING';
export const STOP_LOADING = 'STOP_LOADING';

export const IS_LOADING = 'IS_LOADING';
export const IS_VARIANT_VALID = 'IS_VARIANT_VALID';
export const NEW_VARIANT = 'NEW_VARIANT';
export const SELECTED_VARIANT = 'SELECTED_VARIANT';


export function fetchProduct(product_url, context) {
    return dispatch =>
    dispatch(fetchCollection(product_url, context))
        .then(data => {
            for (const relship of data.relships) {
                dispatch(receivedRelship(relship));
            }

            dispatch(initVariantTable());
            dispatch(setTitle(data));
            dispatch(stopLoading());
        });
}


export const setConfig = (config) => {
    return {
        type: SET_CONFIG,
        config
    };
};

export const setContext = (context) => {
    return {
        type: SET_CONTEXT,
        context
    };
};

export const startLoading = () => {
    return {
        type: START_LOADING
    };
};

export function stopLoading() {
    return {
        type: STOP_LOADING
    };
}

export const newVariant = (newVariant) => {
    return {
        type: NEW_VARIANT,
        newVariant
    };
};

export const isVariantValid = (isVariantValid) => {
    return {
        type: IS_VARIANT_VALID,
        isVariantValid
    };
};

export const setSelectedVariant = (selectedVariant) => {
    return {
        type: SELECTED_VARIANT,
        selectedVariant
    };
};


export function initVariantTable() {
    return (dispatch, getState) => {
        const state = getState();
        const {
            objectsById,
        } = state;
        const {context, config} = state[namespace];

        const product_object_id = context.product_object_id;
        const product_base_url = config.getIn(['links', 'base_urls', 'product']);
        const labels = config.get('labels');

        const product = objectsById.get(product_base_url + '/' + product_object_id);
        const variants = referencedObjects(state, product, 'Variants');

        const propertyValues = Immutable.Map(variants
            .map(variant =>
                [
                    variant.get('@id'),
                    referencedObjects(state, variant, 'PropertyValues')
                ]
            )
        );

        function buildRow(prop) {
            const values = referencedObjects(state, prop, 'EnumValues');
            const children = referencedObjects(state, prop, 'SubProperties');

            const evaluations = Immutable.Map(variants.map(variant => {
                const pvalue = propertyValues
                    .get(variant.get('@id'))
                    .find(pv => pv.get('id') === prop.get('id'));

                return [
                    variant.get('@id'),
                    pvalue ? pvalue : undefined
                ];
            }));

            return Immutable.Map({
                _id: 'property ' + prop.get('@id'),
                property: prop,
                propertyName: prop.get('system:description'),
                propertyFilterValue: undefined,
                propertyValues: values,
                propertyFilter: false,
                _children: children.map(buildRow)
            }).merge(evaluations);
        }

        const rows = referencedObjects(state, product, 'TopLevelProperties')
            .map(buildRow);

        const callbacks = {
            'FILTER_COLUMN_CHANGE': [checkVariant],
            'HIDE_COLUMN': [updatePartList, updateSelectedVariant],
            'SELECT': [updatePartList, updateSelectedVariant],
        };

        dispatch(VariantTableActions.setInitialState(
            createInitialVariantTableState(labels, variants, rows, callbacks)));
    };
}

export function setTitle() {
    return (dispatch, getState) => {
        const state = getState();
        const {objectsById} = state;
        const {config, context} = state[namespace];

        const product = objectsById.get(
            config.getIn(['links', 'base_urls', 'product']) + '/' + context.product_object_id
        );
        const product_desc = product.get('system:description');
        const title = product_desc + ' (' + config.get('title') + ')';
        document.title = title;
    };
}

export const showErrorMessage = () => {
    return (dispatch, getState) => {
        const state = getState();
        const {objectsById} = state;
        const {config, context} = state[namespace];

        const product = objectsById.get(
            config.get(['links', 'base_urls', 'product']) + '/ ' + context.product_object_id
        );
        const product_desc = product.get('system:description');
        const title = product_desc + ' (' + config.get('title') + ')';
        document.title = title;
    };
};

export function updatePartList(action) {
    return (dispatch, getState) => {
        const state = getState();
        if ('HIDE_COLUMN' === action.type) {
            const {selectedVariant} = state[namespace];
            if (selectedVariant && action.columnKey === selectedVariant.get('@id')) {
                dispatch(ArticleListActions.setContent(Immutable.fromJS([])));
            }
        }
        else {
            const {objectsById} = state;
            const variant = objectsById.get(action.col.get(tableConstants.KEY));

            if (variant) {
                const url = variant.getIn(['system:relships', 'relships', 'Parts']);
                dispatch(fetchRelship(url, 'complete-target-with-status-and-operations')).then(
                    () => {
                        const parts = referencedObjects(getState(), variant, 'Parts')
                            .map(part => part.merge({
                                _id: part.get('@id'),
                                _text: part.get('system:description')
                            })
                        );
                        dispatch(ArticleListActions.setContent(parts));
                    }
                );
            }
        }
    };
}

export function updateSelectedVariant(action) {
    return (dispatch, getState) => {
        const state = getState();

        if ('HIDE_COLUMN' === action.type) {
            const {selectedVariant} = state[namespace];
            if (selectedVariant && action.columnKey === selectedVariant.get('@id')) {
                dispatch(setSelectedVariant(false));
            }
        }
        else {
            const {objectsById} = state;
            const variant = objectsById.get(action.col.get(tableConstants.KEY));
            dispatch(setSelectedVariant(variant));
        }
    };
}

export const openDropdown = () => {
    return (table, row, col) => {
        return (dispatch) => {
            const openKey = col.get(tableConstants.KEY) + '_opened';
            dispatch(VariantTableActions.editCell(row, openKey, true));
        };
    };
};

export const newVariantCallback = () => {
    return () => {
        return dispatch => {
            dispatch(newVariant(true));
        };
    };
};

export const toggleCheckbox = () => {
    return (table, row, col) => {
        return (dispatch, getState) => {
            const value = !row.get(col.get(tableConstants.KEY));
            const keyValuePairs = {};
            keyValuePairs[FILTER_KEY] = value;
            if (false === value) {
                keyValuePairs[FILTER_VALUE_KEY] = '';
            }
            dispatch(VariantTableActions.editCells(row, keyValuePairs));
            if (value) {
                // walk up and activate checkboxes ...
                const visibleRows = Array.from(
                    walkVisibleTableRows(table.get(tableConstants.ROWS)));
                visibleRows.reverse();
                let thisRow;
                let lastRowLevel = row.get(tableConstants.ROW_LEVEL);
                for (const currentRow of visibleRows) {
                    if (currentRow.get(tableConstants.ROW_ID) === row.get(tableConstants.ROW_ID)) {
                        thisRow = currentRow;
                        if (0 === currentRow.get(tableConstants.ROW_LEVEL)) {
                            break;
                        }
                    }
                    if (thisRow && lastRowLevel !== currentRow.get(tableConstants.ROW_LEVEL)) {
                        dispatch(VariantTableActions.editCell(currentRow, FILTER_KEY, true));
                        lastRowLevel = currentRow.get(tableConstants.ROW_LEVEL);
                        if (0 === currentRow.get(tableConstants.ROW_LEVEL)) {
                            break;
                        }
                    }
                }
            }
            else {
                // walk down and flush values and checkboxes ...
                const startRows = [row];
                const childRows = Array.from(walkTableRows(startRows));
                for (const currentRow of childRows) {
                    dispatch(VariantTableActions.editCells(currentRow, keyValuePairs));
                }
            }
            // filter table ...
            const state = getState()[namespace][VariantTableContainerId];
            const filterText = state.getIn([tableConstants.FILTER_FIELD_COL, tableConstants.VALUE]);
            dispatch(
                VariantTableActions.filterColumnChange(
                    variantFilterCallback(filterText), filterText
                )
            );
        };
    };
};

export const createVariant = (variantName = undefined) => {
    return (dispatch, getState) => {
        const state = getState();
        const tableState = state[namespace][VariantTableContainerId];
        const rows = Immutable.OrderedSet(walkTableRows(tableState.get('rows')));

        const getValue = row => {
            const value = row.get(FILTER_VALUE_KEY);
            const checkbox = row.get(FILTER_KEY);

            if (value !== undefined && value !== '') {
                return value;
            }
            if (checkbox === true) {
                return checkbox;
            }

            return undefined;
        };

        const values = Immutable.Map(rows
            .filter(row => getValue(row) !== undefined)
            .map(row => [row.getIn(['property', 'id']), getValue(row)]));

        const {config, context: {product_object_id}} = state[namespace];
        const url = config.getIn(['links', 'base_urls', 'variant']);

        dispatch(createObject(url, [{product_object_id, name: variantName, values}]))
            .then(data => dispatch(addVariantToTable(data)));
    };
};

export function checkVariant() {
    return (dispatch, getState) => {
        const state = getState();
        const tableState = state[namespace][VariantTableContainerId];
        const rows = Immutable.OrderedSet(walkTableRows(tableState.get('rows')));

        const getValue = row => {
            const value = row.get(FILTER_VALUE_KEY);
            const checkbox = row.get(FILTER_KEY);
            if (value !== undefined && value !== '') {
                return value;
            }
            if (checkbox === true) {
                return checkbox;
            }
            return undefined;
        };
        const values = Immutable.Map(rows
            .filter(row => getValue(row) !== undefined)
            .map(row => [row.getIn(['property', 'id']), getValue(row)]));
        const {config, context: {product_object_id}} = state[namespace];
        const url = config.getIn(['links', 'util_urls', 'check_variant']);
        const data = {product_object_id, values};

        postJSON(url, data).then(
            // on success
            data => {
                dispatch(isVariantValid(data));
            },
            // on rejected
            () => {
                dispatch(isVariantValid(false));
            }
        );
    };
}


function addVariantToTable(data) {
    return (dispatch, getState) => {
        if (data.length === 0) {
            // error message
        }
        const tableState = getState()[namespace][VariantTableContainerId];

        for (const variant of data.map(Immutable.fromJS)) {
            const relship = variant.getIn(['system:relships', 'relships', 'PropertyValues']);
            dispatch(fetchRelship(relship, 'complete-target'))
            .then(() => {
                const values = referencedObjects(getState(), variant, 'PropertyValues');

                return Promise.all([
                    dispatch(fetchRelships(
                        values.map(value =>
                            Immutable.Map({
                                url: value.getIn(['system:relships', 'relships', 'EnumValue'])
                            })
                        ).toJS()
                    )),
                    dispatch(fetchObject(variant.get('@id'), 'with-variant-operations'))
                ]);
            })
            .then(() => {
                const values = referencedObjects(getState(), variant, 'PropertyValues');
                const newCol = makeVariantCol(variant);
                const visibleRows = Immutable.List(
                    walkTableRows(tableState.get(tableConstants.ROWS))
                );
                const newData = Immutable.Map(visibleRows.map(row => {
                    const value = values.find(pv => pv.get('id') === row.getIn(['property', 'id']));
                    if (value) {
                        return [row.get(tableConstants.ROW_ID), value];
                    }
                    return undefined;
                }));
                dispatch(VariantTableActions.addColumn(newCol.toObject(), newData.toObject()));
            });
        }
    };
}


// Fake actions from cs-web-components-base because they are not exported
const RECEIVED_RELSHIP_1 = 'cs-web-components-base-RECEIVED_RELSHIP_1';

export function receivedRelship1(url, target) {
    return {
        type: RECEIVED_RELSHIP_1,
        payload: target,
        meta: {url: url}
    };
}

const RECEIVED_RELSHIP_N = 'cs-web-components-base-RECEIVED_RELSHIP_N';

export function receivedRelshipN(url, targets) {
    return {
        type: RECEIVED_RELSHIP_N,
        payload: targets,
        meta: {url: url}
    };
}

const RECEIVED_OBJECT = 'cs-web-components-base-RECEIVED_OBJECT';

export function receivedObject(url, object) {
    return {
        type: RECEIVED_OBJECT,
        payload: object,
        meta: {url: url}
    };
}

export function receivedRelship(relship) {
    return dispatch => {
        if (relship.hasOwnProperty('targets')) {
            dispatch(receivedRelshipN(relship['@id'], relship.targets));
            relship.targets.forEach(target => {
                if (target.hasOwnProperty('@id')) {
                    dispatch(receivedObject(target['@id'], target));
                    if (target.hasOwnProperty('system:resolved_relships')) {
                        target['system:resolved_relships'].forEach(resolved_relship => {
                            dispatch(receivedRelship(resolved_relship));
                        });
                    }
                }
            });
        } else {
            dispatch(receivedRelship1(relship['@id'], relship.target));
            if (relship.target) {
                if (relship.target.hasOwnProperty('@id')) {
                    dispatch(receivedObject(relship.target['@id'], relship.target));
                }
                if (relship.target.hasOwnProperty('system:resolved_relships')) {
                    relship.target['system:resolved_relships'].forEach(resolved_relship => {
                        dispatch(receivedRelship(resolved_relship));
                    });
                }
            }
        }
    };
}
