/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: list-components.js 171249 2018-01-09 12:31:54Z gda $"
 */

 // jshint esversion:6

require('./components.css');

import React from 'react';
import PropTypes from 'prop-types';
import {
    FormGroup,
    FormControl,
    InputGroup,
    ListGroup
} from 'react-bootstrap';
import {ImmutablePropTypes} from 'cs-web-components-externals';
import key from 'keymaster';
import jQuery from 'jquery';

import {
    CALLBACK,
    ENTRY_COMPONENT,
    FILTER_FIELD,
    LABEL,
    LIST,
    ROW_ID,
    ROW_SELECTED,
    ROW_TEXT,
    ROW_VISIBLE,
    VISIBLE,
    CONTEXT
} from './list-constants';

import {scrollIntoViewIfNeeded} from 'cs-vp-utils';


export class FilterList extends React.Component {
    scrollTo(element) {
        return scrollIntoViewIfNeeded(this.scrollContainer)(element);
    }

    componentDidMount() {
        const activeKeys = ['up', 'down'];
        const keyHandler = key => (event) => {
            const {activateKey, hasFocus, list} = this.props;
            const target = jQuery(event.target);
            if (hasFocus) {
                if (
                    this.props.keyBlacklistSelector === undefined ||
                    !target.is(this.props.keyBlacklistSelector)
                ) {
                    activateKey(list.get(LIST), key);
                }
            }
            // prevent browser from scrolling
            event.preventDefault();
        };

        for (const shortCut of activeKeys) {
            key(shortCut, keyHandler(shortCut));
        }
    }

    filterChange(filterText) {
        const filterField = this.props.list.get(FILTER_FIELD);
        const filterCallback = filterField.get(CALLBACK);
        this.props.filterChange(filterCallback(filterText), filterText);
    }

    render() {
        const filterIcon = <span className="icon-filter"/>;
        const filterField = this.props.list.get(FILTER_FIELD);
        const filterVisible = filterField && filterField.get(VISIBLE, true);
        const filterInput = filterVisible ? (
            <FormGroup>
                <InputGroup>
                    <FormControl
                        className="form-control"
                        onChange={e => this.filterChange(e.target.value)}
                        {...filterField.toJS()}
                        tabIndex={this.props.tabIndex}
                        type="text"
                    />
                    <InputGroup.Addon>{filterIcon}</InputGroup.Addon>
                </InputGroup>
            </FormGroup>
        ) : undefined;
        let listClassName =
            (this.props.className ? this.props.className + ' list' : 'list') +
            (this.props.hasFocus ? ' focus' : '');
        if (filterVisible) {
            if (filterField.get(LABEL)) {
                listClassName += ' list-with-filter-and-label';
            }
            else {
                listClassName += ' list-with-filter';
            }
        }

        const listContext = this.props.list.get(CONTEXT);
        const listContent = this.props.list.get(LIST);
        const listEntryComponent = this.props.list.get(ENTRY_COMPONENT);
        return (
            <div className="list-filtered">
                {filterInput}
                <div
                    className={listClassName}
                    ref={scrollContainer => this.scrollContainer = scrollContainer}
                    tabIndex={this.props.tabIndex + 1}
                >
                    <List {...this.props}
                        listContext={listContext}
                        listData={listContent}
                        listEntryComponent={listEntryComponent}
                        scrollTo={this.scrollTo.bind(this)}
                    />
                </div>
            </div>
        );
    }
}
FilterList.propTypes = {
    activateKey: PropTypes.func.isRequired,
    className: PropTypes.string,
    filterChange: PropTypes.func.isRequired,
    hasFocus: PropTypes.bool,
    keyBlacklistSelector: PropTypes.string,
    list: ImmutablePropTypes.map.isRequired,
    selectListEntry: PropTypes.func.isRequired,
    tabIndex: PropTypes.number.isRequired
};
FilterList.defaultProps = {
    hasFocus: true,
    keys: {
    },
    tabIndex: -1
};

export class List extends React.Component {
    render() {
        return (
            <ListGroup className="list-group">
                {
                    this.props.listData && this.props.listData.map(
                        entry => {
                            return (
                                <ListEntry {...this.props}
                                    item={entry}
                                    key={entry.get(ROW_ID)}
                                    listEntryComponent={this.props.listEntryComponent}
                                />
                            );
                        }
                    )
                }
            </ListGroup>
        );
    }
}
List.propTypes = {
    listData: PropTypes.object,
    listEntryComponent: PropTypes.func,
    selectListEntry: PropTypes.func.isRequired
};
List.defaultProps = {
    keys: {
    }
};

export class ListEntryDefault extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
        const css_classes = ['list-entry-text'];
        const is_selected = this.props.item.get(ROW_SELECTED, false);
        if (is_selected) {
            css_classes.concat('list-entry-selected');
        } else {
            css_classes.concat('list-entry-not-selected');
        }
        const text = this.props.item.get(ROW_TEXT);
        return (
            <div className={css_classes.join(' ')}>
                {text}
            </div>
        );
    }
}
ListEntryDefault.propTypes = {
    item: ImmutablePropTypes.map.isRequired
};
ListEntryDefault.defaultProps = {
    keys: {
    }
};

export class ListEntry extends React.Component {
    _ifSelectedScrollToMe() {
        const {scrollTo} = this.props;

        if (this.props.item.get(ROW_SELECTED, false)) {
            scrollTo(this.scrollTarget);
        }
    }

    componentDidMount() {
        this._ifSelectedScrollToMe();
    }

    componentDidUpdate() {
        this._ifSelectedScrollToMe();
    }

    constructor(props) {
        super(props);
    }

    selectListEntry() {
        this.props.selectListEntry(this.props.item.get(ROW_ID));
    }

    render() {
        const is_visible = this.props.item.get(ROW_VISIBLE, true);
        if (false === is_visible) {
            return (<div/>);
        }
        const childComponent = (this.props.listEntryComponent)
            ? this.props.listEntryComponent
            : ListEntryDefault;
        const is_selected = this.props.item.get(ROW_SELECTED, false);
        const css_class_name = is_selected
            ? 'list-group-item list-entry list-entry-selected'
            : 'list-group-item list-entry list-entry-not-selected';
        return (
            <div className={css_class_name}
                onClick={this.selectListEntry.bind(this)}
                ref={target => this.scrollTarget = target}
            >
                {React.createElement(childComponent, this.props)}
            </div>
        );
    }
}
ListEntry.propTypes = {
    item: ImmutablePropTypes.map.isRequired,
    listEntryComponent: PropTypes.func,
    scrollTo: PropTypes.func,
    selectListEntry: PropTypes.func.isRequired
};
ListEntry.defaultProps = {
    keys: {
    }
};
