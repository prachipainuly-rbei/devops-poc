/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: list-tests.js 138660 2016-03-17 14:52:41Z gda $"
 */

 // jshint esversion:6

import _                                                  from 'lodash';
import React                                              from 'react';
import ReactDOM                                           from 'react-dom';
import Immutable                                          from 'immutable';

import { createStore, combineReducers, applyMiddleware }  from 'redux';
import { Provider }                                       from 'react-redux';
import thunk                                              from 'redux-thunk';

import listContainerFactory                               from '../index';
import { reducer as listReducerFactory }                  from '../index';
import { actions as listActionsFactory }                  from '../index';

import { FilterList, ListEntry, ListEntryDefault }        from '../list-components';
import { isInView }                                       from '../../utils';

import {
    FILTER_FIELD,
    LIST,
    ROW_SELECTED,
    ROW_TEXT,
    VISIBLE
} from '../list-constants'


const listdata = Immutable.fromJS({
    filterField: {
        callback: filterText => listEntry => listEntry.get('_text').indexOf(filterText) > -1,
        label: 'Optional Filter Label',
        placeholder: 'Bitte Filterbegriff eingeben',
        visible: true
    },
    list :
    [
        { _id : 1, _text : 'Part 1' },
        { _id : 2, _text : 'Article 2' },
        { _id : 3, _text : 'Article 4711' },
        { _id : 4, _text : 'This is an extremly long article description to test text overflow' },
        { _id : 5, _text : 'Product 1' },
        { _id : 6, _text : 'Product 6' },
        { _id : 7, _text : 'Product 7' },
        { _id : 8, _text : 'Product 8' },
        { _id : 9, _text : 'Product 9' },
        { _id : 10, _text : 'Product 10' }
    ].concat(_.range(11, 100).map(n => ({
        _id: n,
        _text: 'Product ' + n
    })))
});

const ListContainerId = 'List';
const ListContainer   = listContainerFactory(ListContainerId);
const ListActions     = listActionsFactory(ListContainerId);

const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);
let reducers = {};
reducers[ListContainerId]  = listReducerFactory(ListContainerId);

const CURSOR_UP = 38;
const CURSOR_DOWN = 40;

// workaround for key events as ReactTestUtils.Simulate does not work together with keymaster
function keyDownEvent(keyCode) {
    let event = document.createEvent('Event');
    event.keyCode = keyCode;
    event.initEvent('keydown');
    document.dispatchEvent(event);
}


describe('The list component', () => {

    it('can be rendered with filter', () => {
        const ReactTestUtils = require('react-addons-test-utils');
        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(ListActions['setInitialState'](listdata.setIn([FILTER_FIELD, VISIBLE], true)));
        store.dispatch(ListActions['setInitialState'](listdata));  //
        const list = ReactTestUtils.renderIntoDocument(
            <ListContainer store={store}/>
        );
        expect(list).not.toBe(undefined);
        expect(ReactTestUtils.isElement(list));

        const filterText = ReactTestUtils.findRenderedDOMComponentWithTag(list, 'Input');
        expect(filterText).not.toBe(undefined);

        const listEntries = ReactTestUtils.scryRenderedComponentsWithType(list, ListEntryDefault);
        const expectedListEntryCount = listdata.get(LIST).size;

        expect(listEntries.length).toBe(expectedListEntryCount);
        expect(listEntries.map(entry => entry.props.item.get(ROW_TEXT))).toEqual(
            listdata.get(LIST).toJS().map(entry => entry._text));
    });

    it('can be rendered without filter', () => {
        const ReactTestUtils = require('react-addons-test-utils');
        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(ListActions['setInitialState'](listdata.setIn([FILTER_FIELD, VISIBLE], false)));
        const list = ReactTestUtils.renderIntoDocument(
            <ListContainer store={store}/>
        );
        expect(list).not.toBe(undefined);
        expect(ReactTestUtils.isElement(list));

        const filterText = ReactTestUtils.scryRenderedDOMComponentsWithTag(list, 'Input');
        expect(filterText.length).toBe(0);

        const listEntries = ReactTestUtils.scryRenderedComponentsWithType(list, ListEntryDefault);
        const expectedListEntryCount = listdata.get(LIST).size;

        expect(listEntries.length).toBe(expectedListEntryCount);
        expect(listEntries.map(entry => entry.props.item.get(ROW_TEXT))).toEqual(
            listdata.get(LIST).toJS().map(entry => entry._text));
    });

    it('can be filtered', () => {
        const ReactTestUtils = require('react-addons-test-utils');
        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(ListActions['setInitialState'](listdata));
        const list = ReactTestUtils.renderIntoDocument(
            <ListContainer store={store}/>
        );
        expect(list).not.toBe(undefined);
        expect(ReactTestUtils.isElement(list));

        const filterText = ReactTestUtils.findRenderedDOMComponentWithTag(list, 'Input');
        expect(filterText).not.toBe(undefined);

        let filterValue = '1';
        let expectedListEntries = listdata.get(LIST).toJS().filter((current)=>{
            return current._text.indexOf(filterValue) > -1
        }).map(entry => entry._text);

        filterText.value = filterValue;
        ReactTestUtils.Simulate.change(filterText);

        let listEntries = ReactTestUtils.scryRenderedComponentsWithType(list, ListEntryDefault);
        expect(listEntries.length).toBe(21);
        expect(listEntries.map(entry => entry.props.item.get(ROW_TEXT))).toEqual(expectedListEntries);

        filterValue = 'ticle';
        expectedListEntries = listdata.get(LIST).toJS().filter((current)=>{
            return current._text.indexOf(filterValue) > -1
        }).map(entry => entry._text);

        filterText.value = filterValue;
        ReactTestUtils.Simulate.change(filterText);

        listEntries = ReactTestUtils.scryRenderedComponentsWithType(list, ListEntryDefault);
        expect(listEntries.length).toBe(3);
        expect(listEntries.map(entry => entry.props.item.get(ROW_TEXT))).toEqual(expectedListEntries);
    });

    it('can be selected', () => {
        const ReactTestUtils = require('react-addons-test-utils');
        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(ListActions['setInitialState'](listdata));
        const list = ReactTestUtils.renderIntoDocument(
            <ListContainer store={store}/>
        );
        expect(list).not.toBe(undefined);
        expect(ReactTestUtils.isElement(list));

        // ensure nothing is selected ...
        let listEntries = ReactTestUtils.scryRenderedComponentsWithType(list, ListEntry);
        let selectedEntries = listEntries.filter(entry => entry.props.item.get(ROW_SELECTED));
        expect(selectedEntries.length).toEqual(0);
        let cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(list, 'list-entry-selected');
        expect(cssSeleted.length).toEqual(0);

        // test select by mouse clicks ...
        ReactTestUtils.Simulate.click(listEntries[0].refs.scrollTarget);
        selectedEntries = listEntries.filter(entry => entry.props.item.get(ROW_SELECTED));
        expect(selectedEntries.length).toEqual(1);
        expect(listEntries[0].props.item.get(ROW_SELECTED)).toEqual(true);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(list, 'list-entry-selected');
        expect(cssSeleted.length).toBeGreaterThan(0);
        ReactTestUtils.Simulate.click(listEntries[1].refs.scrollTarget);
        expect(selectedEntries.length).toEqual(1);
        expect(listEntries[0].props.item.get(ROW_SELECTED)).toEqual(false);
        expect(listEntries[1].props.item.get(ROW_SELECTED)).toEqual(true);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(list, 'list-entry-selected');
        expect(cssSeleted.length).toBeGreaterThan(0);

        // test select by cursor keys ...
        keyDownEvent(CURSOR_UP);
        expect(listEntries[0].props.item.get(ROW_SELECTED)).toEqual(true);
        expect(listEntries[1].props.item.get(ROW_SELECTED)).toEqual(false);
        // test wrapping to last ...
        keyDownEvent(CURSOR_UP);
        expect(listEntries[0].props.item.get(ROW_SELECTED)).toEqual(false);
        expect(listEntries[listEntries.length-1].props.item.get(ROW_SELECTED)).toEqual(true);
        // test wrapping to first ...
        keyDownEvent(CURSOR_DOWN);
        expect(listEntries[0].props.item.get(ROW_SELECTED)).toEqual(true);
        expect(listEntries[listEntries.length-1].props.item.get(ROW_SELECTED)).toEqual(false);
        keyDownEvent(CURSOR_DOWN);
        expect(listEntries[0].props.item.get(ROW_SELECTED)).toEqual(false);
        expect(listEntries[1].props.item.get(ROW_SELECTED)).toEqual(true);
    });

    it('will be scrolled after selection', () => {
        const ReactTestUtils = require('react-addons-test-utils');
        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(ListActions['setInitialState'](listdata));

        // Render really into document
        const div = document.createElement('div');
        Object.assign(div.style, {
            position: 'absolute',
            top: '0px',
            bottom: '0px',
            left: '0px',
            right: '0px',
        });
        document.body.appendChild(div);
        const list = ReactDOM.render(
            <ListContainer store={store}/>
        , div);

        store.dispatch(ListActions['selectListEntry'](99));

        const filterList = ReactTestUtils.findRenderedComponentWithType(list, FilterList);
        const entry = ReactTestUtils.scryRenderedComponentsWithType(list, ListEntry).pop();

        expect(isInView(filterList.refs.scrollContainer, entry.refs.scrollTarget)).toBe(true);

        ReactDOM.unmountComponentAtNode(div);
    });
});
