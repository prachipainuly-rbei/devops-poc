/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: table-components.js 171249 2018-01-09 12:31:54Z gda $"
 */

// jshint esversion:6

require('./components.css');

import {
    CALLBACK,
    CAN_HIDE,
    CELL_COMPONENT,
    CELL_COMPONENT_SHALL_UPDATE_CALLBACK,
    COLS,
    COLSPAN,
    CSS_CLASS_NAME_TABLE_CELL,
    CSS_CLASS_NAME_TABLE_CELL_CONTENT,
    CSS_CLASS_NAME_TABLE_HEADER,
    CSS_CLASS_NAME_TABLE_HEADER_LABEL,
    CSS_CLASS_NAME_TABLE_HEADER_ICON,
    FILTER_FIELD,
    FILTER_FIELD_COL,
    FIXED,
    FOCUSED_COL_KEY,
    FOCUSED_ROW_ID,
    GRAB_FOCUS,
    HEADER,
    HEADER_COMPONENT,
    HIDDEN,
    INDENT,
    KEY,
    LABEL,
    ROWS,
    ROW_CHILDREN,
    ROW_EXPANDED,
    ROW_HAS_CHILDREN,
    ROW_ID,
    ROW_LEVEL,
    ROW_VISIBLE,
    TABLE,
    SELECTED,
    SHOW_ALL_COLS_BUTTON_DISPLAY,
    SHOW_ALL_COLS_BUTTON_LABEL,
    VISIBLE
} from './table-constants';
import {
    FILTER_COLUMN_CHANGE
} from './table-actions';

import React from 'react';
import PropTypes from 'prop-types';

import {
    Button,
    Glyphicon,
    FormGroup,
    FormControl,
    InputGroup,
    Table as ReactTable
} from 'react-bootstrap';
import {ImmutablePropTypes} from 'cs-web-components-externals';
import key from 'keymaster';
import jQuery from 'jquery';
import {walkVisibleTableRows} from './table-tools';

import {scrollIntoViewIfNeeded} from 'cs-vp-utils';


export class TableHeaderDefault extends React.Component {
    constructor(props) {
        super(props);
    }
    render() {
        return (
            <div className={this.props.col.get(CSS_CLASS_NAME_TABLE_HEADER_LABEL)}>
                {this.props.col.get(LABEL)}
            </div>
        );
    }
}
TableHeaderDefault.propTypes = {
    col: ImmutablePropTypes.map.isRequired
};

export class TableCellDefault extends React.Component {
    constructor(props) {
        super(props);
    }

    render() {
        const className = this.props.col.get(CSS_CLASS_NAME_TABLE_CELL_CONTENT);
        return (
            <div className={className} title={this.props.row.get(this.props.col.get(KEY))}>
                {this.props.row.get(this.props.col.get(KEY))}
            </div>
        );
    }
}
TableCellDefault.propTypes = {
    col: ImmutablePropTypes.map.isRequired,
    editCell: PropTypes.func.isRequired,
    row: ImmutablePropTypes.map.isRequired
};

export class FilterTable extends React.Component {

    componentDidMount() {
        const activeKeys = ['down', 'alt+down', 'esc', 'left', 'return', 'right', 'space', 'up'];
        const keyHandler = key => (event) => {
            const {activateKey, hasFocus, table} = this.props;
            const target = jQuery(event.target);
            if (hasFocus) {
                if (
                    this.props.keyBlacklistSelector === undefined ||
                    !target.is(this.props.keyBlacklistSelector)
                ) {
                    activateKey(table, key);
                }
            }
            const tableComplete = this.tableComplete;
            const tableShadow = jQuery('.table-shadow', tableComplete).first();
            const tableWrapper = jQuery('.table-wrapper', tableComplete).first();
            if (event.target === tableShadow.get(0) || event.target === tableWrapper.get(0)) {
                // prevent default only for events coming from table
                event.preventDefault();
            }
        };
        for (const shortCut of activeKeys) {
            key(shortCut, keyHandler(shortCut));
        }
    }

    componentWillUpdate() {
        if (
            this.props.table.getIn([TABLE, FOCUSED_COL_KEY]) &&
            this.props.table.getIn([TABLE, FOCUSED_ROW_ID])
        ) {
            // focus already set ...
        }
        else {
            // set initial focus to first visible row and col ...
            const cols = this.props.table.get(COLS);
            const rows = this.props.table.get(ROWS);
            if (cols && rows) {
                const firstVisibleCol = cols.find(
                    col => col.get(VISIBLE, true) && !col.get(HIDDEN, false));
                const firstVisibleRow = rows.find(row => row.get(ROW_VISIBLE, true));
                if (firstVisibleCol && firstVisibleRow) {
                    this.props.focus(firstVisibleRow, firstVisibleCol);
                }
            }
        }
    }

    filterColumnChange() {
        const {callbacks, filterColumnChange} = this.props;
        const callback = callbacks[FILTER_COLUMN_CHANGE];

        filterColumnChange.apply(this, arguments);
        if (callback !== undefined) {
            callback.apply(this, arguments);
        }
    }

    render() {
        const table = this.props.table;

        const colFilterField = table.get(FILTER_FIELD_COL);
        const rowFilterField = table.get(FILTER_FIELD);
        const colFilterVisible = colFilterField && table.getIn([FILTER_FIELD_COL, VISIBLE], false);
        const rowFilterVisible = rowFilterField && table.getIn([FILTER_FIELD, VISIBLE], false);
        const showAllButtonVisible = table.getIn([TABLE, SHOW_ALL_COLS_BUTTON_DISPLAY], false);

        let tableClassName = 'table-container';
        if (colFilterVisible || rowFilterVisible || showAllButtonVisible) {
            if (
                rowFilterField && rowFilterField.get(LABEL) ||
                colFilterField && colFilterField.get(LABEL)
            ) {
                tableClassName = this.props.className ?
                    this.props.className + ' table-container-with-filter-and-label' :
                    'table-container-with-filter-and-label';
            }
            else {
                tableClassName = this.props.className ?
                    this.props.className + ' table-container-with-filter' :
                    'table-container-with-filter';
            }
        }

        const cols = this.props.table.get(COLS);
        const header = this.props.table.get(HEADER);
        const rows = this.props.table.get(ROWS);

        return (
            <div className="table-filtered" ref={table => {this.tableComplete = table}}>
                <Filter
                    filterColumnChange={this.props.filterColumnChange}
                    filterRowChange={this.props.filterRowChange}
                    showHiddenColumns={this.props.showHiddenColumns}
                    tabIndex={this.props.tabIndex}
                    table={this.props.table}
                />
                <div className={tableClassName} ref={focusElement => this.focusElement = focusElement}>
                    <Table {...this.props}
                        cols={cols}
                        header={header}
                        rows={rows}
                        tabIndex={this.props.tabIndex + 5}
                    />
                </div>
            </div>
        );
    }
}
FilterTable.propTypes = {
    activateKey: PropTypes.func.isRequired,
    callbacks: PropTypes.object.isRequired,
    className: PropTypes.string,
    editCell: PropTypes.func.isRequired,
    editCells: PropTypes.func.isRequired,
    filterColumnChange: PropTypes.func.isRequired,
    filterRowChange: PropTypes.func.isRequired,
    focus: PropTypes.func.isRequired,
    hasFocus: PropTypes.bool,
    hideColumn: PropTypes.func.isRequired,
    keyBlacklistSelector: PropTypes.string,
    onSelection: PropTypes.func,
    select: PropTypes.func.isRequired,
    showHiddenColumns: PropTypes.func.isRequired,
    tabIndex: PropTypes.number.isRequired,
    table: ImmutablePropTypes.map.isRequired,
    toggleRow: PropTypes.func.isRequired
};
FilterTable.defaultProps = {
    hasFocus: true,
    tabIndex: -1
};

export class Filter extends React.Component {

    shouldComponentUpdate(nextProps) {

        const oldShowAllButtonVisible = this.props.table.getIn(
            [TABLE, SHOW_ALL_COLS_BUTTON_DISPLAY], false);
        const newShowAllButtonVisible = nextProps.table.getIn(
            [TABLE, SHOW_ALL_COLS_BUTTON_DISPLAY], false);

        if (oldShowAllButtonVisible !== newShowAllButtonVisible) {
            return true;
        }

        const oldColFilterField = this.props.table.get(FILTER_FIELD_COL);
        const oldColFilterValue = (oldColFilterField) ? oldColFilterField.get('value') : undefined;
        const newColFilterField = nextProps.table.get(FILTER_FIELD_COL);
        const newColFilterValue = (newColFilterField) ? newColFilterField.get('value') : undefined;

        if (oldColFilterValue !== newColFilterValue) {
            return true;
        }

        const oldRowFilterField = this.props.table.get(FILTER_FIELD);
        const oldRowFilterValue = (oldRowFilterField) ? oldRowFilterField.get('value') : undefined;
        const newRowFilterField = nextProps.table.get(FILTER_FIELD);
        const newRowFilterValue = (newRowFilterField) ? newRowFilterField.get('value') : undefined;

        if (oldRowFilterValue !== newRowFilterValue) {
            return true;
        }

        return false;
    }

    colFilterChange(filterText) {
        const filterField = this.props.table.get(FILTER_FIELD_COL);
        const filterCallback = filterField.get(CALLBACK);
        this.props.filterColumnChange(filterCallback(filterText), filterText);
    }

    rowFilterChange(filterText) {
        const filterField = this.props.table.get(FILTER_FIELD);
        const filterCallback = filterField.get(CALLBACK);
        this.props.filterRowChange(filterCallback(filterText), filterText);
    }

    showHiddenColumns() {
        this.props.showHiddenColumns();
    }

    render() {
        const table = this.props.table;
        const colFilterField = table.get(FILTER_FIELD_COL);
        const rowFilterField = table.get(FILTER_FIELD);
        const colFilterVisible = table.getIn([FILTER_FIELD_COL, VISIBLE], false);
        const rowFilterVisible = table.getIn([FILTER_FIELD, VISIBLE], false);
        const showAllButtonVisible = table.getIn([TABLE, SHOW_ALL_COLS_BUTTON_DISPLAY], false);

        const rowfilterIcon = <span className="icon-filter"/>;
        const rowFilterInput = (rowFilterVisible) ? (
            <div className="filter-input">
                <FormGroup>
                    <InputGroup>
                        <FormControl
                            onChange={
                                (e) => {
                                    this.rowFilterChange(e.target.value);
                                }
                            }
                            {...rowFilterField.toJS()}
                            tabIndex={this.props.tabIndex}
                            type="text"
                        />
                        <InputGroup.Addon>{rowfilterIcon}</InputGroup.Addon>
                    </InputGroup>
                </FormGroup>
            </div>
        ) : undefined;

        const colfilterIcon = <span className="icon-filter"/>;
        const colFilterInput = (colFilterVisible) ? (
            <div className="filter-input">
                <FormGroup>
                    <InputGroup>
                        <FormControl
                            onChange={
                                (e) => {
                                    this.colFilterChange(e.target.value);
                                }
                            }
                            {...colFilterField.toJS()}
                            tabIndex={this.props.tabIndex + 1}
                            type="text"
                        />
                        <InputGroup.Addon>{colfilterIcon}</InputGroup.Addon>
                    </InputGroup>
                </FormGroup>
            </div>
        ) : undefined;

        const showAllButton = (showAllButtonVisible) ? (
            <Button
                bsSize="sm"
                className="showHiddenButton"
                onClick={() => this.showHiddenColumns()}
                tabIndex={this.props.tabIndex + 2}
                title={this.props.table.getIn([TABLE, SHOW_ALL_COLS_BUTTON_LABEL])}
            >
                <div className="showHiddenImage"/>
            </Button>
        ) : undefined;

        return (
            <div className="filter">
                {rowFilterInput}
                {colFilterInput}
                {showAllButton}
            </div>
        );
    }
}
Filter.propTypes = {
    filterColumnChange: PropTypes.func.isRequired,
    filterRowChange: PropTypes.func.isRequired,
    showHiddenColumns: PropTypes.func.isRequired,
    tabIndex: PropTypes.number.isRequired,
    table: ImmutablePropTypes.map.isRequired
};

export class Table extends React.Component {

    scrollTo(element) {
        let leftBound = 0;
        const thisTable = this.tableComplete;
        const lastFixedHeaderCell =
            jQuery('.table-shadow .table .table-head .table-cell-fixed', thisTable).last();
        if (0 !== lastFixedHeaderCell.length) {
            leftBound = lastFixedHeaderCell.offset().left;
            leftBound += lastFixedHeaderCell.get(0).clientWidth;
        }
        return scrollIntoViewIfNeeded(this.tableWrapper, leftBound)(element);
    }

    scrollAllTables() {
        const thisTable = this.tableComplete;
        const shadowTable = jQuery('.table-shadow', thisTable);
        if (0 !== shadowTable.length) {
            this.tableShadowColumnWrapper.scrollTop = this.tableWrapper.scrollTop;
        }
    }

    generateHeader(cols, fixed) {
        return (
            <thead className="table-head"><tr>
                {
                cols && cols.map(
                    col => {
                        if (
                            false === col.get(VISIBLE) ||
                            true === col.get(HIDDEN) ||
                            0 === col.get(COLSPAN)
                        ) {
                            return undefined;
                        }
                        else {
                            return (
                                <TableHeaderCell col={col}
                                    fixed={fixed}
                                    key={col.get(KEY)}
                                    {...this.props}
                                />
                            );
                        }
                    }
                )
            }
            </tr></thead>
        );
    }

    generateBody(cols, rows, fixed, scrollTo = (() => {})) {
        const visibleRows = Array.from(walkVisibleTableRows(rows.toArray()));
        return (
            <tbody className="table-body">
                {
                    visibleRows && visibleRows.map(
                        row => {
                            return (
                                <TableRow
                                    {...this.props}
                                    cols={cols}
                                    fixed={fixed}
                                    key={row.get(ROW_ID)}
                                    row={row}
                                    scrollTo={scrollTo.bind(this)}
                                />
                            );
                        }
                    )
                }
            </tbody>
        );
    }

    componentDidUpdate() {
        const grabFocus = this.props.table.getIn([TABLE, GRAB_FOCUS], true);
        if (grabFocus && this.props.hasFocus) {
            const focusedColKey = this.props.table.getIn([TABLE, FOCUSED_COL_KEY]);
            const focusedColumn = this.props.cols.find(
                col => col.get(KEY) === focusedColKey
            );
            if (focusedColumn && focusedColumn.get(FIXED)) {
                this.tableShadowColumnWrapper.focus();

            }
            else {
                this.tableWrapper.focus();
            }
        }
    }

    render() {
        const tableBody = (cols, fixed, scrollTo) =>
            this.generateBody(cols, this.props.rows, fixed, scrollTo);
        const tableHeader = (cols, fixed) => (this.props.header.get(VISIBLE) === false)
            ? undefined
            : this.generateHeader(cols, fixed);
        const firstFixedCol = this.props.cols.find(
            col => (col.get(FIXED) === true)
        );
        const shadowTable = (firstFixedCol === undefined) ? undefined :
            <div className="table-shadow"
                ref={tableShadowColumnWrapper => this.tableShadowColumnWrapper = tableShadowColumnWrapper}
                tabIndex={this.props.tabIndex}
            >
                <ReactTable className="table" ref={tableShadowColumn => this.tableShadowColumn = tableShadowColumn}>
                    {tableHeader(this.props.cols, true)}
                    {tableBody(this.props.cols, true)}
                </ReactTable>
            </div>;
        return (
            <div>
                <div className="table-wrapper"
                    onScroll={this.scrollAllTables.bind(this)}
                    ref={tableWrapper => this.tableWrapper = tableWrapper}
                    tabIndex={this.props.tabIndex}
                >
                    <ReactTable className="table">
                        {tableHeader(this.props.cols, false)}
                        {tableBody(this.props.cols, false, this.scrollTo)}
                    </ReactTable>
                </div>
                {shadowTable}
            </div>
        );
    }
}
Table.propTypes = {
    cols: ImmutablePropTypes.list.isRequired,
    editCell: PropTypes.func.isRequired,
    editCells: PropTypes.func.isRequired,
    focus: PropTypes.func.isRequired,
    hasFocus: PropTypes.bool,
    header: ImmutablePropTypes.map.isRequired,
    hideColumn: PropTypes.func.isRequired,
    rows: PropTypes.object.isRequired,
    onSelection: PropTypes.func,
    select: PropTypes.func.isRequired,
    tabIndex: PropTypes.number.isRequired,
    table: ImmutablePropTypes.map.isRequired,
    toggleRow: PropTypes.func.isRequired
};

export class TableHeaderCell extends React.Component {

    constructor(props) {
        super(props);
        this.state = {
            hover: false
        };
    }

    hideColumn(colKey) {
        this.props.hideColumn(colKey);
    }

    mouseOver() {
        this.setState({hover: true});
    }

    mouseLeave() {
        this.setState({hover: false});
    }

    focusAndSelect() {
        const {col, onSelection, select} = this.props;
        select(undefined, col);

        if (onSelection !== undefined) {
            onSelection(undefined, col);
        }
    }

    render() {
        const col = this.props.col;

        const customComponent = this.props.col.get(HEADER_COMPONENT);
        const headerComponent = (customComponent) ? customComponent : TableHeaderDefault;

        const icon = (this.state.hover && col.get(CAN_HIDE, false)) ?
            <Glyphicon className="remove-icon pull-right" glyph="remove"
                onClick={this.hideColumn.bind(this, col.get(KEY))}
            /> :
            undefined;
        const cssClasses = ['table-cell', col.get(CSS_CLASS_NAME_TABLE_HEADER)];
        if (col.get(FIXED, false)) {
            cssClasses.push('table-cell-fixed');
        }
        const is_selected = this.props.col.get(SELECTED);
        if (is_selected) {
            cssClasses.push('table-header-selected');
        }
        return (
            <th className={cssClasses.join(' ')}
                colSpan={col.get(COLSPAN, 1)}
                key={col.get(KEY)}
                onClick={() => this.focusAndSelect()}
                onMouseLeave={event => this.mouseLeave(event)}
                onMouseOver={event => this.mouseOver(event)}
                title={col.get(LABEL)}
            >
                {React.createElement(headerComponent, this.props)}
                <div className={col.get(CSS_CLASS_NAME_TABLE_HEADER_ICON)}>
                    {icon}
                </div>
            </th>
        );
    }
}
TableHeaderCell.propTypes = {
    col: ImmutablePropTypes.map.isRequired,
    hideColumn: PropTypes.func.isRequired,
    onSelection: PropTypes.func,
    select: PropTypes.func.isRequired
};

export class TableRow extends React.Component {
    shouldComponentUpdate(nextProps) {
        if (false === this.props.cols.equals(nextProps.cols)) {
            // all rows need to be updated due to col selection or strucutre change
            return true;
        }

        const dataHasChanged = (false === this.props.row.equals(nextProps.row));
        const hasBeenFocused =
            this.props.table.getIn([TABLE, FOCUSED_ROW_ID]) === this.props.row.get(ROW_ID);
        const willBeFocused =
            nextProps.table.getIn([TABLE, FOCUSED_ROW_ID]) === nextProps.row.get(ROW_ID);
        const rowSelectionChanged = this.props.row.get(SELECTED) !== nextProps.row.get(SELECTED);

        const rowExpandChanged =
            this.props.row.get(ROW_EXPANDED) !== nextProps.row.get(ROW_EXPANDED);

        return dataHasChanged || hasBeenFocused || willBeFocused ||
            rowSelectionChanged || rowExpandChanged;
    }

    render() {
        const css_class_name = 'table-row table-row-not-selected';
        return (
            <tr className={css_class_name}
                key={this.props.row.get(ROW_ID)}
                ref={scrollTarget => this.scrollTarget = scrollTarget}
            >
                {
                    this.props.cols && this.props.cols.map(
                        col => {
                            if (false === col.get(VISIBLE) || true === col.get(HIDDEN)) {
                                return undefined;
                            }
                            return (
                                <TableCell
                                    {...this.props}
                                    col={col}
                                    fixed={this.props.fixed}
                                    key={this.props.row.get(ROW_ID) + '_' + col.get(KEY)}
                                    row={this.props.row}
                                />
                            );
                        }
                    )
                }
            </tr>
        );
    }
}

TableRow.propTypes = {
    cols: ImmutablePropTypes.list.isRequired,
    editCell: PropTypes.func.isRequired,
    editCells: PropTypes.func.isRequired,
    fixed: PropTypes.bool.isRequired,
    focus: PropTypes.func.isRequired,
    hasFocus: PropTypes.bool,
    row: ImmutablePropTypes.map.isRequired,
    onSelection: PropTypes.func,
    select: PropTypes.func.isRequired,
    table: ImmutablePropTypes.map.isRequired,
    toggleRow: PropTypes.func.isRequired
};

export class TableCell extends React.Component {

    _ifFocusedScrollToMe() {
        const {scrollTo} = this.props;
        const is_focused = this.props.hasFocus &&
            this.props.table.getIn([TABLE, FOCUSED_COL_KEY]) === this.props.col.get(KEY) &&
            this.props.table.getIn([TABLE, FOCUSED_ROW_ID]) === this.props.row.get(ROW_ID);
        if (is_focused) {
            scrollTo(this.tableCell);
        }
    }

    componentDidMount() {
        this._ifFocusedScrollToMe();
    }

    componentDidUpdate() {
        this._ifFocusedScrollToMe();
    }

    shouldComponentUpdate(nextProps) {
        const hasBeen_focused = this.props.hasFocus &&
            this.props.table.getIn([TABLE, FOCUSED_COL_KEY]) === this.props.col.get(KEY) &&
            this.props.table.getIn([TABLE, FOCUSED_ROW_ID]) === this.props.row.get(ROW_ID);
        const willBe_focused = nextProps.hasFocus &&
            nextProps.table.getIn([TABLE, FOCUSED_COL_KEY]) === nextProps.col.get(KEY) &&
            nextProps.table.getIn([TABLE, FOCUSED_ROW_ID]) === nextProps.row.get(ROW_ID);
        const focusHasChanged = (hasBeen_focused !== willBe_focused);
        const selectionHasChanged = (
            this.props.col.get(SELECTED) ||
            this.props.row.get(SELECTED)) !== (nextProps.col.get(SELECTED) ||
            nextProps.row.get(SELECTED)
        );

        const rowExpandChanged =
            this.props.row.get(ROW_EXPANDED) !== nextProps.row.get(ROW_EXPANDED);
        const rowHasCildrenChanged =
            this.props.row.get(ROW_HAS_CHILDREN) !== nextProps.row.get(ROW_HAS_CHILDREN);

        let dataHasChanged;
        const shallCellComponentUpdate = this.props.col.get(CELL_COMPONENT_SHALL_UPDATE_CALLBACK);
        if (shallCellComponentUpdate) {
            dataHasChanged = shallCellComponentUpdate(this.props, nextProps);
        }
        else {
            dataHasChanged =
                this.props.row.get(this.props.col.get(KEY)) !==
                nextProps.row.get(nextProps.col.get(KEY));
        }

        return dataHasChanged || focusHasChanged || rowExpandChanged ||
            rowHasCildrenChanged || selectionHasChanged;
    }

    focusAndSelect() {
        const {col, focus, onSelection, row, select} = this.props;
        focus(row, col);
        select(row, col);

        if (onSelection !== undefined) {
            onSelection(row, col);
        }
    }

    render() {
        const customComponent = this.props.col.get(CELL_COMPONENT);
        const cellComponent = customComponent ? customComponent : TableCellDefault;
        const cssClasses = ['table-cell', this.props.col.get(CSS_CLASS_NAME_TABLE_CELL)];
        if (this.props.col.get(FIXED, false)) {
            cssClasses.push('table-cell-fixed');
        }
        const is_selected = this.props.col.get(SELECTED) || this.props.row.get(SELECTED);
        if (is_selected) {
            cssClasses.push('table-cell-selected');
        }
        const is_focused = this.props.hasFocus &&
            this.props.table.getIn([TABLE, FOCUSED_COL_KEY]) === this.props.col.get(KEY) &&
            this.props.table.getIn([TABLE, FOCUSED_ROW_ID]) === this.props.row.get(ROW_ID);
        if (is_focused) {
            cssClasses.push('table-cell-focus');
        }
        return (
            <td className={cssClasses.join(' ')}
                onClick={this.focusAndSelect.bind(this)}
                ref={tableCell => this.tableCell = tableCell}
            >
                {React.createElement(cellComponent, this.props)}
            </td>
        );
    }
}
TableCell.propTypes = {
    col: ImmutablePropTypes.map.isRequired,
    editCell: PropTypes.func.isRequired,
    editCells: PropTypes.func.isRequired,
    fixed: PropTypes.bool.isRequired,
    focus: PropTypes.func.isRequired,
    hasFocus: PropTypes.bool,
    onSelection: PropTypes.func,
    row: ImmutablePropTypes.map.isRequired,
    scrollTo: PropTypes.func.isRequired,
    select: PropTypes.func.isRequired,
    table: ImmutablePropTypes.map.isRequired
};

export class TableCellTree extends React.Component {
    toggle(e) {
        e.stopPropagation();
        this.props.toggleRow(this.props.row);
        this.props.focus(this.props.row, this.props.col);
    }
    render() {
        const children = this.props.row.get(ROW_CHILDREN);
        const willHaveChildren = this.props.row.get(ROW_HAS_CHILDREN, false);

        const has_children = children && children.size > 0 || willHaveChildren;
        const expanded = this.props.row.get(ROW_EXPANDED, false);

        const icon = has_children ? (
            <span className="table-cell-icon" onClick={this.toggle.bind(this)}>
                <Glyphicon className="pointer-events"
                    glyph={expanded ? 'chevron-down' : 'chevron-right'}
                />
            </span>
        ) : (<span />);
        const textClassName = has_children
            ? 'table-cell-text'
            : 'table-cell-text-without-icon';

        const level = this.props.row.get(ROW_LEVEL, true);
        const indent = this.props.col.get(INDENT, true);
        const indent_span = <span style={{'paddingLeft': indent * level}}/>;
        const classes = ['table-cell-div', this.props.col.get(CSS_CLASS_NAME_TABLE_CELL_CONTENT)];

        return (
            <div className={classes.join(' ')}
                title={this.props.row.get(this.props.col.get(KEY))}
            >
                {indent_span}
                {icon}
                <span className={textClassName}>
                    {this.props.row.get(this.props.col.get(KEY))}
                </span>
            </div>
        );
    }
}
TableCellTree.propTypes = {
    col: ImmutablePropTypes.map.isRequired,
    editCell: PropTypes.func.isRequired,
    focus: PropTypes.func.isRequired,
    row: ImmutablePropTypes.map.isRequired,
    toggleRow: PropTypes.func.isRequired
};
