 /*
  * Copyright (C) 2016 CONTACT Software GmbH
  * All rights reserved.
  * http://www.contact-software.com
  *
  * Revision "$Id: table-actions.js 176176 2018-04-19 07:39:24Z gda $"
  */

// jshint esversion:6

export const ADD_COLUMN = 'ADD_COLUMN';
export const COLLAPSE_ROW = 'COLLAPSE_ROW';
export const EDIT_CELL = 'EDIT_CELL';
export const EDIT_CELLS = 'EDIT_CELLS';
export const EXPAND_ROW = 'EXPAND_ROW';
export const FILTER_COLUMNS = 'FILTER_COLUMNS';
export const FILTER_COLUMN_CHANGE = 'FILTER_COLUMN_CHANGE';
export const FILTER_ROW_CHANGE = 'FILTER_ROW_CHANGE';
export const FOCUS = 'FOCUS';
export const HIDE_COLUMN = 'HIDE_COLUMN';
export const KEY_PRESSED = 'KEY_PRESSED';
export const RESET_COL_SELECTION = 'RESET_COL_SELECTION';
export const RESET_ROW_SELECTION = 'RESET_ROW_SELECTION';
export const SELECT = 'SELECT';
export const SELECT_COL = 'SELECT_COL';
export const SELECT_ROW = 'SELECT_ROW';
export const SET_INITIAL_STATE = 'SET_INITIAL_STATE';
export const SET_CHILDREN = 'SET_CHILDREN';
export const SET_CONTENT = 'SET_CONTENT';
export const SET_GRAB_FOCUS = 'SET_GRAB_FOCUS';
export const SHOW_HIDDEN_COLUMNS = 'SHOW_HIDDEN_COLUMNS';
export const TOGGLE_ROW = 'TOGGLE_ROW';

import Immutable from 'immutable';
import {walkVisibleTableRows} from './table-tools';

import {
    COLS,
    FOCUSED_COL_KEY,
    FOCUSED_ROW_ID,
    HIDDEN,
    KEY,
    KEY_MAPPING,
    ROW_ID,
    ROWS,
    TABLE,
    TREE,
    VISIBLE
} from './table-constants';

export function activateKey(containerId) {
    return (table, key) => {
        const followUpActions = [];
        const focusedColKey = table.getIn([TABLE, FOCUSED_COL_KEY]);
        const focusedRowId = table.getIn([TABLE, FOCUSED_ROW_ID]);
        const visibleCols = table.get(COLS).filter(
            col => col.get(VISIBLE, true) && !col.get(HIDDEN, false));
        const visibleRows = Immutable.List(walkVisibleTableRows(table.get(ROWS)));

        const focusedCol = visibleCols.find(
            col => (col.get(KEY) === focusedColKey)
        );
        const focusedRow = visibleRows.find(
            row => (row.get(ROW_ID) === focusedRowId)
        );

        if (key === 'space') {
            // expand/collapse or select
            if (focusedRow && focusedCol.get(TREE)) {
                followUpActions.push(toggleRow(containerId)(focusedRow));
            }
            else {
                followUpActions.push(select(containerId)(focusedRow, focusedCol));
            }
        }

        if (key === 'left' || key === 'right') {
            // change focus col
            if (visibleCols.isEmpty()) {
                return undefined;
            }
            let lastCol;
            let index = 0;
            for (const col of visibleCols) {
                if (focusedColKey === col.get(KEY)) {
                    if (key === 'left') {
                        const focusMe = lastCol ? lastCol : visibleCols.last();
                        followUpActions.push(focus(containerId)(undefined, focusMe));
                        break;
                    }
                    else if (key === 'right') {
                        const hasNext = visibleCols.size > (index + 1);
                        const focusMe = hasNext ? visibleCols.get(index + 1) : visibleCols.first();
                        followUpActions.push(focus(containerId)(undefined, focusMe));
                        break;
                    }
                }
                lastCol = col;
                index++;
            }
        }

        if (key === 'down' || key === 'up') {
            // change focus row ...
            if (visibleRows.isEmpty()) {
                return undefined;
            }
            let lastRow;
            let index = 0;
            for (const row of visibleRows) {
                if (focusedRowId === row.get(ROW_ID)) {
                    if (key === 'up') {
                        const focusMe = lastRow ? lastRow : visibleRows.last();
                        followUpActions.push(focus(containerId)(focusMe, undefined));
                        break;
                    }
                    else if (key === 'down') {
                        const hasNext = visibleRows.size > (index + 1);
                        const focusMe = hasNext ? visibleRows.get(index + 1) : visibleRows.first();
                        followUpActions.push(focus(containerId)(focusMe, undefined));
                        break;
                    }
                }
                lastRow = row;
                index++;
            }
        }
        if (focusedCol && focusedCol.get(KEY_MAPPING) && focusedCol.get(KEY_MAPPING).get(key)) {
            // add additional action from column
            followUpActions.push(
                focusedCol.get(KEY_MAPPING)
                    .get(key)(containerId)(table, focusedRow, focusedCol, key)
            );
        }

        return dispatch => {
            //React.addons.Perf.start();
            followUpActions.forEach(action => {
                dispatch(action);
            });
            //React.addons.Perf.printWasted();
        };
    };
}

export function keyPressed(containerId) {
    return (keycode) => {
        return {
            type: KEY_PRESSED,
            keycode,
            containerId
        };
    };
}

export function addColumn(containerId) {
    return (col, data) => {
        return {
            type: ADD_COLUMN,
            col,
            data,
            containerId
        };
    };
}

export function collapseRow(containerId) {
    return (id) => {
        return {
            type: COLLAPSE_ROW,
            id,
            containerId
        };
    };
}

export function editCell(containerId) {
    return (row, key, value) => {
        return {
            type: EDIT_CELL,
            row,
            key,
            value,
            containerId
        };
    };
}

export function editCells(containerId) {
    return (row, keyValuePairs) => {
        return {
            type: EDIT_CELLS,
            row,
            keyValuePairs,
            containerId
        };
    };
}

export function expandRow(containerId) {
    return (id) => {
        return {
            type: EXPAND_ROW,
            id,
            containerId
        };
    };
}

export function filterRowChange(containerId) {
    return (callback, text) => {
        return {
            type: FILTER_ROW_CHANGE,
            filterText: text,
            callback,
            containerId
        };
    };
}

export function filterColumns(containerId) {
    return (callback) => {
        return {
            type: FILTER_COLUMNS,
            callback,
            containerId
        };
    };
}

export function filterColumnChange(containerId, namespace) {
    return (callback, text) => (dispatch, getState) => {
        const action = {
            type: FILTER_COLUMN_CHANGE,
            filterText: text,
            callback,
            containerId
        };

        const table = getState()[namespace][containerId];
        const callbacks = table.getIn(['callbacks', FILTER_COLUMN_CHANGE]);
        if (callbacks !== undefined && callbacks !== null) {
            for (const cb of callbacks.toArray()) {
                dispatch(cb(action));
            }
        }

        return dispatch(action);
    };
}

export function focus(containerId) {
    return (row, col) => {
        return {
            type: FOCUS,
            row,
            col,
            containerId
        };
    };
}

export function hideColumn(containerId, namespace) {
    return (columnKey) => (dispatch, getState) => {
        const action = {
            type: HIDE_COLUMN,
            columnKey,
            containerId
        };

        const table = getState()[namespace][containerId];
        const callbacks = table.getIn(['callbacks', HIDE_COLUMN]);
        if (callbacks !== undefined && callbacks !== null) {
            for (const cb of callbacks.toArray()) {
                dispatch(cb(action));
            }
        }

        return dispatch(action);
    };
}

export function resetColSelection(containerId) {
    return () => {
        return {
            type: RESET_COL_SELECTION,
            containerId
        };
    };
}

export function resetRowSelection(containerId) {
    return () => {
        return {
            type: RESET_ROW_SELECTION,
            containerId
        };
    };
}

export function select(containerId, namespace) {
    return (row, col) => (dispatch, getState) => {
        const action = {
            type: SELECT,
            row,
            col,
            containerId
        };

        const table = getState()[namespace][containerId];
        const callbacks = table.getIn(['callbacks', SELECT]);
        if (callbacks !== undefined && callbacks !== null) {
            for (const cb of callbacks.toArray()) {
                dispatch(cb(action));
            }
        }

        return dispatch(action);
    };
}

export function selectCol(containerId) {
    return (col) => {
        return {
            type: SELECT_COL,
            col,
            containerId
        };
    };
}

export function selectRow(containerId) {
    return (row) => {
        return {
            type: SELECT_ROW,
            row,
            containerId
        };
    };
}

export function setInitialState(containerId) {
    return (state) => {
        return {
            type: SET_INITIAL_STATE,
            state,
            containerId
        };
    };
}

export function setContent(containerId) {
    return (content) => ({
        type: SET_CONTENT,
        content,
        containerId
    });
}

export function setChildren(containerId) {
    return (row_id, children) => {
        return {
            type: SET_CHILDREN,
            row_id,
            children,
            containerId
        };
    };
}

export function setGrabFocus(containerId) {
    return (value) => ({
        type: SET_GRAB_FOCUS,
        value,
        containerId
    });
}

export function showHiddenColumns(containerId) {
    return () => ({
        type: SHOW_HIDDEN_COLUMNS,
        containerId
    });
}

export function toggleRow(containerId) {
    return (row) => {
        return {
            type: TOGGLE_ROW,
            row,
            containerId
        };
    };
}
