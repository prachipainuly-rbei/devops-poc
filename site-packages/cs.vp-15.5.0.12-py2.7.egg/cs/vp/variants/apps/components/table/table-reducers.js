/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: table-reducers.js 181938 2018-08-09 12:50:04Z gda $"
 */

// jshint esversion:6

import Immutable from 'immutable';
import {
    changeFocusToVisibleCol,
    changeFocusToVisibleRow,
    collapseRow,
    editCell,
    editCells,
    expandRow,
    hideColumn,
    filterColumn,
    filterRow,
    selectCol,
    selectRow,
    setChildren,
    setColumnData,
    showHiddenColumn,
    toggleRow
} from './table-tools';

import {
    ADD_COLUMN,
    COLLAPSE_ROW,
    EDIT_CELL,
    EDIT_CELLS,
    EXPAND_ROW,
    FILTER_COLUMNS,
    FILTER_COLUMN_CHANGE,
    FILTER_ROW_CHANGE,
    FOCUS,
    HIDE_COLUMN,
    KEY_PRESSED,
    RESET_COL_SELECTION,
    RESET_ROW_SELECTION,
    SELECT,
    SELECT_COL,
    SELECT_ROW,
    SET_INITIAL_STATE,
    SET_CHILDREN,
    SET_CONTENT,
    SET_GRAB_FOCUS,
    SHOW_HIDDEN_COLUMNS,
    TOGGLE_ROW
} from './table-actions';

import {
    COLS,
    FILTER_FIELD,
    FILTER_FIELD_COL,
    FOCUSED_COL_KEY,
    FOCUSED_ROW_ID,
    GRAB_FOCUS,
    INITIALISED,
    KEY,
    KEY_CODE,
    ROWS,
    ROW_ID,
    SELECTION_MODE,
    SELECTION_MODE_BOTH,
    SELECTION_MODE_COL,
    SELECTION_MODE_ROW,
    TABLE,
    VALUE
} from './table-constants';

const defaultState = Immutable.fromJS({
    filterField: {
        visible: true
    },
    header: {
        visible: true,
        fixedColumns: 0
    },
    cols: [],
    rows: [],
    table: {}
});

const tableReducer = (state = defaultState, action) => { // jshint ignore:line
    let columns;
    let focusedColKey;
    let focusedRowId;
    let rows;
    let updatedColumns;
    let updatedRows;
    let updatedState;

    switch (action.type) {
        case ADD_COLUMN:
            columns = state.get(COLS);
            updatedColumns = columns.push(Immutable.fromJS(action.col));
            rows = state.get(ROWS);
            updatedRows = rows.map(row => setColumnData(action.col, row, action.data));
            return state.set(COLS, updatedColumns).set(ROWS, updatedRows);

        case COLLAPSE_ROW:
            rows = state.get(ROWS);
            updatedRows = rows.map(row => collapseRow(row, action.id));
            return state.set(ROWS, updatedRows);

        case EDIT_CELL:
            rows = state.get(ROWS);
            updatedRows = rows.map(
                row => editCell(row, action.row.get(ROW_ID), action.key, action.value));
            return state.set(ROWS, updatedRows);

        case EDIT_CELLS:
            rows = state.get(ROWS);
            updatedRows = rows.map(
                row => editCells(row, action.row.get(ROW_ID), action.keyValuePairs));
            return state.set(ROWS, updatedRows);

        case EXPAND_ROW:
            rows = state.get(ROWS);
            updatedRows = rows.map(row => expandRow(row, action.id));
            return state.set(ROWS, updatedRows);

        case FILTER_COLUMNS:
            columns = state.get(COLS);
            updatedColumns = columns.map(col => filterColumn(state, col, action.callback));
            focusedColKey = changeFocusToVisibleCol(
                state.getIn([TABLE, FOCUSED_COL_KEY]), updatedColumns);
            return state.set(COLS, updatedColumns).setIn([TABLE, FOCUSED_COL_KEY], focusedColKey);

        case FILTER_COLUMN_CHANGE:
            columns = state.get(COLS);
            updatedColumns = columns.map(col => filterColumn(state, col, action.callback));
            focusedColKey = changeFocusToVisibleCol(
                state.getIn([TABLE, FOCUSED_COL_KEY]), updatedColumns);
            return state.updateIn(
                [FILTER_FIELD_COL, VALUE],
                () => action.filterText
            ).set(COLS, updatedColumns)
                .setIn([TABLE, FOCUSED_COL_KEY], focusedColKey);

        case FILTER_ROW_CHANGE:
            rows = state.get(ROWS);
            updatedRows = rows.map(row => filterRow(row, action.callback));
            focusedRowId = changeFocusToVisibleRow(
                state.getIn([TABLE, FOCUSED_ROW_ID]), updatedRows);
            return state
                .updateIn([FILTER_FIELD, VALUE], () => action.filterText)
                .set(ROWS, updatedRows)
                .setIn([TABLE, FOCUSED_ROW_ID], focusedRowId);

        case FOCUS:
            updatedState = state;
            if (action.col) {
                updatedState = updatedState.setIn([TABLE, FOCUSED_COL_KEY], action.col.get(KEY));
            }
            if (action.row) {
                updatedState = updatedState.setIn([TABLE, FOCUSED_ROW_ID], action.row.get(ROW_ID));
            }
            return updatedState;

        case HIDE_COLUMN:
            columns = state.get(COLS);
            updatedColumns = columns.map(col => hideColumn(col, action.columnKey));
            focusedColKey = changeFocusToVisibleCol(
                state.getIn([TABLE, FOCUSED_COL_KEY]), updatedColumns);
            return state.set(COLS, updatedColumns).setIn([TABLE, FOCUSED_COL_KEY], focusedColKey);

        case KEY_PRESSED:
            return state.set(KEY_CODE, action.keycode);

        case RESET_COL_SELECTION:
            columns = state.get(COLS);
            updatedColumns = columns.map(col => selectCol(col, ''));
            return state.set(COLS, updatedColumns);

        case RESET_ROW_SELECTION:
            rows = state.get(ROWS);
            updatedRows = rows.map(row => selectRow(row, ''));
            return state.set(ROWS, updatedRows);

        case SELECT:
            updatedState = state;
            if (action.col) {
                if (
                    (
                        action.col.get(SELECTION_MODE) === SELECTION_MODE_BOTH ||
                        action.col.get(SELECTION_MODE) === SELECTION_MODE_ROW
                    ) && action.row
                ) {
                    rows = state.get(ROWS);
                    updatedRows = rows.map(row => selectRow(row, action.row.get(ROW_ID)));
                    updatedState = updatedState.set(ROWS, updatedRows);
                }
                if (
                    action.col.get(SELECTION_MODE) === SELECTION_MODE_BOTH ||
                    action.col.get(SELECTION_MODE) === SELECTION_MODE_COL
                ) {
                    columns = state.get(COLS);
                    updatedColumns = columns.map(col => selectCol(col, action.col.get(KEY)));
                    updatedState = updatedState.set(COLS, updatedColumns);
                }
            }
            return updatedState;

        case SELECT_COL:
            if (action.col) {
                columns = state.get(COLS);
                updatedColumns = columns.map(col => selectCol(col, action.col.get(KEY)));
                updatedState = updatedState.set(COLS, updatedColumns);
            }
            return state;

        case SELECT_ROW:
            if (action.row) {
                rows = state.get(ROWS);
                updatedRows = rows.map(row => selectRow(row, action.row.get(ROW_ID)));
                return state.set(ROWS, updatedRows);
            }
            return state;

        case SET_INITIAL_STATE:
            return (action.state) ? action.state : state;

        case SET_CONTENT:
            return action.content ?
                state.set(ROWS, action.content).set(INITIALISED, true) :
                state;

        case SET_CHILDREN:
            rows = state.get(ROWS);
            updatedRows = rows.map(row => setChildren(row, action.children, action.row_id));
            return state.set(ROWS, updatedRows);

        case SET_GRAB_FOCUS:
            return state.setIn([TABLE, GRAB_FOCUS], action.value);

        case SHOW_HIDDEN_COLUMNS:
            columns = state.get(COLS);
            updatedColumns = columns.map(col => showHiddenColumn(col));
            return state.set(COLS, updatedColumns);

        case TOGGLE_ROW:
            rows = state.get(ROWS);
            updatedRows = rows.map(row => toggleRow(row, action.row.get(ROW_ID)));
            return state.set(ROWS, updatedRows);

        default:
            return state;
    }
};

const chainReducers = (...reducers) => reducers.reduce(
    (lhs, rhs) => (
        (state, action) => {
            return rhs(lhs(state, action), action);
        }
    ),
    function(state = Immutable.Map()) {
        return state;
    }
);

const reducer = chainReducers(
     tableReducer
);

export default function(containerId) {
    return (state, action) => {
        if (containerId === action.containerId) {
            return reducer(state, action);
        } else {
            return state === undefined ? defaultState : state;
        }
    };
}
