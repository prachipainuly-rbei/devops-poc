/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: table-tools.js 171249 2018-01-09 12:31:54Z gda $"
 */

 // jshint esversion:6

import {
    CAN_HIDE,
    KEY,
    HIDDEN,
    ROW_CHILDREN,
    ROW_ID,
    ROW_EXPANDED,
    ROW_LEVEL,
    ROW_VISIBLE,
    SELECTED,
    VISIBLE
} from './table-constants';

export function changeFocusToVisibleCol(focusedColKey, cols) {
    // convert to array because IE can't iterate over Immutables
    const colsArray = cols.toArray !== undefined ? cols.toArray() : cols;

    let lastCol;
    let changeFocus = false;
    for (const col of colsArray) {
        const visible = col.get(VISIBLE, true) && false === col.get(HIDDEN, false);
        if (visible && changeFocus) {
            return col.get(KEY);
        }
        if (false === visible && col.get(KEY) === focusedColKey) {
            changeFocus = true;
        }
        if (visible) {
            lastCol = col;
        }
    }
    if (changeFocus) {
        if (lastCol) {
            return lastCol.get(KEY);
        }
        else {
            return undefined;
        }
    }
    else {
        return focusedColKey;
    }
}

export function changeFocusToVisibleRow(focusedRowId, rows) {
    // convert to array because IE can't iterate over Immutables
    const rowsArray = rows.toArray !== undefined ? rows.toArray() : rows;

    let lastRow;
    let changeFocus = false;
    for (const row of rowsArray) {
        const visible = row.get(ROW_VISIBLE, true);
        if (visible && changeFocus) {
            return row.get(ROW_ID);
        }
        if (false === visible && row.get(ROW_ID) === focusedRowId) {
            changeFocus = true;
        }
        if (visible) {
            lastRow = row;
        }
    }
    if (changeFocus) {
        if (lastRow) {
            return lastRow.get(ROW_ID);
        }
        else {
            return undefined;
        }
    }
    else {
        return focusedRowId;
    }
}

export function collapseRow(row, forThisId) {
    let immutableRow = row;
    if (immutableRow.get(ROW_EXPANDED, false)) {
        const children = immutableRow.get(ROW_CHILDREN);
        if (children) {
            const updatedChildren = children.map(row => collapseRow(row, forThisId));
            immutableRow = immutableRow.set(ROW_CHILDREN, updatedChildren);
        }
    }
    if (forThisId === immutableRow.get(ROW_ID)) {
        return immutableRow.updateIn([ROW_EXPANDED], () => false);
    }
    else {
        return immutableRow;
    }
}

export function editCell(row, thisId, key, value) {
    let immutableRow = row;

    const children = immutableRow.get(ROW_CHILDREN);
    if (children) {
        const updatedChildren = children.map(row => editCell(row, thisId, key, value));
        immutableRow = immutableRow.set(ROW_CHILDREN, updatedChildren);
    }
    if (thisId === immutableRow.get(ROW_ID)) {
        return immutableRow.updateIn([key], () => value);
    }
    else {
        return immutableRow;
    }
}

export function editCells(row, thisId, keyValuePairs) {
    let immutableRow = row;

    const children = immutableRow.get(ROW_CHILDREN);
    if (children) {
        const updatedChildren = children.map(row => editCells(row, thisId, keyValuePairs));
        immutableRow = immutableRow.set(ROW_CHILDREN, updatedChildren);
    }
    if (thisId === immutableRow.get(ROW_ID)) {
        let updatedRow = immutableRow;

        for (const key in keyValuePairs) {
            if (keyValuePairs.hasOwnProperty(key)) {
                const value = keyValuePairs[key];
                updatedRow = updatedRow.set(key, value);
            }
        }
        return updatedRow;
    }
    else {
        return immutableRow;
    }
}

export function expandRow(row, forThisId) {
    let immutableRow = row;

    if (immutableRow.get(ROW_EXPANDED, false)) {
        const children = immutableRow.get(ROW_CHILDREN);
        if (children) {
            const updatedChildren = children.map(row => expandRow(row, forThisId));
            immutableRow = immutableRow.set(ROW_CHILDREN, updatedChildren);
        }
    }
    if (forThisId === immutableRow.get(ROW_ID)) {
        return immutableRow.set(ROW_EXPANDED, true);
    }
    else {
        return immutableRow;
    }
}

export function filterColumn(state, col, callback) {
    if (col.get(CAN_HIDE)) {
        return col.set(VISIBLE, callback(state, col));
    }
    else {
        return col;
    }
}

export function filterRow(row, callback) {
    let immutableRow = row;
    let hasVisibleChildren = false;
    if (immutableRow.get(ROW_EXPANDED, false)) {
        const children = immutableRow.get(ROW_CHILDREN);
        if (children) {
            const updatedChildren = children.map(row => filterRow(row, callback));
            for (const child of updatedChildren.toArray()) {
                if (child.get(ROW_VISIBLE)) {
                    hasVisibleChildren = true;
                }
            }
            immutableRow = immutableRow.set(ROW_CHILDREN, updatedChildren);
        }
    }
    const isVisible = hasVisibleChildren || callback(immutableRow);
    return immutableRow.set(ROW_VISIBLE, isVisible);
}

export function hideColumn(column, forThisKey) {
    if (forThisKey === column.get(KEY)) {
        return column.set(HIDDEN, true).set(SELECTED, false);
    }
    else {
        return column;
    }
}

export function showHiddenColumn(column) {
    return column.set(HIDDEN, false);
}

export function selectCol(col, forThisKey) {
    return col.updateIn([SELECTED], () => (forThisKey === col.get(KEY)));
}

export function selectRow(row, forThisId) {
    let immutableRow = row;

    if (immutableRow.get(ROW_EXPANDED, false)) {
        const children = immutableRow.get(ROW_CHILDREN);
        if (children) {
            const updatedChildren = children.map(row => selectRow(row, forThisId));
            immutableRow = immutableRow.set(ROW_CHILDREN, updatedChildren);
        }
    }
    if (forThisId === immutableRow.get(ROW_ID)) {
        return immutableRow.updateIn([SELECTED], () => true);
    }
    else {
        return immutableRow.updateIn([SELECTED], () => false);
    }
}

export function setChildren(row, setThisChildren, forThisId) {
    let immutableRow = row;

    const children = immutableRow.get(ROW_CHILDREN);
    if (children) {
        const updatedChildren = children.map(row => setChildren(row, setThisChildren, forThisId));
        immutableRow = immutableRow.set(ROW_CHILDREN, updatedChildren);
    }
    if (forThisId === immutableRow.get(ROW_ID)) {
        return immutableRow.set(ROW_CHILDREN, setThisChildren);
    }
    else {
        return immutableRow;
    }
}

export function setColumnData(col, row, data) {
    let immutableRow = row;
    const children = immutableRow.get(ROW_CHILDREN);
    if (children) {
        const updatedChildren = children.map(row => setColumnData(col, row, data));
        immutableRow = immutableRow.set(ROW_CHILDREN, updatedChildren);
    }
    const rowId = immutableRow.get(ROW_ID);
    const value = data[rowId];
    if (value === undefined) {
        return immutableRow;
    }
    else {
        const newRow = immutableRow.updateIn([col.key], () => value);
        return newRow;
    }
}


export function showColumn(column) {
    return column.updateIn([VISIBLE], () => true);
}

export function toggleRow(row, forThisId) {
    let immutableRow = row;
    if (immutableRow.get(ROW_EXPANDED, false)) {
        const children = immutableRow.get(ROW_CHILDREN);
        if (children) {
            const updatedChildren = children.map(row => toggleRow(row, forThisId));
            immutableRow = immutableRow.set(ROW_CHILDREN, updatedChildren);
        }
    }
    if (forThisId === immutableRow.get(ROW_ID)) {
        return immutableRow.updateIn([ROW_EXPANDED], (oldToggle) => !oldToggle);
    }
    else {
        return immutableRow;
    }
}

export function* walkVisibleTableRows(rows, level = 0) {
    // convert to array because IE can't iterate over Immutables
    const rowArray = rows.toArray !== undefined ? rows.toArray() : rows;

    for (const row of rowArray) {
        if (row.get(ROW_VISIBLE, true)) {
            yield row.set(ROW_LEVEL, level);
            if (row.get(ROW_EXPANDED, false)) {
                const children = row.get(ROW_CHILDREN);
                if (children) {
                    yield *walkVisibleTableRows(children, level + 1);
                }
            }
        }
    }
}

export function* walkTableRows(rows, level = 0) {
    // convert to array because IE can't iterate over Immutables
    const rowArray = rows.toArray !== undefined ? rows.toArray() : rows;

    for (const row of rowArray) {
        yield row.set(ROW_LEVEL, level);
        const children = row.get(ROW_CHILDREN);
        if (children) {
            yield *walkTableRows(children, level + 1);
        }
    }
}
