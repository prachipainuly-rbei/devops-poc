/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: table-tests.js 139918 2016-04-14 07:48:32Z msl $"
 */

 // jshint esversion:6

import _                                                  from 'lodash';
import React                                              from 'react';
import ReactDOM                                           from 'react-dom';

import Immutable                                          from 'immutable';

import { createStore, combineReducers, applyMiddleware }  from 'redux';
import { Provider }                                       from 'react-redux';
import thunk                                              from 'redux-thunk';

import tableContainerFactory                              from '../index';
import { reducer as tableReducerFactory }                 from '../index';
import { actions as tableActionsFactory }                 from '../index';

import { Table, TableCellTree, TableRow, TableCell }      from '../table-components';
import { isInView }                                       from '../../utils/index';

import {
    COLS,
    CSS_CLASS_NAME_TABLE_HEADER,
    CSS_CLASS_NAME_TABLE_CELL,
    FILTER_FIELD,
    FOCUSED_COL_KEY,
    FOCUSED_ROW_ID,
    HEADER,
    KEY,
    LABEL,
    SELECTED,
    SELECTION_MODE_BOTH,
    ROWS,
    ROW_ID,
    TABLE,
    VISIBLE
} from '../table-constants'


export function filterCallback(filterText, row) {
    if (row.get('assembly').indexOf(filterText) > -1) {
        return true;
    }
    if (row.get('item').indexOf(filterText) > -1) {
        return true;
    }
    if (row.get('status').indexOf(filterText) > -1) {
        return true;
    }
    return false;
}

const SPACE = 32;
const CURSOR_LEFT = 37;
const CURSOR_RIGHT = 39;

// workaround for key events as ReactTestUtils.Simulate does not work together with keymaster
function keyDownEvent(keyCode) {
    let event = document.createEvent('Event');
    event.keyCode = keyCode;
    event.initEvent('keydown');
    document.dispatchEvent(event);
}

let tabledata = Immutable.fromJS({
    filterField: {
        callback: filterText => row => filterCallback(filterText, row),
        label: 'Optional Filter Label',
        placeholder: 'Bitte Filterbegriff eingeben',
        visible: true
    },
    header: {
        visible: true,
        fixedColumns: 0
    },
    cols :
    [
        {
            key                  : 'assembly',
            label                : 'Baugruppe',
            classNameHeader      : 'assembly-header',
            classNameHeaderLabel : 'assembly-header-label',
            classNameHeaderIcon  : 'assembly-header-icon',
            classNameCell        : 'assembly-cell',
            classNameCellContent : 'assembly-cell-content',
            cellComponent        : TableCellTree,
            indent               : 15,
            selectionMode        : SELECTION_MODE_BOTH,
            tree                 : true,
            visible              : true
        },
        {
            key                  : 'status',
            label                : 'Status',
            classNameHeader      : 'status-header',
            classNameHeaderLabel : 'status-header-label',
            classNameHeaderIcon  : 'status-header-icon',
            classNameCell        : 'status-cell',
            classNameCellContent : 'status-cell-content',
            selectionMode        : SELECTION_MODE_BOTH,
            visible              : true
        },
        {
            key                  : 'item',
            label                : 'Zugeordneter Artikel',
            classNameHeader      : 'part-header',
            classNameHeaderLabel : 'part-header-label',
            classNameHeaderIcon  : 'part-header-icon',
            classNameCell        : 'part-cell',
            classNameCellContent : 'part-cell-content',
            selectionMode        : SELECTION_MODE_BOTH,
            visible              : true
        }
    ],
    rows :
    [
        {
            _id: '1', assembly: 'Assembly 1', status: 'offen', item: 'Part 1',
            _children: [
                {
                    _id: '1.1', assembly: 'Assembly 1.1', status: 'offen', item: 'Part 1',
                    _children: [
                        {
                            _id: '1.1.1', assembly: 'Assembly 1.1.1', status: 'offen', item: 'Part 1'
                        },
                        {
                            _id: '1.1.2', assembly: 'Assembly 1.1.2', status: 'offen', item: 'Part 1'
                        }
                    ]
                },
                {
                    _id: '1.2', assembly: 'Assembly 1.2', status: 'offen', item: 'Part 1'
                }
            ]
        },
        { _id: '2', assembly: 'Assembly 2', status: 'offen', item: 'Part 2'},
        { _id: '3', assembly: 'Assembly 3', status: 'bearbeitet', item: 'Part 3'},
        { _id: '4', assembly: 'Assembly 4', status: 'offen', item: 'Part 4'},
        {
            _id: '5', assembly: 'Assembly 5', status: 'offen', item: 'Part 5',
            _children: [
                {
                    _id: '5.1', assembly: 'Assembly 5.1', status: 'offen', item: 'Part 5',
                    _children: [
                        {
                            _id: '5.1.1', assembly: 'Assembly 5.1.1', status: 'offen', item: 'Part 5',
                            _children: [
                                {
                                    _id: '5.1.1.1', assembly: 'Assembly 5.1.1.1', status: 'offen', item: 'Part 5',
                                    _children: [
                                        {
                                            _id: '5.1.1.1.1', assembly: 'Assembly 5.1.6.1.1', status: 'offen', item: 'Part 5'
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        { _id: '6', assembly: 'Assembly 6', status: 'offen', item: 'Part 6'},
        { _id: '7', assembly: 'Assembly 7', status: 'bearbeitet', item: 'Part 7'},
        { _id: '8', assembly: 'Assembly 8', status: 'offen', item: 'Part 8'},
        { _id: '9', assembly: 'Assembly 9', status: 'bearbeitet', item: 'Part 9'}
    ]
});

const headerKeys = tabledata.get(COLS).map(col => {
    return col.get(KEY);
}).toJS();


const headerCss = tabledata.get(COLS).map(col => {
    return 'table-cell ' + col.get(CSS_CLASS_NAME_TABLE_HEADER);
}).toJS();

const headerLabel = tabledata.get(COLS).map(col => {
    return col.get(LABEL);
}).toJS();


const TableContainerId = 'Table';
const TableContainer   = tableContainerFactory(TableContainerId);
const TableActions     = tableActionsFactory(TableContainerId);

const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);
let reducers = {};
reducers[TableContainerId]  = tableReducerFactory(TableContainerId);

const CURSOR_UP = 38;
const CURSOR_DOWN = 40;

// workaround for key events as ReactTestUtils.Simulate does not work together with keymaster
function keyDownEvent(keyCode) {
    let event = document.createEvent('Event');
    event.keyCode = keyCode;
    event.initEvent('keydown');
    document.dispatchEvent(event);
}

describe('The table component', () => {
    it('can be rendered with filter and header', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
                tabledata.setIn([FILTER_FIELD, VISIBLE], true).setIn([HEADER, VISIBLE], true)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );

        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const filterText = ReactTestUtils.findRenderedDOMComponentWithTag(table, 'Input');
        expect(filterText).not.toBe(undefined);

        const tableRows = ReactTestUtils.scryRenderedDOMComponentsWithTag(table, 'tr');
        // data plus one header row, for each row data there is one row in the table and one other in the shadow table
        const expectedRowCount = (1 + tabledata.get(ROWS).size);
        expect(tableRows.length).toBe(expectedRowCount);
    });
    it('can be rendered without filter', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
                tabledata.setIn([FILTER_FIELD, VISIBLE], false).setIn([HEADER, VISIBLE], false)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );

        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const filterText = ReactTestUtils.scryRenderedDOMComponentsWithTag(table, 'Input');
        expect(filterText.length).toBe(0);

        const tableRows = ReactTestUtils.scryRenderedDOMComponentsWithTag(table, 'tr');
        // data, for each row data there is one row in the table and one other in the shadow table
        const expectedRowCount = (tabledata.get(ROWS).size);
        expect(tableRows.length).toBe(expectedRowCount);
    });
    it('can be rendered without header', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
                tabledata.setIn([FILTER_FIELD, VISIBLE], false).setIn([HEADER, VISIBLE], false)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );
        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const dataTable        = ReactTestUtils.findRenderedComponentWithType(table, Table).refs.table;
        const tableHeaderCells = ReactTestUtils.scryRenderedDOMComponentsWithTag(dataTable, 'th');

        expect(tableHeaderCells.length).toBe(0);
    });
    it('can be rendered with correct header', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
                tabledata.setIn([FILTER_FIELD, VISIBLE], false).setIn([HEADER, VISIBLE], true)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );
        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const dataTable = ReactTestUtils.findRenderedComponentWithType(table, Table).refs.table;

        const tableHeaderCells = ReactTestUtils.scryRenderedDOMComponentsWithTag(dataTable, 'th');
        expect(tableHeaderCells.map(tableHeader => {
            return tableHeader.textContent;
        })).toEqual(headerLabel);
        expect(tableHeaderCells.map(tableHeader => {
            return tableHeader.getAttribute('class');
        })).toEqual(headerCss);
    });
    it('can be rendered with correct content', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
                tabledata.setIn([FILTER_FIELD, VISIBLE], false).setIn([HEADER, VISIBLE], true)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );
        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const dataTable  = ReactTestUtils.findRenderedComponentWithType(table, Table).refs.table;
        const tableCells = ReactTestUtils.scryRenderedDOMComponentsWithTag(dataTable, 'td');

        let tableValues = [];
        for (let row of tabledata.get(ROWS).values()) {
            tableValues = tableValues.concat(
                tabledata.get(COLS).map(col => {
                    return row.get(col.get(KEY));
                }).toJS()
            );
        }
        expect(tableCells.map(cell => {
            return cell.textContent;
        })).toEqual(tableValues);

        let tableCssClasses = [];
        for (let row of tabledata.get(ROWS).values()) {
            tableCssClasses = tableCssClasses.concat(
                tabledata.get(COLS).map(col => {
                    return 'table-cell ' + col.get(CSS_CLASS_NAME_TABLE_CELL);
                }).toJS()
            );
        }

        expect(tableCells.map(cell => {
            return cell.getAttribute('class');
        })).toEqual(tableCssClasses);
    });

    it('can be filtered', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
                tabledata.setIn([FILTER_FIELD, VISIBLE], true).setIn([HEADER, VISIBLE], false)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );
        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const filterText = ReactTestUtils.findRenderedDOMComponentWithTag(table, 'Input');
        const dataTable = ReactTestUtils.findRenderedComponentWithType(table, Table).refs.table;

        let filterValue = 'offen';
        filterText.value = filterValue;
        ReactTestUtils.Simulate.change(filterText);

        let tableRows = ReactTestUtils.scryRenderedDOMComponentsWithTag(dataTable, 'tr');
        expect(tableRows.length).toBe(6);

        filterValue = 'bearbeitet';
        filterText.value = filterValue;
        ReactTestUtils.Simulate.change(filterText);

        tableRows = ReactTestUtils.scryRenderedDOMComponentsWithTag(dataTable, 'tr');
        expect(tableRows.length).toBe(3);
    });

    it('can be focused', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
                tabledata.setIn([FILTER_FIELD, VISIBLE], false).setIn([HEADER, VISIBLE], false)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );
        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const dataTable = ReactTestUtils.findRenderedComponentWithType(table, Table).refs.table;

        // ensure no focus is set ...
        let tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        let selectedRows = tableRows.filter(entry => entry.props.row.get(SELECTED));
        expect(selectedRows.length).toEqual(0);
        let cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell assembly-cell table-cell-focus');
        expect(cssSeleted.length).toEqual(0);

        // test focus by mouse clicks ...
        let tableCells = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableCell);
        let cell       = ReactTestUtils.findRenderedDOMComponentWithTag (tableCells[0], 'td');
        ReactTestUtils.Simulate.click(cell);
        selectedRows = tableRows.filter(entry => entry.props.row.get(SELECTED));
        expect(selectedRows.length).toEqual(1);
        expect(tableRows[0].props.row.get(SELECTED)).toEqual(true);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell assembly-cell table-cell-focus');
        expect(cssSeleted.length).toEqual(1);

        cell = ReactTestUtils.findRenderedDOMComponentWithTag (tableCells[3], 'td');
        ReactTestUtils.Simulate.click(cell);
        expect(selectedRows.length).toEqual(1);
        expect(tableRows[0].props.row.get(SELECTED)).toEqual(false);
        expect(tableRows[1].props.row.get(SELECTED)).toEqual(true);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell assembly-cell table-cell-focus');
        expect(cssSeleted.length).toEqual(1);

        // test focus by cursor keys ...
        keyDownEvent(CURSOR_UP);
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_ROW_ID])).toEqual('1');
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_COL_KEY])).toEqual('assembly');
        // test wrapping to last ...
        keyDownEvent(CURSOR_UP);
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_ROW_ID])).toEqual('9');
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_COL_KEY])).toEqual('assembly');
        // test wrapping to first ...
        keyDownEvent(CURSOR_DOWN);
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_ROW_ID])).toEqual('1');
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_COL_KEY])).toEqual('assembly');
        keyDownEvent(CURSOR_DOWN);
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_ROW_ID])).toEqual('2');
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_COL_KEY])).toEqual('assembly');

        keyDownEvent(CURSOR_LEFT);
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_ROW_ID])).toEqual('2');
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_COL_KEY])).toEqual('item');
        keyDownEvent(CURSOR_RIGHT);
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_ROW_ID])).toEqual('2');
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_COL_KEY])).toEqual('assembly');
        keyDownEvent(CURSOR_RIGHT);
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_ROW_ID])).toEqual('2');
        expect(tableRows[0].props.table.getIn([TABLE, FOCUSED_COL_KEY])).toEqual('status');
    });

    it('can be selected', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
            tabledata.setIn([FILTER_FIELD, VISIBLE], true).setIn([HEADER, VISIBLE], false)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );
        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const dataTable = ReactTestUtils.findRenderedComponentWithType(table, Table).refs.table;

        // ensure nothing is selected ...
        let tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        let selectedRows = tableRows.filter(entry => entry.props.row.get(SELECTED));
        expect(selectedRows.length).toEqual(0);
        let cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell status-cell table-cell-selected');
        expect(cssSeleted.length).toEqual(0);

        // test selection by mouse clicks ...
        let tableCells = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableCell);
        let cell       = ReactTestUtils.findRenderedDOMComponentWithTag (tableCells[1], 'td');
        ReactTestUtils.Simulate.click(cell);
        selectedRows = tableRows.filter(entry => entry.props.row.get(SELECTED));
        expect(selectedRows.length).toEqual(1);
        expect(tableRows[0].props.row.get(SELECTED)).toEqual(true);

        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell assembly-cell table-cell-selected');
        expect(cssSeleted.length).toEqual(1);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell status-cell table-cell-selected');
        expect(cssSeleted.length).toEqual(9);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell part-cell table-cell-selected');
        expect(cssSeleted.length).toEqual(1);

        cell = ReactTestUtils.findRenderedDOMComponentWithTag (tableCells[4], 'td');
        ReactTestUtils.Simulate.click(cell);
        expect(selectedRows.length).toEqual(1);
        expect(tableRows[0].props.row.get(SELECTED)).toEqual(false);
        expect(tableRows[1].props.row.get(SELECTED)).toEqual(true);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell assembly-cell table-cell-selected');
        expect(cssSeleted.length).toEqual(1);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell status-cell table-cell-selected');
        expect(cssSeleted.length).toEqual(9);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell part-cell table-cell-selected');
        expect(cssSeleted.length).toEqual(1);

        // test focus by cursor keys ...
        keyDownEvent(CURSOR_UP);
        keyDownEvent(SPACE);
        expect(tableRows[0].props.row.get(SELECTED)).toEqual(true);
        expect(tableRows[1].props.row.get(SELECTED)).toEqual(false);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell assembly-cell table-cell-selected');
        expect(cssSeleted.length).toEqual(1);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell status-cell table-cell-selected');
        expect(cssSeleted.length).toEqual(9);
        cssSeleted = ReactTestUtils.scryRenderedDOMComponentsWithClass(dataTable, 'table-cell part-cell table-cell-selected');
        expect(cssSeleted.length).toEqual(1);

    });


    it('can be expanded and collapsed with mouse', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
            tabledata.setIn([FILTER_FIELD, VISIBLE], false).setIn([HEADER, VISIBLE], false)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );
        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const dataTable = ReactTestUtils.findRenderedComponentWithType(table, Table).refs.table;
        let tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(9);

        let treeCells = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableCellTree);
        let treeIcon = ReactTestUtils.findRenderedDOMComponentWithClass(treeCells[0], 'table-cell-icon');
        ReactTestUtils.Simulate.click(treeIcon);

        tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(11);

        treeCells = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableCellTree);
        treeIcon = ReactTestUtils.findRenderedDOMComponentWithClass(treeCells[1], 'table-cell-icon');
        ReactTestUtils.Simulate.click(treeIcon);

        tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(13);

        treeCells = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableCellTree);
        treeIcon = ReactTestUtils.findRenderedDOMComponentWithClass(treeCells[0], 'table-cell-icon');
        ReactTestUtils.Simulate.click(treeIcon);

        tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(9);
    });
    it('can be expanded and collapsed with keyboard', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
            tabledata.setIn([FILTER_FIELD, VISIBLE], false).setIn([HEADER, VISIBLE], false)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );
        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const dataTable = ReactTestUtils.findRenderedComponentWithType(table, Table).refs.table;
        let tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(9);

        let tableCells = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableCell);
        let cell       = ReactTestUtils.findRenderedDOMComponentWithTag (tableCells[0], 'td');
        ReactTestUtils.Simulate.click(cell);

        keyDownEvent(SPACE);
        tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(11);

        tableCells = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableCell);
        cell = ReactTestUtils.findRenderedDOMComponentWithTag (tableCells[3], 'td');
        ReactTestUtils.Simulate.click(cell);
        keyDownEvent(SPACE);
        tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(13);

        cell = ReactTestUtils.findRenderedDOMComponentWithTag (tableCells[0], 'td');
        ReactTestUtils.Simulate.click(cell);
        keyDownEvent(SPACE);
        tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(9);
    });

    it('can be filtered with expanded tree', () => {
        const ReactTestUtils = require('react-addons-test-utils');

        const store = createStoreWithMiddleware(combineReducers(reducers));
        store.dispatch(TableActions['setInitialState'](
            tabledata.setIn([FILTER_FIELD, VISIBLE], true).setIn([HEADER, VISIBLE], false)
        ));
        const table = ReactTestUtils.renderIntoDocument(
            <TableContainer store={store}/>
        );
        expect(table).not.toBe(undefined);
        expect(ReactTestUtils.isElement(table));

        const dataTable = ReactTestUtils.findRenderedComponentWithType(table, Table).refs.table;
        let tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(9);

        let treeCells = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableCellTree);
        let treeIcon = ReactTestUtils.findRenderedDOMComponentWithClass(treeCells[0], 'table-cell-icon');
        ReactTestUtils.Simulate.click(treeIcon);
        tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(11);

        treeCells = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableCellTree);
        treeIcon = ReactTestUtils.findRenderedDOMComponentWithClass(treeCells[1], 'table-cell-icon');
        ReactTestUtils.Simulate.click(treeIcon);
        tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(13);

        // filtered row and all parents should be visible ...
        const filterText = ReactTestUtils.findRenderedDOMComponentWithTag(table, 'Input');
        expect(filterText).not.toBe(undefined);
        filterText.value = '1.1.2';
        ReactTestUtils.Simulate.change(filterText);
        tableRows = ReactTestUtils.scryRenderedComponentsWithType(dataTable, TableRow);
        expect(tableRows.length).toBe(3);
    });

    it('will be scrolled after focus', () => {
        const ReactTestUtils = require('react-addons-test-utils');
        const store = createStoreWithMiddleware(combineReducers(reducers));
        let newRows = tabledata.get('rows').merge(
            _.range(10, 100).map(n => ({
                _id: '' + n,
                _assembly: 'Assembly ' + n,
                status: 'offen',
                item: 'Part ' + n
            })));
        store.dispatch(TableActions['setInitialState'](
            tabledata.set('rows', newRows)
        ));
        // Render really into document
        const div = document.createElement('div');
        Object.assign(div.style, {
            position: 'absolute',
            top: '0px',
            bottom: '0px',
            left: '0px',
            right: '0px'
        });
        document.body.appendChild(div);
        const tableContainer = ReactDOM.render(
            <TableContainer store={store}/>
        , div);

        let rowToFocus = newRows.first();
        store.dispatch(TableActions['focus'](newRows.first(), tabledata.get(COLS).first()));

        rowToFocus = newRows.last();
        store.dispatch(TableActions['focus'](rowToFocus, tabledata.get(COLS).first()));
        const table  = ReactTestUtils.findRenderedComponentWithType(tableContainer, Table);
        const row    = ReactTestUtils.scryRenderedComponentsWithType(table.refs.table, TableRow).pop();
        expect(table.props.table.getIn([TABLE, FOCUSED_ROW_ID])).toEqual(rowToFocus.get(ROW_ID));
        expect(table.props.table.getIn([TABLE, FOCUSED_COL_KEY])).toEqual('assembly');
        expect(isInView(table.refs.tableWrapper, row.refs.scrollTarget)).toBe(true);

        ReactDOM.unmountComponentAtNode(div);
    });
});
