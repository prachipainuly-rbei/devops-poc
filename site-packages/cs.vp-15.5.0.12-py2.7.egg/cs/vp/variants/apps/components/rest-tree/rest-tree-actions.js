import Immutable from 'immutable';
import {referencedObjects, fetchRelships as originalFetchRelships} from 'cs-web-components-base';
import {TreeNodeRestDefaultRenderer} from './rest-tree-renderer';
import {actions as treeActionsFactory} from 'cs-vp-tree-component';
import {TreeTools} from 'cs-vp-utils';
export const REST_TREE_SET_CONFIG = 'REST_TREE_SET_CONFIG';

/* helper functions */

const createTreeNode = (id, content, options) => {
    const {
        expanded,
        children,
        has_children,
        additional_content
    } = options;

    const node_children = children ? children : [];
    return Immutable.fromJS({
        id,
        content,
        expanded: expanded !== undefined ? expanded : false,
        children: node_children,
        has_children: has_children !== undefined ? has_children : false,
        additional_content
    });
};

export function generateNodeId(parent_id, obj) {
    return parent_id ? parent_id + ';' + obj.get('@id') : obj.get('@id');
}

const referencedObjectsAsOrderedSet = (state, obj, relshipId) => {
    const referenceResult = referencedObjects(state, obj, relshipId);
    let childrenObjects = Immutable.OrderedSet();
    if (Immutable.OrderedSet.isOrderedSet(referenceResult)) {
        childrenObjects = referenceResult;
    } else {
        // single item ref -> interpret as set
        if (Immutable.Map.isMap(referenceResult)) {
            childrenObjects = childrenObjects.add(referenceResult);
        }
    }
    return childrenObjects;
};

const getMissingReferenceDownRelships = (state, context, ctx) => {
    const configuredEntityRelships =
        ctx['contentReferences'].concat(ctx['additionalContentReferences']);
    const missingRelships = [];
    configuredEntityRelships.forEach(reference => {
        const url = ctx['derivedObject'].getIn([
            'system:relships', 'relships', reference['id']]);
        if (state.relshipsById.get(url) === undefined) {
            missingRelships.push(
                Immutable.Map({
                    'url': url,
                    'viewName': reference['viewName'],
                    'params': reference.hasOwnProperty('useContextParams') ? context : {}
                })
            );
        }
    });
    return missingRelships;
};

const getDerivedContexts = (state, config, obj) => {
    const treeDownReferences =
        config.getIn(['treeDownReferences', obj.get('@type')]) ?
        config.getIn(['treeDownReferences', obj.get('@type')]).toJS() :
        {references: [], additionalContentReferences: []};
    const objCTX = {
        derivedObject: obj,
        additionalContentReferences: treeDownReferences['additionalContentReferences'],
        contentReferences: treeDownReferences['references'],
        additionalKey: undefined
    };
    const derivedContexts = [objCTX];
    objCTX['additionalContentReferences'].forEach(reference => {
        if (obj.getIn(['system:relships', 'relships', reference['id']])) {
            const derivedObject = referencedObjects(state, obj, reference['id']);
            if (Immutable.Map.isMap(derivedObject)) { // ensure a single object is returned
                const contentReferences =
                    config.getIn([
                        'treeDownReferences',
                        derivedObject.get('@type'),
                        'references'
                    ]).toJS();
                const additionalContentReferences =
                    config.getIn([
                        'treeDownReferences',
                        derivedObject.get('@type'),
                        'additionalContentReferences'
                    ]).toJS();
                const ctx = {
                    derivedObject,
                    contentReferences,
                    additionalContentReferences
                };
                ctx['additionalKey'] = reference['id'];
                derivedContexts.push(ctx);
            }
        }
    });
    return derivedContexts;
};

const getReplacedObject = (state, config, parent_id, obj) => {
    const nodeId = generateNodeId(parent_id, obj);
    const replacedObjId = config.getIn(['replacedNodes', nodeId]);
    if (replacedObjId) {
        const replacedObj = state.objectsById.get(replacedObjId.split(';').pop());
        if (replacedObj) {
            return replacedObj;
        }
    }
    return obj; // give not replaced Object back when there is no replacement
};

const createTreeNodeFromObject = (containerId, namespace) => {
    return (state, obj, expanded, parent_id = null) => {
        const config = state[namespace][containerId].get('rest-config');
        const {context} = state[namespace];
        const processedObj = getReplacedObject(state, config, parent_id, obj);
        const nodeId = generateNodeId(parent_id, processedObj);
        const treeChildren = [];
        let _has_children = false;
        const additionalContent = {};
        let notAlreadyLoadedRelships = [];
        const derivedContexts = getDerivedContexts(state, config, processedObj);
        derivedContexts.forEach(ctx => {
            ctx['contentReferences'].forEach(relship => {
                const res = referencedObjectsAsOrderedSet(
                    state, ctx['derivedObject'], relship['id']);
                res.forEach(child => {
                    treeChildren.push(
                        createTreeNodeFromObject(containerId, namespace)(state, child, null, nodeId)
                    );
                });
            });

            if (ctx['derivedObject'].get('system:has_children') !== undefined) {
                if (ctx['derivedObject'].get('system:has_children')) {
                    _has_children = true; // due to backend indicator that there are some children
                    notAlreadyLoadedRelships = notAlreadyLoadedRelships.concat(
                        getMissingReferenceDownRelships(state, context, ctx));
                    if (notAlreadyLoadedRelships.length === 0) {
                        // invalidate backend indicator when all relships are loaded
                        // and indicate no children to prevent endless waiting
                        _has_children = false;
                    }
                } else {
                    // ignore missing children relships when indicated by backend
                    // i.e. not updating notAlreadyLoadedRelships
                }
            } else {
                notAlreadyLoadedRelships = notAlreadyLoadedRelships
                    .concat(getMissingReferenceDownRelships(state, context, ctx));
            }
            if (ctx['additionalKey'] !== undefined) {
                additionalContent[ctx['additionalKey']] = ctx['derivedObject'];
            }
        });
        const has_children = _has_children ? _has_children : (
            notAlreadyLoadedRelships.length > 0 ? true : (treeChildren.length > 0));

        return createTreeNode(
            nodeId,
            processedObj,
            {
                expanded,
                children: notAlreadyLoadedRelships.length === 0 ? treeChildren : [],
                has_children,
                additional_content: additionalContent
            }
        );
    };
};

/* actions */

const _setConfig = containerId => {
    return config => {
        return {
            type: REST_TREE_SET_CONFIG,
            containerId,
            config
        };
    };
};

export function setConfig(containerId, namespace) {
    return function(
        labels,
        rootId,
        treeDownReferences,
        NodeRendererComponent,
        treeContainerId,
        searchBoxVisibility = false,
        searches = null,
        searchBoxSearchId = undefined,
        searchFieldAction = undefined,
        replacedNodes = undefined
    ) {
        return _setConfig(containerId)({
            containerId,
            labels,
            treeDownReferences,
            boundedTreeActions: treeActionsFactory(namespace, treeContainerId),
            treeContainerId,
            NodeRendererComponent,
            rootId,
            searchBoxVisibility,
            searches,
            searchBoxSearchId,
            searchFieldAction,
            replacedNodes: replacedNodes ? Immutable.Map(replacedNodes) : Immutable.Map()
        });
    };
}

export function fetchNodeChildren(containerId, namespace) {
    return node => {
        return (dispatch, getState) => {
            const state = getState();
            const config = state[namespace][containerId].get('rest-config');
            const {context} = state[namespace];
            const nodeContentId = node.getIn(['content', '@id']);
            const parentId = getParentId(node.get('id'));
            const obj = state.objectsById.get(nodeContentId);
            if (obj) {
                let missingRelships = [];
                getDerivedContexts(state, config, obj).forEach(ctx => {
                    missingRelships = missingRelships.concat(
                        getMissingReferenceDownRelships(state, context, ctx));
                });

                const notAlreadyFetchingRelships = missingRelships.filter(
                    relship => (
                        state.fetchingById.get(relship.get('url')) ? false : true
                    )
                ).map(relship => relship.toJS());
                const updateTreeNodeAction =
                    updateTreeNode(containerId, namespace)(obj, node, parentId);
                if (notAlreadyFetchingRelships.length > 0) {
                    // fetch tree children + update tree node afterwards
                    dispatch(fetchRelships(notAlreadyFetchingRelships))
                        .then(() => dispatch(updateTreeNodeAction));
                } else {
                    dispatch(updateTreeNodeAction);
                }
            }
        };
    };
}

export function updateTreeNode(containerId, namespace) {
    return (obj, node, parentId, expanded) => {
        return (dispatch, getState) => {
            const state = getState();
            const config = state[namespace][containerId].get('rest-config');
            const nodeExpandState = expanded === undefined ? node.get('expanded') : expanded;
            const treeNode = createTreeNodeFromObject(containerId, namespace)(
                    state, obj, nodeExpandState, parentId);
            dispatch(config.get('boundedTreeActions').updateTreeNode(treeNode));
        };
    };
}


const findNode = (rootNode, matcher) => {
    const gen = TreeTools.walkTopDownDepthFirst(rootNode);
    for (const node of gen) {
        if (matcher(node)) {
            return node;
        }
    }
    return undefined;
};

const getNodeById = (rootNode, nodeId) => {
    return findNode(rootNode, node => node.get('id') === nodeId);
};

export function getParentId(nodeId, delimiter = ';') {
    const idSegments = nodeId.split(delimiter);
    if (idSegments.length > 1) {
        return idSegments.slice(0, idSegments.length - 1).join(delimiter);
    } else {
        return '';
    }
}

const generateNode = (containerId, namespace) => {
    return (state, oldNode, obj, expanded) => {
        const parentId = getParentId(oldNode.get('id'));
        const nodeExpandState =
            expanded === undefined ? (oldNode ? oldNode.get('expanded') : false) : expanded;
        const treeNode =
            createTreeNodeFromObject(containerId, namespace)(state, obj, nodeExpandState, parentId);
        return treeNode;
    };
};

export function updateTreeNodeById(containerId, namespace) {
    return (treeContainerId, nodeId, obj, expanded) => {
        return (dispatch, getState) => {
            const state = getState();
            const config = state[namespace][containerId].get('rest-config');
            const rootNode = state[namespace][treeContainerId].get('node');
            const node = getNodeById(rootNode, nodeId);
            const treeNode =
                generateNode(containerId, namespace, treeContainerId)(state, node, obj, expanded);
            dispatch(config.get('boundedTreeActions').updateTreeNode(treeNode, nodeId));
        };
    };
}

export function setReplacedNodeById(containerId, namespace) {
    return (treeContainerId, nodeId, obj) => {
        return (dispatch, getState) => {
            const state = getState();
            const config = state[namespace][containerId].get('rest-config');
            const parentId = getParentId(nodeId);
            const newId = generateNodeId(parentId, obj);
            const newConfig = config.setIn(['replacedNodes', nodeId], newId);
            dispatch(_setConfig(containerId)(newConfig));
            dispatch(
                updateTreeNodeById(containerId, namespace)(
                    treeContainerId, parentId,
                    state.objectsById.get(parentId.split(';').slice(-1)[0]))
                );
        };
    };
}

export function resetReplacedNodeById(containerId, namespace) {
    return (treeContainerId, nodeId) => {
        return (dispatch, getState) => {
            const state = getState();
            const config = state[namespace][containerId].get('rest-config');
            const parentId = getParentId(nodeId);
            const oldNodeId = config.getIn(['replacedNodes', nodeId]);
            if (oldNodeId) {
                const newConfig = config.deleteIn(['replacedNodes', nodeId]);
                dispatch(_setConfig(containerId)(newConfig));
                dispatch(updateTreeNodeById(containerId, namespace)(treeContainerId,
                    parentId, state.objectsById.get(parentId.split(';').slice(-1)[0])));
            }
        };
    };
}

export function buildTree(containerId, namespace) {
    return () => {
        return (dispatch, getState) => {
            const state = getState();
            const config = state[namespace][containerId].get('rest-config');
            const {
                rootId, searchBoxVisibility, searches,
                searchBoxSearchId, searchFieldAction
            } = config.toJS();
            const searchDict = searches ? searches : {};
            let tree = Immutable.fromJS({
                NodeRendererComponent: config.get('NodeRendererComponent') ?
                    config.get('NodeRendererComponent') : TreeNodeRestDefaultRenderer,
                fetchNodeChildren: node => {
                    dispatch(fetchNodeChildren(containerId, namespace)(node));
                },
                node: Immutable.fromJS({}),
                searchField: {
                    placeholder: config.getIn(['labels', 'cdbvp_variants_web_search_placeholder']),
                    visible: searchBoxVisibility,
                    searchId: searchBoxSearchId,
                    searchAction: searchFieldAction
                },
                searches: searchDict
            });

            const root = state.objectsById.get(rootId);
            if (root !== undefined) {
                tree = tree.set('node',
                    createTreeNodeFromObject(containerId, namespace)(state, root));
            } else {
                //console.log('missing root object for id ',rootId);
            }
            dispatch(config.get('boundedTreeActions').setInitialTreeState(tree));
        };
    };
}

// Fake actions from cs-web-components-base because they are not exported
const RECEIVED_RELSHIP_1 = 'cs-web-components-base-RECEIVED_RELSHIP_1';

function receivedRelship1(url, target) {
    return {
        type: RECEIVED_RELSHIP_1,
        payload: target,
        meta: {url: url}
    };
}

const RECEIVED_RELSHIP_N = 'cs-web-components-base-RECEIVED_RELSHIP_N';

function receivedRelshipN(url, targets) {
    return {
        type: RECEIVED_RELSHIP_N,
        payload: targets,
        meta: {url: url}
    };
}

const RECEIVED_OBJECT = 'cs-web-components-base-RECEIVED_OBJECT';

export function receivedObject(url, object) {
    return {
        type: RECEIVED_OBJECT,
        payload: object,
        meta: {url: url}
    };
}

export function receivedRelship(relship) {
    return dispatch => {
        if (relship.hasOwnProperty('targets')) {
            dispatch(receivedRelshipN(relship['@id'], relship.targets));
            relship.targets.forEach(target => {
                if (target.hasOwnProperty('@id')) {
                    dispatch(receivedObject(target['@id'], target));
                    if (target.hasOwnProperty('system:resolved_relships')) {
                        target['system:resolved_relships'].forEach(resolved_relship => {
                            dispatch(receivedRelship(resolved_relship));
                        });
                    }
                }
            });
        } else {
            dispatch(receivedRelship1(relship['@id'], relship.target));
            if (relship.target) {
                if (relship.target.hasOwnProperty('@id')) {
                    dispatch(receivedObject(relship.target['@id'], relship.target));
                }
                if (relship.target.hasOwnProperty('system:resolved_relships')) {
                    relship.target['system:resolved_relships'].forEach(resolved_relship => {
                        dispatch(receivedRelship(resolved_relship));
                    });
                }
            }
        }
    };
}

function fetchRelships(relships) {
    return dispatch =>
        dispatch(originalFetchRelships(relships))
            .then(result => dispatch(receivedRelship(result)));
}
