import Immutable from 'immutable';
import {TreeTools} from 'cs-vp-utils';

import {
    EXPAND_TREE_NODE,
    TOGGLE_TREE_NODE, SELECT_TREE_NODE,
    SET_SEARCH_RESULT, SET_INITIAL_TREE_STATE,
    SET_NAVIGATED_TREE_NODE,
    UPDATE_TREE_NODE
} from './tree-actions';


/*
 * Help Functions
 */

const visitAndUpdate = (state, callback, visitor = TreeTools.visitTopDownDepthFirst) => {
    return state.set('node', visitor(state.get('node'), callback));
};


/*
 * Reducers
 */


const toggleTreeNode = (state, action) => {
    const toggleNode = (id, state) => {
        return visitAndUpdate(state, node => {
            if (node.get('id') === id) {
                const expanded = node.get('expanded');
                return node.set('expanded', !expanded);
            } else {
                return node;
            }
        });
    };

    switch (action.type) {
        case TOGGLE_TREE_NODE:
            return toggleNode(action.id, state);
        default:
            return state;
    }
};


const updateTreeNode = (state, action) => {
    const updateNode = (newNode, state) => {
        const id = action.id ? action.id : newNode.get('id');
        return visitAndUpdate(state, node => {
            if (node.get('id') === id) {
                return newNode;
            } else {
                return node;
            }
        });
    };
    switch (action.type) {
        case UPDATE_TREE_NODE:
            return updateNode(action.node, state);
        default:
            return state;
    }
};


const selectTreeNode = (state, action) => {
    // help function: selects the node with id === state.get('selectedId')
    const select = state => {
        const selection_class = 'user-selected-tree-node';
        return visitAndUpdate(state, node => {
            const selection_matching_classes =
                node.get('selection_matching_classes') ?
                node.get('selection_matching_classes') : Immutable.List();

            if (node.get('id') === state.get('selectedId')) {
                return node.set('selection_matching_classes',
                    selection_matching_classes.push(selection_class));
            } else {
                return node.set('selection_matching_classes',
                    selection_matching_classes.filter(x => x !== selection_class));
            }
        });
    };

    switch (action.type) {
        case SELECT_TREE_NODE:
            return select(state.set('selectedId', action.id));
        default:
            return state;
    }
};


const expandTreeNode = (state, action) => {
    switch (action.type) {
        case EXPAND_TREE_NODE: {
            const visit = match => node => {
                let immutableNode = node;

                const visitChildren = node.get('children').map(visit(match));
                immutableNode = immutableNode.set('children',
                    visitChildren.map(child => child.node));

                const expand = match(immutableNode) ||
                    visitChildren.some(child => child.expand);
                if (expand) {
                    immutableNode = immutableNode.set('expanded', true);
                }

                return {expand, node: immutableNode};
            };

            const {node} =
                visit(node => (node.get('id') === action.id))(state.get('node'));

            return state.set('node', node);
        }
        default:
            return state;
    }
};


const setNavigatedTreeNodeIdx = (state, action) => {
    switch (action.type) {
        case SET_NAVIGATED_TREE_NODE:
            return state.setIn([
                'searches', action.searchId, 'navigatedIdx'],
                action.navigatedIdx
            );
        default:
            return state;
    }
};


const searchTree = (state, action) => {
    let newState = state;
    switch (action.type) {
        case SET_SEARCH_RESULT: {
            if (newState.getIn(['searches', action.search]) !== undefined) {
                // Add new search to the state if given
                newState = newState.setIn(['searches', action.searchId], action.search);
            }
            if (
                newState.getIn(['searches', action.searchId, 'searchCondition']) !==
                action.searchCondition
            ) {
                // search condition changed -> reset navigatedIdx;
                newState = newState.setIn(['searches', action.searchId, 'navigatedIdx'], 0);
            }
            newState = newState.setIn(
                ['searches', action.searchId, 'searchCondition'], action.searchCondition);
            newState = newState.setIn(
                ['searches', action.searchId, 'resultCnt'],
                action.resultCnt ? action.resultCnt : 0
            );
            newState = newState.setIn(
                ['searches', action.searchId, 'matchedNodeIds'],
                action.matchedNodeIds ? action.matchedNodeIds : []
            );
            newState = newState.setIn(
                ['searches', action.searchId, 'idFieldPathList'],
                action.idFieldPathList ? action.idFieldPathList : ['id']
            );
            return newState;
        }
        default:
            return newState;
    }
};

const initialState = Immutable.fromJS({
    node: Immutable.fromJS({
    }),
    searchField: {
        placeholder: '',
        searchId: undefined,
        searchAction: undefined
    },
    searches: {
    },
    NodeRendererComponent: undefined,
    fetchNodeChildren: undefined
});

const setInitialState = (state, action) => {
    switch (action.type) {
        case SET_INITIAL_TREE_STATE:
            return action.state;
        default:
            return state;
    }
};


const chainReducers = (...reducers) => reducers.reduce(
    (lhs, rhs) => (
        (state, action) => {
            return rhs(lhs(state, action), action);
        }
    ),
    function(state = Immutable.Map()) {
        return state;
    }
);

const __reducer__ = chainReducers(
    updateTreeNode,
    toggleTreeNode,
    selectTreeNode,
    searchTree,
    expandTreeNode,
    setNavigatedTreeNodeIdx,
    setInitialState
);


export default function(containerId) {
    return (state, action) => {
        if (containerId === action.containerId) {
            return __reducer__(state, action);
        } else {
            return state === undefined ? initialState : state;
        }
    };
}
