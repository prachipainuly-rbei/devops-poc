import Immutable from 'immutable';

import {TreeTools} from 'cs-vp-utils';

export const EXPAND_TREE_NODE = 'EXPAND_TREE_NODE';
export const SET_NAVIGATED_TREE_NODE = 'SET_NAVIGATED_TREE_NODE';
export const TOGGLE_TREE_NODE = 'TOGGLE_TREE_NODE';
export const SELECT_TREE_NODE = 'SELECT_TREE_NODE';
export const ACTIVE_KEYS = 'ACTIVE_KEYS';
export const SEARCH_TREE = 'SEARCH_TREE';
export const SET_SEARCH_RESULT = 'SET_SEARCH_RESULT';
export const SET_INITIAL_TREE_STATE = 'SET_INITIAL_TREE_STATE';
export const UPDATE_TREE_NODE = 'UPDATE_TREE_NODE';

/*
 * action factories take containerId and return
   specific action for specific containerInstance
 */
export function toggleTreeNode(containerId) {
    return (id) => {
        return {
            type: TOGGLE_TREE_NODE,
            id,
            containerId
        };
    };
}

export function updateTreeNode(containerId) {
    return (node, id) => {
        return {
            type: UPDATE_TREE_NODE,
            id,
            node,
            containerId
        };
    };
}

export function selectTreeNode(containerId) {
    return (node, callback) => {
        return selectTreeNodeById(containerId)(node.get('id'), node.get('content'), callback);
    };
}

export function selectTreeNodeById(containerId) {
    return (id, content, callback) => dispatch => {
        if (callback !== undefined) {
            callback(id);
        }

        dispatch({
            type: SELECT_TREE_NODE,
            id: id,
            content: content,
            containerId
        });
    };
}

export function expandTreeNode(containerId) {
    return (id) => {
        return {
            type: EXPAND_TREE_NODE,
            id,
            containerId
        };
    };
}

export function navigateTreeNode(containerId, namespace) {
    return (searchId, navigatedIdx, callback) => {
        return (dispatch, getState) => {
            const state = getState()[namespace][containerId];
            const search = state.getIn(['searches', searchId]);
            if (search.get('resultCnt') > 0) { // do not try to navigate when no results are available
                const getNodeBySearchIdx = () => {
                    const gen = TreeTools.walkTopDownDepthFirst(state.get('node'));
                    let searchMatchingIdx = 0;
                    for (const child of gen) {
                        if (search.get('match')(child, search.get('searchCondition'))) {
                            if (searchMatchingIdx === navigatedIdx) {
                                return child;
                            }
                            searchMatchingIdx++;
                        }
                    }
                    return undefined;
                };
                const nodeForIdx = getNodeBySearchIdx();
                const nodeForIdxId = nodeForIdx ? nodeForIdx.get('id') : undefined;
                const getParent = () => {
                    const _getParent = (node) => {
                        for (const child of node.get('children').toArray()) {
                            if (child.get('id') === nodeForIdxId) {
                                return node;
                            }
                        }

                        let parent;
                        for (const child of node.get('children').toArray()) {
                            parent = _getParent(child);
                            if (parent !== undefined) {
                                return parent;
                            }
                        }

                        return undefined;
                    };

                    return _getParent(state.get('node'));
                };
                const parent = getParent();
                if (nodeForIdxId) {
                    if (parent) {
                        dispatch(expandTreeNode(containerId)(parent.get('id')));
                    }
                    dispatch(setNavigatedTreeNodeIdx(containerId)(searchId, navigatedIdx));
                    dispatch(selectTreeNode(containerId)(nodeForIdx, callback));
                }
            }
        };
    };
}

export function setNavigatedTreeNodeIdx(containerId) {
    return (searchId, navigatedIdx) => {
        return {
            type: SET_NAVIGATED_TREE_NODE,
            searchId,
            navigatedIdx,
            containerId
        };
    };
}

export function searchTree(containerId, namespace) {
    return (searchCondition, searchId, search, idFieldPath) => {
        const idFieldPathList = idFieldPath ? idFieldPath : ['id'];
        return (dispatch, getState) => {
            const state = getState()[namespace][containerId];
            const search = state.getIn(['searches', searchId]);
            const getMatchingNodeIds = () => {
                const gen = TreeTools.walkTopDownDepthFirst(state.get('node'));
                const matches = [];
                for (const child of gen) {
                    if (search.get('match')(child, searchCondition)) {
                        matches.push(child.getIn(idFieldPathList));
                    }
                }
                return matches;
            };
            const matchedNodeIds = getMatchingNodeIds();
            dispatch(setSearchResult(containerId, namespace)(searchCondition, searchId, search,
                                                  matchedNodeIds, idFieldPathList));
            return matchedNodeIds;
        };
    };
}

const _setSearchResult = (containerId) => {
    return (searchCondition, searchId, search, matchedNodeIds, idFieldPathList, resultCount) => {
        return {
            type: SET_SEARCH_RESULT,
            searchId: searchId,
            searchCondition: searchCondition,
            search: search,
            matchedNodeIds: matchedNodeIds,
            idFieldPathList: idFieldPathList,
            resultCnt: resultCount,
            containerId: containerId
        };
    };
};

export function setSearchResult(containerId, namespace) {
    return (searchCondition, searchId, search, matchedNodeIds, idFieldPath, resultCnt) => {
        const idFieldPathList = idFieldPath ? idFieldPath : ['id'];
        const resultCount = resultCnt ? resultCnt : (matchedNodeIds ? matchedNodeIds.length : 0);
        return (dispatch) => {
            if (searchId !== undefined) {
                dispatch(_setSearchResult(containerId)(searchCondition,
                                                       searchId,
                                                       search,
                                                       matchedNodeIds,
                                                       idFieldPathList,
                                                       resultCount));
                dispatch(navigateTreeNode(containerId, namespace)(searchId, 0));
            }
        };
    };
}

export function setInitialTreeState(containerId) {
    return (state) => {
        return {
            type: SET_INITIAL_TREE_STATE,
            state,
            containerId
        };
    };
}

export function activateKey(containerId) {
    return (key, rootNode, selectedId, callback) => {
        // get the selected node with its previous and next visible nodes
        const getSelected = () => {
            // iterate only on visible nodes
            const iterate = node =>
                (node.get('expanded') ? node.get('children') : Immutable.List());
            const gen = TreeTools.walkTopDownDepthFirstCustom(iterate)(rootNode);

            let previous, selected, next;
            for (const child of gen) {
                if (child.get('id') === selectedId) {
                    selected = child;
                    next = gen.next().value;
                    break;
                }
                previous = child;
            }

            return {
                previous,
                selected,
                next
            };
        };

        const getParent = () => {
            const _getParent = (node) => {
                for (const child of node.get('children')) {
                    if (child.get('id') === selectedId) {
                        return node;
                    }
                }

                let parent;
                for (const child of node.get('children')) {
                    parent = _getParent(child);
                    if (parent !== undefined) {
                        return parent;
                    }
                }

                return undefined;
            };

            return _getParent(rootNode);
        };

        return dispatch => {
            const {previous, selected, next} = getSelected();

            switch (key) {
                // Up and down arrow keys move between visible nodes
                case 'down':
                    if (next) {
                        dispatch(selectTreeNode(containerId)(next, callback));
                    }
                    break;
                case 'up':
                    if (previous) {
                        dispatch(selectTreeNode(containerId)(previous, callback));
                    }
                    break;
                case 'left':
                    if (selected) {
                        if (selected.get('expanded')) {
                            // Left arrow key on an expanded node closes the node
                            dispatch(toggleTreeNode(containerId)(selectedId));
                        } else {
                            // Left arrow key on a closed or end node moves focus to the node's parent
                            const parent = getParent();
                            if (parent) {
                                dispatch(selectTreeNode(containerId)(parent, callback));
                            }
                        }
                    }
                    break;
                case 'right':
                    if (selected) {
                        if (selected.get('expanded')) {
                            // Right arrow key moves to the first child of an open node
                            const children = selected.get('children');
                            if (children && children.size > 0) {
                                dispatch(selectTreeNode(containerId)(children.get(0), callback));
                            }
                        } else {
                            // expands a closed node
                            dispatch(toggleTreeNode(containerId)(selectedId));
                        }
                        // or does nothing on an end node
                    }
                    break;
            }
        };
    };
}
