// jshint esversion:6
require('./components.css');

import React from 'react';
import PropTypes from 'prop-types';
import {
    Glyphicon,
    FormGroup,
    InputGroup,
    FormControl
} from 'react-bootstrap';
import {ImmutablePropTypes} from 'cs-web-components-externals';
import key from 'keymaster';
import jQuery from 'jquery';
import {scrollIntoViewIfNeeded} from 'cs-vp-utils';

export class TreeNodeDefaultRenderer extends React.Component {
    render() {
        return (
            <div className="tree-node-renderer">
                {this.props.node.get('content')}
            </div>
        );
    }
}

TreeNodeDefaultRenderer.propTypes = {
    node: ImmutablePropTypes.map.isRequired
};

TreeNodeDefaultRenderer.defaultProps = {
    keys: {
    }
};

export class TreeContainerSearchBox extends React.Component {
    updateSearchResult(e) {
        e.preventDefault();
        const search = this.props.tree.get('searchField');
        const value = this.search_field.value;
        if (search.get('searchAction')) {
            search.get('searchAction')(value,
                                       search.get('searchId'));
        } else {
            this.props.searchTree(value,
                search.get('searchId'), search, search.get('idFieldPathList'));
        }
    }
    render() {
        const search = this.props.tree.get('searchField');
        const searchIcon = <span className="icon-search"/>;
        return (
            <form
                className="tree-search-form"
                onSubmit={this.updateSearchResult.bind(this)}
            >
                <FormGroup>
                    <InputGroup>
                        <FormControl className="tree-search-text" type="text"
                            {...search.toJS()}
                            inputRef={search_field => this.search_field = search_field}
                            tabIndex={this.props.tabIndex}
                        />
                        <InputGroup.Addon>{searchIcon}</InputGroup.Addon>
                    </InputGroup>
                </FormGroup>
            </form>
        );
    }
}

TreeContainerSearchBox.propTypes = {
    searchTree: PropTypes.func.isRequired,
    tabIndex: PropTypes.number.isRequired,
    tree: ImmutablePropTypes.map.isRequired
};


export class TreeContainerNavigation extends React.Component {
    navigatePrevious() {
        const {
            navigateTreeNode, navigatedIdx,
            resultCnt, searchId, onSelection
        } = this.props;

        let newIndex = 0;
        if (navigatedIdx !== undefined && resultCnt > 0) {
            newIndex = navigatedIdx > 0 ? navigatedIdx - 1 : resultCnt - 1;
        }
        navigateTreeNode(searchId, newIndex, onSelection);
    }
    navigateNext() {
        const {
            navigateTreeNode, navigatedIdx,
            resultCnt, searchId, onSelection
        } = this.props;

        let newIndex = 0;
        if (navigatedIdx !== undefined && resultCnt > 0) {
            newIndex = navigatedIdx < (resultCnt - 1) ? navigatedIdx + 1 : 0;
        }
        navigateTreeNode(searchId, newIndex, onSelection);
    }
    render() {
        // work on indexes - show position (+1)
        let position = this.props.navigatedIdx;
        if (
            position !== undefined &&
            this.props.resultCnt !== undefined &&
            this.props.resultCnt > 0 &&
            position >= 0
        ) {
            position++;
        }
        const positionStr = position + '/' + this.props.resultCnt;
        const navigationCSSClasses = this.props.navigationCSSClasses ?
            'tree-navigation ' + this.props.navigationCSSClasses : 'tree-navigation';
        return (
            <div className={navigationCSSClasses}>
                <Glyphicon
                    glyph={'chevron-left'}
                    onClick={this.navigatePrevious.bind(this)}
                />
                {positionStr}
                <Glyphicon
                    glyph={'chevron-right'}
                    onClick={this.navigateNext.bind(this)}
                />
            </div>
        );
    }
}

TreeContainerNavigation.propTypes = {
    navigateTreeNode: PropTypes.func.isRequired,
    navigatedIdx: PropTypes.number,
    navigationCSSClasses: PropTypes.string,
    onSelection: PropTypes.function,
    resultCnt: PropTypes.number,
    searchId: PropTypes.string.isRequired,
    tree: ImmutablePropTypes.map.isRequired
};

TreeContainerNavigation.defaultProps = {
    resultCnt: 0,
    navigatedIdx: 0
};


export class TreeContainer extends React.Component {
    scrollToNode(element) {
        return scrollIntoViewIfNeeded(this.scrollContainer)(element);
    }

    componentDidMount() {
        // Register key bindings
        const activeKeys = ['left', 'up', 'right', 'down'];

        const keyHandler = key => (event) => {
            const {activateKey, hasFocus, tree} = this.props;
            const target = jQuery(event.target);
            if (hasFocus) {
                if (
                    this.props.keyBlacklistSelector === undefined ||
                    !target.is(this.props.keyBlacklistSelector)
                ) {
                    activateKey(key, tree.get('node'), tree.get('selectedId'));
                }
            }
            // prevent browser from scrolling
            event.preventDefault();
        };

        for (const shortCut of activeKeys) {
            key(shortCut, keyHandler(shortCut));
        }
        if (this.props.hasOwnProperty('initTree')) {
            this.props.setInitialTreeState(this.props.initTree);
        }
    }

    render() {
        const searchNavigations = [];
        for (const search of this.props.tree.get('searches').entrySeq().toArray()) {
            const [key, val] = search;

            if (val.get('resultCnt') > 0) {
                searchNavigations.push(
                    <TreeContainerNavigation
                        key={key}
                        navigateTreeNode={this.props.navigateTreeNode}
                        navigatedIdx={val.get('navigatedIdx')}
                        navigationCSSClasses={val.get('navigationCSSClasses')}
                        onSelection={this.props.onSelection}
                        resultCnt={val.get('resultCnt')}
                        searchId={key}
                        tree={this.props.tree}
                    />);
            }
        }

        const search = this.props.tree.get('searchField');
        const searchBox = (search.get('visible')) ? (
            <div className="tree-search">
                <TreeContainerSearchBox {...this.props} tabIndex={this.props.tabIndex + 1} />
            </div>
        ) : undefined;
        const searchNavigation = (search.get('visible')) ? (
            <div className="tree-navigations">
                {searchNavigations}
            </div>
        ) : undefined;

        let treeClassName = 'tree';
        if (search.get('visible')) {
            if (search.get('label')) {
                treeClassName = 'tree-with-search-and-label';
            }
            else {
                treeClassName = 'tree-with-search';
            }
        }

        return (
            <div
                className={
                    this.props.className + ' tree-container' +
                    (this.props.hasFocus ? ' focus' : '')
                }
            >
                {searchBox}
                {searchNavigation}
                <div className={treeClassName} ref={scrollContainer => this.scrollContainer = scrollContainer}>
                    <TreeNode {...this.props}
                        node={this.props.tree.get('node')}
                        scrollToNode={this.scrollToNode.bind(this)}
                        tabIndex={this.props.tabIndex + 2}
                    />
                </div>
            </div>
        );
    }
}

TreeContainer.propTypes = {
    activateKey: PropTypes.function,
    className: PropTypes.string,
    focusId: PropTypes.number,
    hasFocus: PropTypes.bool,
    initTree: PropTypes.object,
    keyBlacklistSelector: PropTypes.string,
    navigateTreeNode: PropTypes.function,
    onSelection: PropTypes.function,
    setInitialTreeState: PropTypes.function,
    tabIndex: PropTypes.number,
    tree: ImmutablePropTypes.map.isRequired
};

TreeContainer.defaultProps = {
    className: '',
    hasFocus: true
};


export class TreeNode extends React.Component {
    _ifSelectedScrollToMe() {
        const {scrollToNode} = this.props;

        if (this.selected()) {
            scrollToNode(this.scrollTarget);
        }
    }

    selected() {
        const {node, tree} = this.props;
        return tree.get('selectedId') === node.get('id');
    }

    toggleTreeNode() {
        this.props.toggleTreeNode(this.props.node.get('id'));
    }

    selectTreeNode() {
        const {selectTreeNode, node, onSelection} = this.props;
        selectTreeNode(node, onSelection);
    }

    componentWillReceiveProps(nextProps) {
        const current_node = this.props.node;
        const next_node = nextProps.node;

        if (
            !current_node.get('expanded') &&
            next_node.get('expanded') &&
            next_node.get('children').size === 0 &&
            next_node.get('has_children')
        ) {
            this.props.tree.get('fetchNodeChildren')(next_node);
        }
    }

    componentDidMount() {
        this._ifSelectedScrollToMe();
    }

    componentDidUpdate() {
        this._ifSelectedScrollToMe();
    }

    render() {
        const {node} = this.props;
        const children = node.get('children');
        const expanded = node.get('expanded');
        const has_children = node.get('has_children');

        const treeIcon = (
            <div
                className="tree-icon"
                onClick={this.toggleTreeNode.bind(this)}
            >
                {
                    has_children ?
                        <Glyphicon glyph={expanded ? 'chevron-down' : 'chevron-right'}/> :
                        undefined
                }
            </div>
        );

        const contentClasses = ['tree-content'];
        this.props.tree.get('searches').forEach(search => {
            const nodeId = node.getIn(search.get('idFieldPathList'));
            if (search.get('matchedNodeIds').indexOf(nodeId) !== -1) {
                Array.prototype.push.apply(contentClasses,
                                           [search.get('cssclass')]);
            }
        });

        if (node.get('selection_matching_classes')) {
            Array.prototype.push.apply(contentClasses,
                node.get('selection_matching_classes').toArray());
        }

        const customRenderer = this.props.tree.get('NodeRendererComponent');
        const treeNodeRenderer = (customRenderer)
            ? customRenderer
            : TreeNodeDefaultRenderer;


        const loading = (
            node.get('expanded') &&
            node.get('has_children') &&
            node.get('children').size === 0
        );
        const child_rendering = (node.get('expanded')) ? children.map(child =>
            <TreeNode {...this.props} key={child.get('id')}
                node={child}
                tabIndex={undefined}
            />) : undefined;

        const loader = (<div className="waiting-with-endless-loader">&nbsp;</div>);

        return (
            <div className="tree-node" tabIndex={this.props.tabIndex}>
                <div ref={scrollTarget => this.scrollTarget = scrollTarget}>
                    {treeIcon}
                    <div aria-expanded={expanded}
                        className={contentClasses.join(' ')}
                        onClick={this.selectTreeNode.bind(this)}
                    >
                        {React.createElement(treeNodeRenderer, this.props)}
                    </div>
                </div>
                <div className="tree-subtree">
                    {loading ? loader : child_rendering}
                </div>
            </div>
        );
    }
}

TreeNode.propTypes = {
    NodeRendererComponent: PropTypes.instanceOf(React.component).isOptional,
    keys: PropTypes.object.isRequired,
    node: ImmutablePropTypes.map.isRequired,
    onSelection: PropTypes.function,
    scrollToNode: PropTypes.function,
    selectTreeNode: PropTypes.func.isRequired,
    tabIndex: PropTypes.number,
    toggleTreeNode: PropTypes.func.isRequired,
    tree: ImmutablePropTypes.map.isRequired
};

TreeNode.defaultProps = {
    keys: {
        'activeKeys': [],
        'tabIndex': -1
    }
};
