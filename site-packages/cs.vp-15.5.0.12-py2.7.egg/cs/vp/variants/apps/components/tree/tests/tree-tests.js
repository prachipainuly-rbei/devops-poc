/*
 * Copyright (C) 2016 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: tree-tests.js 164057 2017-08-28 11:55:14Z gda $"
 */

 // jshint esversion:6

import React from 'react';
import ReactDOM from 'react-dom';
import Immutable from 'immutable';
import TestUtils from 'react-addons-test-utils';
import { createStore, combineReducers, applyMiddleware }  from 'redux';
import { Provider } from 'cs-web-components-externals';
import thunk                                              from 'redux-thunk';

import containerFactory, {
    actions as actionsFactory,
    reducer as reducerFactory
} from '../index';

import { TreeNode, TreeContainerSearchBox, TreeContainer as TreeComponent } from '../tree-components';
import { TreeTools, isInView } from '../../utils'


const CURSOR_LEFT = 37;
const CURSOR_UP = 38;
const CURSOR_RIGHT = 39;
const CURSOR_DOWN = 40;

// workaround for key events as ReactTestUtils.Simulate does not work together with keymaster
function keyDownEvent(keyCode) {
    let event = document.createEvent('Event');
    event.keyCode = keyCode;
    event.initEvent('keydown');
    document.dispatchEvent(event);
}


const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);

const buildTree = rules => depth => {
    let nodeId = 1;
    const makeNode = depth => n => {
        const node = Immutable.Map({
            id: n,
            content: n,
            expanded: false,
            has_children: depth > 0,
        });
        nodeId += 1;
        return makeChildren(depth)(node);
    };

    const makeChildren = depth => node => {
        const children = depth > 0 ?
            rules.map(rule => makeNode(depth-1)(rule(node.get('content')))) :
            Immutable.List();
        return node.set('children', children);
    }

    const rootId = 2;
    const root = makeNode(depth)(rootId);

    return root.set('expanded', true);
};

const tree = buildTree(Immutable.List([
    n => 2*n,
    n => 3*n,
    n => 5*n,
]))(5);

const initialState = Immutable.fromJS({
    node: tree,
    searchField: {
        label: 'Suche',
        placeholder: 'Bitte Suchbegriff eingeben',
        visible: true,
        searchId: 'simple-text-search'
    },
    searches: {
        'simple-text-search': {
            cssclass: 'simple-search-match',
            match: (node, search) => {
                if (search !== '' && node.get('content').toString().indexOf(search) != -1) {
                    return true;
                } else {
                    return false;
                }
            },
            resultCnt: 0,
            navigatedIdx: 0,
            navigationCSSClass: 'simple-search-navigated',
            matchedNodeIds: [],
            idFieldPathList: ['id']
        }
    }
});

const TreeContainerId = 'tree-tests';
const TreeContainer = containerFactory(TreeContainerId);
const TreeActions = actionsFactory(TreeContainerId);


describe('the tree component', () => {
    beforeEach(function () {
        // set tree and initial state
        let reducers = {};
        reducers[TreeContainerId] = reducerFactory(TreeContainerId);
        this.store = createStoreWithMiddleware(combineReducers(reducers));

        this.store.dispatch(TreeActions['setInitialTreeState'](initialState));

        // Render really into document
        this.renderDiv = document.createElement('div');
        Object.assign(this.renderDiv.style, {
            position: 'absolute',
            top: '0px',
            bottom: '0px',
            left: '0px',
            right: '0px',
        });
        document.body.appendChild(this.renderDiv);
        this.TreeContainer = ReactDOM.render(
            <TreeContainer store={this.store}/>,
        this.renderDiv);
    });

    afterEach(function() {
        ReactDOM.unmountComponentAtNode(this.renderDiv);
    });

    it('will collapse an expanded node if the toggler icon is clicked', function() {
        const node = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode)[0];
        expect(node.props.node.get('id')).toBe(2);
        expect(node.props.node.get('expanded')).toBe(true);
        TestUtils.Simulate.click(node.refs.treeIcon);

        const nodes = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode);
        expect(nodes.length).toBe(1);
        expect(node.props.node.get('expanded')).toBe(false);
    });

    it('will expand a collapsed node if the toggler icon is clicked', function() {
        const node = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode)[1];
        expect(node.props.node.get('id')).toBe(4);
        expect(node.props.node.get('expanded')).toBe(false);
        TestUtils.Simulate.click(node.refs.treeIcon);

        const nodes = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode);
        expect(nodes.length).toBe(7);
        expect(node.props.node.get('expanded')).toBe(true);
    });

    it('will select a node if the user clicks on it', function() {
        const node = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode)[0];
        expect(node.props.tree.get('selectedId')).not.toBe(node.props.node.get('id'));
        TestUtils.Simulate.click(node.refs.contentDiv);
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));
    });

    it('will select the next node if the user hit the ↓ key', function() {
        const nodes = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode);

        let node = nodes[0];
        TestUtils.Simulate.click(node.refs.contentDiv);
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));

        keyDownEvent(CURSOR_DOWN);
        node = nodes[1];
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));
    });

    it('will select the previous node if the user hit the ↑ key', function() {
        const nodes = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode);

        let node = nodes[1];
        TestUtils.Simulate.click(node.refs.contentDiv);
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));

        keyDownEvent(CURSOR_UP);
        node = nodes[0];
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));
    });

    it('will select the first child if the user hit the → key on an expanded node', function() {
        const nodes = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode);

        let node = nodes[0];
        expect(node.props.node.get('expanded')).toBe(true);
        TestUtils.Simulate.click(node.refs.contentDiv);
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));

        keyDownEvent(CURSOR_RIGHT);
        node = nodes[1];
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));
    });

    it('will expand the node if the user hit the → key on a collapsed node', function() {
        const nodes = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode);

        let node = nodes[1];
        expect(node.props.node.get('expanded')).toBe(false);
        TestUtils.Simulate.click(node.refs.contentDiv);
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));

        keyDownEvent(CURSOR_RIGHT);
        expect(node.props.node.get('expanded')).toBe(true);
    });

    it('will select the parent if the user hit the ← key on a collapsed node', function() {
        const nodes = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode);

        let node = nodes[1];
        expect(node.props.node.get('expanded')).toBe(false);
        TestUtils.Simulate.click(node.refs.contentDiv);
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));

        keyDownEvent(CURSOR_LEFT);
        node = nodes[0];
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));
    });

    it('will collapse the node if the user hit the ← key on an expanded node', function() {
        const nodes = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode);

        let node = nodes[0];
        expect(node.props.node.get('expanded')).toBe(true);
        TestUtils.Simulate.click(node.refs.contentDiv);
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));

        keyDownEvent(CURSOR_LEFT);
        expect(node.props.node.get('expanded')).toBe(false);
    });

    it('will search in node text if the user enters something in the search field', function() {
        const searchBox = TestUtils.findRenderedComponentWithType(this.TreeContainer, TreeContainerSearchBox);
        const field = document.querySelector('input.tree-search-text');
        const form = document.querySelector('form.tree-search-form');
        field.value = '64';
        form.dispatchEvent(new Event('submit'));

        const state = this.store.getState()['tree-tests'];
        expect(state.getIn(['searches', 'simple-text-search', 'resultCnt'])).toBe(1);
    });

    it('will select the the first found node if the user enters something in the search field', function() {
        const searchBox = TestUtils.findRenderedComponentWithType(this.TreeContainer, TreeContainerSearchBox);
        const field = document.querySelector('input.tree-search-text');
        const form = document.querySelector('form.tree-search-form');
        field.value = '64';
        form.dispatchEvent(new Event('submit'));

        const nodes = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode);
        const node = nodes.find(node => node.props.node.get('content') === 64);
        expect(node.props.tree.get('selectedId')).toBe(node.props.node.get('id'));
    });

    it('will be scrolled after selection', function() {
        const state = initialState.set('node',
            TreeTools.visitBottomUpDepthFirst(tree,
                node => {
                    return node.set('expanded', true);
                }
            )
        );
        this.store.dispatch(TreeActions.setInitialTreeState(state));

        const component = TestUtils.findRenderedComponentWithType(this.TreeContainer, TreeComponent);
        const nodes = TestUtils.scryRenderedComponentsWithType(this.TreeContainer, TreeNode);
        const node = nodes.pop();
        this.store.dispatch(TreeActions.selectTreeNode(node.props.node));

        expect(isInView(component.refs.scrollContainer, node.refs.scrollTarget)).toBe(true);
    })
});
