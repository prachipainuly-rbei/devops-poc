#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
# vim: set fileencoding=latin1 :
# -*- Python -*-
# $Id: _items.py 171229 2018-01-09 09:35:08Z gda $
#
# Copyright (C) 1990 - 2006 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
# File:     Item.py
# Author:   aki
# Creation: 01.08.06
# Purpose:

# pylint: disable-msg=R0901,R0201,R0904,E0203,W0212,W0201

import os
import sys
import datetime

from cdb import ue
from cdb import sqlapi
from cdb import auth
from cdb import kernel
from cdb import util
from cdb.classbody import classbody
from cdb.rte import require_config

from cdb.objects import ReferenceMethods_1

from cs.vp.items import Item
from cs.vp.items import ItemCategory
from cdb.objects.common import WithStateChangeNotification
from cdb.objects.org import CommonRole

# Sentinel: raise when "std-solution" is not set
require_config("std-solution")


@classbody
class Item(WithStateChangeNotification):

    def _PreviousIndex(self):
        ctx = self.GetContext()
        if ctx and ctx.action == "index" and ctx.mode in ['post_mask', 'pre']:
            prev_idx = ctx.cdbtemplate.t_index
        else:
            prev_idx = kernel.get_prev_index(self.teilenummer, self.t_index, self.GetTableName())
        return Item.ByKeys(self.teilenummer, prev_idx)
    PreviousIndex = ReferenceMethods_1(Item, lambda self: self._PreviousIndex())

    _MAX_COMPONENTS_MSG = 15

    def checkComponentsReleased(self):
        # Hinweis: self.Components Reference hier aus Performancegründen nicht verwendet.
        if self.isAssembly():
            t = sqlapi.SQLselect("teilenummer from einzelteile_v where baugruppe='%s' and b_index='%s' "
                                 "and status not in (200, 300, 400)"
                                 % (self.teilenummer, self.t_index))
            rows = sqlapi.SQLrows(t)
            if rows > 0:
                items = []
                for i in range(min(rows, self._MAX_COMPONENTS_MSG)):
                    items.append(sqlapi.SQLstring(t, 0, i))
                text = ",\n".join(items)

                if rows > self._MAX_COMPONENTS_MSG:
                    text += "\n" + \
                            util.get_label("cdbvp_and_x_more") % (rows - self._MAX_COMPONENTS_MSG)

                raise ue.Exception("cdb_konfstd_009", "\n" + text)

    def on_state_change_pre(self, ctx):
        self.Super(Item).on_state_change_pre(ctx)

        # Zur Freigabe von Baugruppen müssen alle Komponenten freigegeben sein
        if self.status == 200:
            self.checkComponentsReleased()

    def stateChangeAllowed(self, target_state, batch):
        if batch:
            return True
        exclude = {"*": [180, 190, 300],
                   0: [200],
                   190: [200],
                   }
        return (target_state not in exclude.get("*", []) and
                target_state not in exclude.get(self.status, []))

    # == Email notification ==
    def getNotificationReceiver(self, ctx=None):
        rcvr = {}
        if self.status == 100:
            releaseRole = CommonRole.ByKeys("Design Release")
            for pers in releaseRole.getPersons():
                if pers.e_mail:
                    tolist = rcvr.setdefault("to", [])
                    tolist.append((pers.e_mail, pers.name))
        return [rcvr]
    # == End email notification ==

    def _prevIndexStateChange(self, item, target_state):
        # In der Regel sollte es hier nur einen Artikel geben
        try:
            item.ChangeState(target_state)
        except RuntimeError, e:
            raise ue.Exception("cdb_konfstd_008", "%d" % (item.status), "%s" % (target_state), e)

    def on_state_change_pre_mask(self, ctx):
        self.Super(Item).on_state_change_pre_mask(ctx)

        for state in ctx.statelist:
            if not self.stateChangeAllowed(state, ctx.batch):
                ctx.excl_state(state)

    def on_state_change_post(self, ctx):
        self.Super(Item).on_state_change_post(ctx)

        if ctx.error != 0:
            return
        if ctx.old.status == '100' and ctx.new.status == '200':
            # Prüfer und Prüfdatum setzen
            self.t_pruefer = auth.get_name()
            self.t_pruef_datum = datetime.datetime.now()
            # Vorgängerindex von 'in Änderung' auf 'ungültig' setzen

            items = Item.KeywordQuery(teilenummer=self.teilenummer, status=190)
            for item in items:
                self._prevIndexStateChange(item, 180)

    def on_modify_pre(self, ctx):
        repl_for_set = 0
        if "t_ersatz_fuer" in ctx.dialog.get_attribute_names():
            if ctx.dialog.t_ersatz_fuer != ctx.object.t_ersatz_fuer:
                repl_for_set = 1
        ctx.set("cdb::argument.repl_for_set", "%d" % (repl_for_set))

    def on_modify_post(self, ctx):
        if ctx.error:
            return
        if ctx.sys_args["repl_for_set"] == "1":
            self.removeReplacementFor()
            self.setReplacementFor(ctx)

    def setWorkflow(self, ctx):
        categ = ItemCategory.ByKeys(self.t_kategorie)
        if categ:
            self.cdb_objektart = categ.teileart
        else:
            raise ue.Exception("cdb_konfstd_018", self.t_kategorie)

    def on_delete_post(self, ctx):
        if ctx.error:
            return
        # Wenn der Artikel überhaupt nicht mehr existiert, kann er auch keinen Anderen mehr ersetzen.
        # Ein Fall, der in Produktivumgebungen eigentlich nicht vorkommen kann, hier aber
        # der Vollständigkeit halber implementiert.
        if len(Item.KeywordQuery(teilenummer='%s' % self.teilenummer)) == 0:
            self.removeReplacementFor()
        # Vorgängerindex wieder in ursprünglichen Status zurücksetzen
        items = Item.KeywordQuery(teilenummer=self.teilenummer, status=190)
        for item in items:
            self._prevIndexStateChange(item, item.status_prev)

    def indexPost(self, template_index):
        pObj = self.getPersistentObject()
        pObj.clearAttributes()
        # Status des Vorgängerindex von 200 (freigeben) nach 190 (in Änderung)

        item = Item.ByKeys(self.teilenummer, template_index)
        if item and item.status == 200:
            old_state = item.status
            self._prevIndexStateChange(item, 190)
            item.status_prev = old_state

    def on_index_post(self, ctx):
        if ctx.error:
            return
        self.indexPost(ctx.cdbtemplate.t_index)
        # Wir haben am teile_stamm Aenderungen vorgenommen - damit der Server
        # das mitkriegt, muessen wir es ihm mitteilen
        ctx.refresh_tables(["teile_stamm"])

    def on_copy_pre_mask(self, ctx):
        self.t_index = ""
        self.clearAttributes()

    def clearAttributes(self):
        # Felder leeren
        attrs = ['t_ersatz_fuer', 't_ersatz_durch', 't_pruefer', 't_pruef_datum']
        for attr in attrs:
            self[attr] = ""

    def setDefaults(self, ctx):
        self.t_bereich = auth.get_department()

    def setReplacementFor(self, ctx):

        u""" Setzt 'Ersetzt durch' Attribut bei allen Indexständen des ersetzten Teils
        und leert ggf. zuvor das 'Ersatz für' Attribut des zuvor eingetragenen Teils."""

        if ctx.error or not self.t_ersatz_fuer:
            return
        t = sqlapi.SQLselect("t_ersatz_durch from teile_stamm where "
                             "teilenummer = '%s' and t_ersatz_durch!='%s' and t_ersatz_durch != '' " %
                             (self.t_ersatz_fuer, self.teilenummer))
        if sqlapi.SQLrows(t) > 0:
            sqlapi.SQLupdate("teile_stamm set t_ersatz_fuer = '' where teilenummer = '%s'" %
                             (sqlapi.SQLstring(t, 0, 0)))
        sqlapi.SQLupdate("teile_stamm SET t_ersatz_durch = '%s' WHERE teilenummer = '%s'" %
                         (self.teilenummer, self.t_ersatz_fuer))
        # Wir haben am teile_stamm Aenderungen vorgenommen - damit der Server
        # das mitkriegt, muessen wir es ihm mitteilen
        ctx.refresh_tables(["teile_stamm"])

    def removeReplacementFor(self):
        sqlapi.SQLupdate("teile_stamm SET t_ersatz_durch = '' WHERE t_ersatz_durch = '%s'" % self.teilenummer)

    def on_preview_now(self, ctx):
        # Wenn es ein zugeordnetes CAD-Dokument gibt, dieses als Vorschau verwenden
        for doc in self.Documents:
            if doc.isModel():
                # Wenn es eine geeignete Datei gibt, setzen
                preview_file = doc.GetPreviewFile()
                if preview_file:
                    preview_file.handlePreviewCtx(ctx)
                    return
        # Kein geeignetes Dokument gefunden - auf Standard zurueckfallen
        self.Super(Item).on_preview_now(ctx)

    event_map = {
        (('copy', 'create', 'modify', 'info', 'query', 'requery'), 'pre_mask'): "smlPremaskImages",
        (('copy', 'create'), 'pre'): ("setWorkflow", "setItemNumber", "setItemIndex"),
        (('copy', 'create'), 'post_mask'): ("setWorkflow"),
        (('copy', 'create'), 'post'): ("setReplacementFor"),
        (('copy', 'create'), 'pre_mask'): ("setDefaults")}

# Email notification attributes
Item.__notification_template__ = "part_approval.html"
Item.__notification_title__ = u"CIM DATABASE - Artikel zur Prüfung / Part for approval"
# Force looking for the template file in defined folder
dirname = os.path.dirname(__file__.decode(sys.getfilesystemencoding()))
Item.__notification_template_folder__ = os.path.join(dirname, "chrome")
