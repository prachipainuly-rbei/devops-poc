import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {getJSON, ContentBlock, Registry, ObjectContent} from 'cs-web-components-base';
import {ButtonToolbar, ButtonGroup, Button} from 'react-bootstrap';
import Immutable from 'immutable';

export default class MultiFormatPreview extends Component {

    constructor(props) {
        super(props);
        this.state = {
            availableViewers: null,
            activeViewer: null,
            viewersFetched: false
        };
        this.changePreview = this.changePreview.bind(this);
        this.body_class = "cs-vp-items-components-multi-format-preview-body";
    }

    updatePreviewComponent(object_id) {
        this.setState({availableViewers: null, activeViewer: null}, () => {
            this.setState({viewersFetched: false}, () => {
                this.fetchViewer(object_id);
            });
        });
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.contextObject !== this.props.contextObject
            || (nextProps.selectedFile === undefined
                && this.props.selectedFile !== nextProps.selectedFile)) {
            this.updatePreviewComponent(nextProps.contextObject.get("cdb_object_id", null));
        } else if (nextProps.selectedFile !== this.props.selectedFile) {
            if (nextProps.selectedFile) {
                this.setState({
                    availableViewers: null,
                    activeViewer: null,
                    viewersFetched: true
                });
            } else {
                this.updatePreviewComponent(null);
            }
        }
    }

    fetchViewer(object_id) {
        if (object_id) {
            getJSON(this.props.viewerConfigLink + object_id).then(
                data => {
                    if (data.length !== 0) {
                        if (this.props.multiConfigExpected) {
                            this.setState({
                                availableViewers: data[0],
                                activeViewer: data[0][0],
                                viewersFetched: true
                            });
                        } else {
                            this.setState({
                                availableViewers: data,
                                activeViewer: data[0],
                                viewersFetched: true
                            });
                        }
                    }
                },
                () => {
                    this.setState({
                        availableViewers: null,
                        activeViewer: null,
                        viewersFetched: true
                    });
                }
            );
        }
    }

    componentDidMount() {
        const object_id = this.props.contextObject.get("cdb_object_id", null);
        this.fetchViewer(object_id);
    }

    changePreview(evt) {
        const viewer_index = parseInt(evt.target.getAttribute("data-viewer-index"));
        this.setState({
            activeViewer: this.state.availableViewers[viewer_index]
        });
    }

    renderContentPreview() {
        const viewer = this.state.activeViewer;
        const {minified} = this.props;
        const DisplayComponent = Registry.findComponent(viewer.component);

        if (!DisplayComponent) {
            return "";
        }

        return (
            <DisplayComponent
                {...viewer.props}
                hideTree={minified}
                hideTriad={minified}
                minified={minified}
            />
        );
    }

    render() {
        const viewer = this.state.availableViewers;

        if (!this.state.viewersFetched) {
            return null;
        }

        if (!viewer) {
            return (
                <ObjectContent {...this.props} />
            );
        }

        if (this.props.minified) {
            this.body_class = "cs-vp-items-components-multi-format-preview-body-minified";
        } else {
            this.body_class = "cs-vp-items-components-multi-format-preview-body";
        }

        const viewer_buttons = viewer.map((entry, index) => {
            return (
                <Button key={"view_selector_" + index}
                    data-viewer-index={index}
                    onClick={this.changePreview}>
                    {entry.label}
                </Button>
            );
        });

        return (
            <ContentBlock collapsible={false}>
                <ContentBlock.Header>
                    <ButtonToolbar>
                        <ButtonGroup>
                            {viewer_buttons}
                        </ButtonGroup>
                    </ButtonToolbar>
                </ContentBlock.Header>
                <ContentBlock.Body>
                    <div className={this.body_class}>
                        {this.renderContentPreview()}
                    </div>
                </ContentBlock.Body>
            </ContentBlock>
        );
    }
}

MultiFormatPreview.propTypes = {
    contextObject: PropTypes.instanceOf(Immutable.Map).isRequired,
    minified: PropTypes.bool,
    viewerConfigLink: PropTypes.string.isRequired,
    multiConfigExpected: PropTypes.bool.isRequired,
    selectedFile: PropTypes.string
};

MultiFormatPreview.defaultProps = {
    contextObject: null,
    minified: false,
    viewerConfigLink: "",
    multiConfigExpected: false,
    selectedFile: undefined
};
