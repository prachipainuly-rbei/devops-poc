#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Module cs.vp.bom.diffutil.nanoroute
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: nanoroute.py 152003 2017-01-17 15:29:02Z gda $"

import json
import traceback
import datetime

from cdb import sqlapi
from cdb import misc
from cdb import i18n
from cdb import objects


class App(object):
    # App responses directly to request(writes the data back)
    def __init__(self):
        self.routes = {}

    def handle_request(self, req, path=None):
        path = tuple(path)
        for route, handler in self.routes.items():
            matched = match_route(route, path)
            if matched is not None:
                return handler(req, **matched)
        return None

    def register(self, route, handler):
        self.routes[parse_route(route)] = handler

    def register_with_render(self, route, func, render):
        def wrapper(req, **kw):
            result = func(req, **kw)
            result = render(req, result)
            req.write(result)
        self.register(route, wrapper)

    def registration(self, route, render):
        def wrapper(func):
            self.register_with_render(route, func, render)
            return func
        return wrapper

    def resource(self, route):
        return self.registration(route, resource_render)

    def json(self, route):
        return self.registration(route, json_render)


class LookUp(App):
    # LookUp just returns the rendered data and
    # let the caller deal with the data
    def register_with_render(self, route, func, render):
        def wrapper(req, **kw):
            try:
                result = func(req, **kw)
            except Exception as e:
                misc.log_error(traceback.format_exc())
                return render(req, None, e)
            return render(req, result)
        self.register(route, wrapper)


def parse_route(s):
    return tuple(s.split('/'))


def match_route(route, path):
    if len(route) != len(path):
        return None
    result = {}
    for pattern, step in zip(route, path):
        if pattern.startswith(':'):
            result[pattern[1:]] = step
        else:
            if pattern != step:
                return None
    return result


def resource_render(req, data, error=None):
    return data


def _json_convert(v):
    if v is sqlapi.NULL:
        return None
    elif isinstance(v, datetime.datetime):
        return unicode(v)
    elif isinstance(v, sqlapi.Record):
        return dict(v)
    elif isinstance(v, objects.Object):
        return dict(v)
    else:
        raise TypeError("%r is not JSON serializable" % v)


def json_render(req, data, error=None):
    req.type = 'application'
    req.subtype = 'json'
    result = {"success": 1 if error is None else 0,
              "result": data if data is not None else ''}
    if error is not None:
        result.update({"message": unicode(error)})
    return json.dumps(result, default=_json_convert)


def posted_json(req):
    assert len(req.upstreams) == 1

    charset = req.charset
    path = req.upstreams[0]['id'].decode(charset)

    assert isinstance(path, unicode)
    with open(path, 'rb') as f:
        return json.load(f)
