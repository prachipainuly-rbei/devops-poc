App.NodeSelection = Ember.ArrayProxy.extend({
    init: function() {
        this.set("content", Ember.A());
    },

    /*
     * Called when a node is clicked.
     *
     * If shift is true the node will be added to the selection
     * together with all the positions between the current selection and
     * the node.
     *
     * If shift is false the node will be added to the selection.
     *
     * If ctrl is true and the node is already selected,
     * the node will be removed from the selection.
     */
    click: function(node, ctrl, shift) {
        if (ctrl && this.content.contains(node)) {
            this.removeNode(node, ctrl, shift);
        } else {
            this.addNode(node, ctrl, shift);
        }
    },

    /*
     * Add a node to the selection.
     *
     * If ctrl and shift are false the current selection is reset.
     *
     * If ctrl or shift are true, both node and the current selection should
     * be in the same tree structure (i.e. both eBom or both mBom).
     * Otherwise the method behaves as if ctrl and shift were false.
     *
     * parameters:
     * node     The node to be added to the selection.
     * ctrl     true if the current selection should not be reset
     *          (additive behaviour).
     * shift    true if all the positions between the current selection and
     *          node should be added to the selection.
     */
    addNode: function(node, ctrl, shift) {
        var content = this.get("content");

        // If an element of a different bom tree is selected,
        // reset the selection
        if (!content.everyBy("isEbomView", node.get("isEbomView"))) {
            ctrl = false;
            shift = false;
        }

        if (ctrl) {
            if (!content.contains(node)) {
                content.pushObject(node);
            }
        } else if (shift) {
            var minPos = Math.min(
                    content.mapBy("position").min(),
                    node.get("position")
            );
            var maxPos = Math.max(
                    content.mapBy("position").max(),
                    node.get("position")
            );

            var parent = node.get("parent");
            if (!parent) {
                // the top level node is selected
                parent = node;
                if (!content.contains(parent)) {
                    content.pushObject(parent);
                }
            }
            parent.get("content").forEach(function(el) {
                var position = el.get("position");
                if (position >= minPos && position <= maxPos) {
                    if (!content.contains(el)) {
                        content.pushObject(el);
                    }
                }
            });
        } else {
            content.clear();
            content.pushObject(node);
        }
    },

    /*
     * Remove node from the selection
     *
     * If ctrl and shift are false the current selection is reset.
     *
     * If ctrl is true the current selection will not be reset.
     */
    removeNode: function(node, ctrl, shift) {
        if (!ctrl) {
            this.get("content").clear();
        }

        this.get("content").removeObject(node);
    },

    isEbomView: function() {
        return this.get("content").everyBy("isEbomView", true);
    }.property("content.[]"),

    containsTopNode: function() {
        return this.get("content").isAny("parent", undefined);
    }.property("content.[]"),

    /*
     * If only one node is selected, then return it's parent node.
     * If multiple nodes are selected, then return the parent
     * of their "most recent common ancestor".
     */
    mostRecentCommonAncestor: function() {
        var content = this.get("content");
        var node = content.objectAt(0);
        if (content.length == 1) {
            return node;
        } else if (content.length > 1) {
            var path = [];
            while (node) {
                path.insertAt(0, node);
                node = node.get("parent");
            }
            for (var i = 1; i < content.length; i++) {
                node = content.objectAt(i);
                while (node) {
                    if (path.contains(node)) {
                        var cutIndex = path.lastIndexOf(node) + 1;
                        path.removeAt(cutIndex, path.length - cutIndex);
                        break;
                    }
                    node = node.get("parent");
                }
            }
            return path.popObject();
        }
    }.property("content.[]")
});
