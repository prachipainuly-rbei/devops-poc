/*
 * Cache layer
 */

App.PromiseObject = Ember.ObjectProxy.extend(Ember.PromiseProxyMixin);

/*
 * ObjectCache: a class to cache objects coming from ajax-calls
 *
 * Following parameters are needed:
 *
 * url A function taking a key as parameter and returning a url providing a json object for the given key
 *
 * ajax (Optional) A function taking a list of keys and return a url providing a list of json objects for the given
 * keys. Used for performance optimizations
 *
 *
 * Public API:
 *
 * handleResult (Optional) A hook called on the result of the ajax calls, before storing the result on the cache. Can be
 * use to manipulate objects before saving them. The return value is stored in the cache
 *
 * update Save an element in the cache, if not already present
 *
 * updateMany Take a list of elements and store those element which are not already present
 *
 * getProperties Return a list with the value of many properties at once. If the parameter `ajax` is defined, perfoms
 * only one ajax call.
 *
 * load Load or reload an element in the cache, given its key.
 */


App.ObjectCache =
    Ember.ObjectProxy.extend({

        /*
         * Parameters
         */

        // url for fetching a single item
        url: null,
        // data for fetching a single item
        data: null,
        // ajax call for fetching many items (optional)
        ajax: null,

        filter: {},

        escapeKey: function(key) {
            // replace points with a unicode punctuation space character
            // because ember interprets points as path separators.
            // this is not the regular white space, so it's very unlikely
            // that it occurrs in a key.
            var pointReplacer = "\u2008";
            var result = key.replace(/\./g, pointReplacer);
            return result;
        },

        unescapeKey: function(key) {
            var result = key.replace(/\u2008/g, ".");
            return result;
        },

        get: function(key) {
            var escapedKey = this.escapeKey(key);
            return this._super(escapedKey);
        },

        set: function(key, value) {
            var escapedKey = this.escapeKey(key);
            return this._super(escapedKey, value);
        },


        /*
         * Hooks
         */

        // hook to transform the result of the ajax call, you can override this
        handleResult: function(result) {
            return Ember.Object.create(result);
        },
        handleResults: function(promise, keys) {
            var self = this;
            var cacheKey = this.get("cacheKey");

            keys.forEach(function(key) {
                self.set(key, App.PromiseObject.create({
                    promise: promise.then(function(data) {
                        return self.handleResult(data.findBy(cacheKey, key));
                    })
                }));
            });
        },
        // hook called after a property has been set
        post: function(key) {
        },

        /*
         * Public API
         */

        updateMany: function(content) {
            for (var key in content) {
                if (content.hasOwnProperty(key)) {
                    this.update(key, content[key]);
                }
            }
        },

        update: function(key, el, force) {
            var escapedKey = this.escapeKey(key);
            if (!this.get("content").hasOwnProperty(escapedKey) || force) {
                var new_val = this.handleResult(el);
                if (force) {
                    var old_val = this.get('content').get(escapedKey);

                    if (old_val instanceof App.PromiseObject && old_val.get('isFulfilled')) {
                        old_val = old_val.get('content');
                    } else if (old_val instanceof App.PromiseObject && !old_val.get('isFulfilled')) {
                        old_val = undefined; // unloaded promises can be replaced by already loaded content
                    }
                    this.get('content').set(escapedKey, new_val);
                    this.postPropertyReload(key);
                } else {
                    this.get('content').set(escapedKey, new_val);
                }
            }
        },

        // get many items with one ajax-call
        getProperties: function(keys) {
            var self = this;
            var promise = Ember.RSVP.resolve();
            // Load all the missing keys with one ajax call
            if (self.ajax && keys) {
                var content = self.get("content");

                // Check if some items are not in the cache
                var missing_keys = [];
                keys.forEach(function(key) {
                    var escapedKey = self.escapeKey(key);
                    if (content.get(escapedKey) === undefined) {
                        missing_keys.push(key);
                    }
                });

                // Load missing items in the cache
                if (missing_keys.length > 0) {
                    promise = self.ajax(missing_keys).then(function(data) {
                        if (data.success) {
                            return data.result;
                        } else {
                            cdb.elink.alert(data.message);
                        }
                    });
                    self.handleResults(promise, missing_keys);
                }
            }

            // Return all items from the cache
            return promise.then(function() {
                return keys.map(function(key) {
                    return self.get(key);
                });
            });
        },

        /*
         * Private functions
         */

        postPropertyReload: function(key) {
            // to be overriden
        },

        reloadProperties: function(keys) {
            var self = this;
            if (keys === undefined) {
                var keys = Ember.keys(this.content);
                // remove erroneous added toString key
                var toStringIdx = keys.indexOf("toString");
                if (toStringIdx !== -1) {
                    keys.removeAt(toStringIdx);
                }
            }
            if (self.ajax && keys.length > 0) { // Load all keys with one ajax call
                var content = self.get("content");
                return self.ajax(keys).then(function(data) {
                    if (data.success) {
                        keys.forEach(function(key) {
                            var item = self.getItemFromAjaxDataByKey(data.result, key);
                            if (item !== undefined) {
                                self.update(key, self.handleResult(item), true);
                            }
                        });
                    } else {
                        cdb.elink.alert(data.message);
                        return Ember.RSVP.reject(data.message);
                    }
                });
            } else {
                return Ember.RSVP.resolve();
            }
        },

        getItemFromAjaxDataByKey: function(data, key) {
            var cacheKey = this.get("cacheKey");
            var item = data.findBy(cacheKey, key);
            return item;
        },

        init: function() {
            this._super();

            this.set("content", Ember.Object.create());
        },

        unknownProperty: function(key) {
            var self = this;
            var promise = this._super(key);

            if (promise === undefined) {
                promise = this.load(key);
            }

            // cache should always return a promise
            var result = App.PromiseObject.create({
                promise: Ember.RSVP.resolve(null).then(function() {
                    return promise;
                })
            });
            this.get('content').set(key, result);
            return result;
        },

        load: function(key) {
            // load item description from server
            var url = this.url(key);
            var self = this;
            var label = this.label;

            return App.ajax({
                url: url,
                data: $.extend(this.get('data'), {filter: this.get('filter')}),
                dataType: 'json',
                type: 'get',
                async: true
            }, true, label).then(function(data) {
                var result;
                if (data.success) {
                    result = self.handleResult(data.result);
                    // self.set(key, result);
                } else {
                    cdb.elink.alertCDBMessage(data.message);
                }
                return result;
            });
        },

        setUnknownProperty: function(key, value) {
            this.content.set(key, value);

            // call hook
            $.proxy(this.get("post"), this)(key, value);
        },

        clear: function() {
            this.set("content", Ember.Object.create());
        }
    });

/*
 * Mixin for objects which have cached properties
 *
 * A cached property is defined by a property with the suffix -Cache. For example the property `itemCache` defines the
 * cached property `item`.
 *
 * The definition of a cached property can be an object or a string. If it is an object, the following attributes should
 * be given.
 *
 * name The name of the cache, in which the property values are stored. The cache must be an instance of App.ObjectCache
 * and must be a property of App.CacheLayer.
 *
 * key The name of the property, which will be used as key for storage in the cache. `key` must be a property of the
 * same object which has the cached property.
 *
 * If the definition of a cached property is a string, it will be used in place of `key`, the property name of the
 * definition (e.g. `itemCache`) will be used as cache name.
 */

App.CachedObjectMixin = Ember.Mixin.create({
    _cacheSuffix: "Cache",

    init: function() {
        var self = this;
        self._super();

        var _cacheKeys = Ember.A();

        for (var prop in self) {
            if (prop.endsWith(self._cacheSuffix)) {
                var name = prop.slice(0, -(self._cacheSuffix.length));

                var cacheName;
                var keyName;
                if (typeof self.get(prop) === 'string' || self.get(prop) instanceof String) {
                    cacheName = prop;
                    keyName = self.get(prop);
                } else {
                    cacheName = self.get(prop).name;
                    keyName = self.get(prop).key;
                }
                _cacheKeys.pushObject(Ember.Object.create({
                    name: name,
                    cacheName: cacheName,
                    keyName: keyName
                }));
            }
        }
        this.set('_cacheKeys', _cacheKeys);

        // create properties
        _cacheKeys.forEach(function(values) {
            Ember.defineProperty(self, values.get('name'), Ember.computed(function() {
                var cache = App.CacheLayer.get(values.get('cacheName'));
                var key = self.get(values.get('keyName'));
                if (key) {
                    return App.PromiseObject.create({
                        promise: cache.get(key)
                    });
                }
            }).property(values.get('keyName')));
        });
    }
});

/*
 * A class for objects which have cached properties (see App.CachedObjectMixin)
 */

App.CachedObject = Ember.Object.extend(App.CachedObjectMixin);

/*
 * A class for array of cached object.
 *
 * The array stores only the keys. That is, by using pushObject or similar you should only pass the keys as argument
 * (e.g. the cdb_object_id of an item).
 *
 * Reading the array will return the cached value.
 *
 * The following parameter is required.
 *
 * cacheName The name of the cache, in which the property values are stored. The cache must be an instance of
 * App.ObjectCache and must be a property of App.CacheLayer.
 */

App.CachedArray = Ember.ArrayProxy.extend({
    cacheName: null,
    objectAtContent: function(idx) {
        var cache = App.CacheLayer.get(this.cacheName);
        if (cache) {
            var key = this.get('content').objectAt(idx);
            return App.PromiseObject.create({
                promise: cache.get(key)
            });
        }
    }
});

// lazy loaded cached fixed size array which loads server pages when an element which previously wasn't loaded is
// requested
App.PaginatedCachedArray = Ember.Object.extend(Ember.MutableArray, {
    length: 0,
    pageSize: 10,
    unknownProperty: function(key) {
        var val = this._super('' + key);
        if (val === undefined && parseInt(key) >= 0) {
            return this.load(key)
        }
        return val;
    },
    objectAt: function(index) {
        if (parseInt(index) < 0 || parseInt(index) >= this.get('length')) {
            return undefined;
        }
        return this.get('' + index);
    },
    replace: function(index, atm, objects) {
        var length = this.get('length');
        var newData = {};
        for (var i = index + objects.length; i < atm; i++) {
            newData['' + i] = undefined;
        }
        for (var i = index; i < index + objects.length; i++) {
            newData['' + i] = objects[i - index];
        }
        newData['length'] = length - atm + objects.length;
        this.setProperties(newData);
    },
    data: function(idx, pagingData) {
        return pagingData;
    },
    url: function(idx, pagingData) {
        // url for fetching a page of items - must be given
    },

    calcPagingData: function(idx) {
        var idx = parseInt(idx);
        var pageSize = this.get('pageSize');
        var neededPage = Math.floor(idx / pageSize);
        var neededPageStartIdx = neededPage * pageSize;
        return {
            startIdx: neededPageStartIdx,
            page: neededPage,
            pageSize: pageSize
        };
    },
    handleResults: function(results, idx) {
        var self = this;
        var result;
        var pageStartIdx = this.calcPagingData(idx)['startIdx'];
        var offsetIdx = idx - pageStartIdx;
        var newData = {};
        results.forEach(function(obj, index) {
            var res = Ember.Object.create(obj);
            newData['' + (pageStartIdx + index)] = res;
            // return queried idx value
            if (index == offsetIdx) {
                result = res;
            }
        });
        self.setProperties(newData);
        return result;
    },
    load: function(idx) {
        var self = this;
        var pagingData = this.calcPagingData(idx);
        var url = this.url(idx, pagingData);
        var result;

        $.ajax({
            url: url,
            data: this.data(idx, pagingData),
            dataType: 'json',
            type: 'get',
            async: false
        }).done(function(data) {
            if (data.success) {
                if (data.result.results !== undefined) {
                    result = self.handleResults(data.result.results, idx);
                }
            } else {
                cdb.elink.alertCDBMessage(data.message);
            }
        });
        return result;
    }
});

/*
 * Cache Layer
 *
 * Here we define the caches that are used through the application.
 */

App.Item =
    App.CachedObject.reopenClass({
        detailProperty: function(name) {
            return Ember.computed('itemDetails.isFulfilled', function() {
                if ('itemDetails.isFulfilled') {
                    return this.get('itemDetails.' + name);
                }
            });
        }
    }).extend({
        usagesCache: "cdb_object_id",
        itemDetailsCache: "cdb_object_id",

        initDetails: function() {
            var self = this;
            [
                'link',
                'description',
                'tooltip',
                'state_icon',
                'mbom_desc'
            ].forEach(function(field) {
                Ember.defineProperty(
                    self,
                    field,
                    App.Item.detailProperty(field)
                );
            });
        }.on('init'),

        isEqual: function(b) {
            var a = this;
            var fields =
                Ember.A(["status", "object_type", "cdb_object_id", "is_assembly",
                    "idx", "is_mbom", "nr", "cdb_depends_on"]);
            if (b === undefined) {
                return false;
            }
            var result = fields.every(function(field) {
                return a.get(field) == b.get(field);
            });
            return result;
        }
    });

var BomItemUtils = Ember.Object.reopenClass({
    keyAttributes: [
        "baugruppe",
        "b_index",
        "teilenummer",
        "variante",
        "position"
    ],

    fromArray: function(arr) {
        var result = {};
        BomItemUtils.keyAttributes.forEach(function(attr, index) {
            result[attr] = arr[index];
        });
        return BomItemUtils.create(result);
    }
}).extend({
    pkeys: function() {
        var self = this;
        return BomItemUtils.keyAttributes.map(function(attr) {
            return self.get(attr);
        }).join(";");
    }.property("baugruppe", "b_index", "teilenummer", "t_index",
        "variante", "position")
});

App.Bom =
    App.CachedObject.extend({
        itemCache: "item_object_id",
        predicatesCache: "pkeys",
        init: function() {
            this._super();
        },
        isEqual: function(b) {
            var a = this;
            var fields =
                Ember.A(["teilenummer", "t_index", "baugruppe", "b_index",
                    "auswahlmenge", "position", "tooltip",
                    "description"]);
            if (b === undefined) {
                return false;
            }
            var result = fields.every(function(field) {
                return a.get(field) == b.get(field);
            });
            return result;
        },
        pkeys: function() {
            var self = this;

            return BomItemUtils.fromArray(
                    BomItemUtils.keyAttributes.map(function(attr) {
                return self.get(attr);
            })).get('pkeys');
        }.property("baugruppe", "b_index", "teilenummer",
            "variante", "position")
    });

App.ComparableArray = Ember.ArrayProxy.extend({
    isEqual: function(b) {
        var a = this;
        var all_a_in_b = a.every(function(aItem) {
            return b.any(function(bItem) {
                return aItem.isEqual(bItem);
            });
        });
        if (!all_a_in_b) {
            return false;
        } else {
            var all_b_in_a = b.every(function(bItem) {
                return a.any(function(aItem) {
                    return aItem.isEqual(bItem);
                });
            });
            return all_b_in_a;
        }
    }
});

App.UsagesCache =
    App.ObjectCache.extend({
        litem: null,
        ritem: null,
        label: 'cdbvp_elink_diffutil_load_usages',
        url: function(key) {
            var litem_object_id = this.get('litem') ? this.get('litem').get('cdb_object_id') : undefined;
            var ritem_object_id = this.get('ritem') ? this.get('ritem').get('cdb_object_id') : undefined;
            var url =
                App.get('apiUrlRoot') + key + "/" + litem_object_id + "/" + ritem_object_id + "/usages";

            return url;
        },
        handleResult: function(result) {
            return Ember.A(result);
        }
    });

App.DifferencesCache =
    App.ObjectCache.extend({
        litem: null,
        ritem: null,
        label: 'cdbvp_elink_diffutil_load_differences',
        product_object_id: null,
        variant: null,

        _variantChanged: function() {
            var variant = this.get('variant');

            this.set('data', {
                variant_id: variant.vid,
                signature: variant.signature
            });

            this.clear();
        }.observes('variant'),

        url: function(key) {
            var product_object_id = this.get('product_object_id');
            var litem_object_id = this.get('litem') ? this.get('litem').get('cdb_object_id') : undefined;
            var ritem_object_id = this.get('ritem') ? this.get('ritem').get('cdb_object_id') : undefined;
            var url =
                App.get('apiUrlRoot') + key + '/' + litem_object_id + '/' + ritem_object_id +
                    (product_object_id !== null ?  ('/' + product_object_id) : '') +
                    '/find_differences';

            return url;
        },
        handleResult: function(result) {
            return Ember.Object.create({
                left: Ember.A(result.left),
                right: Ember.A(result.right),
                usages: Ember.A(result.usages)
            });
        }
    });

App.CacheLayer = Ember.Object.extend({
    reload: function(keys) {
        var cacheLayer = this;

        // differencesCache must be cleared, but not reloaded
        cacheLayer.get('differencesCache').clear();

        // on usagesCache we must only delete the keys
        // and not reload them (usagesCache will be updated when needed).
        if (keys) {
            keys.forEach(function(key) {
                cacheLayer.get('usagesCache').get('content').set(key, undefined);
            }, this);
        }

        // bomCache and itemCache will be reloaded
        [cacheLayer.get('itemCache'), cacheLayer.get('bomCache')].forEach(function(cache) {
            cache.reloadProperties(keys);
        });

        if (keys) {
            cacheLayer.get('bomCache').getProperties(keys).then(function(boms) {
                return Ember.RSVP.all(boms);
            }).then(function(boms) {
                var pkeys = [];

                for (var i = 0; i < boms.length; i++) {
                    var bom = boms[i].content;
                    pkeys.push.apply(pkeys, bom.map(function(position) {
                        return position.get('pkeys');
                    }));
                }

                cacheLayer.get('predicatesCache').reloadProperties(pkeys);
            });
        } else {
            cacheLayer.get('predicatesCache').reloadProperties();
        }
    },
    clear: function(key) {
        for (var cacheName in this) {
            if (this.hasOwnProperty(cacheName) && this[cacheName] instanceof App.ObjectCache) {
                this[cacheName].clear();
            }
        }
    }
}).create({
    predicatesCache: App.ObjectCache.extend({
        label: 'cdbvp_elink_diffutil_load_predicates',
        cacheKey: "pkeys",
        itemsMap: Ember.A(),

        url: function(pkeys) {
            return App.get('apiUrlRoot') + pkeys + "/bom_predicates";
        },

        handleResult: function(result) {
            return Ember.A(result);
        },

        handleResults: function(promise, keys) {
            var self = this;

            keys.forEach(function(key) {
                self.set(key, App.PromiseObject.create({
                    promise: promise.then(function(data) {
                        return data[key];
                    })
                }));
            });
        },

        // ajax call for fetching many items
        ajax: function(pkeys) {
            var url = App.get('apiUrlRoot') + 'bom_predicates_list';
            var label = this.label;
            return App.ajax({
                url: url,
                dataType: 'json',
                data: {
                    "pkeys": pkeys
                },
                type: 'post',
                async: true
            }, true, label);
        },

        // hook called after a property has been set
        post: function(key, predicates) {
            var predicatesCache = this;
            predicates.then(function(predicates) {
                predicatesCache.get('itemsMap').set(key, predicates.map(function(predicate) {
                    return predicate.item_object_id;
                }));
            });
        },

        postPropertyReload: function(key) {
            var predicates = this.get('content').get(key);

            // update itemsMap
            var items = this.get('itemsMap').get(key);
            if (items === undefined) {
                items = [];
            }
            var treeNodesToRender = [];
            predicates.forEach(function(predicate) {
                var item_object_id = predicate.item_object_id;
                var nodes = Object.keys(App.TreeNodeDict[item_object_id])
                    .map(function(key) {
                        return App.TreeNodeDict[item_object_id][key];
                    })
                    .filter(function(node) {
                        return (
                            node.get('baugruppe') === predicate.baugruppe &&
                            node.get('b_index') === predicate.b_index &&
                            node.get('teilenummer') === predicate.teilenummer &&
                            node.get('variante') === predicate.variante &&
                            node.get('position') === predicate.position
                        );
                    });
                treeNodesToRender.push.apply(treeNodesToRender, nodes);

                if (!items.contains(item_object_id)) {
                    items.push(item_object_id);
                }
            });

            this.get('itemsMap').set(key, items);
            treeNodesToRender.forEach(function(node) {
                node.set('predicates', predicates);
                node.render(true);
            });
        },
        getItemFromAjaxDataByKey: function(data, key) {
            return data[key];
        }
    }).create(),

    itemCache: App.ObjectCache.extend({
        cacheKey: "cdb_object_id",
        label: 'cdbvp_elink_diffutil_load_items',

        // url for fetching a single item
        url: function(key) {
            var url = App.get('apiUrlRoot');
            return url + key + '/item';
        },
        handleResult: function(result) {
            var statecolors = window.statecolors;

            result.state_color = statecolors[result.object_type][result.status];
            return App.Item.create(result);
        },
        // ajax call for fetching many items
        ajax: function(keys) {
            var url = App.get('apiUrlRoot') + 'items';
            var label = this.label;

            return App.ajax({
                url: url,
                dataType: 'json',
                data: {
                    "oids": keys
                },
                type: 'post',
                async: true
            }, true, label);
        },
        postPropertyReload: function(key) {
            var item = this.get(key);
            var treeNodesToRender = App.TreeNodeDict[key];
            Ember.keys(treeNodesToRender).forEach(function(nodeKey) {
                var node = treeNodesToRender[nodeKey];
                node.set('item', item);
                node.render(true);
            });
        }
    }).create(),

    itemDetailsCache: App.ObjectCache.extend({
        cacheKey: "cdb_object_id",
        label: 'cdbvp_elink_diffutil_load_item_details',

        // url for fetching a single item
        url: function(key) {
            var url = App.get('apiUrlRoot');
            return url + key + '/itemdetails';
        },
        handleResult: function(result) {
            return Ember.Object.create(result);
        },
        // ajax call for fetching many items
        ajax: function(keys) {
            var url = App.get('apiUrlRoot') + 'itemsdetails';
            var label = this.label;

            return App.ajax({
                url: url,
                dataType: 'json',
                data: {
                    "oids": keys
                },
                type: 'post',
                async: true
            }, true, label);
        }
    }).create(),

    bomCache: App.ObjectCache.extend({
        cacheKey: "item_object_id",
        label: 'cdbvp_elink_diffutil_load_boms',

        // url for fetching a single item
        url: function(key) {
            var url = App.get('apiUrlRoot');
            return url + key + '/bom';
        },

        variant: null,

        _variantChanged: function() {
            var variant = this.get('variant');
            var old_ids = Ember.keys(this.get('content'));
            var data = variant ? {
                "variant_id": variant.vid,
                "product_object_id": variant.product_object_id,
                "signature": variant.signature
            } : {};
            this.set('data', data);
            this.clear();
            // take the new boms filtered by variant
            this.getProperties(old_ids);
        }.observes('variant'),

        handleResult: function(data) {
            var result = App.ComparableArray.create({
                content: []
            });

            data.forEach(function(el) {
                var itemCache = App.CacheLayer.itemCache;
                itemCache.update(el.item_object_id, el.item);

                result.pushObject(App.Bom.create(el));
            });

            return result;
        },

        // ajax call for fetching many items
        ajax: function(keys) {
            var url = App.get('apiUrlRoot') + 'boms';
            var label = this.label;
            var custom_data = this.get('data');
            var data = {
                "oids": keys,
                "filter": this.get('filter')
            };
            if (custom_data) {
                for (var attrname in custom_data) {
                    if (custom_data.hasOwnProperty(attrname)) {
                        data[attrname] = custom_data[attrname];
                    }
                }
            }
            return App.ajax({
                url: url,
                dataType: 'json',
                data: data,
                type: 'post',
                async: true
            }, true, label);
        },
        handleResults: function(promise, keys) {
            var self = this;

            keys.forEach(function(key) {
                self.set(key, App.PromiseObject.create({
                    promise: promise.then(function(data) {
                        var result = data.find(function(result) {
                            return result[0] === key;
                        });
                        if (result) {
                            return self.handleResult(result[1]);
                        }
                    })
                }));
            });
        },
        getItemFromAjaxDataByKey: function(data, key) {
            var result = data.find(function(result) {
                return result[0] === key;
            });
            if (result) {
                return result[1];
            }
        },
        postPropertyReload: function(key) {
            var treeNodesToRender = App.TreeNodeDict[key];
            Ember.keys(treeNodesToRender).forEach(function(nodeKey) {
                var node = treeNodesToRender[nodeKey];
                node.loadComponents(true).then(function() {
                    node.render(true);
                });
            });
        }
    }).create(),

    usagesCache: null,
    differencesCache: null
});
