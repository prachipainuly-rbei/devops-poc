App.SelectView = Ember.Select;

App.PartMetaView = Ember.View.extend({
  templateName: 'partmeta',
  classNames: ['container-fluid', 'part-meta-data'],
  ritemChanged: function() {
      if (this.get('controller.ritem.isFulfilled')) {
          this.rerender();
      }
  }.observes("controller.ritem")
});

App.DroppableMixin = Ember.Mixin.create({
    expandNode: function(node) {
        this.get('treeComponent')
            .sendAction('nodeWillExpand', node, true);
    },
    didInsertElement: function() {
        var self = this;

        // Drag & drop
        if (this.get("drag")) {
            this.$().draggable({
                helper: function() {
                    // correct the current selection in case the user is simultaneously
                    // selecting something and starting to drag it
                    var targetNode = self.get("controller.treeNode");
                    var content = self.get("selectedNodes").get("content");
                    if (content.contains(targetNode)) {
                        // a) when item is already selected (no matter if ctrl or shift is pressed):
                        //    -do nothing special
                    } else {
                        if ((content.length > 0) &&
                            (content.objectAt(0).get("isEbomView") != targetNode.get("isEbomView"))) {
                            // b) when selected items are from different views:
                            //    -clear selection
                            //    -add dragged item to selection
                            content.clear();
                        } else if (self.get("ctrlKeyDown") || self.get("shiftKeyDown")) {
                            // c) when item isn't selected yet and ctrl or shift is pressed:
                            //    -add dragged item to selection
                        } else {
                            // d) when item isn't selected yet and ctrl or shift is not pressed:
                            //    -clear selection
                            //    -add dragged item to selection
                            content.clear();
                        }
                        content.pushObject(targetNode);
                    }
                    // show purpose specific icons
                    if (content.length > 0) {
                        return $('<img>', {'src': self.get('controller.urlpaths.localres') + 'drag&drop.png'});
                    }
                },
                appendTo: "body",
                containment: "#mbom-draggable-containment",
                opacity: 0.9,
                addClasses: false,
                cursor: "none",
                cursorAt: {
                    top: 12,
                    left: 12
                },
                drag: function(event, ui) {
                    // scroll inside right panel. jQueryUI draggable doesn't
                    // support this, so we need to implement it here

                    if (ui.position.left > window.innerWidth / 2) {
                        var second_view = $(".second-view");

                        if (ui.offset.top < $('#mbom-draggable-containment').offset().top + 2) {
                            second_view.scrollTop(second_view.scrollTop() - 10);
                        } else if (ui.offset.top >
                                $('#mbom-draggable-containment').offset().top +
                                $('#mbom-draggable-containment').height() - 27) {
                            second_view.scrollTop(second_view.scrollTop() + 10);
                        }
                    }

                }
            });
        }

        if (this.get("drop")) {
            this.$().droppable({
                activeClass: "drop-active",
                hoverClass: "drop-hover",
                addClasses: false
            });
            this.$().on("drop", function(event, ui) {
                var selectedNodes = self.get("selectedNodes");
                var content = selectedNodes.get("content");
                var targetNode = self.get("controller.treeNode");
                if (targetNode.expanded === undefined) {
                    targetNode = targetNode.get('content');
                }

                var containsTopNode = selectedNodes.get("containsTopNode");

                if (targetNode && selectedNodes && (content.length > 0) && !containsTopNode) {
                    var dropMode = content.objectAt(0).get("isEbomView") ? "copy" : "move";

                    var data = content.map(function(node) {
                        var item = node.get("item");
                        return {
                            parent_node_id: node.get("parent").get("nodeId"),
                            teilenummer: item.get("nr"),
                            t_index: item.get("idx"),
                            position: node.get("position"),
                            variante: node.get("variante"),
                            auswahlmenge: node.get("auswahlmenge"),
                            target_bom_item_baugruppe: targetNode.baugruppe,
                            target_bom_item_b_index: targetNode.b_index,
                            target_bom_item_teilenummer: targetNode.teilenummer,
                            target_bom_item_t_index: targetNode.t_index,
                            target_bom_item_position: targetNode.position,
                            target_bom_item_variante: targetNode.variante,
                            target_bom_item_auswahlmenge: targetNode.auswahlmenge
                        };
                    });

                    if (
                        data.length === 1 &&
                        targetNode.teilenummer === data[0].teilenummer &&
                        targetNode.t_index === data[0].t_index
                    ) { // single drop on same part
                        dropMode = "copy_device_tag";
                    }

                    var url = App.get('apiUrlRoot') +
                        targetNode.get("nodeId") + "/" +
                        dropMode + "/dropitems";

                    App.ajax({
                        url: url,
                        dataType: 'json',
                        data: {bomitems: JSON.stringify(data)},
                        type: 'post',
                        async: true
                    }).then(function(data) {
                        if (data.success) {
                            var treeComponent = self.get('controller.treeComponent');
                            var reloadParent = false;
                            if (dropMode == "copy_device_tag") {
                                var reloadParent = true;
                            }
                            treeComponent.sendAction("refreshBom",
                                    treeComponent,
                                    targetNode,
                                    /*reloadParent=*/ reloadParent);
                            targetNode.expand();
                            if (dropMode == "move") {
                                // FIXME: currently refreshBom doesn't recurse the children of a
                                //        node, but only the immediate children
                                //treeComponent.sendAction("refreshBom",
                                        //treeComponent,
                                        //selectedNodes.get("mostRecentCommonAncestor"));
                                content.forEach(function(node) {
                                    treeComponent.sendAction(
                                        "refreshBom", treeComponent, node,
                                        /*reloadParent=*/ true);
                                });
                            }
                        } else {
                            cdb.elink.alertCDBMessage(data.message);
                        }
                    });
                }
            });
        }
    },

    // Add the click and mouseDown handlers to the selection, which are needed for Drag & Drop
    click: function(event) {
        var selectedNodes = this.get("selectedNodes");
        if (selectedNodes) {
            selectedNodes.click(this.get("treeNode"), event.ctrlKey, event.shiftKey);
        }
    },
    ctrlKeyDown: false,
    shiftKeyDown: false,
    mouseDown: function(event) {
        this.set("ctrlKeyDown", event.ctrlKey);
        this.set("shiftKeyDown", event.shiftKey);
    }
});

App.BomGroupNodeView = Ember.View.extend(
    App.DroppableMixin,
    {
        templateName: 'bomgroupnode',
        classNames: 'bom-tree-node',
        classNameBindings: [
            'isSelected:selected',
            'treeNode.inVariant::not-in-variant'
        ]
});

App.BomComponentNodeView = Ember.View.extend(
    App.DroppableMixin, {
        templateName: 'bomcomponentnode',
        classNames: 'bom-tree-node',
        classNameBindings: [
            'isSelected:selected',
            'treeNode.inVariant::not-in-variant'
        ]
});

App.TreeLoadingView = Ember.View.extend({
    templateName: 'treeloading'
});

App.BomTreeNodeViewSelector = App.TreeNodeViewSelector.create({
    viewFor: function(node) {
        if (node.get('isLoading')) {
            return App.TreeLoadingView;
        }
        return node.get('bomType') == 'group' ? App.BomGroupNodeView : App.BomComponentNodeView;
    }
});
