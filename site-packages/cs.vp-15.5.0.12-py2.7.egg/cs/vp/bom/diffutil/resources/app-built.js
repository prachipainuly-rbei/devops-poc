Ember.TEMPLATES["action-view"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', escapeExpression=this.escapeExpression;


  data.buffer.push("<i ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":tree-action-toggle :icon-caret-right view.expanding:hide")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("\r\n    ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "toggleAction", {hash:{
    'target': ("view")
  },hashTypes:{'target': "ID"},hashContexts:{'target': depth0},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("></i>\r\n<i ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":tree-action-toggle :icon-caret-down view.expanding::hide")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("\r\n    ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "toggleAction", {hash:{
    'target': ("view")
  },hashTypes:{'target': "ID"},hashContexts:{'target': depth0},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("></i>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["application"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1;


  stack1 = helpers._triageMustache.call(depth0, "outlet", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  
});

Ember.TEMPLATES["bomcomponentnode"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, helper, options, escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n    <img class=\"tree-node-object-icon\" ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("treeNode.bomIcon")
  },hashTypes:{'src': "ID"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("/>\r\n");
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n    <img class=\"tree-node-object-icon\" ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("treeNode.item.state_icon")
  },hashTypes:{'src': "ID"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("/>\r\n");
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, "treeNode.bomIcon", {hash:{},hashTypes:{},hashContexts:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  data.buffer.push(escapeExpression((helper = helpers['state-icon'] || (depth0 && depth0['state-icon']),options={hash:{
    'fillColor': ("treeNode.item.state_color")
  },hashTypes:{'fillColor': "ID"},hashContexts:{'fillColor': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "state-icon", options))));
  data.buffer.push(" ");
  stack1 = helpers._triageMustache.call(depth0, "treeNode.description", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  
});

Ember.TEMPLATES["bomgroupnode"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, helper, options, escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n    <img class=\"tree-node-object-icon\" ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("treeNode.bomIcon")
  },hashTypes:{'src': "ID"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("/>\r\n");
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n    <img class=\"tree-node-object-icon\" ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("treeNode.item.state_icon")
  },hashTypes:{'src': "ID"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("/>\r\n");
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, "treeNode.bomIcon", {hash:{},hashTypes:{},hashContexts:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n\r\n");
  data.buffer.push(escapeExpression((helper = helpers['state-icon'] || (depth0 && depth0['state-icon']),options={hash:{
    'fillColor': ("treeNode.item.state_color")
  },hashTypes:{'fillColor': "ID"},hashContexts:{'fillColor': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "state-icon", options))));
  data.buffer.push("\r\n");
  stack1 = helpers._triageMustache.call(depth0, "treeNode.description", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  
});

Ember.TEMPLATES["components/collapsible-block"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n");
  stack1 = helpers['if'].call(depth0, "buttonIcon", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(2, program2, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n");
  stack1 = helpers['if'].call(depth0, "buttonTooltip", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(3, program3, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n<button\r\n    ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":collapsible-button :btn :btn-mini buttonActive:active")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("\r\n    ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "buttonAction", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("\r\n    ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'title': ("buttonTooltip")
  },hashTypes:{'title': "ID"},hashContexts:{'title': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n    <img ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("buttonIcon")
  },hashTypes:{'src': "ID"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("/>\r\n</button>\r\n");
  return buffer;
  }

  data.buffer.push("<i ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":caret-icon expanded:caret-expanded:caret-hidden")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("\r\n    ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "toggleCaret", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("></i>\r\n<div class=\"caret-title\">");
  stack1 = helpers._triageMustache.call(depth0, "blocktitle", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push(" (");
  stack1 = helpers._triageMustache.call(depth0, "diffCount", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push(")</div>\r\n");
  stack1 = helpers['if'].call(depth0, "buttonAction", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n<div ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":collapsbile-content expanded::hide")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n");
  stack1 = helpers._triageMustache.call(depth0, "yield", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</div>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["components/debug-tool"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, helper, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n    <table>\r\n        <thead>\r\n            <th>url</th>\r\n            <th>time</th>\r\n        </thead>\r\n    ");
  stack1 = helpers.each.call(depth0, "entries", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(2, program2, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </table>\r\n");
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n        <tr>\r\n            <td>");
  stack1 = helpers._triageMustache.call(depth0, "url", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("</td>\r\n            <td>");
  stack1 = helpers._triageMustache.call(depth0, "time", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("s</td>\r\n        </tr>\r\n    ");
  return buffer;
  }

  stack1 = (helper = helpers['modal-window'] || (depth0 && depth0['modal-window']),options={hash:{
    'isVisible': (true)
  },hashTypes:{'isVisible': "BOOLEAN"},hashContexts:{'isVisible': depth0},inverse:self.noop,fn:self.program(1, program1, data),contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "modal-window", options));
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  
});

Ember.TEMPLATES["components/diff-table"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, helper, options, escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\n                <b>Filter:</b> ");
  stack1 = helpers._triageMustache.call(depth0, "filter_txt", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\n            ");
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n            ");
  stack1 = helpers['if'].call(depth0, "hasVariants", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(4, program4, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n        ");
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n                <div class=\"context-metadata span10 product-div\" ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'title': ("description")
  },hashTypes:{'title': "ID"},hashContexts:{'title': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n                    ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "Ember.Select", {hash:{
    'class': ("diff-table-select"),
    'content': ("products"),
    'selection': ("product"),
    'optionLabelPath': ("content.description"),
    'prompt': (" ")
  },hashTypes:{'class': "STRING",'content': "ID",'selection': "ID",'optionLabelPath': "STRING",'prompt': "STRING"},hashContexts:{'class': depth0,'content': depth0,'selection': depth0,'optionLabelPath': depth0,'prompt': depth0},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push("\r\n\r\n                    ");
  stack1 = helpers.unless.call(depth0, "selectVariant", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(5, program5, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n\r\n                    <span class=\"variant-description\">\r\n                    ");
  stack1 = helpers['if'].call(depth0, "variant", {hash:{},hashTypes:{},hashContexts:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n                    </span>\r\n                </div>\r\n            ");
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n                        <button accesskey=\"v\"\r\n                            ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': ("modalActive:active: :btn :variant-button"),
    'title': ("labels.cdbvp_elink_diffutils_select_variant")
  },hashTypes:{'class': "STRING",'title': "ID"},hashContexts:{'class': depth0,'title': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("\r\n                            ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "showModalWindow", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push(">\r\n                                <img ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("catalogIcon")
  },hashTypes:{'src': "ID"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(" ></button>\r\n                    ");
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n                        ");
  stack1 = helpers._triageMustache.call(depth0, "variant.description", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n                    ");
  return buffer;
  }

function program9(depth0,data) {
  
  
  data.buffer.push("\r\n                        -\r\n                    ");
  }

function program11(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n          <div class=\"alert inplace alert-warning\">\r\n              ");
  stack1 = helpers._triageMustache.call(depth0, "errorMessage", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n          </div>\r\n      ");
  return buffer;
  }

  data.buffer.push("<div class=\"diff-table-toolbar\">\r\n    <div class=\"half-column lhs row-fluid\">\r\n        <div class=\"span4\">\r\n            ");
  data.buffer.push(escapeExpression((helper = helpers.input || (depth0 && depth0.input),options={hash:{
    'type': ("text"),
    'value': ("filterText"),
    'class': ("search_field"),
    'placeholder': ("labels.cdbvp_elink_diffutils_filter")
  },hashTypes:{'type': "STRING",'value': "ID",'class': "STRING",'placeholder': "ID"},hashContexts:{'type': depth0,'value': depth0,'class': depth0,'placeholder': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "input", options))));
  data.buffer.push("\n        </div>\n        <div class=\"span2\">\n            <div class=\"diff-table-filter-btns btn-group\">\n                ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "diffTableButton", {hash:{
    'classNames': ("show-assemblies-button"),
    'title': ("labels.cdbvp_bom_show_assemblies"),
    'icon': ("assembly.png"),
    'value': ("showAssemblies")
  },hashTypes:{'classNames': "STRING",'title': "ID",'icon': "STRING",'value': "ID"},hashContexts:{'classNames': depth0,'title': depth0,'icon': depth0,'value': depth0},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("\r\n\r\n                ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "diffTableButton", {hash:{
    'title': ("labels.cdbvp_bom_show_leaves"),
    'classNames': ("show-components-button"),
    'icon': ("component.png"),
    'value': ("showLeaves")
  },hashTypes:{'title': "ID",'classNames': "STRING",'icon': "STRING",'value': "ID"},hashContexts:{'title': depth0,'classNames': depth0,'icon': depth0,'value': depth0},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("\n            </div>\n        </div>\n        <div class=\"span6\">\n            ");
  stack1 = helpers['if'].call(depth0, "filter_txt", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\n        </div>\n    </div>\n    <div class=\"half-column rhs with-padding\">\n        <button type=\"button\"\n            ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":btn :\n            btn-default :link-table-button linked:active")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("\n            ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'title': ("labels.cdbvp_elink_diffutils_update_table")
  },hashTypes:{'title': "ID"},hashContexts:{'title': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("\n            ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "toogleLink", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("\n            ><i class=\"icon-link icon-large\"></i></button>\n        ");
  stack1 = helpers['if'].call(depth0, "hasProducts", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(3, program3, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </div>\r\n</div>\r\n<div class=\"row-fluid\">\r\n    <div class=\"span12 table_container\">\r\n\r\n        ");
  data.buffer.push(escapeExpression((helper = helpers['ember-table'] || (depth0 && depth0['ember-table']),options={hash:{
    'columns': ("columns"),
    'content': ("filteredContent"),
    'selection': ("selectedItem"),
    'sortAction': ("sort"),
    'rowHeight': (16),
    'ignorePart': ("ignorePart"),
    'ignoreDifference': ("ignoreDifference"),
    'deleteIgnore': ("deleteIgnore")
  },hashTypes:{'columns': "ID",'content': "ID",'selection': "ID",'sortAction': "STRING",'rowHeight': "INTEGER",'ignorePart': "STRING",'ignoreDifference': "STRING",'deleteIgnore': "STRING"},hashContexts:{'columns': depth0,'content': depth0,'selection': depth0,'sortAction': depth0,'rowHeight': depth0,'ignorePart': depth0,'ignoreDifference': depth0,'deleteIgnore': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "ember-table", options))));
  data.buffer.push("\r\n\r\n      ");
  stack1 = helpers.unless.call(depth0, "content.length", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(11, program11, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </div>\r\n</div>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["components/generic-table-td"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var stack1, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n	<img ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("value")
  },hashTypes:{'src': "ID"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("/>\r\n");
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n	");
  stack1 = helpers._triageMustache.call(depth0, "value", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, "isImage", {hash:{},hashTypes:{},hashContexts:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  else { data.buffer.push(''); }
  
});

Ember.TEMPLATES["components/generic-table"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n          <div class=\"alert inplace alert-warning\">\r\n              ");
  stack1 = helpers._triageMustache.call(depth0, "errorMessage", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n          </div>\r\n      ");
  return buffer;
  }

  data.buffer.push("<div class=\"group-label\">\r\n");
  stack1 = helpers._triageMustache.call(depth0, "title", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</div>\r\n<div class=\"row-fluid\">\r\n	<div class=\"span12\">\r\n	<form class=\"filter_form\">\r\n		");
  data.buffer.push(escapeExpression((helper = helpers.input || (depth0 && depth0.input),options={hash:{
    'type': ("text"),
    'value': ("filterText"),
    'class': ("search_field"),
    'placeholder': ("filter_placeholder")
  },hashTypes:{'type': "STRING",'value': "ID",'class': "STRING",'placeholder': "ID"},hashContexts:{'type': depth0,'value': depth0,'class': depth0,'placeholder': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "input", options))));
  data.buffer.push("\r\n	</form>\r\n	</div>\r\n</div>\r\n<div class=\"row-fluid\">\r\n	<div class=\"span12 table_container\">\r\n      ");
  data.buffer.push(escapeExpression((helper = helpers['ember-table'] || (depth0 && depth0['ember-table']),options={hash:{
    'columns': ("columns"),
    'content': ("content"),
    'selection': ("selection"),
    'rowHeight': ("rowHeight"),
    'numFixedColumns': ("numFixedColumns")
  },hashTypes:{'columns': "ID",'content': "ID",'selection': "ID",'rowHeight': "ID",'numFixedColumns': "ID"},hashContexts:{'columns': depth0,'content': depth0,'selection': depth0,'rowHeight': depth0,'numFixedColumns': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "ember-table", options))));
  data.buffer.push("\r\n      ");
  stack1 = helpers.unless.call(depth0, "content.length", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n	</div>\r\n</div>");
  return buffer;
  
});

Ember.TEMPLATES["components/modal-window"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n    <button ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "buttonTriggered", "button.action", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0,depth0],types:["STRING","ID"],data:data})));
  data.buffer.push(" aria-hidden=\"true\" ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': ("button.classes")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">");
  stack1 = helpers._triageMustache.call(depth0, "button.label", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("</button>\r\n  	");
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n    <button ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "buttonTriggered", "button.action", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0,depth0],types:["STRING","ID"],data:data})));
  data.buffer.push(" aria-hidden=\"true\" ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': ("button.classes")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">");
  stack1 = helpers._triageMustache.call(depth0, "button.label", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("</button>\r\n  ");
  return buffer;
  }

  data.buffer.push("<div class=\"modal-header\">\r\n    ");
  stack1 = helpers.each.call(depth0, "button", "in", "header_buttons", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(1, program1, data),contexts:[depth0,depth0,depth0],types:["ID","ID","ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    <div class=\"modal-header-slot\">\r\n      ");
  stack1 = helpers._triageMustache.call(depth0, "header", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </div>\r\n</div>\r\n<div class=\"modal-body\">\r\n  ");
  stack1 = helpers._triageMustache.call(depth0, "yield", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</div>\r\n<div class=\"modal-footer\">\r\n  ");
  stack1 = helpers._triageMustache.call(depth0, "footer", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n  ");
  stack1 = helpers.each.call(depth0, "button", "in", "footer_buttons", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(3, program3, data),contexts:[depth0,depth0,depth0],types:["ID","ID","ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</div>\r\n\r\n");
  return buffer;
  
});

Ember.TEMPLATES["components/preview-control"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n<div class=\"btn-group\">\r\n    <a ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":btn :btn-mini preview3D:active"),
    'title': ("labels.cdbvp_elink_diffutil_open_3d_preview")
  },hashTypes:{'class': "STRING",'title': "STRING"},hashContexts:{'class': depth0,'title': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("\r\n        ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "setPreviewMode", "3D", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0,depth0],types:["ID","STRING"],data:data})));
  data.buffer.push("\r\n        role=\"button\">3D</a>\r\n    <a ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":btn :btn-mini preview2D:active"),
    'title': ("labels.cdbvp_elink_diffutil_open_2d_preview")
  },hashTypes:{'class': "STRING",'title': "STRING"},hashContexts:{'class': depth0,'title': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("\r\n        ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "setPreviewMode", "2D", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0,depth0],types:["ID","STRING"],data:data})));
  data.buffer.push("\r\n        role=\"button\">2D</a>\r\n\r\n    ");
  stack1 = helpers['if'].call(depth0, "csThreedInstalled", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(2, program2, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</div>\r\n<div class=\"preview-control-label\">\r\n    ");
  stack1 = helpers._triageMustache.call(depth0, "toplabel", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</div>\r\n<div class=\"refresh pull-left\" style=\"margin-right:10px;\" ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'title': ("labels.cdbvp_elink_diffutil_refresh")
  },hashTypes:{'title': "STRING"},hashContexts:{'title': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n    <i class=\"icon-refresh\" style=\"vertical-align: bottom;\" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "refreshAll", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("></i>\r\n</div>\r\n");
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n    <a ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":btn :btn-mini preview3Dcockpit:active"),
    'href': ("threedSynchUrl"),
    'title': ("labels.cdbvp_elink_diffutil_open_synched_cockpit")
  },hashTypes:{'class': "STRING",'href': "STRING",'title': "STRING"},hashContexts:{'class': depth0,'href': depth0,'title': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("\r\n        role=\"button\"\r\n        target=\"_threed\"\r\n        id=\"sync-threed-button\">\r\n        <img ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("sync3DIcon")
  },hashTypes:{'src': "STRING"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(" />\r\n    </a>\r\n    ");
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, "showPreviewControls", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  
});

Ember.TEMPLATES["components/state-icon"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', escapeExpression=this.escapeExpression;


  data.buffer.push("<div class=\"state-icon\" ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'style': ("iconStyle")
  },hashTypes:{'style': "STRING"},hashContexts:{'style': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("></div>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["components/tree-view-button"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n            <img class=\"op-button-icon\"");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("selectedOperation.icon")
  },hashTypes:{'src': "ID"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(" />");
  stack1 = helpers._triageMustache.call(depth0, "selectedOperation.label", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n        ");
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n            ");
  stack1 = helpers._triageMustache.call(depth0, "labels.cdbvp_elink_diffutils_operations", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n        ");
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n            <li class=\"head\">");
  stack1 = helpers._triageMustache.call(depth0, "labels.cdbvp_elink_diffutils_item_ops", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("</li>\r\n            ");
  stack1 = helpers.each.call(depth0, "operation", "in", "_operations.item", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(6, program6, data),contexts:[depth0,depth0,depth0],types:["ID","ID","ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n       ");
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n                ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "App.TreeViewOperationView", {hash:{
    'operation': ("operation"),
    'optype': ("item")
  },hashTypes:{'operation': "ID",'optype': "STRING"},hashContexts:{'operation': depth0,'optype': depth0},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push("\r\n            ");
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n           <li class=\"head\">");
  stack1 = helpers._triageMustache.call(depth0, "labels.cdbvp_elink_diffutils_bom_item_ops", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("</li>\r\n           ");
  stack1 = helpers.each.call(depth0, "operation", "in", "_operations.bom", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(9, program9, data),contexts:[depth0,depth0,depth0],types:["ID","ID","ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n       ");
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n               ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "App.TreeViewOperationView", {hash:{
    'operation': ("operation"),
    'optype': ("bom")
  },hashTypes:{'operation': "ID",'optype': "STRING"},hashContexts:{'operation': depth0,'optype': depth0},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push("\r\n           ");
  return buffer;
  }

  data.buffer.push("<div class=\"btn-group pull-right dropdown\" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "addNodeToSelection", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push(">\r\n    <button ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":btn :btn-mini :op-button")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "executeOperation", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push(">\r\n        ");
  stack1 = helpers['if'].call(depth0, "selectedOperation", {hash:{},hashTypes:{},hashContexts:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </button>\r\n    <button ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":btn :btn-mini :dropup-button :dropdown-toggle")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "adjustMenu", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push(" data-toggle=\"dropdown\">\r\n        <span class=\"caret\"></span>\r\n    </button>\r\n    <ul class=\"dropdown-menu btn-mini drop-menu\">\r\n        ");
  stack1 = helpers['if'].call(depth0, "_operations.item.length", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(5, program5, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n       ");
  stack1 = helpers['if'].call(depth0, "_operations.bom.length", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(8, program8, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </ul>\r\n</div>\r\n<div class=\"no-float\"></div>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["components/tree-view-node"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '', helper, options;
  data.buffer.push("\r\n            \r\n            ");
  data.buffer.push(escapeExpression((helper = helpers['tree-view-button'] || (depth0 && depth0['tree-view-button']),options={hash:{
    'rootNode': ("treeNode"),
    'selectedNodes': ("selectedNodes"),
    'selectedNode': ("selectedNode"),
    'operations': ("treeNode.operations"),
    'refreshBom': ("refreshBom"),
    'treeComponent': (""),
    'treeNode': ("treeNode"),
    'selectedOperationName': ("selectedOperationName"),
    'selectedOperationContext': ("selectedOperationContext")
  },hashTypes:{'rootNode': "ID",'selectedNodes': "ID",'selectedNode': "ID",'operations': "ID",'refreshBom': "STRING",'treeComponent': "ID",'treeNode': "ID",'selectedOperationName': "ID",'selectedOperationContext': "ID"},hashContexts:{'rootNode': depth0,'selectedNodes': depth0,'selectedNode': depth0,'operations': depth0,'refreshBom': depth0,'treeComponent': depth0,'treeNode': depth0,'selectedOperationName': depth0,'selectedOperationContext': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "tree-view-button", options))));
  data.buffer.push("\r\n        ");
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n        ");
  stack1 = helpers['if'].call(depth0, "treeNode.expanded", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(4, program4, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    ");
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n            ");
  stack1 = helpers['if'].call(depth0, "treeNode.predicates", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(5, program5, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n        ");
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n                ");
  stack1 = helpers.each.call(depth0, "predicate", "in", "treeNode.predicates", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(6, program6, data),contexts:[depth0,depth0,depth0],types:["ID","ID","ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n            ");
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = '', helper, options;
  data.buffer.push("\r\n                    ");
  data.buffer.push(escapeExpression((helper = helpers['tree-view-predicate'] || (depth0 && depth0['tree-view-predicate']),options={hash:{
    'predicate': ("predicate")
  },hashTypes:{'predicate': "ID"},hashContexts:{'predicate': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "tree-view-predicate", options))));
  data.buffer.push("\r\n                ");
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n        ");
  stack1 = helpers['if'].call(depth0, "cldNode.visible", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(9, program9, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    ");
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = '', helper, options;
  data.buffer.push("\r\n            ");
  data.buffer.push(escapeExpression((helper = helpers['tree-view-node'] || (depth0 && depth0['tree-view-node']),options={hash:{
    'treeNode': ("cldNode"),
    'treeComponent': ("treeComponent"),
    'selectedNodes': ("selectedNodes"),
    'viewSelector': ("viewSelector"),
    'expandLevel': ("nextExpandLevel"),
    'findNode': ("findNode"),
    'treeSearches': ("treeSearches"),
    'drag': ("drag"),
    'drop': ("drop"),
    'selectedOperationName': ("selectedOperationName"),
    'selectedOperationContext': ("selectedOperationContext")
  },hashTypes:{'treeNode': "ID",'treeComponent': "ID",'selectedNodes': "ID",'viewSelector': "ID",'expandLevel': "ID",'findNode': "ID",'treeSearches': "ID",'drag': "ID",'drop': "ID",'selectedOperationName': "ID",'selectedOperationContext': "ID"},hashContexts:{'treeNode': depth0,'treeComponent': depth0,'selectedNodes': depth0,'viewSelector': depth0,'expandLevel': depth0,'findNode': depth0,'treeSearches': depth0,'drag': depth0,'drop': depth0,'selectedOperationName': depth0,'selectedOperationContext': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "tree-view-node", options))));
  data.buffer.push("\r\n        ");
  return buffer;
  }

  data.buffer.push("<div ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":tree-action hasChildren::invisible :pull-left")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n    ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "actionView", {hash:{
    'expandingBinding': ("treeNode.expanded")
  },hashTypes:{'expandingBinding': "STRING"},hashContexts:{'expandingBinding': depth0},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push("\r\n</div>\r\n<div class=\"tree-node-structure\">\r\n    <div  ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":tree-current-node isSelectable:tree-selectable isHit:node-found isNavigated:node-navigated treeCssClasses"),
    'title': ("treeNode.tooltip")
  },hashTypes:{'class': "STRING",'title': "STRING"},hashContexts:{'class': depth0,'title': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "toggleButtonVisibility", {hash:{
    'on': ("mouseEnter")
  },hashTypes:{'on': "STRING"},hashContexts:{'on': depth0},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push(">\r\n        ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "treeNodeView", {hash:{
    'treeComponent': ("treeComponent"),
    'drag': ("drag"),
    'drop': ("drop"),
    'treeNode': ("treeNode"),
    'isSelected': ("isSelected"),
    'selectedNodesBinding': ("selectedNodes")
  },hashTypes:{'treeComponent': "ID",'drag': "ID",'drop': "ID",'treeNode': "ID",'isSelected': "ID",'selectedNodesBinding': "STRING"},hashContexts:{'treeComponent': depth0,'drag': depth0,'drop': depth0,'treeNode': depth0,'isSelected': depth0,'selectedNodesBinding': depth0},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push("\r\n\r\n        ");
  stack1 = helpers['if'].call(depth0, "buttonVisible", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </div>\r\n    <div class=\"tree-child-nodes collapse\">\r\n    ");
  stack1 = helpers['if'].call(depth0, "treeNode.hasPredicates", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(3, program3, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    ");
  stack1 = helpers.each.call(depth0, "cldNode", "in", "treeNode.renderContent", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(8, program8, data),contexts:[depth0,depth0,depth0],types:["ID","ID","ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </div>\r\n</div>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["components/tree-view-predicate"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression;


  data.buffer.push("<div class=\"tree-node-structure\">\r\n    <img ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("predicate.icon"),
    'class': (":tree-node-object-icon")
  },hashTypes:{'src': "ID",'class': "STRING"},hashContexts:{'src': depth0,'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("/> ");
  stack1 = helpers._triageMustache.call(depth0, "predicate.text", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</div>");
  return buffer;
  
});

Ember.TEMPLATES["components/tree-view-toolbar"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, helper, options, escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n            ");
  stack1 = helpers['if'].call(depth0, "treeSearch.showNavigation", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(2, program2, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n        ");
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n                ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "navigationView", {hash:{
    'treeSearchBinding': ("treeSearch"),
    'classNameBindings': ("treeSearch.cssClass"),
    'classNames': ("tree-search-navigation")
  },hashTypes:{'treeSearchBinding': "STRING",'classNameBindings': "STRING",'classNames': "STRING"},hashContexts:{'treeSearchBinding': depth0,'classNameBindings': depth0,'classNames': depth0},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push("\r\n            ");
  return buffer;
  }

  data.buffer.push("<div class=\"row-fluid\">\r\n    <div class=\"span4\">\r\n        <div class=\"tree-view-toolbar\">\r\n            <form ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "searchBOM", "", {hash:{
    'on': ("submit")
  },hashTypes:{'on': "STRING"},hashContexts:{'on': depth0},contexts:[depth0,depth0],types:["STRING","ID"],data:data})));
  data.buffer.push(">\r\n                ");
  data.buffer.push(escapeExpression((helper = helpers.input || (depth0 && depth0.input),options={hash:{
    'type': ("text"),
    'value': ("searchStringValue"),
    'placeholder': ("labels.cdbvp_elink_diffutils_search")
  },hashTypes:{'type': "STRING",'value': "ID",'placeholder': "ID"},hashContexts:{'type': depth0,'value': depth0,'placeholder': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "input", options))));
  data.buffer.push("\r\n            </form>\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"span8 tree-view-navigator\">\r\n        ");
  stack1 = helpers.each.call(depth0, "treeSearch", "in", "sortedTreeSearches", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(1, program1, data),contexts:[depth0,depth0,depth0],types:["ID","ID","ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </div>\r\n</div>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["components/tree-view"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  data.buffer.push(escapeExpression((helper = helpers['tree-view-node'] || (depth0 && depth0['tree-view-node']),options={hash:{
    'treeNodeBinding': ("treeNode"),
    'treeComponent': (""),
    'viewSelectorBinding': ("viewSelector"),
    'expandLevelBinding': ("expandLevel"),
    'findNodeBinding': ("findNode"),
    'expandParent': ("expandParent"),
    'treeSearchesBinding': ("treeSearches"),
    'drag': ("drag"),
    'drop': ("drop"),
    'rootNode': ("treeNode"),
    'selectedNodesBinding': ("selectedNodes"),
    'selectedNodeBinding': ("selectedNode"),
    'operationsBinding': ("operations"),
    'refreshBom': ("refreshBom"),
    'treeComponent': ("")
  },hashTypes:{'treeNodeBinding': "STRING",'treeComponent': "ID",'viewSelectorBinding': "STRING",'expandLevelBinding': "STRING",'findNodeBinding': "STRING",'expandParent': "STRING",'treeSearchesBinding': "STRING",'drag': "ID",'drop': "ID",'rootNode': "ID",'selectedNodesBinding': "STRING",'selectedNodeBinding': "STRING",'operationsBinding': "STRING",'refreshBom': "STRING",'treeComponent': "ID"},hashContexts:{'treeNodeBinding': depth0,'treeComponent': depth0,'viewSelectorBinding': depth0,'expandLevelBinding': depth0,'findNodeBinding': depth0,'expandParent': depth0,'treeSearchesBinding': depth0,'drag': depth0,'drop': depth0,'rootNode': depth0,'selectedNodesBinding': depth0,'selectedNodeBinding': depth0,'operationsBinding': depth0,'refreshBom': depth0,'treeComponent': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "tree-view-node", options))));
  data.buffer.push("\r\n");
  return buffer;
  
});

Ember.TEMPLATES["diff-table-button"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', escapeExpression=this.escapeExpression;


  data.buffer.push("<img ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("view.iconUrl")
  },hashTypes:{'src': "ID"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n");
  return buffer;
  
});

Ember.TEMPLATES["diffheadercell"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '', stack1, helper, options;
  data.buffer.push("\r\n            <a href=\"#\" data-toggle=\"dropdown\" class=\"dropdown pull-right filter-menu\" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "adjustMenu", {hash:{
    'target': ("view")
  },hashTypes:{'target': "ID"},hashContexts:{'target': depth0},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push(">\r\n                <span><i class=\"icon-filter\"></i></span>\r\n            </a>\r\n            <ul class=\"dropdown-menu drop-menu\">\r\n                <li>");
  data.buffer.push(escapeExpression((helper = helpers.input || (depth0 && depth0.input),options={hash:{
    'type': ("checkbox"),
    'checked': ("view.allChecked"),
    'indeterminate': ("view.isIndeterminate")
  },hashTypes:{'type': "STRING",'checked': "ID",'indeterminate': "ID"},hashContexts:{'type': depth0,'checked': depth0,'indeterminate': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "input", options))));
  data.buffer.push("\r\n                    ");
  stack1 = helpers._triageMustache.call(depth0, "labels.cdbvp_elink_diffutil_all", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("</li>\r\n                <li class=\"divider\"></li>\r\n                ");
  stack1 = helpers.each.call(depth0, "value", "in", "view.filterValues", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(2, program2, data),contexts:[depth0,depth0,depth0],types:["ID","ID","ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n            </ul>\r\n        ");
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = '', stack1, helper, options;
  data.buffer.push("\r\n                    <li>");
  data.buffer.push(escapeExpression((helper = helpers.input || (depth0 && depth0.input),options={hash:{
    'type': ("checkbox"),
    'checked': ("value.checked")
  },hashTypes:{'type': "STRING",'checked': "ID"},hashContexts:{'type': depth0,'checked': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "input", options))));
  stack1 = helpers._triageMustache.call(depth0, "value.value", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("</li>\r\n                ");
  return buffer;
  }

  data.buffer.push("<div ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': ("view.content.contentPath :ember-table-content-container")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n    <span class=\"ember-table-content\">\r\n        <div class=\"sortIcon\" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "sortByColumn", {hash:{
    'target': ("view")
  },hashTypes:{'target': "ID"},hashContexts:{'target': depth0},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push(">\r\n            ");
  stack1 = helpers._triageMustache.call(depth0, "view.sortIcon", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n        </div>\r\n        ");
  stack1 = helpers._triageMustache.call(depth0, "view.content.headerCellName", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n\r\n        ");
  stack1 = helpers['if'].call(depth0, "view.filterValues", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </span>\r\n</div>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["header-raw-cell"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression;


  data.buffer.push("<div ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': ("view.content.contentPath :ember-table-content-container")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n    <span class=\"ember-table-content\">\r\n        ");
  stack1 = helpers._triageMustache.call(depth0, "view.content.headerCellName", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </span>\r\n</div>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["loading"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '';


  return buffer;
  
});

Ember.TEMPLATES["main"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '', helper, options;
  data.buffer.push("\r\n    <div class=\"row-fluid diffutil-prv-tbar-row row-layout header\">\r\n        ");
  data.buffer.push(escapeExpression((helper = helpers['preview-control'] || (depth0 && depth0['preview-control']),options={hash:{
    'csThreedInstalled': ("csThreedInstalled"),
    'threedUrl': ("threedUrl"),
    'linkBinding': ("previewLink"),
    'titleBinding': ("previewItem.nr"),
    'descriptionBinding': ("previewItem.description"),
    'placeholder': ("controller.labels.cdbvp_elink_diffutils_preview"),
    'previewMode': ("previewMode"),
    'showPreviewControls': (true),
    'refreshAll': ("refreshAll")
  },hashTypes:{'csThreedInstalled': "ID",'threedUrl': "ID",'linkBinding': "STRING",'titleBinding': "STRING",'descriptionBinding': "STRING",'placeholder': "ID",'previewMode': "ID",'showPreviewControls': "BOOLEAN",'refreshAll': "STRING"},hashContexts:{'csThreedInstalled': depth0,'threedUrl': depth0,'linkBinding': depth0,'titleBinding': depth0,'descriptionBinding': depth0,'placeholder': depth0,'previewMode': depth0,'showPreviewControls': depth0,'refreshAll': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "preview-control", options))));
  data.buffer.push("\r\n    </div>\r\n");
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = '', stack1, helper, options;
  data.buffer.push("\r\n    ");
  data.buffer.push(escapeExpression((helper = helpers['preview-control'] || (depth0 && depth0['preview-control']),options={hash:{
    'showPreviewControls': (false)
  },hashTypes:{'showPreviewControls': "BOOLEAN"},hashContexts:{'showPreviewControls': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "preview-control", options))));
  data.buffer.push("\r\n    <div class=\"alert inplace alert-warning preview-warning\">\r\n    ");
  stack1 = helpers['if'].call(depth0, "hasMultipleMBOMs", {hash:{},hashTypes:{},hashContexts:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </div>\r\n");
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n        ");
  stack1 = helpers._triageMustache.call(depth0, "controller.labels.cdbvp_elink_diffutils_mbom_select", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    ");
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n        ");
  stack1 = helpers._triageMustache.call(depth0, "controller.labels.cdbvp_elink_diffutils_mbom_no_mbom_available", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    ");
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n            <div class=\"diffutil-treeview-tbar-row row-layout body\">\r\n                <div class=\"half-column lhs\">\r\n                    ");
  stack1 = helpers['if'].call(depth0, "lRootNode.isFulfilled", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(9, program9, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n                </div>\r\n                <div class=\"half-column rhs with-padding\">\r\n                    ");
  stack1 = helpers['if'].call(depth0, "rRootNode.isFulfilled", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(11, program11, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n                </div>\r\n            </div>\r\n            <div id=\"mbom-draggable-containment\" class=\"row-fluid diffutil-treeview-row row-layout body\">\r\n                ");
  stack1 = helpers['if'].call(depth0, "lRootNode.nodeId", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(13, program13, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n            </div>\r\n        ");
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = '', helper, options;
  data.buffer.push("\r\n                        ");
  data.buffer.push(escapeExpression((helper = helpers['tree-view-toolbar'] || (depth0 && depth0['tree-view-toolbar']),options={hash:{
    'treeNode': ("lRootNode"),
    'showNavigation': (true),
    'viewSelector': ("App.BomTreeNodeViewSelector"),
    'treeSearches': ("lTreeSearches"),
    'searchString': ("lSearchString")
  },hashTypes:{'treeNode': "ID",'showNavigation': "BOOLEAN",'viewSelector': "ID",'treeSearches': "ID",'searchString': "ID"},hashContexts:{'treeNode': depth0,'showNavigation': depth0,'viewSelector': depth0,'treeSearches': depth0,'searchString': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "tree-view-toolbar", options))));
  data.buffer.push("\r\n                    ");
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = '', helper, options;
  data.buffer.push("\r\n                        ");
  data.buffer.push(escapeExpression((helper = helpers['tree-view-toolbar'] || (depth0 && depth0['tree-view-toolbar']),options={hash:{
    'treeNode': ("rRootNode"),
    'treeSearches': ("rTreeSearches"),
    'searchString': ("rSearchString")
  },hashTypes:{'treeNode': "ID",'treeSearches': "ID",'searchString': "ID"},hashContexts:{'treeNode': depth0,'treeSearches': depth0,'searchString': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "tree-view-toolbar", options))));
  data.buffer.push("\r\n                    ");
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = '', helper, options;
  data.buffer.push("\r\n                    <div class=\"half-column lhs\">\r\n                        ");
  data.buffer.push(escapeExpression((helper = helpers['tree-view'] || (depth0 && depth0['tree-view']),options={hash:{
    'classNames': ("first-view"),
    'selectedNodesBinding': ("selectedNodes"),
    'selectedNodeBinding': ("selectedNode"),
    'operationsBinding': ("operations"),
    'treeNodeBinding': ("lRootNode"),
    'treeViewTitle': ("controller.labels.cdbvp_elink_diffutils_left_bom"),
    'viewSelector': ("App.BomTreeNodeViewSelector"),
    'expandLevel': ("expandLevelLeft"),
    'findNodeBinding': ("selectedItem.item_object_id"),
    'showNavigation': (true),
    'refreshBom': ("refreshBom"),
    'nodeClicked': ("nodeClicked"),
    'triggerSync': ("triggerSync"),
    'drag': (true),
    'treeSearches': ("lTreeSearches")
  },hashTypes:{'classNames': "STRING",'selectedNodesBinding': "STRING",'selectedNodeBinding': "STRING",'operationsBinding': "STRING",'treeNodeBinding': "STRING",'treeViewTitle': "ID",'viewSelector': "ID",'expandLevel': "ID",'findNodeBinding': "STRING",'showNavigation': "BOOLEAN",'refreshBom': "STRING",'nodeClicked': "STRING",'triggerSync': "STRING",'drag': "BOOLEAN",'treeSearches': "ID"},hashContexts:{'classNames': depth0,'selectedNodesBinding': depth0,'selectedNodeBinding': depth0,'operationsBinding': depth0,'treeNodeBinding': depth0,'treeViewTitle': depth0,'viewSelector': depth0,'expandLevel': depth0,'findNodeBinding': depth0,'showNavigation': depth0,'refreshBom': depth0,'nodeClicked': depth0,'triggerSync': depth0,'drag': depth0,'treeSearches': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "tree-view", options))));
  data.buffer.push("\r\n                    </div>\r\n                    <div class=\"half-column rhs\">\r\n                        <div class=\"btn sync\" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "triggerSync", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("><img ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("sync_view_icon")
  },hashTypes:{'src': "ID"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("></div>\r\n                        ");
  data.buffer.push(escapeExpression((helper = helpers['tree-view'] || (depth0 && depth0['tree-view']),options={hash:{
    'classNames': ("second-view"),
    'selectedNodesBinding': ("selectedNodes"),
    'selectedNodeBinding': ("selectedNode"),
    'operationsBinding': ("operations"),
    'treeNodeBinding': ("rRootNode"),
    'treeViewTitle': ("controller.labels.cdbvp_elink_diffutils_right_bom"),
    'viewSelector': ("App.BomTreeNodeViewSelector"),
    'expandLevel': ("expandLevelRight"),
    'findNodeBinding': ("selectedItem.item_object_id"),
    'showNavigation': (true),
    'refreshBom': ("refreshBom"),
    'nodeClicked': ("nodeClicked"),
    'drag': (true),
    'drop': (true),
    'treeSearches': ("rTreeSearches")
  },hashTypes:{'classNames': "STRING",'selectedNodesBinding': "STRING",'selectedNodeBinding': "STRING",'operationsBinding': "STRING",'treeNodeBinding': "STRING",'treeViewTitle': "ID",'viewSelector': "ID",'expandLevel': "ID",'findNodeBinding': "STRING",'showNavigation': "BOOLEAN",'refreshBom': "STRING",'nodeClicked': "STRING",'drag': "BOOLEAN",'drop': "BOOLEAN",'treeSearches': "ID"},hashContexts:{'classNames': depth0,'selectedNodesBinding': depth0,'selectedNodeBinding': depth0,'operationsBinding': depth0,'treeNodeBinding': depth0,'treeViewTitle': depth0,'viewSelector': depth0,'expandLevel': depth0,'findNodeBinding': depth0,'showNavigation': depth0,'refreshBom': depth0,'nodeClicked': depth0,'drag': depth0,'drop': depth0,'treeSearches': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "tree-view", options))));
  data.buffer.push("\r\n                    </div>\r\n                ");
  return buffer;
  }

function program15(depth0,data) {
  
  var buffer = '', stack1, helper, options;
  data.buffer.push("\r\n    ");
  stack1 = (helper = helpers['collapsible-block'] || (depth0 && depth0['collapsible-block']),options={hash:{
    'blocktitle': ("labels.cdbvp_elink_diffutils_differences"),
    'classNames': ("diffutil row-layout footer diff-table-row"),
    'expanded': ("tableExpanded"),
    'diffCount': ("ndiffs")
  },hashTypes:{'blocktitle': "ID",'classNames': "STRING",'expanded': "ID",'diffCount': "ID"},hashContexts:{'blocktitle': depth0,'classNames': depth0,'expanded': depth0,'diffCount': depth0},inverse:self.noop,fn:self.program(16, program16, data),contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "collapsible-block", options));
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  }
function program16(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n        ");
  stack1 = helpers['if'].call(depth0, "rRootNode.nodeId", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(17, program17, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\n    ");
  return buffer;
  }
function program17(depth0,data) {
  
  var buffer = '', helper, options;
  data.buffer.push("\r\n            <div class=\"diffutil-table-row\">\r\n                <div ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': ("span12")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n                    ");
  data.buffer.push(escapeExpression((helper = helpers['diff-table'] || (depth0 && depth0['diff-table']),options={hash:{
    'selectedItem': ("selectedItem"),
    'content': ("differences"),
    'headerContent': ("diffHeaderContent"),
    'hasProducts': ("hasProducts"),
    'hasVariants': ("hasVariants"),
    'selectVariant': ("selectVariant"),
    'product': ("product"),
    'products': ("products"),
    'variant': ("variant"),
    'linked': ("tableLinked"),
    'showModalWindow': ("showModalWindow"),
    'errorMessage': ("labels.cdbvp_elink_diffutils_no_differences"),
    'tableSizeChange': ("tableExpanded"),
    'ignore': ("ignoreDifference"),
    'deleteIgnore': ("deleteIgnore"),
    'filter_txt': ("filter_txt")
  },hashTypes:{'selectedItem': "ID",'content': "ID",'headerContent': "ID",'hasProducts': "ID",'hasVariants': "ID",'selectVariant': "ID",'product': "ID",'products': "ID",'variant': "ID",'linked': "ID",'showModalWindow': "STRING",'errorMessage': "ID",'tableSizeChange': "ID",'ignore': "STRING",'deleteIgnore': "STRING",'filter_txt': "ID"},hashContexts:{'selectedItem': depth0,'content': depth0,'headerContent': depth0,'hasProducts': depth0,'hasVariants': depth0,'selectVariant': depth0,'product': depth0,'products': depth0,'variant': depth0,'linked': depth0,'showModalWindow': depth0,'errorMessage': depth0,'tableSizeChange': depth0,'ignore': depth0,'deleteIgnore': depth0,'filter_txt': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "diff-table", options))));
  data.buffer.push("\n                </div>\n            </div>\n        ");
  return buffer;
  }

function program19(depth0,data) {
  
  var buffer = '', stack1, helper, options;
  data.buffer.push("\r\n    ");
  stack1 = (helper = helpers['modal-window'] || (depth0 && depth0['modal-window']),options={hash:{
    'isVisible': ("modalActive"),
    'header': ("labels.cdbvp_elink_diffutils_select_variant"),
    'footer_buttons': ("modalFooterButtons"),
    'header_buttons': ("modalHeaderButtons"),
    'buttonTriggered': ("modalButtonTriggered")
  },hashTypes:{'isVisible': "ID",'header': "ID",'footer_buttons': "ID",'header_buttons': "ID",'buttonTriggered': "STRING"},hashContexts:{'isVisible': depth0,'header': depth0,'footer_buttons': depth0,'header_buttons': depth0,'buttonTriggered': depth0},inverse:self.noop,fn:self.program(20, program20, data),contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "modal-window", options));
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  }
function program20(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n        <div class=\"container-fluid\">\r\n            ");
  stack1 = helpers['if'].call(depth0, "hasProducts", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(21, program21, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n            ");
  stack1 = helpers['if'].call(depth0, "variantsExists", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(23, program23, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n        </div>\r\n    ");
  return buffer;
  }
function program21(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n                <div class=\"row-fluid modal-products\">\r\n                    <div class=\"span1\">");
  stack1 = helpers._triageMustache.call(depth0, "labels.cdbvp_elink_diffutils_product", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("</div>\r\n                    <div class=\"span11\">\r\n                        ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "Ember.Select", {hash:{
    'content': ("products"),
    'selection': ("product"),
    'optionLabelPath': ("content.description"),
    'prompt': (" ")
  },hashTypes:{'content': "ID",'selection': "ID",'optionLabelPath': "STRING",'prompt': "STRING"},hashContexts:{'content': depth0,'selection': depth0,'optionLabelPath': depth0,'prompt': depth0},contexts:[depth0],types:["ID"],data:data})));
  data.buffer.push("\r\n                    </div>\r\n                </div>\r\n            ");
  return buffer;
  }

function program23(depth0,data) {
  
  var buffer = '', helper, options;
  data.buffer.push("\r\n                <div class=\"row-fluid modal-variants\">\r\n                    <div class=\"span12\">\r\n                        ");
  data.buffer.push(escapeExpression((helper = helpers['generic-table'] || (depth0 && depth0['generic-table']),options={hash:{
    'content': ("variants"),
    'filter': ("searchVariants"),
    'filter_placeholder': ("labels.cdbvp_elink_diffutils_search"),
    'selection': ("variant"),
    'numFixedColumns': (2),
    'rowHeight': (16),
    'headerContentBinding': ("variantTableHeader"),
    'tableSizeChange': ("variantTableExpanded")
  },hashTypes:{'content': "ID",'filter': "STRING",'filter_placeholder': "ID",'selection': "ID",'numFixedColumns': "INTEGER",'rowHeight': "INTEGER",'headerContentBinding': "STRING",'tableSizeChange': "ID"},hashContexts:{'content': depth0,'filter': depth0,'filter_placeholder': depth0,'selection': depth0,'numFixedColumns': depth0,'rowHeight': depth0,'headerContentBinding': depth0,'tableSizeChange': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "generic-table", options))));
  data.buffer.push("\r\n                    </div>\r\n                </div>\r\n            ");
  return buffer;
  }

function program25(depth0,data) {
  
  var buffer = '', helper, options;
  data.buffer.push("\r\n    ");
  data.buffer.push(escapeExpression((helper = helpers['debug-tool'] || (depth0 && depth0['debug-tool']),options={hash:{
    'entries': ("debugEntries")
  },hashTypes:{'entries': "ID"},hashContexts:{'entries': depth0},contexts:[],types:[],data:data},helper ? helper.call(depth0, options) : helperMissing.call(depth0, "debug-tool", options))));
  data.buffer.push("\r\n");
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, "rRootNode.nodeId", {hash:{},hashTypes:{},hashContexts:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n<div ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': (":diffutil :row-layout :body tableExpanded")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n    <div class=\"row-layout container\">\r\n        <div class=\"diffutil-metadata-row row-layout header\">\r\n            ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "partMeta", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("\r\n        </div>\r\n        ");
  stack1 = helpers['if'].call(depth0, "rRootNode.nodeId", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(8, program8, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    </div>\r\n</div>\r\n");
  stack1 = helpers['if'].call(depth0, "rRootNode.nodeId", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(15, program15, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n\r\n");
  stack1 = helpers['if'].call(depth0, "modalFirstLoad", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(19, program19, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n\r\n");
  stack1 = helpers['if'].call(depth0, "showDebugTool", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(25, program25, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n\r\n<div class=\"ajax-alerts\">\r\n</div>");
  return buffer;
  
});

Ember.TEMPLATES["navigation-view"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression;


  data.buffer.push("<div class=\"tree-nav-action prev btn btn-mini btn-link\" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "jumpToPrev", "treeSearch", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0,depth0],types:["STRING","ID"],data:data})));
  data.buffer.push(">\r\n    <i class=\"icon-step-backward\"></i>\r\n</div>\r\n<div class=\"tree-nav-info btn btn-mini btn-link\"  ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "jumpToCurrent", "treeSearch", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0,depth0],types:["STRING","ID"],data:data})));
  data.buffer.push(">\r\n    ");
  stack1 = helpers._triageMustache.call(depth0, "treeSearch.navIdxPlusOne", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push(" / ");
  stack1 = helpers._triageMustache.call(depth0, "treeSearch.content.length", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</div>\r\n<div class=\"tree-nav-action next btn btn-mini btn-link\" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "jumpToNext", "treeSearch", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0,depth0],types:["STRING","ID"],data:data})));
  data.buffer.push(">\r\n    <i class=\"icon-step-forward\"></i>\r\n</div>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["node-view"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1;


  stack1 = helpers._triageMustache.call(depth0, "treeNode.name", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  
});

Ember.TEMPLATES["partmeta"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression;


  data.buffer.push("<div class=\"row-fluid part-meta-inner\">\r\n    <div class=\"span6\">\r\n        <div class=\"container-fluid\">\r\n            <div class=\"row-fluid part-meta-left\">\r\n                <div class=\"span2 meta-label\">\r\n                    ");
  stack1 = helpers._triageMustache.call(depth0, "labels.cdbvp_elink_diffutils_left_bom", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push(":\r\n                </div>\r\n                <div class=\"span10\">\r\n                    ");
  stack1 = helpers._triageMustache.call(depth0, "litem.description", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div class=\"span6\">\r\n        <div class=\"container-fluid\">\r\n            <div class=\"row-fluid\">\r\n                <div class=\"span2 meta-label\">\r\n                    ");
  stack1 = helpers._triageMustache.call(depth0, "labels.cdbvp_elink_diffutils_right_bom", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push(":\r\n                </div>\r\n                <div class=\"span10\">\r\n                    ");
  data.buffer.push(escapeExpression(helpers.view.call(depth0, "select", {hash:{
    'contentBinding': ("itemList"),
    'optionLabelPath': ("content.description"),
    'prompt': (" "),
    'selection': ("ritemSelection")
  },hashTypes:{'contentBinding': "STRING",'optionLabelPath': "STRING",'prompt': "STRING",'selection': "ID"},hashContexts:{'contentBinding': depth0,'optionLabelPath': depth0,'prompt': depth0,'selection': depth0},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push("\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["tablecellview"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '';
  data.buffer.push("\r\n    <a class=\"btn btn-tiny ignore-button\" ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "ignore", {hash:{
    'target': ("view")
  },hashTypes:{'target': "STRING"},hashContexts:{'target': depth0},contexts:[depth0],types:["STRING"],data:data})));
  data.buffer.push(">\r\n        <i class=\"icon-minus\"></i>\r\n    </a>\r\n");
  return buffer;
  }

  data.buffer.push("<span ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'class': ("view.content.attribute :ember-table-content")
  },hashTypes:{'class': "STRING"},hashContexts:{'class': depth0},contexts:[],types:[],data:data})));
  data.buffer.push(">\r\n    ");
  stack1 = helpers._triageMustache.call(depth0, "view.cellContent.text", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</span>\r\n");
  stack1 = helpers['if'].call(depth0, "view.content.ignore", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(1, program1, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n");
  return buffer;
  
});

Ember.TEMPLATES["treeloading"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  


  data.buffer.push("loading...");
  
});

Ember.TEMPLATES["treenodecontextmenu"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n        <li><a ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'href': ("operation.url")
  },hashTypes:{'href': "STRING"},hashContexts:{'href': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("> <img ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("operation.icon")
  },hashTypes:{'src': "STRING"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("/>");
  stack1 = helpers._triageMustache.call(depth0, "operation.label", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push(" </a></li>\r\n    ");
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n        <li class=\"head\">");
  stack1 = helpers._triageMustache.call(depth0, "labels.cdbvp_elink_diffutils_bom_item_ops", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("</li>\r\n        ");
  stack1 = helpers.each.call(depth0, "operation", "in", "view.treeNode.bomOperations", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(4, program4, data),contexts:[depth0,depth0,depth0],types:["ID","ID","ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    ");
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = '', stack1;
  data.buffer.push("\r\n            <li><a ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'href': ("operation.url")
  },hashTypes:{'href': "STRING"},hashContexts:{'href': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("> <img ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("operation.icon")
  },hashTypes:{'src': "STRING"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("/>");
  stack1 = helpers._triageMustache.call(depth0, "operation.label", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push(" </a></li>\r\n        ");
  return buffer;
  }

  data.buffer.push("<ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"dLabel\">\r\n    <li class=\"head\">");
  stack1 = helpers._triageMustache.call(depth0, "labels.cdbvp_elink_diffutils_item_ops", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("</li>\r\n    ");
  stack1 = helpers.each.call(depth0, "operation", "in", "view.treeNode.item.operations", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(1, program1, data),contexts:[depth0,depth0,depth0],types:["ID","ID","ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n    ");
  stack1 = helpers['if'].call(depth0, "view.treeNode.bomOperations.length", {hash:{},hashTypes:{},hashContexts:{},inverse:self.noop,fn:self.program(3, program3, data),contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</ul>\r\n");
  return buffer;
  
});

Ember.TEMPLATES["treeviewoperation"] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data
/**/) {
this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Ember.Handlebars.helpers); data = data || {};
  var buffer = '', stack1, escapeExpression=this.escapeExpression;


  data.buffer.push("<a ");
  data.buffer.push(escapeExpression(helpers.action.call(depth0, "selectOperation", "operation", "view.optype", "rootNode.isEbomView", {hash:{
    'target': ("view")
  },hashTypes:{'target': "ID"},hashContexts:{'target': depth0},contexts:[depth0,depth0,depth0,depth0],types:["ID","ID","ID","ID"],data:data})));
  data.buffer.push(">\r\n    <img class=\"op-li\" ");
  data.buffer.push(escapeExpression(helpers['bind-attr'].call(depth0, {hash:{
    'src': ("operation.icon")
  },hashTypes:{'src': "STRING"},hashContexts:{'src': depth0},contexts:[],types:[],data:data})));
  data.buffer.push("/>\r\n    ");
  stack1 = helpers._triageMustache.call(depth0, "operation.label", {hash:{},hashTypes:{},hashContexts:{},contexts:[depth0],types:["ID"],data:data});
  if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
  data.buffer.push("\r\n</a>\r\n");
  return buffer;
  
});
Ember.Handlebars.helper('getattrof', function(context, attrName) {
    return context[attrName];
});

if (typeof String.prototype.endsWith !== 'function') {
    String.prototype.endsWith = function(suffix) {
        return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
}

if (typeof String.prototype.contains !== 'function') {
    String.prototype.contains = function(substring) {
        return this.indexOf(substring) !== -1;
    };
}

if (typeof Array.prototype.min !== 'function') {
    Array.prototype.min = function() {
        return Math.min.apply(Math, this);
    };
}

if (typeof Array.prototype.max !== 'function') {
    Array.prototype.max = function() {
        return Math.max.apply(Math, this);
    };
}

function scrollIntoViewIfNeeded(container, element) {
    // inspired by https://gist.github.com/hsablonniere/2581101

    if (container !== undefined && element !== undefined) {
        var containerOffset = jQuery(container).offset();
        var elementOffset = jQuery(element).offset();

        var overTop =
            elementOffset.top < containerOffset.top;
        var overBottom =
            elementOffset.top + element.clientHeight > containerOffset.top + container.clientHeight;

        if (overTop || overBottom) {
            container.scrollTop +=
                elementOffset.top - containerOffset.top
                - container.clientHeight / 2.0;
        }
    }
}

function getQueryParams() {
    var query = window.location.search.substring(1);
    var vars = query.split("&");
    var params = {}
    for (var i=0;i<vars.length;i++) {
            var t = vars[i].split("=");
            if(t[0] !== '') {
                params[t[0]] = t[1];
            }
    }

    return params;
}
var DiffutilApp = Ember.Application.extend({
    Resolver: Ember.DefaultResolver.extend({
        //Get hbs templates when needed
        //If template is included in index.html, this one will be used
        //otherwise, the template will be loaded per ajax
        resolveTemplate: function(parsedName) {
            var template = this._super(parsedName);
            var templateName = parsedName.fullNameWithoutType.replace(/\./g, '/');
            if (!template && this.namespace.get('templateUrlRoot')) {
                var filePath = this.namespace.get('templateUrlRoot') + templateName + '.hbs';

                $.ajax({
                    url: filePath,
                    async: false,
                    success: function(response) {
                        template = Ember.TEMPLATES[templateName] = Ember.Handlebars
                                .compile(response);
                    }
                });
            }
            return template;
        }
    }),

    templateUrlRoot: function() {
        if (this.get('_templateUrlRoot') === undefined) {
            if (this.get('rootElement')) {
                this.set('_templateUrlRoot', Ember.$(this.get('rootElement')).data(
                    'template-url-root'));
            } else {
                this.set('_templateUrlRoot', '');
            }
        }
        return this.get('_templateUrlRoot');
    }.property(),

    apiUrlRoot: function() {
        if (this.get('_apiUrlRoot') === undefined) {
            if (this.get('rootElement')) {
                this.set('_apiUrlRoot', Ember.$(this.get('rootElement')).data(
                    'api-url-root'));
            } else {
                this.set('_apiUrlRoot', '');
            }
        }
        return this.get('_apiUrlRoot');
    }.property(),

    appDataUrl: function() {
        if (this.get('_appDataUrl') === undefined) {
            if (this.get('rootElement')) {
                this.set('_appDataUrl', Ember.$(this.get('rootElement')).data(
                    'app-data'));
            } else {
                this.set('_appDataUrl', '');
            }
        }
        return this.get('_appDataUrl');
    }.property(),

    _initAjax: function() {
        this.set('_ajaxCount', 0);
        this.set('_ajax', Ember.RSVP.resolve(null));
    }.on('init'),

    _ajaxTime: [],
    _ajaxLabels: [],
    _ajaxId: 0,

    ajax: function(args, displayLoader, label) {
        var app = this;

        if (displayLoader === undefined) {
            displayLoader = true;
        }

        if (displayLoader) {
            this.incrementProperty('_ajaxCount');
        }
        var _ajax = this.get('_ajax');

        this.set('_ajax', _ajax.then(function() {
            var start;
            var ajaxId = app.incrementProperty('_ajaxId');
            args.beforeSend = function() {
                start = new Date();
                if (label !== undefined) {
                    app.get('_ajaxLabels').pushObject({
                        id: ajaxId,
                        label: window.diffutilLabels[label]
                    });
                }
            };

            return Ember.$.ajax(args)
                    .then(function(data) {

                app.get('_ajaxTime').pushObject({
                    time: (new Date() - start) / 1000,
                    url: args.url
                });

                if (displayLoader) {
                    app.decrementProperty('_ajaxCount');
                }

                if (label !== undefined) {
                    app.get('_ajaxLabels').removeObject(
                        app.get('_ajaxLabels').findBy('id', ajaxId)
                    );
                }

                return Ember.RSVP.resolve(data);
            });
        }));
        return this.get('_ajax');
    },

    showAjaxLoader: function() {
        Ember.run.schedule('afterRender', this, function() {
            if (this.get('_ajaxCount') <= 0) {
                cdb.elink.stopWaiting();
                this.$('.ajax-alerts').css('display', 'none');
            } else {
                cdb.elink.startWaiting();
                this.$('.ajax-alerts').css('display', 'block');
            }
        });
    }.observes('_ajaxCount'),

    _observeLabels: function() {
        var app = this;
        this.get('_ajaxLabels').addEnumerableObserver(this, {
            willChange: function(navigatedBy, removing, addCount) {
                removing.forEach(function(obj) {
                    var el = app.$('.ajax-alerts div[data-id="' + obj.id + '"]');
                    if (el !== undefined) {
                        el.remove();
                    }
                });
            },
            didChange: function(navigatedBy, removeCount, adding) {
                adding.forEach(function(obj) {
                    var el = $('<div>', {
                        'data-id': obj.id
                    });
                    el.text(obj.label);
                    el.appendTo(app.$('.ajax-alerts'));
                });
            }
        });
    }.on('init'),

    willDestroy: function() {
        if (this.get('_ajaxLabels') !== undefined) {
            this.get('_ajaxLabels').removeEnumerableObserver(this);
        }
    }
});

var App = window.App = DiffutilApp.create({
    rootElement: '#diffutil',
    TreeNodeDict: {},
    ready: function() {
        // inject labels into all controllers
        this.register('labels:main', Ember.Object.extend(window.diffutilLabels), {singleton: true});
        this.inject('controller', 'labels', 'labels:main');
        this.inject('component', 'labels', 'labels:main');
        this.register('statecolors:main', Ember.Object.extend(window.statecolors), {singleton: true});
        this.inject('controller', 'statecolors', 'statecolors:main');
        this.register('urlpaths:main', Ember.Object.extend(window.urlpaths), {singleton: true});
        this.inject('controller', 'urlpaths', 'urlpaths:main');
        this.inject('component', 'urlpaths', 'urlpaths:main');
    },

    //DEBUG
    LOG_TRANSITIONS: true,
    LOG_TRANSITIONS_INTERNAL: true,
    LOG_BINDINGS: true,
    LOG_VIEW_LOOKUPS: true,
    LOG_STACKTRACE_ON_DEPRECATION: true,
    LOG_VERSION: true,
    debugMode: false
});

App.NodeSelection = Ember.ArrayProxy.extend({
    init: function() {
        this.set("content", Ember.A());
    },

    /*
     * Called when a node is clicked.
     *
     * If shift is true the node will be added to the selection
     * together with all the positions between the current selection and
     * the node.
     *
     * If shift is false the node will be added to the selection.
     *
     * If ctrl is true and the node is already selected,
     * the node will be removed from the selection.
     */
    click: function(node, ctrl, shift) {
        if (ctrl && this.content.contains(node)) {
            this.removeNode(node, ctrl, shift);
        } else {
            this.addNode(node, ctrl, shift);
        }
    },

    /*
     * Add a node to the selection.
     *
     * If ctrl and shift are false the current selection is reset.
     *
     * If ctrl or shift are true, both node and the current selection should
     * be in the same tree structure (i.e. both eBom or both mBom).
     * Otherwise the method behaves as if ctrl and shift were false.
     *
     * parameters:
     * node     The node to be added to the selection.
     * ctrl     true if the current selection should not be reset
     *          (additive behaviour).
     * shift    true if all the positions between the current selection and
     *          node should be added to the selection.
     */
    addNode: function(node, ctrl, shift) {
        var content = this.get("content");

        // If an element of a different bom tree is selected,
        // reset the selection
        if (!content.everyBy("isEbomView", node.get("isEbomView"))) {
            ctrl = false;
            shift = false;
        }

        if (ctrl) {
            if (!content.contains(node)) {
                content.pushObject(node);
            }
        } else if (shift) {
            var minPos = Math.min(
                    content.mapBy("position").min(),
                    node.get("position")
            );
            var maxPos = Math.max(
                    content.mapBy("position").max(),
                    node.get("position")
            );

            var parent = node.get("parent");
            if (!parent) {
                // the top level node is selected
                parent = node;
                if (!content.contains(parent)) {
                    content.pushObject(parent);
                }
            }
            parent.get("content").forEach(function(el) {
                var position = el.get("position");
                if (position >= minPos && position <= maxPos) {
                    if (!content.contains(el)) {
                        content.pushObject(el);
                    }
                }
            });
        } else {
            content.clear();
            content.pushObject(node);
        }
    },

    /*
     * Remove node from the selection
     *
     * If ctrl and shift are false the current selection is reset.
     *
     * If ctrl is true the current selection will not be reset.
     */
    removeNode: function(node, ctrl, shift) {
        if (!ctrl) {
            this.get("content").clear();
        }

        this.get("content").removeObject(node);
    },

    isEbomView: function() {
        return this.get("content").everyBy("isEbomView", true);
    }.property("content.[]"),

    containsTopNode: function() {
        return this.get("content").isAny("parent", undefined);
    }.property("content.[]"),

    /*
     * If only one node is selected, then return it's parent node.
     * If multiple nodes are selected, then return the parent
     * of their "most recent common ancestor".
     */
    mostRecentCommonAncestor: function() {
        var content = this.get("content");
        var node = content.objectAt(0);
        if (content.length == 1) {
            return node;
        } else if (content.length > 1) {
            var path = [];
            while (node) {
                path.insertAt(0, node);
                node = node.get("parent");
            }
            for (var i = 1; i < content.length; i++) {
                node = content.objectAt(i);
                while (node) {
                    if (path.contains(node)) {
                        var cutIndex = path.lastIndexOf(node) + 1;
                        path.removeAt(cutIndex, path.length - cutIndex);
                        break;
                    }
                    node = node.get("parent");
                }
            }
            return path.popObject();
        }
    }.property("content.[]")
});

/*
 * Cache layer
 */

App.PromiseObject = Ember.ObjectProxy.extend(Ember.PromiseProxyMixin);

/*
 * ObjectCache: a class to cache objects coming from ajax-calls
 *
 * Following parameters are needed:
 *
 * url A function taking a key as parameter and returning a url providing a json object for the given key
 *
 * ajax (Optional) A function taking a list of keys and return a url providing a list of json objects for the given
 * keys. Used for performance optimizations
 *
 *
 * Public API:
 *
 * handleResult (Optional) A hook called on the result of the ajax calls, before storing the result on the cache. Can be
 * use to manipulate objects before saving them. The return value is stored in the cache
 *
 * update Save an element in the cache, if not already present
 *
 * updateMany Take a list of elements and store those element which are not already present
 *
 * getProperties Return a list with the value of many properties at once. If the parameter `ajax` is defined, perfoms
 * only one ajax call.
 *
 * load Load or reload an element in the cache, given its key.
 */

App.ObjectCache =
    Ember.ObjectProxy.extend({

        /*
         * Parameters
         */

        // url for fetching a single item
        url: null,
        // data for fetching a single item
        data: null,
        // ajax call for fetching many items (optional)
        ajax: null,

        filter: {},

        escapeKey: function(key) {
            // replace points with a unicode punctuation space character
            // because ember interprets points as path separators.
            // this is not the regular white space, so it's very unlikely
            // that it occurrs in a key.
            var pointReplacer = "\u2008";
            var result = key.replace(/\./g, pointReplacer);
            return result;
        },

        unescapeKey: function(key) {
            var result = key.replace(/\u2008/g, ".");
            return result;
        },

        get: function(key) {
            var escapedKey = this.escapeKey(key);
            return this._super(escapedKey);
        },

        set: function(key, value) {
            var escapedKey = this.escapeKey(key);
            return this._super(escapedKey, value);
        },

        /*
         * Hooks
         */

        // hook to transform the result of the ajax call, you can override this
        handleResult: function(result) {
            return Ember.Object.create(result);
        },
        handleResults: function(promise, keys) {
            var self = this;
            var cacheKey = this.get("cacheKey");

            keys.forEach(function(key) {
                self.set(key, App.PromiseObject.create({
                    promise: promise.then(function(data) {
                        return self.handleResult(data.findBy(cacheKey, key));
                    })
                }));
            });
        },
        // hook called after a property has been set
        post: function(key) {
        },

        /*
         * Public API
         */

        updateMany: function(content) {
            for (var key in content) {
                if (content.hasOwnProperty(key)) {
                    this.update(key, content[key]);
                }
            }
        },

        update: function(key, el, force) {
            var escapedKey = this.escapeKey(key);
            if (!this.get("content").hasOwnProperty(escapedKey) || force) {
                var new_val = this.handleResult(el);
                if (force) {
                    var old_val = this.get('content').get(escapedKey);

                    if (old_val instanceof App.PromiseObject && old_val.get('isFulfilled')) {
                        old_val = old_val.get('content');
                    } else if (old_val instanceof App.PromiseObject && !old_val.get('isFulfilled')) {
                        old_val = undefined; // unloaded promises can be replaced by already loaded content
                    }
                    this.get('content').set(escapedKey, new_val);
                    this.postPropertyReload(key);
                } else {
                    this.get('content').set(escapedKey, new_val);
                }
            }
        },

        // get many items with one ajax-call
        getProperties: function(keys) {
            var self = this;
            var promise = Ember.RSVP.resolve();
            // Load all the missing keys with one ajax call
            if (self.ajax && keys) {
                var content = self.get("content");

                // Check if some items are not in the cache
                var missing_keys = [];
                keys.forEach(function(key) {
                    var escapedKey = self.escapeKey(key);
                    if (content.get(escapedKey) === undefined) {
                        missing_keys.push(key);
                    }
                });

                // Load missing items in the cache
                if (missing_keys.length > 0) {
                    promise = self.ajax(missing_keys).then(function(data) {
                        if (data.success) {
                            return data.result;
                        } else {
                            cdb.elink.alert(data.message);
                        }
                    });
                    self.handleResults(promise, missing_keys);
                }
            }

            // Return all items from the cache
            return promise.then(function() {
                return keys.map(function(key) {
                    return self.get(key);
                });
            });
        },

        /*
         * Private functions
         */

        postPropertyReload: function(key) {
            // to be overriden
        },

        reloadProperties: function(keys) {
            var self = this;
            if (keys === undefined) {
                var keys = Ember.keys(this.content);
                // remove erroneous added toString key
                var toStringIdx = keys.indexOf("toString");
                if (toStringIdx !== -1) {
                    keys.removeAt(toStringIdx);
                }
            }
            if (self.ajax && keys.length > 0) { // Load all keys with one ajax call
                var content = self.get("content");
                return self.ajax(keys).then(function(data) {
                    if (data.success) {
                        keys.forEach(function(key) {
                            var item = self.getItemFromAjaxDataByKey(data.result, key);
                            if (item !== undefined) {
                                self.update(key, self.handleResult(item), true);
                            }
                        });
                    } else {
                        cdb.elink.alert(data.message);
                        return Ember.RSVP.reject(data.message);
                    }
                });
            } else {
                return Ember.RSVP.resolve();
            }
        },

        getItemFromAjaxDataByKey: function(data, key) {
            var cacheKey = this.get("cacheKey");
            var item = data.findBy(cacheKey, key);
            return item;
        },

        init: function() {
            this._super();

            this.set("content", Ember.Object.create());
        },

        unknownProperty: function(key) {
            var self = this;
            var promise = this._super(key);

            if (promise === undefined) {
                promise = this.load(key);
            }

            // cache should always return a promise
            var result = App.PromiseObject.create({
                promise: Ember.RSVP.resolve(null).then(function() {
                    return promise;
                })
            });
            this.get('content').set(key, result);
            return result;
        },

        load: function(key) {
            // load item description from server
            var url = this.url(key);
            var self = this;
            var label = this.label;

            return App.ajax({
                url: url,
                data: $.extend(this.get('data'), {filter: this.get('filter')}),
                dataType: 'json',
                type: 'get',
                async: true
            }, true, label).then(function(data) {
                var result;
                if (data.success) {
                    result = self.handleResult(data.result);
                    // self.set(key, result);
                } else {
                    cdb.elink.alertCDBMessage(data.message);
                }
                return result;
            });
        },

        setUnknownProperty: function(key, value) {
            this.content.set(key, value);

            // call hook
            $.proxy(this.get("post"), this)(key, value);
        },

        clear: function() {
            this.set("content", Ember.Object.create());
        }
    });

/*
 * Mixin for objects which have cached properties
 *
 * A cached property is defined by a property with the suffix -Cache. For example the property `itemCache` defines the
 * cached property `item`.
 *
 * The definition of a cached property can be an object or a string. If it is an object, the following attributes should
 * be given.
 *
 * name The name of the cache, in which the property values are stored. The cache must be an instance of App.ObjectCache
 * and must be a property of App.CacheLayer.
 *
 * key The name of the property, which will be used as key for storage in the cache. `key` must be a property of the
 * same object which has the cached property.
 *
 * If the definition of a cached property is a string, it will be used in place of `key`, the property name of the
 * definition (e.g. `itemCache`) will be used as cache name.
 */

App.CachedObjectMixin = Ember.Mixin.create({
    _cacheSuffix: "Cache",

    init: function() {
        var self = this;
        self._super();

        var _cacheKeys = Ember.A();

        for (var prop in self) {
            if (prop.endsWith(self._cacheSuffix)) {
                var name = prop.slice(0, -(self._cacheSuffix.length));

                var cacheName;
                var keyName;
                if (typeof self.get(prop) === 'string' || self.get(prop) instanceof String) {
                    cacheName = prop;
                    keyName = self.get(prop);
                } else {
                    cacheName = self.get(prop).name;
                    keyName = self.get(prop).key;
                }
                _cacheKeys.pushObject(Ember.Object.create({
                    name: name,
                    cacheName: cacheName,
                    keyName: keyName
                }));
            }
        }
        this.set('_cacheKeys', _cacheKeys);

        // create properties
        _cacheKeys.forEach(function(values) {
            Ember.defineProperty(self, values.get('name'), Ember.computed(function() {
                var cache = App.CacheLayer.get(values.get('cacheName'));
                var key = self.get(values.get('keyName'));
                if (key) {
                    return App.PromiseObject.create({
                        promise: cache.get(key)
                    });
                }
            }).property(values.get('keyName')));
        });
    }
});

/*
 * A class for objects which have cached properties (see App.CachedObjectMixin)
 */

App.CachedObject = Ember.Object.extend(App.CachedObjectMixin);

/*
 * A class for array of cached object.
 *
 * The array stores only the keys. That is, by using pushObject or similar you should only pass the keys as argument
 * (e.g. the cdb_object_id of an item).
 *
 * Reading the array will return the cached value.
 *
 * The following parameter is required.
 *
 * cacheName The name of the cache, in which the property values are stored. The cache must be an instance of
 * App.ObjectCache and must be a property of App.CacheLayer.
 */

App.CachedArray = Ember.ArrayProxy.extend({
    cacheName: null,
    objectAtContent: function(idx) {
        var cache = App.CacheLayer.get(this.cacheName);
        if (cache) {
            var key = this.get('content').objectAt(idx);
            return App.PromiseObject.create({
                promise: cache.get(key)
            });
        }
    }
});

// lazy loaded cached fixed size array which loads server pages when an element which previously wasn't loaded is
// requested
App.PaginatedCachedArray = Ember.Object.extend(Ember.MutableArray, {
    length: 0,
    pageSize: 10,
    unknownProperty: function(key) {
        var val = this._super('' + key);
        if (val === undefined && parseInt(key) >= 0) {
            return this.load(key)
        }
        return val;
    },
    objectAt: function(index) {
        if (parseInt(index) < 0 || parseInt(index) >= this.get('length')) {
            return undefined;
        }
        return this.get('' + index);
    },
    replace: function(index, atm, objects) {
        var length = this.get('length');
        var newData = {};
        for (var i = index + objects.length; i < atm; i++) {
            newData['' + i] = undefined;
        }
        for (var i = index; i < index + objects.length; i++) {
            newData['' + i] = objects[i - index];
        }
        newData['length'] = length - atm + objects.length;
        this.setProperties(newData);
    },
    data: function(idx, pagingData) {
        return pagingData;
    },
    url: function(idx, pagingData) {
        // url for fetching a page of items - must be given
    },

    calcPagingData: function(idx) {
        var idx = parseInt(idx);
        var pageSize = this.get('pageSize');
        var neededPage = Math.floor(idx / pageSize);
        var neededPageStartIdx = neededPage * pageSize;
        return {
            startIdx: neededPageStartIdx,
            page: neededPage,
            pageSize: pageSize
        };
    },
    handleResults: function(results, idx) {
        var self = this;
        var result;
        var pageStartIdx = this.calcPagingData(idx)['startIdx'];
        var offsetIdx = idx - pageStartIdx;
        var newData = {};
        results.forEach(function(obj, index) {
            var res = Ember.Object.create(obj);
            newData['' + (pageStartIdx + index)] = res;
            // return queried idx value
            if (index == offsetIdx) {
                result = res;
            }
        });
        self.setProperties(newData);
        return result;
    },
    load: function(idx) {
        var self = this;
        var pagingData = this.calcPagingData(idx);
        var url = this.url(idx, pagingData);
        var result;

        $.ajax({
            url: url,
            data: this.data(idx, pagingData),
            dataType: 'json',
            type: 'get',
            async: false
        }).done(function(data) {
            if (data.success) {
                if (data.result.results !== undefined) {
                    result = self.handleResults(data.result.results, idx);
                }
            } else {
                cdb.elink.alertCDBMessage(data.message);
            }
        });
        return result;
    }
});

/*
 * Cache Layer
 *
 * Here we define the caches that are used through the application.
 */

App.Item =
    App.CachedObject.reopenClass({
        detailProperty: function(name) {
            return Ember.computed('itemDetails.isFulfilled', function() {
                if ('itemDetails.isFulfilled') {
                    return this.get('itemDetails.' + name);
                }
            });
        }
    }).extend({
        usagesCache: "cdb_object_id",
        itemDetailsCache: "cdb_object_id",

        initDetails: function() {
            var self = this;
            [
                'link',
                'description',
                'tooltip',
                'state_icon',
                'mbom_desc'
            ].forEach(function(field) {
                Ember.defineProperty(
                    self,
                    field,
                    App.Item.detailProperty(field)
                );
            });
        }.on('init'),

        isEqual: function(b) {
            var a = this;
            var fields =
                Ember.A(["status", "object_type", "cdb_object_id", "is_assembly",
                    "idx", "is_mbom", "nr", "cdb_depends_on"]);
            if (b === undefined) {
                return false;
            }
            var result = fields.every(function(field) {
                return a.get(field) == b.get(field);
            });
            return result;
        }
    });

var BomItemUtils = Ember.Object.reopenClass({
    keyAttributes: [
        "baugruppe",
        "b_index",
        "teilenummer",
        "variante",
        "position"
    ],

    fromArray: function(arr) {
        var result = {};
        BomItemUtils.keyAttributes.forEach(function(attr, index) {
            result[attr] = arr[index];
        });
        return BomItemUtils.create(result);
    }
}).extend({
    pkeys: function() {
        var self = this;
        return BomItemUtils.keyAttributes.map(function(attr) {
            return self.get(attr);
        }).join(";");
    }.property("baugruppe", "b_index", "teilenummer", "t_index",
        "variante", "position")
});

App.Bom =
    App.CachedObject.extend({
        itemCache: "item_object_id",
        predicatesCache: "pkeys",
        init: function() {
            this._super();
        },
        isEqual: function(b) {
            var a = this;
            var fields =
                Ember.A(["teilenummer", "t_index", "baugruppe", "b_index",
                    "auswahlmenge", "position", "tooltip",
                    "description"]);
            if (b === undefined) {
                return false;
            }
            var result = fields.every(function(field) {
                return a.get(field) == b.get(field);
            });
            return result;
        },
        pkeys: function() {
            var self = this;

            return BomItemUtils.fromArray(
                    BomItemUtils.keyAttributes.map(function(attr) {
                return self.get(attr);
            })).get('pkeys');
        }.property("baugruppe", "b_index", "teilenummer",
            "variante", "position")
    });

App.ComparableArray = Ember.ArrayProxy.extend({
    isEqual: function(b) {
        var a = this;
        var all_a_in_b = a.every(function(aItem) {
            return b.any(function(bItem) {
                return aItem.isEqual(bItem);
            });
        });
        if (!all_a_in_b) {
            return false;
        } else {
            var all_b_in_a = b.every(function(bItem) {
                return a.any(function(aItem) {
                    return aItem.isEqual(bItem);
                });
            });
            return all_b_in_a;
        }
    }
});

App.UsagesCache =
    App.ObjectCache.extend({
        litem: null,
        ritem: null,
        label: 'cdbvp_elink_diffutil_load_usages',
        url: function(key) {
            var litem_object_id = this.get('litem') ? this.get('litem').get('cdb_object_id') : undefined;
            var ritem_object_id = this.get('ritem') ? this.get('ritem').get('cdb_object_id') : undefined;
            var url =
                App.get('apiUrlRoot') + key + "/" + litem_object_id + "/" + ritem_object_id + "/usages";

            return url;
        },
        handleResult: function(result) {
            return Ember.A(result);
        }
    });

App.DifferencesCache =
    App.ObjectCache.extend({
        litem: null,
        ritem: null,
        label: 'cdbvp_elink_diffutil_load_differences',
        product_object_id: null,
        variant: null,

        _variantChanged: function() {
            var variant = this.get('variant');

            this.set('data', {
                variant_id: variant.vid,
                signature: variant.signature
            });

            this.clear();
        }.observes('variant'),

        url: function(key) {
            var product_object_id = this.get('product_object_id');
            var litem_object_id = this.get('litem') ? this.get('litem').get('cdb_object_id') : undefined;
            var ritem_object_id = this.get('ritem') ? this.get('ritem').get('cdb_object_id') : undefined;
            var url =
                App.get('apiUrlRoot') + key + '/' + litem_object_id + '/' + ritem_object_id +
                    (product_object_id !== null ?  ('/' + product_object_id) : '') +
                    '/find_differences';

            return url;
        },
        handleResult: function(result) {
            return Ember.Object.create({
                left: Ember.A(result.left),
                right: Ember.A(result.right),
                usages: Ember.A(result.usages)
            });
        }
    });

App.CacheLayer = Ember.Object.extend({
    reload: function(keys) {
        var cacheLayer = this;

        // differencesCache must be cleared, but not reloaded
        cacheLayer.get('differencesCache').clear();

        // on usagesCache we must only delete the keys
        // and not reload them (usagesCache will be updated when needed).
        if (keys) {
            keys.forEach(function(key) {
                cacheLayer.get('usagesCache').get('content').set(key, undefined);
            }, this);
        }

        // bomCache and itemCache will be reloaded
        [cacheLayer.get('itemCache'), cacheLayer.get('bomCache')].forEach(function(cache) {
            cache.reloadProperties(keys);
        });

        if (keys) {
            cacheLayer.get('bomCache').getProperties(keys).then(function(boms) {
                return Ember.RSVP.all(boms);
            }).then(function(boms) {
                var pkeys = [];

                for (var i = 0; i < boms.length; i++) {
                    var bom = boms[i].content;
                    pkeys.push.apply(pkeys, bom.map(function(position) {
                        return position.get('pkeys');
                    }));
                }

                cacheLayer.get('predicatesCache').reloadProperties(pkeys);
            });
        } else {
            cacheLayer.get('predicatesCache').reloadProperties();
        }
    },
    clear: function(key) {
        for (var cacheName in this) {
            if (this.hasOwnProperty(cacheName) && this[cacheName] instanceof App.ObjectCache) {
                this[cacheName].clear();
            }
        }
    }
}).create({
    predicatesCache: App.ObjectCache.extend({
        label: 'cdbvp_elink_diffutil_load_predicates',
        cacheKey: "pkeys",
        itemsMap: Ember.A(),

        url: function(pkeys) {
            return App.get('apiUrlRoot') + pkeys + "/bom_predicates";
        },

        handleResult: function(result) {
            return Ember.A(result);
        },

        handleResults: function(promise, keys) {
            var self = this;

            keys.forEach(function(key) {
                self.set(key, App.PromiseObject.create({
                    promise: promise.then(function(data) {
                        return data[key];
                    })
                }));
            });
        },

        // ajax call for fetching many items
        ajax: function(pkeys) {
            var url = App.get('apiUrlRoot') + 'bom_predicates_list';
            var label = this.label;
            return App.ajax({
                url: url,
                dataType: 'json',
                data: {
                    "pkeys": pkeys
                },
                type: 'post',
                async: true
            }, true, label);
        },

        // hook called after a property has been set
        post: function(key, predicates) {
            var predicatesCache = this;
            predicates.then(function(predicates) {
                predicatesCache.get('itemsMap').set(key, predicates.map(function(predicate) {
                    return predicate.item_object_id;
                }));
            });
        },

        postPropertyReload: function(key) {
            var predicates = this.get('content').get(key);

            // update itemsMap
            var items = this.get('itemsMap').get(key);
            if (items === undefined) {
                items = [];
            }
            var treeNodesToRender = [];
            predicates.forEach(function(predicate) {
                var item_object_id = predicate.item_object_id;
                var nodes = Object.keys(App.TreeNodeDict[item_object_id])
                    .map(function(key) {
                        return App.TreeNodeDict[item_object_id][key];
                    })
                    .filter(function(node) {
                        return (
                            node.get('baugruppe') === predicate.baugruppe &&
                            node.get('b_index') === predicate.b_index &&
                            node.get('teilenummer') === predicate.teilenummer &&
                            node.get('variante') === predicate.variante &&
                            node.get('position') === predicate.position
                        );
                    });
                treeNodesToRender.push.apply(treeNodesToRender, nodes);

                if (!items.contains(item_object_id)) {
                    items.push(item_object_id);
                }
            });

            this.get('itemsMap').set(key, items);
            treeNodesToRender.forEach(function(node) {
                node.set('predicates', predicates);
                node.render(true);
            });
        },
        getItemFromAjaxDataByKey: function(data, key) {
            return data[key];
        }
    }).create(),

    itemCache: App.ObjectCache.extend({
        cacheKey: "cdb_object_id",
        label: 'cdbvp_elink_diffutil_load_items',

        // url for fetching a single item
        url: function(key) {
            var url = App.get('apiUrlRoot');
            return url + key + '/item';
        },
        handleResult: function(result) {
            var statecolors = window.statecolors;

            result.state_color = statecolors[result.object_type][result.status];
            return App.Item.create(result);
        },
        // ajax call for fetching many items
        ajax: function(keys) {
            var url = App.get('apiUrlRoot') + 'items';
            var label = this.label;

            return App.ajax({
                url: url,
                dataType: 'json',
                data: {
                    "oids": keys
                },
                type: 'post',
                async: true
            }, true, label);
        },
        postPropertyReload: function(key) {
            var item = this.get(key);
            var treeNodesToRender = App.TreeNodeDict[key];
            Ember.keys(treeNodesToRender).forEach(function(nodeKey) {
                var node = treeNodesToRender[nodeKey];
                node.set('item', item);
                node.render(true);
            });
        }
    }).create(),

    itemDetailsCache: App.ObjectCache.extend({
        cacheKey: "cdb_object_id",
        label: 'cdbvp_elink_diffutil_load_item_details',

        // url for fetching a single item
        url: function(key) {
            var url = App.get('apiUrlRoot');
            return url + key + '/itemdetails';
        },
        handleResult: function(result) {
            return Ember.Object.create(result);
        },
        // ajax call for fetching many items
        ajax: function(keys) {
            var url = App.get('apiUrlRoot') + 'itemsdetails';
            var label = this.label;

            return App.ajax({
                url: url,
                dataType: 'json',
                data: {
                    "oids": keys
                },
                type: 'post',
                async: true
            }, true, label);
        }
    }).create(),

    bomCache: App.ObjectCache.extend({
        cacheKey: "item_object_id",
        label: 'cdbvp_elink_diffutil_load_boms',

        // url for fetching a single item
        url: function(key) {
            var url = App.get('apiUrlRoot');
            return url + key + '/bom';
        },

        variant: null,

        _variantChanged: function() {
            var variant = this.get('variant');
            var old_ids = Ember.keys(this.get('content'));
            var data = variant ? {
                "variant_id": variant.vid,
                "product_object_id": variant.product_object_id,
                "signature": variant.signature
            } : {};
            this.set('data', data);
            this.clear();
            // take the new boms filtered by variant
            this.getProperties(old_ids);
        }.observes('variant'),

        handleResult: function(data) {
            var result = App.ComparableArray.create({
                content: []
            });

            data.forEach(function(el) {
                var itemCache = App.CacheLayer.itemCache;
                itemCache.update(el.item_object_id, el.item);

                result.pushObject(App.Bom.create(el));
            });

            return result;
        },

        // ajax call for fetching many items
        ajax: function(keys) {
            var url = App.get('apiUrlRoot') + 'boms';
            var label = this.label;
            var custom_data = this.get('data');
            var data = {
                "oids": keys,
                "filter": this.get('filter')
            };
            if (custom_data) {
                for (var attrname in custom_data) {
                    if (custom_data.hasOwnProperty(attrname)) {
                        data[attrname] = custom_data[attrname];
                    }
                }
            }
            return App.ajax({
                url: url,
                dataType: 'json',
                data: data,
                type: 'post',
                async: true
            }, true, label);
        },
        handleResults: function(promise, keys) {
            var self = this;

            keys.forEach(function(key) {
                self.set(key, App.PromiseObject.create({
                    promise: promise.then(function(data) {
                        var result = data.find(function(result) {
                            return result[0] === key;
                        });
                        if (result) {
                            return self.handleResult(result[1]);
                        }
                    })
                }));
            });
        },
        getItemFromAjaxDataByKey: function(data, key) {
            var result = data.find(function(result) {
                return result[0] === key;
            });
            if (result) {
                return result[1];
            }
        },
        postPropertyReload: function(key) {
            var treeNodesToRender = App.TreeNodeDict[key];
            Ember.keys(treeNodesToRender).forEach(function(nodeKey) {
                var node = treeNodesToRender[nodeKey];
                node.loadComponents(true).then(function() {
                    node.render(true);
                });
            });
        }
    }).create(),

    usagesCache: null,
    differencesCache: null
});

App.Difference = App.CachedObject.extend({
    itemCache: "item_object_id"
});

App.IndexModel = App.CachedObject.extend({

    /*
     * Initialization
     */
    differencesReloadToggle: false,
    tableExpanded: true,
    tableLinked: true,
    variant: null,
    variantSearchStr: '',
    product: null,
    itemList: [],
    filter: {},

    init: function() {
        this._super();
    },

    /*
     * Cached properties
     */

    // Definition of the cached property `litem`
    litemCache: {
        name: "itemCache",
        key: "litem_object_id"
    },

    // Definition of the cached property `lbom`
    lbomCache: {
        name: "bomCache",
        key: "litem_object_id"
    },

    // Definition of the cached property `ritem`
    ritemCache: {
        name: "itemCache",
        key: "ritem_object_id"
    },

    // Definition of the cached property `rbom`
    rbomCache: {
        name: "bomCache",
        key: "ritem_object_id"
    },

    /*
     * Computed properties
     */
    _variants_search_length_lookup: '',
    _variants_search_length: 0,
    variants: function() {
        var self = this;
        var length = self.get('product.variantCount');
        var searchstr = self.get('variantSearchStr');
        if (searchstr !== '') {
            if (self.get('_variants_search_length_lookup') !== searchstr) {
                App.ajax({
                    url: App.get('apiUrlRoot') + '/' + self.get('product.cdb_object_id') + '/product_variants_meta',
                    data: {
                        searchStr: searchstr
                    },
                    dataType: 'json',
                    type: 'get',
                    async: true
                }, true, 'cdbvp_elink_diffutil_load_variants').then(function(data) {
                    if (data.success) {
                        length = data.result;
                        self.setProperties({'_variants_search_length_lookup': searchstr,
                                            '_variants_search_length': length});
                        self.notifyPropertyChange('variants');
                    } else {
                        cdb.elink.alertCDBMessage(data.message);
                    }
                });
                return Ember.A([]);
            } else {
                length = self.get('_variants_search_length');
                self.setProperties({'_variants_search_length_lookup': '',
                    '_variants_search_length': 0});
            }
        }
        var variantCache = App.PaginatedCachedArray.create({
            pageSize: 100,
            length: length,
            url: function(idx) {
                var url = App.get('apiUrlRoot');
                url += '/' + self.get('product.cdb_object_id');
                url += '/product_variants';
                return url;
            },
            data: function(idx, pagingData) {
                var data = {
                    startIdx: pagingData.startIdx,
                    page: pagingData.page,
                    pageSize: pagingData.pageSize,
                    searchStr: searchstr
                };
                return data;
            }
        });
        return variantCache;
    }.property('product', 'variantSearchStr'),

    variantsExists: function() {
        var searchstr = this.get('variantSearchStr');
        var variants = this.get('variants');
        // needed to reset search strings
        return searchstr == '' ? variants.length > 0 : true;
    }.property('variants'),

    // differences between the BOM of the left item
    // and the BOM of the right item
    _computeDifferences: function() {
        var litem = this.get('litem');
        var ritem = this.get('ritem');

        var params = getQueryParams();
        delete params._filtertext;
        var bomfilter = JSON.stringify(params);

        if (litem && ritem) {
            var url = App.get('apiUrlRoot') +
                litem.get('nr') + ';' + litem.get('idx') + '/' +
                ritem.get('nr') + ';' + ritem.get('idx') + '/diff_table';

            var data = {};

            var product = this.get('product');
            if (product) {
                data['product_oid'] = product.get('cdb_object_id');
            }

            var variant = this.get('variant');
            if (variant) {
                data['variant_id'] = variant.get('vid');
                data['signature'] = variant.get('signature');
            }

            data['filter'] = bomfilter;

            return App.PromiseObject.create({
                promise: App.ajax({
                    url: url,
                    dataType: 'json',
                    data: data,
                    type: 'post',
                    async: true
                }, true, 'cdbvp_elink_diffutil_load_difference_table').then(function(data) {
                    var tableContent = Ember.A([]);
                    if (data.success) {
                        $.each(data.result, function(i, elem) {
                            tableContent.pushObject(App.Difference.create(elem));
                        });
                    } else {
                        cdb.elink.alertCDBMessage(data.message);
                    }
                    return tableContent;
                }.bind(this))
            });
        }
    },

    differences: function() {
        if (!this.get('tableExpanded')) {
            this.set('reloadDifferencesWhenExpanded', true);
        }

        if (this.get('tableExpanded') && this.get('tableLinked') &&
                this.get('litem.isFulfilled') && this.get('ritem.isFulfilled')) {
            this.set('_differences', this._computeDifferences());
        }

        return this.get('_differences');
    }.property('litem.isFulfilled', 'ritem.isFulfilled', 'product',
        'variant', 'differencesReloadToggle', 'tableLinked')
});

App.EmberTableComponent = Ember.Table.EmberTableComponent.extend({
    enableColumnReorder: false,
    hasFooter: false,

    /**
     * Setup Manual Resize
     *
     * Allow manual resizing of the table by toggling the property "tableSizeChange" on the controller
     * (see https://github.com/Addepar/ember-table/issues/114)
     */
    setupManualResize: function() {
        var parentController = this.get('targetObject');
        Ember.addObserver(parentController, 'tableSizeChange', this, function() {
            Ember.run.schedule('afterRender', this, function() {
                this.elementSizeDidChange();
            });
        });
    }.on('init'),

    actions: {
        sortByColumn: function(col) {
            this.sendAction('sortAction', col);
        }
    }
});

App.FilterValue = Ember.Object.extend({
    checked: true,
    value: null,
    column: null
});

App.HeaderCellView = Ember.Table.HeaderCell.extend({
    templateName: 'diffheadercell',

    classNameBindings: ['content.attribute'],

    sortIcon: function() {
        var ascState = this.get('content.asc');
        return ascState === null ? '' : (ascState ? '▲' : '▼');
    }.property('content.asc'),

    click: function(event) {
        if (!$(event.target).parents('a.dropdown').length > 0 ||
                $(event.target).parents('ul.dropdown-menu').length > 0) {
            event.stopPropagation();
        }
    },

    filterValues: Ember.computed.alias('content.filterValues'),

    allChecked: function(key, value) {
        if (value !== undefined) {
            // set property
            this.get('filterValues').forEach(function(item) {
                item.set('checked', value);
            });
        }

        return this.get('filterValues').isEvery('checked', true);
    }.property('filterValues.@each.checked'),

    isIndeterminate: function() {
        return this.get('filterValues').isAny('checked', true) && this.get('filterValues').isAny('checked', false);
    }.property('filterValues.@each.checked'),

    actions: {
        sortByColumn: function() {
            this.get('controller').send('sortByColumn', this.get('content'));
        },
        adjustMenu: function() {
            var button = this.$('a');
            var menu = this.$('ul.dropdown-menu');
            menu.css('left', button.offset().left - 155 + 'px');

            var top = button.offset().top + button.outerHeight();
            var bottom = top + menu.outerHeight();

            var isEntirelyVisible = top + menu.outerHeight() <=
                $(window).height();
            if (isEntirelyVisible) {
                menu.css('top', top + 'px');
            } else {
                // if the menu is to big for the page, open it upwards
                bottom = button.offset().top;
                menu.css('top', 'auto');
                menu.css('bottom', $(window).height() - bottom + 'px');
            }
        }
    }
});

App.TableCellView = Ember.Table.TableCell.extend({
    templateName: 'tablecellview',
    classNameBindings: ['content.attribute'],

    click: function(event) {
        var target = $(event.target);
        if (target.parents('.ignore-button').length > 0) {
            event.stopPropagation();
        }
    },

    actions: {
        ignore: function() {
            this.get('controller').sendAction(this.get('content.ignore'), this.get('cellContent.row'));
        }
    }
});

App.DiffTableComponent = Ember.Component.extend({
    classNames: ['diff-table'],
    filterText: null,
    sortConditions: Ember.A([]),
    showAssemblies: true,
    showLeaves: true,
    selectedItem: null,
    headerContent: Ember.A([]),
    linked: true,

    init: function() {
        this._super();
    },

    didInsertElement: function() {
        $('input, textarea').placeholder();
    },

    catalogIcon: function() {
        return this.get('urlpaths.localres') + 'catalog.png';
    }.property(),

    sortFunction: function() {
        var conditions = this.get('sortConditions');

        return function(a, b) {
            for (var i = 0; i < conditions.length; i++) {
                var condition = conditions[i];
                var fieldname = condition.get('attribute');
                var mode = condition.get('asc') ? 1 : -1;

                var lhs = Ember.get(a, fieldname);
                var rhs = Ember.get(b, fieldname);

                if (lhs > rhs) {
                    return 1 * mode;
                } else if (lhs < rhs) {
                    return -1 * mode;
                }
            }
            return 0;
        };
    }.property('sortConditions.[]'),

    sortedContent: function() {
        if (this.get('content.isFulfilled')) {
            var content = this.get('content.content');
            var result = content ? content.slice() : Ember.A();

            var sortFunction = this.get('sortFunction');
            if (sortFunction) {
                result.sort(sortFunction);
            }

            return result;
        } else {
            return Ember.A();
        }
    }.property('sortFunction', 'content.isFulfilled'),

    filterValues: function() {
        return this.get('columns').reduce(function(previousValue, item) {
            return previousValue.addObjects(item.get('filterValues'));
        }, Em.A());
    }.property('columns.@each.filterValues'),

    filteredContent: function() {
        var content = this.get('sortedContent');

        var filterText = this.get('filterText');
        var showAssemblies = this.get('showAssemblies');
        var showLeaves = this.get('showLeaves');
        var headerContent = this.get('headerContent');

        /* DO NOT DELETE THE FOLLOWING LINE!
           otherwise filterValues will not be computed and
           filterValues.@each.checked won't work!!
         */
        var filterValues = this.get('filterValues');

        return content.filter(function(entry) {
            if (filterText) {
                var match = headerContent.any(function(item) {
                    return ('' + entry[item.id]).toLowerCase().contains(filterText.toLowerCase());
                });
            } else {
                var match = true;
            }

            var button_state = (showAssemblies && !entry.get('is_leaf')) || (showLeaves  && entry.get('is_leaf'));

            var filter_menu = this.get('columns').every(function(column) {
                var entry_value = entry.get(column.get('attribute'));
                var value = column.get('filterValues').findBy('value', entry_value);

                return value === undefined || value.get('checked');
            });

            var visible = match && button_state && filter_menu;
            return visible;
        }, this);
    }.property('filterText', 'content.@each.ignored',
        'showAssemblies', 'showLeaves',
        'filterValues.@each.checked', 'sortedContent'),

    description: function() {
        var product = this.get('product');
        var variant = this.get('variant');

        return (product ? product.get('description') : '-') + ' ' +
            (variant ? variant.get('description') : '-');
    }.property('product', 'variant'),

    /*
     * Ember Table stuff
     */

    columns: function() {
        var optionals = ['maxWidth', 'defaultColumnWidth', 'canAutoResize'];
        var result = this.get('headerContent').map(function(item) {
            var column =  Ember.Table.ColumnDefinition.create({
                headerCellName: item.get('label'),
                attribute: item.get('id'),
                getCellContent: function(row) {
                    var attr = item.get('id');
                    return {
                        text: row.get(attr),
                        row: row
                    }
                },
                headerCellView: 'App.HeaderCellView',
                tableCellView: 'App.TableCellView',
                textAlign: 'left',
                asc: item.get('asc'),
                ignore: item.get('ignore'),
                filterValues: Ember.A(item.get('filterValues')).map(function(value) {
                    return App.FilterValue.create({
                        value: value.get('value'),
                        column: item.get('id'),
                        checked: value.get('default')
                    })
                })
            });

            // Set optional attributes
            for (var i = 0; i < optionals.length; i++) {
                var attr = optionals[i];
                if (item.get(attr) !== undefined) {
                    column.set(attr, item.get(attr));
                }
            }

            if (item.get('sortOnInit') === true) {
                this.send('sort', column);
            }

            return column;
        }, this);

        return result;
    }.property('headerContent'),

    actions: {
        sort: function(col) {
            var sortConditions = this.get('sortConditions');
            if (col.get('asc') === null) {
                col.set('asc', true);
            } else {
                col.set('asc', !col.get('asc'));
            }
            if (sortConditions.contains(col)) {
                sortConditions.removeObject(col);
            }
            sortConditions.insertAt(0, col);
        },
        select: function(row) {
            var selectedItem = this.get('selectedItem');
            if (selectedItem) {
                // clear selected
                selectedItem.set('selected', '');
            }
            // select clicked row
            row.set('selected', 'selected');
            // mark selected
            this.set('selectedItem', row);
        },
        showModalWindow: function() {
            this.sendAction('showModalWindow');
        },
        ignorePart: function(row) {
            this.sendAction('ignore', row.get('name'), row.get('content'));
        },
        ignoreDifference: function(row) {
            this.sendAction('ignore', row.get('name'), row.get('act_sbom'), row.get('content'));
        },
        deleteIgnore: function(row) {
            if (row.get('ignored')) {
                this.sendAction('deleteIgnore', row.get('name'), row.get('content'));
            }
        },
        toogleLink: function() {
            this.toggleProperty('linked');
        }
    }
});

App.DiffTableButtonView = Ember.View.extend({
    tagName: 'button',
    templateName: 'diff-table-button',
    attributeBindings: ['title'],
    classNameBindings: [':btn', 'value:active'],

    iconUrl: function() {
        return this.get('controller.urlpaths.localres') + this.get('icon');
    }.property('icon'),

    click: function() {
        this.toggleProperty('value');
    }
});

App.TreeSearch = Ember.ArrayProxy.extend({
    init: function() {
        this.set('content', Ember.A());

        this.initResults();
    },

    willDestroy: function() {
        this.clear();
        this._super();
    },

    /*
     * Following attributes must be set on creation
     */
    name: null,  // mandatory
    rootNode: null, // mandatory
    cssClass: "tree-search",  // optional

    /*
     * function called with (node) must return true/false
     * example function:
     *
     * function(node){
     *      return (node.get('id') === nodeSearch.get('searchId'));
     * }
     */
    match: null, // mandatory
    expand: function(node) { return false; }, // optional
    applyEffect: undefined,  // optional
    // whether to show a navigation for search result
    showNavigation: false,

    /*
     * Results
     */

    clear: function(context) {
        var self = this;

        var navNode = this.content.objectAt(this.get("navIdx"));
        navNode.get("navigatedBy").removeObject(this);

        this.content.forEach(function(node) {
            node.get("hitBy").removeObject(this);
        });

        this._super();
    },

    navIdx: 0,
    navIdxPlusOne: function() {
        return this.get("content.length") > 0 ? this.get("navIdx") + 1 : 0;
    }.property("navIdx", "content.length"),

    navigatedNode: function() {
        var navIdx = this.get("navIdx");
        return this.get("content").objectAt(navIdx);
    }.property("navIdx"),

    navIdxWillChange: function() {
        var navNode = this.content.objectAt(this.get("navIdx"));
        if (navNode) {
            navNode.get("navigatedBy").removeObject(this);
        }
    }.observesBefore("navIdx"),
    navIdxChanged: function() {
        var navNode = this.content.objectAt(this.get("navIdx"));
        if (navNode) {
            navNode.get("navigatedBy").pushObject(this);
        }

        this._navigate();
    }.observes("navIdx", "content.isFulfilled"),

    navigateForward: function() {
        if (this.get("navIdx") + 1 < this.get("content").length) {
            this.incrementProperty("navIdx");
        }
    },
    navigateBackward: function() {
        if (this.get("navIdx") > 0) {
            this.decrementProperty("navIdx");
        }
    },
    navigateCyclic: function() {
        if (this.get("content").length == 1) {
            var navNode = this.content.objectAt("0");
            navNode.get("navigatedBy").removeObject(this);
            navNode.get("navigatedBy").pushObject(this);
        } else {
            if (this.get("navIdx") + 1 < this.get("content").length) {
                this.incrementProperty("navIdx");
            } else {
                this.set("navIdx", 0);
            }
        }
    },

    _navigate: function() {
        var navIdx = this.get('navIdx');

        if (navIdx >= 0 && navIdx < this.content.length) {
            var node = this.get("content").objectAt(navIdx);
            if (node) {
                node.render();
                //node.expand();
                Ember.run.schedule('afterRender', node, "expand");
            }
        }
    },

    _initResults: function(node) {
        var self = this;

        var result = Ember.A([]);
        return Ember.RSVP.resolve(node).then(function(node) {
            return Ember.RSVP.hash({
                match: Ember.RSVP.resolve(self.match(node)).then(function(match) {
                    if (match) {
                        result.pushObject(node);
                        node.get("hitBy").pushObject(self);
                    }
                }),
                expand: Ember.RSVP.resolve(self.expand(node))
            }).then(function(data) {
                var expand = data.expand;
                var promise = Ember.RSVP.resolve(result);

                if (expand) {
                    // load nodes, but do not render!
                    promise = node.loadComponents().then(function(content) {
                        return Ember.RSVP.all(content.map(function(child) {
                            return self._initResults(child);
                        })).then(function(child_results) {
                            child_results.forEach(function(_res) {
                                result.pushObjects(_res);
                            });
                            return result;
                        });
                    });
                }
                return promise;
            });
        });
    },

    initResults: function() {
        var rootNode = this.get("rootNode");
        this._initResults(rootNode).then(function(content) {
            this.set("content", content);
        }.bind(this));
    }
});

App.TreeViewOperationView = Ember.View.extend({
    templateName: 'treeviewoperation',
    tagName: 'li',
    classNameBindings: ['disabled'],

    disabled: function() {
        return this.get('controller.multiSelect') && !this.get('operation').multi_select_op;
    }.property('operation', 'controller.multiSelect'),

    enabled: Ember.computed.not('disabled'),

    click: function(event) {
        if (this.get('disabled')) {
            event.stopPropagation();
        }
    },

    actions: {
        selectOperation: function(operation, context, isEbomView) {
            if (this.get('enabled')) {
                this.get('controller').send("selectOperation", operation, context, isEbomView);
            }
        }
    }
});

App.TreeViewButtonComponent = Ember.Component.extend({

    classNames: ['tree-view-button', 'pull-right'],

    selectedNodes: null,
    operations: null,
    selectedOperation: function() {
        var context = this.get('selectedOperationContext');
        var name = this.get('selectedOperationName');
        var multiSelect = this.get('multiSelect');

        if (context && name) {
            var global_operations = this.get('operations');
            var operations = global_operations ? global_operations.get(context) : null;
            if (operations) {
                if (this.get('isEbomView')) {
                    var operation = operations['ebom_ops'].findBy('label', name);
                } else {
                    var operation = operations['mbom_ops'].findBy('label', name);
                }
                if (!multiSelect || operation.multi_select_op) {
                    return operation;
                }
            }
        }
    }.property('selectedOperationName', 'selectedOperationContext', 'operations', 'multiSelect'),

    _operations: function() {
        if (this.get('rootNode.isEbomView')) {
            var item = this.get('operations.item.ebom_ops');
            var bom = this.get('operations.bom.ebom_ops');
        } else {
            var item = this.get('operations.item.mbom_ops');
            var bom = this.get('operations.bom.mbom_ops');
        }
        return Ember.Object.create({
            bom: bom,
            item: item
        });
    }.property('operations'),

    multiSelect: function() {
        return this.get('selectedNodes.content.length') > 1;
    }.property('selectedNodes.content.length'),

    _fetchOperationUrl: function(name, context, node) {
        // fetch url from server
        var url = App.get('apiUrlRoot') + name + '/' + context +
            '/operation_url';

        if (context == 'item') {
            var keys = {cdb_object_id: node.get('nodeId')};
        } else {
            var keys = {
                baugruppe: node.get('baugruppe'),
                b_index: node.get('b_index'),
                teilenummer: node.get('teilenummer'),
                t_index: node.get('t_index'),
                position: node.get('position'),
                variante: node.get('variante'),
                auswahlmenge: node.get('auswahlmenge')
            };
        }

        return App.ajax({
            url: url,
            data: keys,
            dataType: 'json'
        });
    },

    actions: {
        addNodeToSelection: function() {
            var selectedNodes = this.get('selectedNodes');
            if (!(selectedNodes.get('content').contains(this.get('treeNode')))) {
                selectedNodes.click(this.get('treeNode'), false, false);
            }
        },

        selectOperation: function(operation, context, isEbomView) {
            this.set('selectedOperationContext', context);
            this.set('selectedOperationName', operation.label);
            this.set('isEbomView', isEbomView);
            this.send('executeOperation');
        },

        adjustMenu: function() {
            var button = this.$('button:nth-child(1)');

            var menu = this.$('.dropdown-menu');
            menu.css('left', button.offset().left - 155 + 'px');
            menu.css('width', '230px');

            var top = button.offset().top + button.outerHeight();
            var bottom = top + menu.outerHeight();

            if (bottom <= $(window).height()) {
                menu.css('top', top + 'px');
            } else {
                // if the menu is to big for the page, open it upwards
                bottom = button.offset().top;
                menu.css('top', 'auto');
                menu.css('bottom', $(window).height() - bottom + 'px');
            }
        },

        executeOperation: function() {
            var self = this;

            var operation = this.get('selectedOperation');
            if (operation) {
                var exec_op = this;
                var content = this.get('selectedNodes.content');
                if (content.length == 1) {
                    // single select operation

                    this._fetchOperationUrl(operation.name,
                        this.get('selectedOperationContext'),
                        this.get('treeNode')).then(function(data) {
                        if (data.success) {
                            window.open(data.result, '_self');

                            if (operation.needsReload) {
                                self.sendAction('refreshBom',
                                                self.get('treeComponent'),
                                                self.get('treeNode'));
                            }

                            if (operation.unselect) {
                                content.removeObject(node);
                            }
                        } else {
                            cdb.elink.alert(data.message);
                        }
                    });
                } else if (content.length > 1) {
                    // multi select operations
                    if (this.get('selectedOperationContext') == "item") {
                        var pk = function(node) {
                            return {cdb_object_id: node.get('nodeId')};
                        };
                    } else {
                        var pk = function(node) {
                            return {
                                baugruppe: node.get('baugruppe'),
                                b_index: node.get('b_index'),
                                teilenummer: node.get('teilenummer'),
                                t_index: node.get('t_index'),
                                position: node.get('position'),
                                variante: node.get('variante'),
                                auswahlmenge: node.get('auswahlmenge')
                            }
                        };
                    }
                    var keys = this.get('selectedNodes.content').map(pk, this);

                    var exec_multi_select_op = function(exec_op, operation, content) {
                        App.ajax({
                            url: operation.custom_url,
                            data: {
                                opname: operation.opname,
                                keys: JSON.stringify(keys)
                            },
                            dataType: 'json',
                            type: 'post',
                            async: false
                        }).then(function(data) {
                            if (data.success) {
                                if (operation.needsReload) {
                                    content.forEach(function(item) {
                                        exec_op.sendAction('refreshBom',
                                        exec_op.get('treeComponent'), item);
                                    });
                                }
                                if (operation.unselect) {
                                    content.clear();
                                }
                            } else {
                                cdb.elink.alertCDBMessage(data.message);
                            }
                        });
                    };

                    if (operation.dialogText) {
                        cdb.elink.modal({
                            pre_mask: function(mask) {
                                $('<p>', {'class': 'alert'}).text(
                                    operation.dialogText).appendTo(mask.find('.modal-body'));
                                var dlgBtns = $.parseJSON(operation.dialogBtns);
                                mask.find('button.lbl-ok').text(dlgBtns.ok);
                                mask.find('button.lbl-cancel').text(dlgBtns.cancel);
                            },
                            ok: function() {
                                exec_multi_select_op(exec_op, operation, content);
                            },
                            cancel: function() { }
                        });
                    } else {
                        exec_multi_select_op(exec_op, operation, content);
                    }
                }
            }
        }
    }
});

App.TreeNodeViewSelector = Ember.Object.extend({
    actionViewClass: Ember.View.extend({
        expanding: false,
        templateName: 'action-view',
        actions: {
            toggleAction: function() {
                this.toggleProperty('expanding');
            }
        }
    }),
    nodeViewClass: Ember.View.extend({
        templateName: 'node-view'
    }),
    navigationViewClass: Ember.View.extend({
        templateName: 'navigation-view'
    }),

    viewFor: function(node) {
        return this.get('nodeViewClass');
    }
});

App.TreeViewComponent = Ember.Component.extend({
    classNames: ['tree-view-component'],
    classnameBindings: ['treeNode.item.is_mbom:ebom:mbom'],

    registerTreeSearches: function() {
        var self = this;
        this.get('treeSearches').addEnumerableObserver(this, {
            willChange: function(navigatedBy, removing, addCount) {},
            didChange: function(navigatedBy, removeCount, adding) {
                adding.forEach(function(item) {
                    item.set('controller', self);
                });
            }
        });
    }.on('init'),

    didInsertElement: function() {
        var self = this;

        this.$('input, textarea').placeholder();

        this.$().scroll(function() {
            self.renderVisibleArea();
        });

        this.setContainerHeight();
    },

    _setContainerHeight: function() {
        var container = this.$("> .tree-node");

        if (container) {
            var height = this.get('treeNode.listContent.length') * 17.15;
            container.height(height);
        }

        this.renderVisibleArea();
    },

    setContainerHeight: function() {
        Ember.run.once(this, "_setContainerHeight");
    }.observes('treeNode.listContent'),

    renderVisibleArea: function() {
        var viewport = this.$();
        var container = this.$("> .tree-node");
        var listContent = this.get('treeNode.listContent');

        if (viewport && container && listContent) {

            // Visible area (relative to container)
            var top = viewport.scrollTop();
            var bottom = top + viewport.height();

            // first visible index (approximate)
            //var begin = Math.max(Math.floor((top / container.height()) * listContent.length) - 10, 0);
            var begin = 0;
            // last visible index (approximate)
            var end = Math.ceil((bottom / container.height()) * listContent.length) + 10;

            // set visible flag
            Ember.beginPropertyChanges();
            listContent.slice(begin, end).forEach(function(node) {
                node.set('visible', true);
            });
            Ember.endPropertyChanges();
        }
    },

    // root
    treeNode: null,

    scrollToNode: function(node, effect) {
        var scrollContainer = this.$();

        var listContent = this.get('treeNode.listContent');
        if (listContent) {
            var index = listContent.indexOf(node);
            if (index >= 0) {
                // set visible flag
                Ember.beginPropertyChanges();
                listContent.slice(0, index+1).forEach(function(node) {
                    node.set('visible', true);
                });
                Ember.endPropertyChanges();

                Ember.run.schedule('afterRender', function() {
                    var container = scrollContainer[0];
                    var component = node.get('component');
                    if (component) {
                        var element = component.$()[0];
                        if (container && element) {
                            scrollIntoViewIfNeeded(container, element);
                        }
                    }
                });
            }
        }

        if (effect) {
            node.trigger('animate', effect);
        }
    },

    actions: {
        refreshBom: function(bom, node, reloadParent) {
            this.sendAction('refreshBom', bom, node, reloadParent);
        },

        triggerSync: function(bom, node) {
            this.sendAction('triggerSync');
        }
    }
});

App.TreeViewNodeComponent = Ember.Component.extend({
    classNames: ['tree-node'],
    classNameBindings: [
        'treeNode.item.is_mbom:mbom-node:ebom-node',
        'treeNode.item.is_assembly:assembly:bomitem'
    ],

    viewSelector: App.TreeNodeViewSelector.create({}),

    registerOnTreeNode: function() {
        var self = this;
        var treeNode = Ember.RSVP.resolve(this.get('treeNode'));
        treeNode.then(function(node) {
            node.set('component', self);
        });
    },

    animate: function() {
        var self = this;
        var treeNode = Ember.RSVP.resolve(this.get('treeNode'));
        treeNode.then(function(node) {
            node.on('animate', function(effect) {
                effect(self.$());
            });

            node.get('navigatedBy').forEach(function(treeSearch) {
                if (treeSearch.applyEffect) {
                    treeSearch.applyEffect(self.$());
                }
            });
        });
    }.on('init'),

    willDestroy: function() {
        if (this.get('treeNode.navigatedBy')) {
            this.get('treeNode.navigatedBy').removeEnumerableObserver(this);
        }
    },

    isNavigated: Ember.computed.notEmpty('treeNode.navigatedBy.[]'),
    isHit: Ember.computed.notEmpty('treeNode.hitBy.[]'),

    treeCssClasses: function() {
        var treeSearchClasses = this.get('treeNode.treeSearchClasses');
        if (treeSearchClasses) {
            return treeSearchClasses.join(' ');
        }
    }.property('treeNode.treeSearchClasses.[]'),

    actionView: function() {
        return this.get('viewSelector').get('actionViewClass');
    }.property('viewSelector'),

    treeComponent: null,

    isRoot: false,

    isSelected: function() {
        return this.get('selectedNodes.content').contains(this.get('treeNode'));
    }.property('treeNode', 'selectedNodes.content.[]'),

    treeNode: null,
    treeNodeView: function() {
        return this.get('viewSelector').viewFor(this.get('treeNode'));
    }.property('treeNode', 'viewSelector'),

    treeNodeHasContent: Ember.computed.notEmpty('treeNode.[]'),
    hasChildren: Ember.computed.or('treeNodeHasContent', 'treeNode.hasChildren', 'treeNode.hasPredicates'),

    collapsible: function() {
        return this.$('.tree-child-nodes.collapse:first');
    },

    expandCurrentNode: function(state) {
        var expanded = this.get('treeNode.expanded');

        if (expanded) {
            this.collapsible().addClass('in');
        } else {
            this.collapsible().removeClass('in');
        }
    }.observes('treeNode.expanded'),

    didInsertElement: function() {
        this.registerOnTreeNode();
        this.expandCurrentNode();
    },

    buttonVisible: false,

    refreshBom: "refreshBom",
    actions: {
        refreshBom: function(bom, node, reloadParent) {
            this.sendAction('refreshBom', bom, node, reloadParent);
        },
        toggleButtonVisibility: function() {
            this.set('buttonVisible', true);
        }
    }
});

App.TreeViewPredicateComponent = Ember.Component.extend({
    classNames: ['bom-tree-predicate']
});

App.TreeViewToolbarComponent = Ember.Component.extend({
    viewSelector: App.TreeNodeViewSelector.create({}),

    sortProperties: ['position'],
    sortedTreeSearches: Ember.computed.sort('treeSearches', 'sortProperties'),

    navigationView: function() {
        return this.get('viewSelector.navigationViewClass');
    }.property('viewSelector'),

    jumpToFirst: function(treeSearch) {
        treeSearch.set('navIdx', 0);
    },

    actions: {
        searchBOM: function(field) {
            var condition = this.get('searchStringValue');
            this.set('searchString', condition);
        },

        // navigations
        jumpToNext: function(treeSearch) {
            treeSearch.navigateForward();
        },
        jumpToPrev: function(treeSearch) {
            treeSearch.navigateBackward();
        },
        jumpToCurrent: function(treeSearch) {
            // TODO
        }
    }
});

App.PreviewControlComponent = Ember.Component.extend({
    classNames: ['container-fluid', 'diffutil-preview-control-row'],
    toplabel: function() {
        var title = this.get('title');
        var description = this.get('description');
        if (title && description) {
            return this.get('labels.cdbvp_diffutil_selected_element') + ': ' +
                this.get('title') + ' / ' + this.get('description');
        } else {
            return this.get('placeholder');
        }
    }.property('title', 'description'),

    previewMode: null,
    preview2D: function() {
        return this.get('previewMode') === '2D';
    }.property('previewMode'),
    preview3D: function() {
        return this.get('previewMode') === '3D';
    }.property('previewMode'),

    sync3DIcon: function() {
        return this.get('urlpaths.localres') + 'synch_threed.png'
    }.property(),

    threedSynchUrl: function () {
        if (this.get('threedUrl.isFulfilled')) {
            return this.get('threedUrl.url');
        }
    }.property('threedUrl.isFulfilled'),

    actions: {
        refreshAll: function(){
          this.sendAction(this.get('refreshAll'));
        },
        setPreviewMode: function(mode) {
            this.set('previewMode',
                this.get('previewMode') === mode ? null : mode);
        }
    }
});

App.HeaderRawCellView = Ember.Table.HeaderCell.extend({
    templateName: 'header-raw-cell'
});

App.GenericTableComponent =
    Ember.Component
        .extend({
            classNames: ['container-fluid', 'generic-table'],
            filterText: null,
            pageSize: 10,
            title: '',
            filter_placeholder: 'search ...',
            selectedItem: null,
            headerContent: Ember.A([]),
            init: function() {
                this._super();
            },

            didInsertElement: function() {
                var self = this;
                $('input, textarea').placeholder();
                self.$('form.filter_form').submit(function(ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    self.sendAction('filter', self.get('filterText'));
                    return false;
                });
            },
            columns: function() {
                var optionals = ['maxWidth', 'defaultColumnWidth', 'canAutoResize'];
                var result = this.get('headerContent').map(function(item) {
                    var column =  Ember.Table.ColumnDefinition.create({
                        headerCellName: item.get('label'),
                        contentPath: item.get('id'),
                        headerCellView: 'App.HeaderRawCellView',
                        textAlign: 'left'
                    });

                    // Set optional attributes
                    for (var i = 0; i < optionals.length; i++) {
                        var attr = optionals[i];
                        if (item.get(attr) !== undefined) {
                            column.set(attr, item.get(attr));
                        }
                    }
                    return column;
                });
                return result;
            }.property('headerContent')
        });

App.StateIconComponent = Ember.Component.extend({
    classNames: ['state-icon-component'],
    fillColor: null,
    borderColor: null,
    iconStyle: function() {
        var fillColor = this.get('fillColor');
        var borderColor = this.get('borderColor');
        if (!fillColor) {
            fillColor = [255, 255, 255];
        }
        if (!borderColor) {
            borderColor = [0, 0, 0];
        }
        return 'background-color: rgb(' + String(fillColor)
                + '); border: 1px solid rgb(' + String(borderColor) + ');';
    }.property('fillColor', 'borderColor')
});

App.ModalWindowComponent = Ember.Component.extend({
    isVisible: false,
    classNames: ['modal', 'fade'],
    didInsertElement: function() {
        var self = this;
        this.$().on('hidden', function() {
            self.set('isVisible', false);
        });
        this._modal_hide();
    },
    _modal_hide: function() {
        var is_visible = this.get('isVisible');
        if (is_visible) {
            this.$().modal('show');
        } else {
            this.$().modal('hide');
        }
    }.observes('isVisible'),
    actions: {
        buttonTriggered: function(button_action) {
            // should be connected to parent view/component
            this.sendAction('buttonTriggered', button_action);
        }
    }
});

App.CollapsibleBlockComponent = Ember.Component.extend({
    attributeBindings: ['blocktitle', 'expanded'],
    classNames: ['collapsible-block'],
    actions: {
        toggleCaret: function() {
            this.set('expanded', !this.get('expanded'));
        },
        buttonAction: function() {
            if (this.get('isActive') !== undefined) {
                this.sendAction('buttonAction', !this.get('isActive'));
            } else {
                this.sendAction('buttonAction');
            }
        }
    }
});

App.IndexController =
    Ember.ObjectController
        .extend({
            init: function() {
                this.set('lTreeSearches', Ember.A([]));
                this.set('rTreeSearches', Ember.A([]));

                this.set('selectedNodes', App.NodeSelection.create([]));

                // set preview mode
                var previewCookie = $.cookie('cs.vp.bom.diffutil_preview_mode');
                if (previewCookie) {
                    this.set('previewMode', previewCookie);
                }

                // apply query params as filter
                var params = getQueryParams();

                this.set('filter_txt', '');
                if (params['_filtertext']) {
                    this.set('filter_txt', decodeURIComponent(params['_filtertext'].replace(/\+/g, '%20')));
                }

                delete params._filtertext;

                this.set('filter', JSON.stringify(params));
                App.CacheLayer.get('bomCache').set('filter', this.get('filter'));
            },
            afterModel: function() {
                this.set('model.filter', this.get('filter'));
            },
            watchKeyEvents: function() {
                var controller = this;

                $(document).on('keydown', function(event) {
                    if (event.altKey === true && event.ctrlKey === true && event.key === "d") {
                        controller.set('showDebugTool', false);
                        Ember.run.later(function() {
                            controller.set('debugEntries', App.get('_ajaxTime'));
                            controller.set('showDebugTool', true);
                        });
                    }
                })
            }.on('init'),

            diffHeaderContent: function() {
                var headerContent = [{
                    id: 'name',
                    label: this.get('labels.cdbvp_elink_diffutil_part_no'),
                    asc: false,
                    maxWidth: 150,
                    canAutoResize: true,
                    ignore: 'ignorePart'
                }, {
                    id: 'idx',
                    label: this.get('labels.cdbvp_elink_diffutil_idx'),
                    asc: false,
                    maxWidth: 60,
                    canAutoResize: true
                }, {
                    id: 'level',
                    label: this.get('labels.cdbvp_elink_diffutil_level'),
                    asc: false,
                    maxWidth: 120,
                    canAutoResize: true,
                    sortOnInit: true
                }, {
                    id: 'caption',
                    label: this.get('labels.cdbvp_elink_diffutils_name'),
                    asc: false,
                    canAutoResize: true
                }, {
                    id: 'category',
                    label: this.get('labels.cdbvp_elink_diffutils_category'),
                    filterValues: this.get("categories").map(function(value) {
                        return Ember.Object.create({
                            value: value,
                            default: true
                        });
                    }),
                    asc: false,
                    maxWidth: 150,
                    canAutoResize: true
                }, {
                    id: 'cnt_fbom',
                    label: this.get('labels.cdbvp_elink_diffutils_cnt_fbom'),
                    asc: false,
                    maxWidth: 70,
                    canAutoResize: true
                }, {
                    id: 'cnt_sbom',
                    label: this.get('labels.cdbvp_elink_diffutils_cnt_sbom'),
                    asc: false,
                    maxWidth: 70,
                    canAutoResize: true
                }, {
                    id: 'act_sbom',
                    label: this.get('labels.cdbvp_elink_diffutils_act_right_bom'),
                    asc: false,
                    maxWidth: 200,
                    canAutoResize: true,
                    ignore: 'ignoreDifference'
                }, {
                    id: 'ignored',
                    label: this.get('labels.cdbvp_diffutil_ignored'),
                    asc: false,
                    maxWidth: 150,
                    canAutoResize: true,
                    ignore: 'deleteIgnore',
                    filterValues: [this.get('labels.cdbvp_diffutil_ignored_difference'),
                        this.get('labels.cdbvp_diffutil_ignored_item')].map(function(value) {
                        return Ember.Object.create({
                            value: value,
                            default: false
                        });
                    })
                }];

                return Ember.A(headerContent.map(function(el) {
                    return Ember.Object.create(el);
                }));
            }.property(),

            classNames: ["row-layout", "container"],
            variantTableExpanded: true,

            sync_view_icon: function() {
                return this.get('urlpaths.localres') + 'sync_view.png';
            }.property(),

            /* MBOM select */
            _syncRitem2Selection: function() {
                var ritem_object_id = this.get('ritem_object_id');
                var itemList = this.get('itemList');

                if (ritem_object_id && itemList) {
                    var item = itemList.findBy("cdb_object_id", ritem_object_id);
                    if (item) {
                        this.set('ritemSelection', item);
                    }
                }
            }.observes('ritem_object_id'),

            _syncSelection2Ritem: function() {
                var ritem_object_id = this.get('ritem_object_id');
                var ritemSelection = this.get('ritemSelection');

                if (ritemSelection &&
                        ritemSelection.get('cdb_object_id') !== ritem_object_id) {
                    this.set('ritem_object_id', ritemSelection.get('cdb_object_id'));
                }
            }.observes('ritemSelection'),

            /*
             * 3D Cockpit
             */
            csThreedInstalled: function() {
                return this.get('threed_plugin_id') !== undefined;
            }.property('threed_plugin_id'),

            threedUrl: function() {
                if (this.get('csThreedInstalled')) {
                    var self = this;
                    var loid = this.get("litem_object_id");
                    var roid = this.get("ritem_object_id");

                    if (loid !== undefined && roid !== undefined) {
                        var url = App.get('apiUrlRoot') + loid + '/' + roid +
                            '/threed_url';
                        // FIMXE: label
                        return App.PromiseObject.create({
                            promise: App.ajax({
                                url: url,
                                dataType: 'json',
                                type: 'get',
                                async: true
                            }).then(function(data) {
                                if (data.success) {
                                    var result = data.result + "#/plugin/" +
                                        self.get('threed_plugin_id');
                                    return {"url": result}
                                } else {
                                    cdb.elink.alertCDBMessage(data.message);
                                }
                            })
                        });
                    }
                }
            }.property("litem_object_id", "ritem_object_id"),

            /*
             * Variant Selection
             */
            modalActive: false,
            // only used to prevent preloading of variants
            modalFirstLoad: false,
            variantProperties: Ember.A([]),
            hasProducts: function() {
                return this.get('products').length > 0;
            }.property('products'),
            hasVariants: function() {
                var products = this.get('products');
                return products.any(function(product) {
                    return product.variantCount > 0;
                });
            }.property('products'),

            hasMultipleMBOMs: function() {
                return this.get('itemList').length > 1;
            }.property(),

            variantTableHeader: function() {
                var columns = [];
                columns.push(Ember.Object.create({
                    id: 'vid',
                    label: this.get("labels.cdbvp_elink_diffutils_variant_id"),
                    asc: false
                }));

                columns.push(Ember.Object.create({
                    id: 'name',
                    label: this.get("labels.cdbvp_elink_diffutils_variant_name"),
                    asc: false
                }));

                this.get('variantProperties').forEach(function(prop) {
                    columns.push(Ember.Object.create({
                        id: '' + prop.id,
                        label: prop.name,
                        asc: false,
                        additionalClasses: 'property'
                    }));
                });
                return Ember.A(columns);
            }.property('variantProperties'),

            modalFooterButtons: function() {
                return [{
                    'label': this.get('labels.cdbvp_elink_diffutils_cancel'),
                    'classes': 'btn label_cancel',
                    'action': 'cancel'
                }];
            }.property(),

            modalHeaderButtons: function() {
                return [{
                    label: '×',
                    classes: 'close',
                    action: 'close'
                }];
            }.property(),
            _reactOnVariantSelection: function() {
                var variant = this.get('variant');
                if (this.get('modalActive')) {
                    this.set('modalActive', false);
                }
                App.CacheLayer.get("bomCache").set('variant', variant);
                var differencesCache = App.CacheLayer.get("differencesCache");
                if (differencesCache) {
                    differencesCache.set('variant', variant);
                }
                // dummy will not be used
                this.set('lRootNode', 'dummy');
                // dummy will not be used
                this.set('rRootNode', 'dummy');
            }.observes('variant'),

            _reactOnVariantProductSelection: function() {
                Ember.run.schedule('afterRender', this, function() {
                    this._preSelectProductVariant();
                    this._loadProductVariantProperties();
                });
            }.observes('product'),

            _preSelectProductVariant: function() {
                var product = this.get('product');
                if (product && window.variant) {
                    if (product.get('cdb_object_id') === window.product_object_id) {
                        var variant = Ember.Object.create(window.variant);
                        variant.set('selected', true);
                        this.set('variant', variant);
                        window.variant = undefined;
                    }
                }
            },

            _loadProductVariantProperties: function() {
                var product = this.get('product');
                if (product) {
                    var results = Ember.A([]);
                    var url = App.get('apiUrlRoot');
                    url += '/' + product.cdb_object_id;
                    url += '/product_properties';
                    App.ajax({
                        url: url,
                        type: 'get',
                        dataType: 'json',
                        async: true
                    }, true, 'cdbvp_elink_diffutil_load_variants').then(function(data) {
                        if (data.success) {
                            $.each(data.result, function(index, item) {
                                results.pushObject(Ember.Object.create(item));
                            });
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }
                        this.set('variantProperties', results);
                    }.bind(this));
                } else {
                    this.set('variantProperties', Ember.A([]));
                    this.set('variant', null);
                }
            },

            // Root node for the left bom tree
            // params needed to renew property (variant)
            lRootNode: function(key, value, oldValue) {
                if (this.get('model.litem.isFulfilled')) {
                    return this._loadRootNode('litem', /* isEbomView */true);
                }
            }.property('model.litem.isFulfilled'),

            // Root node for the right bom tree
            // params needed to renew property (variant)
            rRootNode: function(key, value, oldValue) {
                if (this.get('model.ritem.isFulfilled')) {
                    return this._loadRootNode('ritem', /* isEbomView */false);
                }
            }.property('model.ritem.isFulfilled'),

            selectedItem: null,
            selectedNodes: null,
            syncNode: null,

            selectedItemChanged: function() {
                this.get('selectedItem.item').then(function(item) {
                    if (item) {
                        // load preview
                        this.set('previewItem', item);

                        // search in tree structures
                        this.set('diffSearchItem', item);
                    }
                }.bind(this));
            }.observes('selectedItem'),

            selectedNode: function() {
                var content = this.get('selectedNodes.content');

                if (content.length === 1) {
                    return content.objectAt(0);
                }
            }.property('selectedNodes.content.[]'),

            selectedNodeChanged: function() {
                var selectedNode = this.get('selectedNode');

                if (selectedNode) {
                    this.selectIn3DViewer(selectedNode);
                    this.set('previewItem', selectedNode.get('item'));
                } else {
                    this.set('previewItem', null);
                }
            }.observes('selectedNode'),

            selectIn3DViewer: function(node) {
                if (this.get('threed_plugin_id') !== undefined) {
                    var msg = {
                        id: this.get('threed_plugin_id'),
                        'type': 'product',
                        path: node.get('path')
                    };
                    localStorage.setItem('cs.threed.path_event',
                        JSON.stringify(msg));
                }
            },

            externalPreview: function() {
                return this.get("previewMode") === "3D" ||
                    this.get("previewMode") === "2D";
            }.property("previewMode"),

            previewLink: function() {
                var previewItem = this.get('previewItem');
                var previewMode = this.get('previewMode');

                if (previewItem) {
                    var url =
                        App.get('apiUrlRoot') + previewItem.get('cdb_object_id') + '/' + previewMode + '/previewlink';

                    return App.ajax({
                        url: url,
                        dataType: 'json',
                        type: 'post',
                        async: true
                    }, true, 'cdbvp_elink_diffutil_load_preview_link').then(function(data) {
                        if (data.success) {
                            return data.result;
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }
                    });
                } else {
                    return Ember.RSVP.resolve();
                }
            }.property('previewItem', 'previewMode'),

            openExternalPreview: function() {
                var app = this;
                var externalPreview = this.get('externalPreview');
                if (externalPreview) {
                    var previewItem = this.get('previewItem');
                    if (previewItem) {
                        previewItem.get('itemDetails').then(function() {
                            $.cookie('cs.vp.bom.diffutil_preview_title',
                                previewItem.get('description'), {
                                path: '/'
                            });
                        });
                    } else {
                        $.cookie('cs.vp.bom.diffutil_preview_title', this
                            .get('labels.cdbvp_elink_diffutils_nopreview'), {
                            path: '/'
                        });
                    }

                    this.get('previewLink').then(function(link) {
                        if (link) {
                            // set cookie
                            $.cookie('cs.vp.bom.diffutil_preview_link', link, {
                                path: '/'
                            });
                        } else {
                            // set cookie
                            $.cookie('cs.vp.bom.diffutil_preview_link', 'nopreview', {
                                path: '/'
                            });
                        }

                        // open tab
                        var url = app.get('urlpaths.preview');
                        window.open(url, 'bompreview');
                    });
                }
            }.observes('previewLink', 'externalPreview'),

            differenceSearch: function(rootNode, differences, usages) {
                var selectedItem = this.get('diffSearchItem');

                var paths = Ember.A();
                paths.pushObjects(differences.get('left'));
                paths.pushObjects(differences.get('right'));

                return App.TreeSearch.create({
                    position: 20,
                    rootNode: rootNode,
                    name: 'differences',
                    cssClass: rootNode.isEbomView ? 'differences ebom-nav' : 'differences mbom-nav',
                    match: function(node) {
                        var matchPath = node.get('inVariant') && (paths.length === 0 || paths.any(function(path) {
                            return node.isContainedInPath(path);
                        }));
                        if (matchPath) {
                            return (node.get('item.cdb_object_id') === selectedItem.get('cdb_object_id') ||
                                node.get('item.cdb_depends_on') === selectedItem.get('cdb_object_id'));
                        }
                        return false;
                    },
                    expand: function(node) {
                        return node.get('inVariant') && (paths.length === 0 || paths.any(function(path) {
                            return node.isContainedInPath(path) || node.containsPath(path)
                        })) && usages.contains(node.get('item.cdb_object_id'));
                    },
                    showNavigation: true
                });
            },

            bomSearch: function(rootNode, item, searchString) {
                var condition = this.get(searchString);

                if (condition) {
                    var url = App.get('apiUrlRoot') + item.get('cdb_object_id') + '/stringsearch';
                    return App.ajax({
                        url: url,
                        dataType: 'json',
                        data: {
                            condition: condition
                        },
                        type: 'get',
                        async: true
                    }, true, 'cdbvp_elink_diffutil_load_search_result').then(function(data) {
                        // Get results from server
                        var results = Ember.A([]);
                        var usages = Ember.A([]);

                        if (data.success) {
                            results.pushObjects(data.result.results);
                            usages.pushObjects(data.result.usages);
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }

                        return {
                            results: results,
                            usages: usages
                        };
                    }).then(function(data) {
                        // optimization: fetch every needed bom at once
                        var bomCache = App.CacheLayer.get('bomCache');
                        data._cache = bomCache.getProperties(data.usages);
                        return Ember.RSVP.hash({
                            usages: data.usages,
                            results: data.results,
                            _cache: Ember.RSVP.resolve(data._cache)
                        });
                    }).then(function(data) {
                        return App.TreeSearch.create({
                            position: 10,
                            rootNode: rootNode,
                            name: 'search',
                            cssClass: 'bom-search',
                            match: function(node) {
                                // compare primary keys
                                return data.results.find(function(value) {
                                    return Object.keys(value).every(function(key) {
                                        return String(node.get(key)) === value[key];
                                    });
                                }) !== undefined;
                            },
                            expand: function(node) {
                                return data.usages.contains(node.get('nodeId'));
                            },
                            showNavigation: true
                        });
                    });
                } else {
                    return Ember.RSVP.resolve();
                }
            },

            syncSearch: function() {
                var syncNode = this.get('syncNode');
                var self = this;
                if (syncNode) {
                    var url = App.get('apiUrlRoot') +
                        syncNode.get('nodeId') + '/' +
                        this.get('litem_object_id') + '/' +
                        this.get('ritem_object_id') + '/syncbom';

                    return App.ajax({
                        url: url,
                        data: {
                            path: JSON.stringify(syncNode.get('path')),
                            is_ebom: syncNode.get('isEbomView')
                        },
                        dataType: 'json',
                        type: 'get',
                        async: true
                    }).then(function(data) {
                        if (data.success) {
                            var partners = Ember.A([]);
                            var usages = Ember.A([]);
                            var paths = Ember.A([]);

                            if (data.result.partners.length > 0) {
                                partners.pushObjects(data.result.partners);
                                usages.pushObjects(data.result.usages);
                            }
                            paths.pushObjects(data.result.paths);
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }

                        return {
                            partners: partners,
                            paths: paths,
                            usages: usages
                        };
                    }).then(function(data) {
                        if (!data.partners || data.partners.length === 0) {
                            data.partners = Ember.A();
                            data.usages = syncNode.get('item.usages');
                        }
                        data.partners.push(syncNode.get('item.cdb_object_id'));

                        return Ember.RSVP.hash(data);
                    }).then(function(data) {
                        if (syncNode.get('isEbomView')) {
                            var rootNode = self.get('rRootNode');
                        } else {
                            var rootNode = self.get('lRootNode');
                        }
                        return App.TreeSearch.create({
                            rootNode: rootNode,
                            name: 'sync',
                            cssClass: 'sync',
                            match: function(node) {
                                // only match nodes which are contained in the path
                                return data.paths.any(function(path) {
                                    return node.isContainedInPath(path) &&
                                        data.partners.contains(node.get('nodeId'));
                                });
                            },
                            expand: function(node) {
                                // only expand nodes which intersect the path
                                return data.paths.any(function(path) {
                                    return (node.isContainedInPath(path) || node.containsPath(path)) &&
                                        data.usages.contains(node.get('nodeId'));
                                });
                            },
                            applyEffect: function(el) {
                                el.effect('highlight', {
                                    color: '#FF8000'
                                }, 3000);
                            },
                            showNavigation: false
                        });
                    });
                }
            }.property('syncNode'),

            setCaches: function() {
                var product_object_id = this.get('product.cdb_object_id');
                var filter = this.get('filter');

                Ember.RSVP.hash({
                    litem: this.get('litem'),
                    ritem: this.get('ritem')
                }).then(function(options) {
                    var litem = options.litem;
                    var ritem = options.ritem;

                    if (litem && ritem) {
                        App.CacheLayer.set('usagesCache', App.UsagesCache.create({
                            litem: litem,
                            ritem: ritem
                        }));
                        App.CacheLayer.set('differencesCache', App.DifferencesCache.create({
                            litem: litem,
                            ritem: ritem,
                            product_object_id: product_object_id
                        }));
                        App.CacheLayer.get("differencesCache").set('filter', filter);
                    } else {
                        App.CacheLayer.set('usagesCache', null);
                        App.CacheLayer.set('differencesCache', null);
                    }
                });
            }.observes('litem_object_id', 'ritem_object_id', 'product'),

            /*
             * tree searches
             */

            _clean_collection: function(collection, name) {
                collection.removeObject(collection.findBy('name', name));
            },

            cleanUpSearch: function(node, name) {
                if (node) {
                    var self = this;

                    this._clean_collection(node.get('navigatedBy'), name);
                    this._clean_collection(node.get('hitBy'), name);

                    node.get('content').forEach(function(child) {
                        self.cleanUpSearch(child, name);
                    });
                }
            },

            ndiffs: function() {
                if (this.get('differences.isFulfilled')) {
                    return this.get('differences.length');
                }
            }.property('differences.isFulfilled'),

            diffSearchItemChanged: function() {
                var self = this;
                Ember.RSVP.all([this.get('lRootNode'),
                                this.get('rRootNode')].map(function(rootNode) {
                                    if (rootNode) {
                                        rootNode.then(function(rootNode) {
                                            self.cleanUpSearch(rootNode, 'differences');
                                        });
                                    }
                                }));
                var diffSearchItem = this.get('diffSearchItem');
                var self = this;

                // optimization: fetch every needed bom at once
                var promise = Ember.RSVP.resolve();
                if (diffSearchItem) {
                    var differencesCache = App.CacheLayer.get('differencesCache');
                    var usagesCache = App.CacheLayer.get('usagesCache');
                    var bomCache = App.CacheLayer.get('bomCache');
                    var item_object_id = diffSearchItem.get('cdb_object_id');

                    promise = Ember.RSVP.hash({
                        differences: differencesCache.get(item_object_id)
                                .then(function(data) {
                            usagesCache.set(item_object_id, Ember.A(data.usages));
                            return Ember.RSVP.hash({
                                differences: data
                                //boms: bomCache.getProperties(data.usages)
                            });
                        }),
                        usages: diffSearchItem.get('usages')
                    });
                }

                promise.then(function(data) {
                    Ember.A([{
                        treeSearches: this.get('lTreeSearches'),
                        rootNode: this.get('lRootNode')
                    }, {
                        treeSearches: this.get('rTreeSearches'),
                        rootNode: this.get('rRootNode')
                    }]).forEach(function(args) {
                        var old = args.treeSearches.findBy('name', 'differences');
                        if (old) {
                            args.treeSearches.removeObject(old);
                        }

                        if (data) {
                            var differenceSearch = self.differenceSearch(
                                args.rootNode,
                                data.differences.differences,
                                data.usages
                            );
                            args.treeSearches.pushObject(differenceSearch);
                        }
                    });
                }.bind(this));
            }.observes('diffSearchItem').on('init'),

            lSearchStringChanged: function() {
                var self = this;
                var treeSearches = this.get('lTreeSearches');
                var lRootNode = this.get('lRootNode');
                if (lRootNode) {
                    lRootNode.then(function(rootNode) {
                        self.cleanUpSearch(rootNode, 'search');

                        var old = treeSearches.findBy('name', 'search');
                        if (old) {
                            treeSearches.removeObject(old);
                        }

                        if (self.get('lSearchString')) {
                            self.get('model.litem').then(function(litem) {
                                self.bomSearch(rootNode, litem, 'lSearchString').then(function(bomSearch) {
                                    treeSearches.pushObject(bomSearch);
                                });
                            });
                        }
                    });
                }
            }.observes('lSearchString'),

            rSearchStringChanged: function() {
                var self = this;
                var treeSearches = this.get('rTreeSearches');
                var rRootNode = this.get('rRootNode');
                if (rRootNode) {
                    rRootNode.then(function(rootNode) {
                        self.cleanUpSearch(rootNode, 'search');

                        var old = treeSearches.findBy('name', 'search');
                        if (old) {
                            treeSearches.removeObject(old);
                        }

                        if (self.get('rSearchString')) {
                            self.get('model.ritem').then(function(ritem) {
                                self.bomSearch(rootNode, ritem, 'rSearchString').then(function(bomSearch) {
                                    treeSearches.pushObject(bomSearch);
                                });
                            });
                        }
                    });
                }
            }.observes('rSearchString'),

            syncNodeChanged: function() {
                var self = this;
                this.cleanUpSearch(this.get('rRootNode'), 'sync');

                ["lTreeSearches", "rTreeSearches"].forEach(function(attr) {
                    var treeSearches = self.get(attr);
                    var old = treeSearches.findBy('name', 'sync');
                    if (old) {
                        treeSearches.removeObject(old);
                    }
                });

                if (this.get('syncNode')) {
                    var treeSearches;
                    if (this.get('syncNode.isEbomView')) {
                        treeSearches = this.get("rTreeSearches");
                    } else {
                        treeSearches = this.get("lTreeSearches");
                    }

                    this.get('syncSearch').then(function(syncSearch) {
                        treeSearches.pushObject(syncSearch);
                    });
                }
            }.observes('syncNode'),

            tableExpandedChanged: function() {
                var model = this.get('model');
                if (model.get('reloadDifferencesWhenExpanded')) {
                    model.set('reloadDifferencesWhenExpanded', false);
                    model.toggleProperty('differencesReloadToggle');
                }
            }.observes('tableExpanded'),

            /*
             * Action handlers
             */

            actions: {
                refreshAll: function() {
                    App.CacheLayer.reload();
                    this.set('diffSearchItem', null);
                    this.get('model').toggleProperty('differencesReloadToggle');
                },
                refreshBom: function(bom, node, reloadParent) {
                    if (reloadParent === undefined) {
                        reloadParent = true;
                    }

                    var parentId = node.get('parentId');
                    var nodeId = node.get('nodeId');
                    var ids = (reloadParent === true && parentId) ? [parentId, nodeId] : [nodeId];
                    App.CacheLayer.reload(ids);

                    // reset searches
                    this.set('diffSearchItem', null);
                    this.set('lSearchString', '');
                    this.set('rSearchString', '');

                    this.get('model').toggleProperty('differencesReloadToggle');
                },
                triggerSync: function() {
                    var selectedNode = this.get('selectedNode');
                    if (selectedNode) {
                        if (selectedNode === this.get('syncNode')) {
                            this.get('syncSearch').then(function(syncSearch) {
                                syncSearch.navigateCyclic();
                            });
                        } else {
                            this.set('syncNode', selectedNode);
                        }
                    }
                },
                showModalWindow: function() {
                    this.set('modalFirstLoad', true);
                    this.set('modalActive', true);
                    Ember.run.schedule('afterRender', this, function() {
                        this.toggleProperty('variantTableExpanded');
                    });
                },
                modalButtonTriggered: function(button_action) {
                    if (button_action == 'cancel') {
                        this.set('modalActive', false);
                    } else if (button_action == 'apply') {
                        this.set('modalActive', false);
                    } else if (button_action == 'close') {
                        this.set('modalActive', false);
                    }
                },
                searchVariants: function(search_str) {
                    this.set('model.variantSearchStr', search_str);
                },
                ignoreDifference: function(teilenummer) {
                    // The second argument (difference) is optional
                    // The last argument is the row
                    if (arguments.length >= 3) {
                        var difference = arguments[1];
                        var row = arguments[2];
                    } else {
                        var row = arguments[1];
                    }

                    this.get('model.ritem').then(function(ritem) {
                        var context_teilenummer = ritem.get('nr');
                        var url = App.get('apiUrlRoot') +
                            context_teilenummer + '/' + teilenummer;
                        if (difference !== undefined) {
                            url += '/' + difference;
                        }
                        url += '/ignore';

                        return App.ajax({
                            url: encodeURI(url),
                            type: 'post',
                            dataType: 'json',
                            async: true
                        });
                    }).then(function(data) {
                        if (data.success) {
                            row.set('ignored', data.result.ignored)
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }
                    });
                },
                deleteIgnore: function(teilenummer, row) {
                    var context_teilenummer = this.get('ritem.nr');
                    var url = App.get('apiUrlRoot') + context_teilenummer + '/' + teilenummer + '/delete_ignore';

                    App.ajax({
                        url: url,
                        type: 'post',
                        dataType: 'json',
                        async: true
                    }).then(function(data) {
                        if (data.success) {
                            row.set('ignored', data.result.ignored)
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }
                    });
                }
            },

            /*
             * Functions
             */

            saveRItemCookie: function() {
                var ritem_object_id = this.get('ritem_object_id');

                if (ritem_object_id) {
                    $.cookie('cs.vp.bom.diffutil_ritem_object_id', ritem_object_id);
                }
            }.observes('model.ritem_object_id'),

            savePreviewCookie: function() {
                var previewMode = this.get('previewMode');
                $.cookie('cs.vp.bom.diffutil_preview_mode', previewMode);
            }.observes('previewMode'),

            /*
             * Private functions
             */

            // load a root node for a bom tree, given its name
            _loadRootNode: function(name, isEbomView) {
                // Optimization: load bom_infos for all the expanded nodes in one step
                var cookie = $.parseJSON($.cookie('cs.vp.bom.diffutil_expandedNodes'));
                //var cookie = false;
                var promise = Ember.RSVP.resolve();
                if (cookie) {
                    var ids = cookie.map(function(uniqueId) {
                        return uniqueId.split("#").pop();
                    });

                    var pkeys = cookie.map(function(uniqueId) {
                        var attrs =
                            ["baugruppe", "b_index",
                             "teilenummer", "t_index",
                             "variante", "position", "auswahlmenge", "nodeId"];
                        var keys = {};
                        uniqueId.split('#').forEach(function(val, index) {
                            keys[attrs[index]] = val;
                        });
                        return [keys.baugruppe, keys.b_index, keys.teilenummer,
                            keys.variante, keys.position].join(';');
                    });
                    promise = Ember.RSVP.hash({
                        boms: App.CacheLayer.get("bomCache").getProperties(ids),
                        predicates: App.CacheLayer.get("predicatesCache").getProperties(pkeys)
                    });
                }

                return App.PromiseObject.create({
                    promise: promise.then(function(h) {
                        var item = this.get(name);
                        if (item) {
                            var node = App.TreeBomNode.fromItem(item);
                            item.get('itemDetails').then(function() {
                                node.set('description', item.get('description'));
                                node.set('tooltip', item.get('tooltip'));
                            });
                            node.set('isEbomView', isEbomView);
                            node.loadComponents().then(function() {
                                node.render();
                                Ember.run.schedule('afterRender', node, 'expand');
                            });
                            return node;
                        }
                    }.bind(this))
                });
            }
        });

/*
 * Bom tree node representation
 *
 * Custom class to represent bom tree nodes, wraps item data coming from the model.
 *
 * For each occurrence of an item in a bom tree a new instance is created
 */

App.TreeBomNode =
    Ember.ArrayProxy.extend(Ember.Evented, {
        // item data coming from the model
        item: null,
        bom: null,
        // must be set with object id or unique id for using
        nodeId: null,
        // treeview
        parentId: null,
        isEbomView: false,
        position: null,
        bomType: null,
        hasChildren: null,
        expanded: false,
        visible: false,
        inVariant: true,

        parent: null,

        init: function() {
            var self = this;
            if (!(self.get('nodeId') in App.TreeNodeDict)) {
                App.TreeNodeDict[self.get('nodeId')] = {};
            }
            App.TreeNodeDict[self.get('nodeId')][JSON.stringify(self.get('path'))] = this;

            this.set('renderContent', Ember.A());
            this.set('navigatedBy', Ember.A());
            this.set('hitBy', Ember.A());

            // Navigation
            var handleNavigation = function(treeSearch) {
                var effect = treeSearch.applyEffect;
                Ember.run.debounce(
                    treeSearch.get('controller'), 'scrollToNode',
                    self, effect, 100);
            };

            this.get('navigatedBy').forEach(handleNavigation);
            this.get('navigatedBy').addEnumerableObserver(this, {
                willChange: function(navigatedBy, removing, addCount) {},
                didChange: function(navigatedBy, removeCount, adding) {
                    adding.forEach(handleNavigation);
                }
            });
        },

        setExpanded: function() {
            if (this.get("uniqueId")) {
                // Check cookie and set this.expanded accordingly
                var cookie = this.getCookieValue(false);
                if (cookie && this.get('uniqueId') && cookie.contains(this.get('uniqueId'))) {
                    this.set('expanded', true);
                }
            }
        }.observes("baugruppe", "b_index", "teilenummer", "t_index",
            "variante", "position", "auswahlmenge"),

        uniqueId: function() {
            var keys = [
                "baugruppe", "b_index", "teilenummer", "t_index",
                "variante", "position", "auswahlmenge", "nodeId"
            ];

            var keysAvailable = keys.every(function(prop) {
                return (this.get(prop) !== undefined);
            }, this);

            if (this.get('parent')) {
                var parentId = this.get('parent.uniqueId');
            } else {
                var parentId = this.get('item.cdb_object_id');
            }

            if (keysAvailable) {
                var id = keys.map(function(key) {
                    return this.get(key);
                }, this).join("#");

                if (parentId) {
                    return id ? parentId + "/" + id : parentId;
                } else {
                    return id;
                }
            }
        }.property("baugruppe", "b_index", "teilenummer", "t_index",
            "variante", "position", "auswahlmenge"),

        editExpandedCookie: function() {
            var expanded = this.get("expanded");
            var cookie = this.getCookieValue(true);
            if (expanded) {
                // Add to cookie
                if (cookie && this.get('uniqueId') && !cookie.contains(this.get('uniqueId'))) {
                    cookie.pushObject(this.get('uniqueId'));
                }
                $.cookie('cs.vp.bom.diffutil_expandedNodes', JSON.stringify(cookie));
            } else {
                // Remove from cookie
                cookie = cookie.filter(function(cdb_object_id) {
                    return (cdb_object_id !== this.get('uniqueId'));
                }, this);
                $.cookie('cs.vp.bom.diffutil_expandedNodes', JSON.stringify(cookie));
            }
        }.observes("expanded"),

        getCookieValue: function(editCookie) {
            try {
                var cookie = $.parseJSON($.cookie('cs.vp.bom.diffutil_expandedNodes'));
                if (cookie === null) {
                    cookie = [];
                }
                return cookie;
            } catch (error) {
                if (error.name === 'SyntaxError' && editCookie) {
                    return [];
                } else if (error.name === 'SyntaxError' && !editCookie) {
                    cdb.elink.alert(error.message);
                    cdb.elink.stopWaiting();
                } else {
                    throw (error);
                }
            }
        },

        // load the bom tree structure under a given node
        loadComponents: function(reload) {
            var node = this;

            if (reload) {
                node.clear();
            }

            if (node.content.length === 0) {
                var itemCache = App.CacheLayer.get('itemCache');
                var bomCache = App.CacheLayer.get('bomCache');

                var nodes = Ember.A([]);

                // Build a list with the object ids of the bom tree elements
                return bomCache.get(node.get('item.cdb_object_id')).then(function(bomitems) {
                    var keys = [];
                    bomitems.forEach(function(bomitem) {
                        keys.push(bomitem.item_object_id);
                    });

                    // build tree nodes
                    return Ember.RSVP.all(bomitems.map(function(bomitem) {
                        return App.TreeBomNode.fromBomItem(bomitem, node).then(function(childnode) {
                            childnode.set('parentId', node.get('item.cdb_object_id'));
                            node.pushObject(childnode);
                            return childnode;
                        });
                    }));
                }).then(function(content) {
                    node.set('content', content);
                    return content;
                });
            } else {
                return Ember.RSVP.resolve(node.content);
            }
        },

        render: function(rerender) {
            var renderContent = this.get('renderContent');

            if (rerender) {
                renderContent.clear();
            }
            if (renderContent.length !== this.get('content.length')) {
                var parent = this.get('parent');
                if (parent) {
                    parent.render();
                }

                renderContent.pushObjects(this.get('content'));
            }
        },

        expandedWillChange: function() {
            var promise = Ember.RSVP.resolve();
            if (this.content.length === 0) {
                promise = this.loadComponents();
            }

            promise.then(function() {
                this.render();
            }.bind(this));
        }.observesBefore('expanded'),

        expand: function() {
            if (this.get('parent')) {
                this.get('parent').expand();
            }
            this.set('expanded', true);
        },

        collapse: function() {
            this.set('expanded', false);
        },

        treeSearchClasses: function() {
            var result = Ember.A();
            this.get('hitBy').forEach(function(treeSearch) {
                if (treeSearch.get('cssClass')) {
                    result.pushObject(treeSearch.get('cssClass'));
                }
            });

            return result;
        }.property('hitBy.[]'),

        path: function() {
            if (this.get('parent')) {
                var result = this.get('parent.path').copy();
                result.pushObject(App.BOMKeys.create({
                    baugruppe: this.get("baugruppe"),
                    b_index: this.get("b_index"),
                    teilenummer: this.get("teilenummer"),
                    t_index: this.get("t_index"),
                    position: this.get("position"),
                    variante: this.get("variante"),
                    auswahlmenge: this.get("auswahlmenge")
                }));
                return result;
            } else {
                return Ember.A([App.BOMKeys.create({
                    teilenummer: this.get("item.nr"),
                    t_index: this.get("item.idx")
                })]);
            }
        }.property('parent', 'baugruppe', 'b_index', 'teilenummer',
            't_index', 'position', 'variante', 'auswahlmenge'),

        operations: function() {
            var itemOps = this.get('item.operations');
            var bomOps = this.get('bomOperations');
            return Ember.Object.create({
                'item': itemOps,
                'bom': bomOps
            });
        }.property('item.operations', 'bomOperations'),

        isContainedInPath: function(path) {
            var node = this;
            return path.every(function(bomKeys, index) {
                var nodeKeys = node.get('path').objectAt(index);
                if (nodeKeys) {
                    return nodeKeys.isEqual(Ember.Object.create(bomKeys));
                }
            });
        },

        containsPath: function(path) {
            var node = this;
            return node.get('path').every(function(bomKeys, index) {
                var nodeKeys = path.objectAt(index);
                if (nodeKeys) {
                    return bomKeys.isEqual(Ember.Object.create(nodeKeys));
                }
            });
        },

        listContent: function() {
            var result = Ember.A([this]);
            if (this.get('expanded')) {
                if (this.get('predicates.isFulfilled')) {
                    result.pushObjects(this.get('predicates.content'));
                }
                this.get('renderContent').forEach(function(item) {
                    result.pushObjects(item.get('listContent'));
                }, this);
            }

            return result;
        }.property('expanded', 'predicates.isFulfilled',
            'renderContent.@each.listContent'),

        level: function() {
            var parent = this.get('parent');
            if (parent) {
                return parent.get('level') + 1;
            } else {
                return 0;
            }
        }.property('parent'),

        predicates: function() {
            if (this.get('bomItem.predicates.isFulfilled')) {
                return this.get('bomItem.predicates.content');
            }
        }.property('bomItem.predicates.isFulfilled')
    });

App.TreeBomNode.reopenClass({
    fromItem: function(item, parent) {
        return App.TreeBomNode.create({
            parent: parent,
            item: item,
            nodeId: item.get('cdb_object_id'),
            bomType: item.get('is_assembly') ? 'group' : 'component',
            hasChildren: item.get('is_assembly'),
            content: Ember.A([]),
            teilenummer: item.get("nr"),
            t_index: item.get("idx")
        });
    },
    fromBomItem: function(bomitem, parent) {
        return bomitem.get('item').then(function(item) {
            return App.TreeBomNode.fromItem(item, parent);
        }).then(function(result) {
            return App.TreeBomNode.updateBomItem(result, bomitem);
        });
    },
    updateBomItem: function(node, bomitem) {
        node.beginPropertyChanges();
        node.set('bomItem', bomitem);

        node.set('description', bomitem.get('description'));

        // Primary keys bom_item
        node.set('baugruppe', bomitem.get('baugruppe'));
        node.set('b_index', bomitem.get('b_index'));
        node.set('teilenummer', bomitem.get('teilenummer'));
        node.set('t_index', bomitem.get('t_index'));
        node.set('position', bomitem.get('position'));
        node.set('variante', bomitem.get('variante'));
        node.set('auswahlmenge', bomitem.get('auswahlmenge'));
        node.set('tooltip', bomitem.get('tooltip'));
        if (node.get('parent') !== undefined) {
            node.set('isEbomView', node.get('parent').get('isEbomView'));
        }
        node.set('hasPredicates', bomitem.get('has_predicates'));
        node.set('bomIcon', bomitem.get('bom_icon'));
        node.set('bomOperations', bomitem.get('operations'));
        node.set('inVariant', bomitem.get('in_variant'));
        node.set('mbom_mapping_tag', bomitem.get('mbom_mapping_tag'));
        node.endPropertyChanges();
        return node;
    }
});

App.BOMKeys = Ember.Object.extend({
    isEqual: function(rhs) {
        var keys = Ember.A(['baugruppe', 'b_index', 'teilenummer', 't_index', 'position', 'variante', 'auswahlmenge']);

        return keys.every(function(key) {
            // We use == on purpose, since this.get('position') is an integer,
            // while rhs.get('position') is a string. DO NOT CHANGE!
            return this.get(key) == rhs.get(key);
        }, this);
    }
});

App.SelectView = Ember.Select;

App.PartMetaView = Ember.View.extend({
  templateName: 'partmeta',
  classNames: ['container-fluid', 'part-meta-data'],
  ritemChanged: function() {
      if (this.get('controller.ritem.isFulfilled')) {
          this.rerender();
      }
  }.observes("controller.ritem")
});

App.DroppableMixin = Ember.Mixin.create({
    expandNode: function(node) {
        this.get('treeComponent')
            .sendAction('nodeWillExpand', node, true);
    },
    didInsertElement: function() {
        var self = this;

        // Drag & drop
        if (this.get("drag")) {
            this.$().draggable({
                helper: function() {
                    // correct the current selection in case the user is simultaneously
                    // selecting something and starting to drag it
                    var targetNode = self.get("controller.treeNode");
                    var content = self.get("selectedNodes").get("content");
                    if (content.contains(targetNode)) {
                        // a) when item is already selected (no matter if ctrl or shift is pressed):
                        //    -do nothing special
                    } else {
                        if ((content.length > 0) &&
                            (content.objectAt(0).get("isEbomView") != targetNode.get("isEbomView"))) {
                            // b) when selected items are from different views:
                            //    -clear selection
                            //    -add dragged item to selection
                            content.clear();
                        } else if (self.get("ctrlKeyDown") || self.get("shiftKeyDown")) {
                            // c) when item isn't selected yet and ctrl or shift is pressed:
                            //    -add dragged item to selection
                        } else {
                            // d) when item isn't selected yet and ctrl or shift is not pressed:
                            //    -clear selection
                            //    -add dragged item to selection
                            content.clear();
                        }
                        content.pushObject(targetNode);
                    }
                    // show purpose specific icons
                    if (content.length > 0) {
                        return $('<img>', {'src': self.get('controller.urlpaths.localres') + 'drag&drop.png'});
                    }
                },
                appendTo: "body",
                containment: "#mbom-draggable-containment",
                opacity: 0.9,
                addClasses: false,
                cursor: "none",
                cursorAt: {
                    top: 12,
                    left: 12
                },
                drag: function(event, ui) {
                    // scroll inside right panel. jQueryUI draggable doesn't
                    // support this, so we need to implement it here

                    if (ui.position.left > window.innerWidth / 2) {
                        var second_view = $(".second-view");

                        if (ui.offset.top < $('#mbom-draggable-containment').offset().top + 2) {
                            second_view.scrollTop(second_view.scrollTop() - 10);
                        } else if (ui.offset.top >
                                $('#mbom-draggable-containment').offset().top +
                                $('#mbom-draggable-containment').height() - 27) {
                            second_view.scrollTop(second_view.scrollTop() + 10);
                        }
                    }

                }
            });
        }

        if (this.get("drop")) {
            this.$().droppable({
                activeClass: "drop-active",
                hoverClass: "drop-hover",
                addClasses: false
            });
            this.$().on("drop", function(event, ui) {
                var selectedNodes = self.get("selectedNodes");
                var content = selectedNodes.get("content");
                var targetNode = self.get("controller.treeNode");
                if (targetNode.expanded === undefined) {
                    targetNode = targetNode.get('content');
                }

                var containsTopNode = selectedNodes.get("containsTopNode");

                if (targetNode && selectedNodes && (content.length > 0) && !containsTopNode) {
                    var dropMode = content.objectAt(0).get("isEbomView") ? "copy" : "move";

                    var data = content.map(function(node) {
                        var item = node.get("item");
                        return {
                            parent_node_id: node.get("parent").get("nodeId"),
                            teilenummer: item.get("nr"),
                            t_index: item.get("idx"),
                            position: node.get("position"),
                            variante: node.get("variante"),
                            auswahlmenge: node.get("auswahlmenge"),
                            target_bom_item_baugruppe: targetNode.baugruppe,
                            target_bom_item_b_index: targetNode.b_index,
                            target_bom_item_teilenummer: targetNode.teilenummer,
                            target_bom_item_t_index: targetNode.t_index,
                            target_bom_item_position: targetNode.position,
                            target_bom_item_variante: targetNode.variante,
                            target_bom_item_auswahlmenge: targetNode.auswahlmenge
                        };
                    });

                    if (
                        data.length === 1 &&
                        targetNode.teilenummer === data[0].teilenummer &&
                        targetNode.t_index === data[0].t_index
                    ) { // single drop on same part
                        dropMode = "copy_device_tag";
                    }

                    var url = App.get('apiUrlRoot') +
                        targetNode.get("nodeId") + "/" +
                        dropMode + "/dropitems";

                    App.ajax({
                        url: url,
                        dataType: 'json',
                        data: {bomitems: JSON.stringify(data)},
                        type: 'post',
                        async: true
                    }).then(function(data) {
                        if (data.success) {
                            var treeComponent = self.get('controller.treeComponent');
                            var reloadParent = false;
                            if (dropMode == "copy_device_tag") {
                                var reloadParent = true;
                            }
                            treeComponent.sendAction("refreshBom",
                                    treeComponent,
                                    targetNode,
                                    /*reloadParent=*/ reloadParent);
                            targetNode.expand();
                            if (dropMode == "move") {
                                // FIXME: currently refreshBom doesn't recurse the children of a
                                //        node, but only the immediate children
                                //treeComponent.sendAction("refreshBom",
                                        //treeComponent,
                                        //selectedNodes.get("mostRecentCommonAncestor"));
                                content.forEach(function(node) {
                                    treeComponent.sendAction(
                                        "refreshBom", treeComponent, node,
                                        /*reloadParent=*/ true);
                                });
                            }
                        } else {
                            cdb.elink.alertCDBMessage(data.message);
                        }
                    });
                }
            });
        }
    },

    // Add the click and mouseDown handlers to the selection, which are needed for Drag & Drop
    click: function(event) {
        var selectedNodes = this.get("selectedNodes");
        if (selectedNodes) {
            selectedNodes.click(this.get("treeNode"), event.ctrlKey, event.shiftKey);
        }
    },
    ctrlKeyDown: false,
    shiftKeyDown: false,
    mouseDown: function(event) {
        this.set("ctrlKeyDown", event.ctrlKey);
        this.set("shiftKeyDown", event.shiftKey);
    }
});

App.BomGroupNodeView = Ember.View.extend(
    App.DroppableMixin,
    {
        templateName: 'bomgroupnode',
        classNames: 'bom-tree-node',
        classNameBindings: [
            'isSelected:selected',
            'treeNode.inVariant::not-in-variant'
        ]
});

App.BomComponentNodeView = Ember.View.extend(
    App.DroppableMixin, {
        templateName: 'bomcomponentnode',
        classNames: 'bom-tree-node',
        classNameBindings: [
            'isSelected:selected',
            'treeNode.inVariant::not-in-variant'
        ]
});

App.TreeLoadingView = Ember.View.extend({
    templateName: 'treeloading'
});

App.BomTreeNodeViewSelector = App.TreeNodeViewSelector.create({
    viewFor: function(node) {
        if (node.get('isLoading')) {
            return App.TreeLoadingView;
        }
        return node.get('bomType') == 'group' ? App.BomGroupNodeView : App.BomComponentNodeView;
    }
});

App.Router.map(function() {
    this.resource('mbom', {path: '/mbom/:mbom_id'});
});

App.MbomRoute = Ember.Route.extend({
    model: function(params) {
        $.cookie("cs.vp.bom.diffutil_ritem_object_id", params.mbom_id);
    },
    renderTemplate: function() {
        this.transitionTo("index");
    }
});

App.IndexRoute = Ember.Route.extend({
    //model: function() {
    //    return $.when(cdb.elink.startWaiting().delay(200))
    //        .then(this.get("_model").bind(this));
    //},
    model: function() {
        return App.ajax({
            url: App.get('appDataUrl'),
            dataType: 'json',
            type: 'get',
            async: true
        }).then(function(data) {
            var result = App.IndexModel.create();
            if (data.success) {
                // Update caches
                var itemCacheContent = {};
                var itemDetailsCacheContent = {};
                var bomCacheContent = {};

                if (data.result.threed_plugin_id !== undefined) {
                    result.set("threed_plugin_id",
                        data.result.threed_plugin_id);
                }

                if (data.result.litem !== undefined) {
                    var litem = data.result.litem;
                    result.set("litem_object_id", litem.cdb_object_id);
                    itemCacheContent[litem.cdb_object_id] = App.Item.create(litem);

                    var lbom = data.result.lbom;
                    if (lbom) {
                        bomCacheContent[litem.cdb_object_id] = App.Bom.create(lbom);
                    }
                }

                data.result.itemDetails.forEach(function(detail) {
                    itemDetailsCacheContent[detail.cdb_object_id] =
                        Ember.Object.create(detail);
                })

                var itemList = data.result.itemList.map(function(item) {
                    itemCacheContent[item.cdb_object_id] = App.Item.create(item);

                    var detail = itemDetailsCacheContent[item.cdb_object_id];
                    return Ember.Object.create({
                        cdb_object_id: item.cdb_object_id,
                        description: detail.mbom_desc
                    });
                });
                result.set('itemList', itemList);

                result.set('categories', Ember.A(data.result.categories));

                result.set("products", Ember.A(data.result.products
                        .map(function(product) {
                    return Ember.Object.create(product);
                })));
                if (result.get("products").length == 1) {
                    result.set("product", result.get("products").objectAt(0));
                }

                // preselect product even when more then one product is available
                // when forced uri
                if(window.product_object_id !== undefined
                    && result.get('products').findBy('cdb_object_id',
                        window.product_object_id)){
                    result.set("product", result.get('products').findBy('cdb_object_id',
                        window.product_object_id));
                }

                // Update item cache
                var itemCache = App.CacheLayer.get("itemCache");
                itemCache.updateMany(itemCacheContent);

                // Update item details cache
                var itemDetailsCache = App.CacheLayer.get("itemDetailsCache");
                itemDetailsCache.updateMany(itemDetailsCacheContent);

                // Update bom cache
                var bomCache = App.CacheLayer.get("bomCache");
                bomCache.updateMany(bomCacheContent);

                if (data.result.ritem === undefined) {
                    // if a cookie with the object if of the ritem
                    // has been saved, try to use that ritem

                    if (data.result.itemList.length === 1) {
                        // if there is only one possible ritem, use that one
                        var ritem = result.get('itemList').objectAt(0);
                        result.set('ritem_object_id', ritem.get('cdb_object_id'));
                    } else {
                        var cookie_object_id = $.cookie('cs.vp.bom.diffutil_ritem_object_id');

                        if (result.get('itemList').findBy('cdb_object_id', cookie_object_id)) {
                            result.set('ritem_object_id', cookie_object_id);
                        }
                    }
                }
            } else {
                cdb.elink.alertCDBMessage(data.message);
            }
            return result;
        }, function() {
            return {};
        });

    },
    renderTemplate: function() {
        this.render('main', {into:'application'});
    }
});
