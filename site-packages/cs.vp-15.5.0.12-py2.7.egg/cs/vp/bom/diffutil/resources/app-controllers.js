App.IndexController =
    Ember.ObjectController
        .extend({
            init: function() {
                this.set('lTreeSearches', Ember.A([]));
                this.set('rTreeSearches', Ember.A([]));

                this.set('selectedNodes', App.NodeSelection.create([]));

                // set preview mode
                var previewCookie = $.cookie('cs.vp.bom.diffutil_preview_mode');
                if (previewCookie) {
                    this.set('previewMode', previewCookie);
                }

                // apply query params as filter
                var params = getQueryParams();

                this.set('filter_txt', '');
                if (params['_filtertext']) {
                    this.set('filter_txt', decodeURIComponent(params['_filtertext'].replace(/\+/g, '%20')));
                }

                delete params._filtertext;

                this.set('filter', JSON.stringify(params));
                App.CacheLayer.get('bomCache').set('filter', this.get('filter'));
            },
            afterModel: function() {
                this.set('model.filter', this.get('filter'));
            },
            watchKeyEvents: function() {
                var controller = this;

                $(document).on('keydown', function(event) {
                    if (event.altKey === true && event.ctrlKey === true && event.key === "d") {
                        controller.set('showDebugTool', false);
                        Ember.run.later(function() {
                            controller.set('debugEntries', App.get('_ajaxTime'));
                            controller.set('showDebugTool', true);
                        });
                    }
                })
            }.on('init'),

            diffHeaderContent: function() {
                var headerContent = [{
                    id: 'name',
                    label: this.get('labels.cdbvp_elink_diffutil_part_no'),
                    asc: false,
                    maxWidth: 150,
                    canAutoResize: true,
                    ignore: 'ignorePart'
                }, {
                    id: 'idx',
                    label: this.get('labels.cdbvp_elink_diffutil_idx'),
                    asc: false,
                    maxWidth: 60,
                    canAutoResize: true
                }, {
                    id: 'level',
                    label: this.get('labels.cdbvp_elink_diffutil_level'),
                    asc: false,
                    maxWidth: 120,
                    canAutoResize: true,
                    sortOnInit: true
                }, {
                    id: 'caption',
                    label: this.get('labels.cdbvp_elink_diffutils_name'),
                    asc: false,
                    canAutoResize: true
                }, {
                    id: 'category',
                    label: this.get('labels.cdbvp_elink_diffutils_category'),
                    filterValues: this.get("categories").map(function(value) {
                        return Ember.Object.create({
                            value: value,
                            default: true
                        });
                    }),
                    asc: false,
                    maxWidth: 150,
                    canAutoResize: true
                }, {
                    id: 'cnt_fbom',
                    label: this.get('labels.cdbvp_elink_diffutils_cnt_fbom'),
                    asc: false,
                    maxWidth: 70,
                    canAutoResize: true
                }, {
                    id: 'cnt_sbom',
                    label: this.get('labels.cdbvp_elink_diffutils_cnt_sbom'),
                    asc: false,
                    maxWidth: 70,
                    canAutoResize: true
                }, {
                    id: 'act_sbom',
                    label: this.get('labels.cdbvp_elink_diffutils_act_right_bom'),
                    asc: false,
                    maxWidth: 200,
                    canAutoResize: true,
                    ignore: 'ignoreDifference'
                }, {
                    id: 'ignored',
                    label: this.get('labels.cdbvp_diffutil_ignored'),
                    asc: false,
                    maxWidth: 150,
                    canAutoResize: true,
                    ignore: 'deleteIgnore',
                    filterValues: [this.get('labels.cdbvp_diffutil_ignored_difference'),
                        this.get('labels.cdbvp_diffutil_ignored_item')].map(function(value) {
                        return Ember.Object.create({
                            value: value,
                            default: false
                        });
                    })
                }];

                return Ember.A(headerContent.map(function(el) {
                    return Ember.Object.create(el);
                }));
            }.property(),

            classNames: ["row-layout", "container"],
            variantTableExpanded: true,

            sync_view_icon: function() {
                return this.get('urlpaths.localres') + 'sync_view.png';
            }.property(),

            /* MBOM select */
            _syncRitem2Selection: function() {
                var ritem_object_id = this.get('ritem_object_id');
                var itemList = this.get('itemList');

                if (ritem_object_id && itemList) {
                    var item = itemList.findBy("cdb_object_id", ritem_object_id);
                    if (item) {
                        this.set('ritemSelection', item);
                    }
                }
            }.observes('ritem_object_id'),

            _syncSelection2Ritem: function() {
                var ritem_object_id = this.get('ritem_object_id');
                var ritemSelection = this.get('ritemSelection');

                if (ritemSelection &&
                        ritemSelection.get('cdb_object_id') !== ritem_object_id) {
                    this.set('ritem_object_id', ritemSelection.get('cdb_object_id'));
                }
            }.observes('ritemSelection'),

            /*
             * 3D Cockpit
             */
            csThreedInstalled: function() {
                return this.get('threed_plugin_id') !== undefined;
            }.property('threed_plugin_id'),

            threedUrl: function() {
                if (this.get('csThreedInstalled')) {
                    var self = this;
                    var loid = this.get("litem_object_id");
                    var roid = this.get("ritem_object_id");

                    if (loid !== undefined && roid !== undefined) {
                        var url = App.get('apiUrlRoot') + loid + '/' + roid +
                            '/threed_url';
                        // FIMXE: label
                        return App.PromiseObject.create({
                            promise: App.ajax({
                                url: url,
                                dataType: 'json',
                                type: 'get',
                                async: true
                            }).then(function(data) {
                                if (data.success) {
                                    var result = data.result + "#/plugin/" +
                                        self.get('threed_plugin_id');
                                    return {"url": result}
                                } else {
                                    cdb.elink.alertCDBMessage(data.message);
                                }
                            })
                        });
                    }
                }
            }.property("litem_object_id", "ritem_object_id"),

            /*
             * Variant Selection
             */
            modalActive: false,
            // only used to prevent preloading of variants
            modalFirstLoad: false,
            variantProperties: Ember.A([]),
            hasProducts: function() {
                return this.get('products').length > 0;
            }.property('products'),
            hasVariants: function() {
                var products = this.get('products');
                return products.any(function(product) {
                    return product.variantCount > 0;
                });
            }.property('products'),

            hasMultipleMBOMs: function() {
                return this.get('itemList').length > 1;
            }.property(),

            variantTableHeader: function() {
                var columns = [];
                columns.push(Ember.Object.create({
                    id: 'vid',
                    label: this.get("labels.cdbvp_elink_diffutils_variant_id"),
                    asc: false
                }));

                columns.push(Ember.Object.create({
                    id: 'name',
                    label: this.get("labels.cdbvp_elink_diffutils_variant_name"),
                    asc: false
                }));

                this.get('variantProperties').forEach(function(prop) {
                    columns.push(Ember.Object.create({
                        id: '' + prop.id,
                        label: prop.name,
                        asc: false,
                        additionalClasses: 'property'
                    }));
                });
                return Ember.A(columns);
            }.property('variantProperties'),

            modalFooterButtons: function() {
                return [{
                    'label': this.get('labels.cdbvp_elink_diffutils_cancel'),
                    'classes': 'btn label_cancel',
                    'action': 'cancel'
                }];
            }.property(),

            modalHeaderButtons: function() {
                return [{
                    label: 'Ã—',
                    classes: 'close',
                    action: 'close'
                }];
            }.property(),
            _reactOnVariantSelection: function() {
                var variant = this.get('variant');
                if (this.get('modalActive')) {
                    this.set('modalActive', false);
                }
                App.CacheLayer.get("bomCache").set('variant', variant);
                var differencesCache = App.CacheLayer.get("differencesCache");
                if (differencesCache) {
                    differencesCache.set('variant', variant);
                }
                // dummy will not be used
                this.set('lRootNode', 'dummy');
                // dummy will not be used
                this.set('rRootNode', 'dummy');
            }.observes('variant'),

            _reactOnVariantProductSelection: function() {
                Ember.run.schedule('afterRender', this, function() {
                    this._preSelectProductVariant();
                    this._loadProductVariantProperties();
                });
            }.observes('product'),

            _preSelectProductVariant: function() {
                var product = this.get('product');
                if (product && window.variant) {
                    if (product.get('cdb_object_id') === window.product_object_id) {
                        var variant = Ember.Object.create(window.variant);
                        variant.set('selected', true);
                        this.set('variant', variant);
                        window.variant = undefined;
                    }
                }
            },

            _loadProductVariantProperties: function() {
                var product = this.get('product');
                if (product) {
                    var results = Ember.A([]);
                    var url = App.get('apiUrlRoot');
                    url += '/' + product.cdb_object_id;
                    url += '/product_properties';
                    App.ajax({
                        url: url,
                        type: 'get',
                        dataType: 'json',
                        async: true
                    }, true, 'cdbvp_elink_diffutil_load_variants').then(function(data) {
                        if (data.success) {
                            $.each(data.result, function(index, item) {
                                results.pushObject(Ember.Object.create(item));
                            });
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }
                        this.set('variantProperties', results);
                    }.bind(this));
                } else {
                    this.set('variantProperties', Ember.A([]));
                    this.set('variant', null);
                }
            },

            // Root node for the left bom tree
            // params needed to renew property (variant)
            lRootNode: function(key, value, oldValue) {
                if (this.get('model.litem.isFulfilled')) {
                    return this._loadRootNode('litem', /* isEbomView */true);
                }
            }.property('model.litem.isFulfilled'),

            // Root node for the right bom tree
            // params needed to renew property (variant)
            rRootNode: function(key, value, oldValue) {
                if (this.get('model.ritem.isFulfilled')) {
                    return this._loadRootNode('ritem', /* isEbomView */false);
                }
            }.property('model.ritem.isFulfilled'),

            selectedItem: null,
            selectedNodes: null,
            syncNode: null,

            selectedItemChanged: function() {
                this.get('selectedItem.item').then(function(item) {
                    if (item) {
                        // load preview
                        this.set('previewItem', item);

                        // search in tree structures
                        this.set('diffSearchItem', item);
                    }
                }.bind(this));
            }.observes('selectedItem'),

            selectedNode: function() {
                var content = this.get('selectedNodes.content');

                if (content.length === 1) {
                    return content.objectAt(0);
                }
            }.property('selectedNodes.content.[]'),

            selectedNodeChanged: function() {
                var selectedNode = this.get('selectedNode');

                if (selectedNode) {
                    this.selectIn3DViewer(selectedNode);
                    this.set('previewItem', selectedNode.get('item'));
                } else {
                    this.set('previewItem', null);
                }
            }.observes('selectedNode'),

            selectIn3DViewer: function(node) {
                if (this.get('threed_plugin_id') !== undefined) {
                    var msg = {
                        id: this.get('threed_plugin_id'),
                        'type': 'product',
                        path: node.get('path')
                    };
                    localStorage.setItem('cs.threed.path_event',
                        JSON.stringify(msg));
                }
            },

            externalPreview: function() {
                return this.get("previewMode") === "3D" ||
                    this.get("previewMode") === "2D";
            }.property("previewMode"),

            previewLink: function() {
                var previewItem = this.get('previewItem');
                var previewMode = this.get('previewMode');

                if (previewItem) {
                    var url =
                        App.get('apiUrlRoot') + previewItem.get('cdb_object_id') + '/' + previewMode + '/previewlink';

                    return App.ajax({
                        url: url,
                        dataType: 'json',
                        type: 'post',
                        async: true
                    }, true, 'cdbvp_elink_diffutil_load_preview_link').then(function(data) {
                        if (data.success) {
                            return data.result;
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }
                    });
                } else {
                    return Ember.RSVP.resolve();
                }
            }.property('previewItem', 'previewMode'),

            openExternalPreview: function() {
                var app = this;
                var externalPreview = this.get('externalPreview');
                if (externalPreview) {
                    var previewItem = this.get('previewItem');
                    if (previewItem) {
                        previewItem.get('itemDetails').then(function() {
                            $.cookie('cs.vp.bom.diffutil_preview_title',
                                previewItem.get('description'), {
                                path: '/'
                            });
                        });
                    } else {
                        $.cookie('cs.vp.bom.diffutil_preview_title', this
                            .get('labels.cdbvp_elink_diffutils_nopreview'), {
                            path: '/'
                        });
                    }

                    this.get('previewLink').then(function(link) {
                        if (link) {
                            // set cookie
                            $.cookie('cs.vp.bom.diffutil_preview_link', link, {
                                path: '/'
                            });
                        } else {
                            // set cookie
                            $.cookie('cs.vp.bom.diffutil_preview_link', 'nopreview', {
                                path: '/'
                            });
                        }

                        // open tab
                        var url = app.get('urlpaths.preview');
                        window.open(url, 'bompreview');
                    });
                }
            }.observes('previewLink', 'externalPreview'),

            differenceSearch: function(rootNode, differences, usages) {
                var selectedItem = this.get('diffSearchItem');

                var paths = Ember.A();
                paths.pushObjects(differences.get('left'));
                paths.pushObjects(differences.get('right'));

                return App.TreeSearch.create({
                    position: 20,
                    rootNode: rootNode,
                    name: 'differences',
                    cssClass: rootNode.isEbomView ? 'differences ebom-nav' : 'differences mbom-nav',
                    match: function(node) {
                        var matchPath = node.get('inVariant') && (paths.length === 0 || paths.any(function(path) {
                            return node.isContainedInPath(path);
                        }));
                        if (matchPath) {
                            return (node.get('item.cdb_object_id') === selectedItem.get('cdb_object_id') ||
                                node.get('item.cdb_depends_on') === selectedItem.get('cdb_object_id'));
                        }
                        return false;
                    },
                    expand: function(node) {
                        return node.get('inVariant') && (paths.length === 0 || paths.any(function(path) {
                            return node.isContainedInPath(path) || node.containsPath(path)
                        })) && usages.contains(node.get('item.cdb_object_id'));
                    },
                    showNavigation: true
                });
            },

            bomSearch: function(rootNode, item, searchString) {
                var condition = this.get(searchString);

                if (condition) {
                    var url = App.get('apiUrlRoot') + item.get('cdb_object_id') + '/stringsearch';
                    return App.ajax({
                        url: url,
                        dataType: 'json',
                        data: {
                            condition: condition
                        },
                        type: 'get',
                        async: true
                    }, true, 'cdbvp_elink_diffutil_load_search_result').then(function(data) {
                        // Get results from server
                        var results = Ember.A([]);
                        var usages = Ember.A([]);

                        if (data.success) {
                            results.pushObjects(data.result.results);
                            usages.pushObjects(data.result.usages);
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }

                        return {
                            results: results,
                            usages: usages
                        };
                    }).then(function(data) {
                        // optimization: fetch every needed bom at once
                        var bomCache = App.CacheLayer.get('bomCache');
                        data._cache = bomCache.getProperties(data.usages);
                        return Ember.RSVP.hash({
                            usages: data.usages,
                            results: data.results,
                            _cache: Ember.RSVP.resolve(data._cache)
                        });
                    }).then(function(data) {
                        return App.TreeSearch.create({
                            position: 10,
                            rootNode: rootNode,
                            name: 'search',
                            cssClass: 'bom-search',
                            match: function(node) {
                                // compare primary keys
                                return data.results.find(function(value) {
                                    return Object.keys(value).every(function(key) {
                                        return String(node.get(key)) === value[key];
                                    });
                                }) !== undefined;
                            },
                            expand: function(node) {
                                return data.usages.contains(node.get('nodeId'));
                            },
                            showNavigation: true
                        });
                    });
                } else {
                    return Ember.RSVP.resolve();
                }
            },

            syncSearch: function() {
                var syncNode = this.get('syncNode');
                var self = this;
                if (syncNode) {
                    var url = App.get('apiUrlRoot') +
                        syncNode.get('nodeId') + '/' +
                        this.get('litem_object_id') + '/' +
                        this.get('ritem_object_id') + '/syncbom';

                    return App.ajax({
                        url: url,
                        data: {
                            path: JSON.stringify(syncNode.get('path')),
                            is_ebom: syncNode.get('isEbomView')
                        },
                        dataType: 'json',
                        type: 'get',
                        async: true
                    }).then(function(data) {
                        if (data.success) {
                            var partners = Ember.A([]);
                            var usages = Ember.A([]);
                            var paths = Ember.A([]);

                            if (data.result.partners.length > 0) {
                                partners.pushObjects(data.result.partners);
                                usages.pushObjects(data.result.usages);
                            }
                            paths.pushObjects(data.result.paths);
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }

                        return {
                            partners: partners,
                            paths: paths,
                            usages: usages
                        };
                    }).then(function(data) {
                        if (!data.partners || data.partners.length === 0) {
                            data.partners = Ember.A();
                            data.usages = syncNode.get('item.usages');
                        }
                        data.partners.push(syncNode.get('item.cdb_object_id'));

                        return Ember.RSVP.hash(data);
                    }).then(function(data) {
                        if (syncNode.get('isEbomView')) {
                            var rootNode = self.get('rRootNode');
                        } else {
                            var rootNode = self.get('lRootNode');
                        }
                        return App.TreeSearch.create({
                            rootNode: rootNode,
                            name: 'sync',
                            cssClass: 'sync',
                            match: function(node) {
                                // only match nodes which are contained in the path
                                return data.paths.any(function(path) {
                                    return node.isContainedInPath(path) &&
                                        data.partners.contains(node.get('nodeId'));
                                });
                            },
                            expand: function(node) {
                                // only expand nodes which intersect the path
                                return data.paths.any(function(path) {
                                    return (node.isContainedInPath(path) || node.containsPath(path)) &&
                                        data.usages.contains(node.get('nodeId'));
                                });
                            },
                            applyEffect: function(el) {
                                el.effect('highlight', {
                                    color: '#FF8000'
                                }, 3000);
                            },
                            showNavigation: false
                        });
                    });
                }
            }.property('syncNode'),

            setCaches: function() {
                var product_object_id = this.get('product.cdb_object_id');
                var filter = this.get('filter');

                Ember.RSVP.hash({
                    litem: this.get('litem'),
                    ritem: this.get('ritem')
                }).then(function(options) {
                    var litem = options.litem;
                    var ritem = options.ritem;

                    if (litem && ritem) {
                        App.CacheLayer.set('usagesCache', App.UsagesCache.create({
                            litem: litem,
                            ritem: ritem
                        }));
                        App.CacheLayer.set('differencesCache', App.DifferencesCache.create({
                            litem: litem,
                            ritem: ritem,
                            product_object_id: product_object_id
                        }));
                        App.CacheLayer.get("differencesCache").set('filter', filter);
                    } else {
                        App.CacheLayer.set('usagesCache', null);
                        App.CacheLayer.set('differencesCache', null);
                    }
                });
            }.observes('litem_object_id', 'ritem_object_id', 'product'),

            /*
             * tree searches
             */

            _clean_collection: function(collection, name) {
                collection.removeObject(collection.findBy('name', name));
            },

            cleanUpSearch: function(node, name) {
                if (node) {
                    var self = this;

                    this._clean_collection(node.get('navigatedBy'), name);
                    this._clean_collection(node.get('hitBy'), name);

                    node.get('content').forEach(function(child) {
                        self.cleanUpSearch(child, name);
                    });
                }
            },

            ndiffs: function() {
                if (this.get('differences.isFulfilled')) {
                    return this.get('differences.length');
                }
            }.property('differences.isFulfilled'),

            diffSearchItemChanged: function() {
                var self = this;
                Ember.RSVP.all([this.get('lRootNode'),
                                this.get('rRootNode')].map(function(rootNode) {
                                    if (rootNode) {
                                        rootNode.then(function(rootNode) {
                                            self.cleanUpSearch(rootNode, 'differences');
                                        });
                                    }
                                }));
                var diffSearchItem = this.get('diffSearchItem');
                var self = this;

                // optimization: fetch every needed bom at once
                var promise = Ember.RSVP.resolve();
                if (diffSearchItem) {
                    var differencesCache = App.CacheLayer.get('differencesCache');
                    var usagesCache = App.CacheLayer.get('usagesCache');
                    var bomCache = App.CacheLayer.get('bomCache');
                    var item_object_id = diffSearchItem.get('cdb_object_id');

                    promise = Ember.RSVP.hash({
                        differences: differencesCache.get(item_object_id)
                                .then(function(data) {
                            usagesCache.set(item_object_id, Ember.A(data.usages));
                            return Ember.RSVP.hash({
                                differences: data
                                //boms: bomCache.getProperties(data.usages)
                            });
                        }),
                        usages: diffSearchItem.get('usages')
                    });
                }

                promise.then(function(data) {
                    Ember.A([{
                        treeSearches: this.get('lTreeSearches'),
                        rootNode: this.get('lRootNode')
                    }, {
                        treeSearches: this.get('rTreeSearches'),
                        rootNode: this.get('rRootNode')
                    }]).forEach(function(args) {
                        var old = args.treeSearches.findBy('name', 'differences');
                        if (old) {
                            args.treeSearches.removeObject(old);
                        }

                        if (data) {
                            var differenceSearch = self.differenceSearch(
                                args.rootNode,
                                data.differences.differences,
                                data.usages
                            );
                            args.treeSearches.pushObject(differenceSearch);
                        }
                    });
                }.bind(this));
            }.observes('diffSearchItem').on('init'),

            lSearchStringChanged: function() {
                var self = this;
                var treeSearches = this.get('lTreeSearches');
                var lRootNode = this.get('lRootNode');
                if (lRootNode) {
                    lRootNode.then(function(rootNode) {
                        self.cleanUpSearch(rootNode, 'search');

                        var old = treeSearches.findBy('name', 'search');
                        if (old) {
                            treeSearches.removeObject(old);
                        }

                        if (self.get('lSearchString')) {
                            self.get('model.litem').then(function(litem) {
                                self.bomSearch(rootNode, litem, 'lSearchString').then(function(bomSearch) {
                                    treeSearches.pushObject(bomSearch);
                                });
                            });
                        }
                    });
                }
            }.observes('lSearchString'),

            rSearchStringChanged: function() {
                var self = this;
                var treeSearches = this.get('rTreeSearches');
                var rRootNode = this.get('rRootNode');
                if (rRootNode) {
                    rRootNode.then(function(rootNode) {
                        self.cleanUpSearch(rootNode, 'search');

                        var old = treeSearches.findBy('name', 'search');
                        if (old) {
                            treeSearches.removeObject(old);
                        }

                        if (self.get('rSearchString')) {
                            self.get('model.ritem').then(function(ritem) {
                                self.bomSearch(rootNode, ritem, 'rSearchString').then(function(bomSearch) {
                                    treeSearches.pushObject(bomSearch);
                                });
                            });
                        }
                    });
                }
            }.observes('rSearchString'),

            syncNodeChanged: function() {
                var self = this;
                this.cleanUpSearch(this.get('rRootNode'), 'sync');

                ["lTreeSearches", "rTreeSearches"].forEach(function(attr) {
                    var treeSearches = self.get(attr);
                    var old = treeSearches.findBy('name', 'sync');
                    if (old) {
                        treeSearches.removeObject(old);
                    }
                });

                if (this.get('syncNode')) {
                    var treeSearches;
                    if (this.get('syncNode.isEbomView')) {
                        treeSearches = this.get("rTreeSearches");
                    } else {
                        treeSearches = this.get("lTreeSearches");
                    }

                    this.get('syncSearch').then(function(syncSearch) {
                        treeSearches.pushObject(syncSearch);
                    });
                }
            }.observes('syncNode'),

            tableExpandedChanged: function() {
                var model = this.get('model');
                if (model.get('reloadDifferencesWhenExpanded')) {
                    model.set('reloadDifferencesWhenExpanded', false);
                    model.toggleProperty('differencesReloadToggle');
                }
            }.observes('tableExpanded'),

            /*
             * Action handlers
             */

            actions: {
                refreshAll: function() {
                    App.CacheLayer.reload();
                    this.set('diffSearchItem', null);
                    this.get('model').toggleProperty('differencesReloadToggle');
                },
                refreshBom: function(bom, node, reloadParent) {
                    if (reloadParent === undefined) {
                        reloadParent = true;
                    }

                    var parentId = node.get('parentId');
                    var nodeId = node.get('nodeId');
                    var ids = (reloadParent === true && parentId) ? [parentId, nodeId] : [nodeId];
                    App.CacheLayer.reload(ids);

                    // reset searches
                    this.set('diffSearchItem', null);
                    this.set('lSearchString', '');
                    this.set('rSearchString', '');

                    this.get('model').toggleProperty('differencesReloadToggle');
                },
                triggerSync: function() {
                    var selectedNode = this.get('selectedNode');
                    if (selectedNode) {
                        if (selectedNode === this.get('syncNode')) {
                            this.get('syncSearch').then(function(syncSearch) {
                                syncSearch.navigateCyclic();
                            });
                        } else {
                            this.set('syncNode', selectedNode);
                        }
                    }
                },
                showModalWindow: function() {
                    this.set('modalFirstLoad', true);
                    this.set('modalActive', true);
                    Ember.run.schedule('afterRender', this, function() {
                        this.toggleProperty('variantTableExpanded');
                    });
                },
                modalButtonTriggered: function(button_action) {
                    if (button_action == 'cancel') {
                        this.set('modalActive', false);
                    } else if (button_action == 'apply') {
                        this.set('modalActive', false);
                    } else if (button_action == 'close') {
                        this.set('modalActive', false);
                    }
                },
                searchVariants: function(search_str) {
                    this.set('model.variantSearchStr', search_str);
                },
                ignoreDifference: function(teilenummer) {
                    // The second argument (difference) is optional
                    // The last argument is the row
                    if (arguments.length >= 3) {
                        var difference = arguments[1];
                        var row = arguments[2];
                    } else {
                        var row = arguments[1];
                    }

                    this.get('model.ritem').then(function(ritem) {
                        var context_teilenummer = ritem.get('nr');
                        var url = App.get('apiUrlRoot') +
                            context_teilenummer + '/' + teilenummer;
                        if (difference !== undefined) {
                            url += '/' + difference;
                        }
                        url += '/ignore';

                        return App.ajax({
                            url: encodeURI(url),
                            type: 'post',
                            dataType: 'json',
                            async: true
                        });
                    }).then(function(data) {
                        if (data.success) {
                            row.set('ignored', data.result.ignored)
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }
                    });
                },
                deleteIgnore: function(teilenummer, row) {
                    var context_teilenummer = this.get('ritem.nr');
                    var url = App.get('apiUrlRoot') + context_teilenummer + '/' + teilenummer + '/delete_ignore';

                    App.ajax({
                        url: url,
                        type: 'post',
                        dataType: 'json',
                        async: true
                    }).then(function(data) {
                        if (data.success) {
                            row.set('ignored', data.result.ignored)
                        } else {
                            cdb.elink.alert(data.message);
                            cdb.elink.stopWaiting();
                        }
                    });
                }
            },

            /*
             * Functions
             */

            saveRItemCookie: function() {
                var ritem_object_id = this.get('ritem_object_id');

                if (ritem_object_id) {
                    $.cookie('cs.vp.bom.diffutil_ritem_object_id', ritem_object_id);
                }
            }.observes('model.ritem_object_id'),

            savePreviewCookie: function() {
                var previewMode = this.get('previewMode');
                $.cookie('cs.vp.bom.diffutil_preview_mode', previewMode);
            }.observes('previewMode'),

            /*
             * Private functions
             */

            // load a root node for a bom tree, given its name
            _loadRootNode: function(name, isEbomView) {
                // Optimization: load bom_infos for all the expanded nodes in one step
                var cookie = $.parseJSON($.cookie('cs.vp.bom.diffutil_expandedNodes'));
                //var cookie = false;
                var promise = Ember.RSVP.resolve();
                if (cookie) {
                    var ids = cookie.map(function(uniqueId) {
                        return uniqueId.split("#").pop();
                    });

                    var pkeys = cookie.map(function(uniqueId) {
                        var attrs =
                            ["baugruppe", "b_index",
                             "teilenummer", "t_index",
                             "variante", "position", "auswahlmenge", "nodeId"];
                        var keys = {};
                        uniqueId.split('#').forEach(function(val, index) {
                            keys[attrs[index]] = val;
                        });
                        return [keys.baugruppe, keys.b_index, keys.teilenummer,
                            keys.variante, keys.position].join(';');
                    });
                    promise = Ember.RSVP.hash({
                        boms: App.CacheLayer.get("bomCache").getProperties(ids),
                        predicates: App.CacheLayer.get("predicatesCache").getProperties(pkeys)
                    });
                }

                return App.PromiseObject.create({
                    promise: promise.then(function(h) {
                        var item = this.get(name);
                        if (item) {
                            var node = App.TreeBomNode.fromItem(item);
                            item.get('itemDetails').then(function() {
                                node.set('description', item.get('description'));
                                node.set('tooltip', item.get('tooltip'));
                            });
                            node.set('isEbomView', isEbomView);
                            node.loadComponents().then(function() {
                                node.render();
                                Ember.run.schedule('afterRender', node, 'expand');
                            });
                            return node;
                        }
                    }.bind(this))
                });
            }
        });

/*
 * Bom tree node representation
 *
 * Custom class to represent bom tree nodes, wraps item data coming from the model.
 *
 * For each occurrence of an item in a bom tree a new instance is created
 */

App.TreeBomNode =
    Ember.ArrayProxy.extend(Ember.Evented, {
        // item data coming from the model
        item: null,
        bom: null,
        // must be set with object id or unique id for using
        nodeId: null,
        // treeview
        parentId: null,
        isEbomView: false,
        position: null,
        bomType: null,
        hasChildren: null,
        expanded: false,
        visible: false,
        inVariant: true,

        parent: null,

        init: function() {
            var self = this;
            if (!(self.get('nodeId') in App.TreeNodeDict)) {
                App.TreeNodeDict[self.get('nodeId')] = {};
            }
            App.TreeNodeDict[self.get('nodeId')][JSON.stringify(self.get('path'))] = this;

            this.set('renderContent', Ember.A());
            this.set('navigatedBy', Ember.A());
            this.set('hitBy', Ember.A());

            // Navigation
            var handleNavigation = function(treeSearch) {
                var effect = treeSearch.applyEffect;
                Ember.run.debounce(
                    treeSearch.get('controller'), 'scrollToNode',
                    self, effect, 100);
            };

            this.get('navigatedBy').forEach(handleNavigation);
            this.get('navigatedBy').addEnumerableObserver(this, {
                willChange: function(navigatedBy, removing, addCount) {},
                didChange: function(navigatedBy, removeCount, adding) {
                    adding.forEach(handleNavigation);
                }
            });
        },

        setExpanded: function() {
            if (this.get("uniqueId")) {
                // Check cookie and set this.expanded accordingly
                var cookie = this.getCookieValue(false);
                if (cookie && this.get('uniqueId') && cookie.contains(this.get('uniqueId'))) {
                    this.set('expanded', true);
                }
            }
        }.observes("baugruppe", "b_index", "teilenummer", "t_index",
            "variante", "position", "auswahlmenge"),

        uniqueId: function() {
            var keys = [
                "baugruppe", "b_index", "teilenummer", "t_index",
                "variante", "position", "auswahlmenge", "nodeId"
            ];

            var keysAvailable = keys.every(function(prop) {
                return (this.get(prop) !== undefined);
            }, this);

            if (this.get('parent')) {
                var parentId = this.get('parent.uniqueId');
            } else {
                var parentId = this.get('item.cdb_object_id');
            }

            if (keysAvailable) {
                var id = keys.map(function(key) {
                    return this.get(key);
                }, this).join("#");

                if (parentId) {
                    return id ? parentId + "/" + id : parentId;
                } else {
                    return id;
                }
            }
        }.property("baugruppe", "b_index", "teilenummer", "t_index",
            "variante", "position", "auswahlmenge"),

        editExpandedCookie: function() {
            var expanded = this.get("expanded");
            var cookie = this.getCookieValue(true);
            if (expanded) {
                // Add to cookie
                if (cookie && this.get('uniqueId') && !cookie.contains(this.get('uniqueId'))) {
                    cookie.pushObject(this.get('uniqueId'));
                }
                $.cookie('cs.vp.bom.diffutil_expandedNodes', JSON.stringify(cookie));
            } else {
                // Remove from cookie
                cookie = cookie.filter(function(cdb_object_id) {
                    return (cdb_object_id !== this.get('uniqueId'));
                }, this);
                $.cookie('cs.vp.bom.diffutil_expandedNodes', JSON.stringify(cookie));
            }
        }.observes("expanded"),

        getCookieValue: function(editCookie) {
            try {
                var cookie = $.parseJSON($.cookie('cs.vp.bom.diffutil_expandedNodes'));
                if (cookie === null) {
                    cookie = [];
                }
                return cookie;
            } catch (error) {
                if (error.name === 'SyntaxError' && editCookie) {
                    return [];
                } else if (error.name === 'SyntaxError' && !editCookie) {
                    cdb.elink.alert(error.message);
                    cdb.elink.stopWaiting();
                } else {
                    throw (error);
                }
            }
        },

        // load the bom tree structure under a given node
        loadComponents: function(reload) {
            var node = this;

            if (reload) {
                node.clear();
            }

            if (node.content.length === 0) {
                var itemCache = App.CacheLayer.get('itemCache');
                var bomCache = App.CacheLayer.get('bomCache');

                var nodes = Ember.A([]);

                // Build a list with the object ids of the bom tree elements
                return bomCache.get(node.get('item.cdb_object_id')).then(function(bomitems) {
                    var keys = [];
                    bomitems.forEach(function(bomitem) {
                        keys.push(bomitem.item_object_id);
                    });

                    // build tree nodes
                    return Ember.RSVP.all(bomitems.map(function(bomitem) {
                        return App.TreeBomNode.fromBomItem(bomitem, node).then(function(childnode) {
                            childnode.set('parentId', node.get('item.cdb_object_id'));
                            node.pushObject(childnode);
                            return childnode;
                        });
                    }));
                }).then(function(content) {
                    node.set('content', content);
                    return content;
                });
            } else {
                return Ember.RSVP.resolve(node.content);
            }
        },

        render: function(rerender) {
            var renderContent = this.get('renderContent');

            if (rerender) {
                renderContent.clear();
            }
            if (renderContent.length !== this.get('content.length')) {
                var parent = this.get('parent');
                if (parent) {
                    parent.render();
                }

                renderContent.pushObjects(this.get('content'));
            }
        },

        expandedWillChange: function() {
            var promise = Ember.RSVP.resolve();
            if (this.content.length === 0) {
                promise = this.loadComponents();
            }

            promise.then(function() {
                this.render();
            }.bind(this));
        }.observesBefore('expanded'),

        expand: function() {
            if (this.get('parent')) {
                this.get('parent').expand();
            }
            this.set('expanded', true);
        },

        collapse: function() {
            this.set('expanded', false);
        },

        treeSearchClasses: function() {
            var result = Ember.A();
            this.get('hitBy').forEach(function(treeSearch) {
                if (treeSearch.get('cssClass')) {
                    result.pushObject(treeSearch.get('cssClass'));
                }
            });

            return result;
        }.property('hitBy.[]'),

        path: function() {
            if (this.get('parent')) {
                var result = this.get('parent.path').copy();
                result.pushObject(App.BOMKeys.create({
                    baugruppe: this.get("baugruppe"),
                    b_index: this.get("b_index"),
                    teilenummer: this.get("teilenummer"),
                    t_index: this.get("t_index"),
                    position: this.get("position"),
                    variante: this.get("variante"),
                    auswahlmenge: this.get("auswahlmenge")
                }));
                return result;
            } else {
                return Ember.A([App.BOMKeys.create({
                    teilenummer: this.get("item.nr"),
                    t_index: this.get("item.idx")
                })]);
            }
        }.property('parent', 'baugruppe', 'b_index', 'teilenummer',
            't_index', 'position', 'variante', 'auswahlmenge'),

        operations: function() {
            var itemOps = this.get('item.operations');
            var bomOps = this.get('bomOperations');
            return Ember.Object.create({
                'item': itemOps,
                'bom': bomOps
            });
        }.property('item.operations', 'bomOperations'),

        isContainedInPath: function(path) {
            var node = this;
            return path.every(function(bomKeys, index) {
                var nodeKeys = node.get('path').objectAt(index);
                if (nodeKeys) {
                    return nodeKeys.isEqual(Ember.Object.create(bomKeys));
                }
            });
        },

        containsPath: function(path) {
            var node = this;
            return node.get('path').every(function(bomKeys, index) {
                var nodeKeys = path.objectAt(index);
                if (nodeKeys) {
                    return bomKeys.isEqual(Ember.Object.create(nodeKeys));
                }
            });
        },

        listContent: function() {
            var result = Ember.A([this]);
            if (this.get('expanded')) {
                if (this.get('predicates.isFulfilled')) {
                    result.pushObjects(this.get('predicates.content'));
                }
                this.get('renderContent').forEach(function(item) {
                    result.pushObjects(item.get('listContent'));
                }, this);
            }

            return result;
        }.property('expanded', 'predicates.isFulfilled',
            'renderContent.@each.listContent'),

        level: function() {
            var parent = this.get('parent');
            if (parent) {
                return parent.get('level') + 1;
            } else {
                return 0;
            }
        }.property('parent'),

        predicates: function() {
            if (this.get('bomItem.predicates.isFulfilled')) {
                return this.get('bomItem.predicates.content');
            }
        }.property('bomItem.predicates.isFulfilled')
    });

App.TreeBomNode.reopenClass({
    fromItem: function(item, parent) {
        return App.TreeBomNode.create({
            parent: parent,
            item: item,
            nodeId: item.get('cdb_object_id'),
            bomType: item.get('is_assembly') ? 'group' : 'component',
            hasChildren: item.get('is_assembly'),
            content: Ember.A([]),
            teilenummer: item.get("nr"),
            t_index: item.get("idx")
        });
    },
    fromBomItem: function(bomitem, parent) {
        return bomitem.get('item').then(function(item) {
            return App.TreeBomNode.fromItem(item, parent);
        }).then(function(result) {
            return App.TreeBomNode.updateBomItem(result, bomitem);
        });
    },
    updateBomItem: function(node, bomitem) {
        node.beginPropertyChanges();
        node.set('bomItem', bomitem);

        node.set('description', bomitem.get('description'));

        // Primary keys bom_item
        node.set('baugruppe', bomitem.get('baugruppe'));
        node.set('b_index', bomitem.get('b_index'));
        node.set('teilenummer', bomitem.get('teilenummer'));
        node.set('t_index', bomitem.get('t_index'));
        node.set('position', bomitem.get('position'));
        node.set('variante', bomitem.get('variante'));
        node.set('auswahlmenge', bomitem.get('auswahlmenge'));
        node.set('tooltip', bomitem.get('tooltip'));
        if (node.get('parent') !== undefined) {
            node.set('isEbomView', node.get('parent').get('isEbomView'));
        }
        node.set('hasPredicates', bomitem.get('has_predicates'));
        node.set('bomIcon', bomitem.get('bom_icon'));
        node.set('bomOperations', bomitem.get('operations'));
        node.set('inVariant', bomitem.get('in_variant'));
        node.set('mbom_mapping_tag', bomitem.get('mbom_mapping_tag'));
        node.endPropertyChanges();
        return node;
    }
});

App.BOMKeys = Ember.Object.extend({
    isEqual: function(rhs) {
        var keys = Ember.A(['baugruppe', 'b_index', 'teilenummer', 't_index', 'position', 'variante', 'auswahlmenge']);

        return keys.every(function(key) {
            // We use == on purpose, since this.get('position') is an integer,
            // while rhs.get('position') is a string. DO NOT CHANGE!
            return this.get(key) == rhs.get(key);
        }, this);
    }
});
