#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""
Compute the differences between two product structures.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: differences.py 179845 2018-07-03 07:32:52Z gda $"

# Some imports
import sys
import collections
import operator

from cdb import sqlapi
from cdb import dberrors
from cdb import misc
from cdb import objects
from cdb import util
from cdb import lru_cache

from cs.vp import items
from cs.vp import bom
from cs.vp.bom import bomqueries
from cs.vp.bom import mapping
from cs.vp.bom import usages
from cs.vp.variants import bomlinks
from cs.vp.bom.diffutil.misc import _chunked

__all__ = [
    "get_differences", "has_differences", "find_differences",
    "compute_eye", "compute_reverse_eye", "diff_plugins"
]

FILTER_RULE = "mBOM Manager: Ignore differences"


def get_differences(lbom, rbom, product_object_id=None, variant_filter=None, bomfilter=None):
    """ Computes the differences between an engineering BOM and a manufacturing BOM.

        .. important ::

            This method only works when the attribute ``mbom_mapping_tag`` of
            the bom positions is set correctly.

        :param lbom: the engineering BOM
        :type lbom: an instance of ``cs.vp.items.Item``

        :param rbom: the manufacturing BOM
        :type rbom: an instance of ``cs.vp.items.Item``

        :param variant_filter: variant filter object, used to filter the BOMs
        :type BOMFilter: an instance of ``cp.vp.variants.BOMFilter``

        :param bomfilter: bomfilter dict, used to filter the BOMs
        :type dict: an instance of ``dict``

        :return: an iterable which provides dictionary-like objects with
            the following keys:

            * teilenummer
            * t_index
            * lbom_quantity
            * rbom_quantity
            * item_object_id
    """
    # filter out wanted differences
    result = collections.defaultdict(dict)

    for plugin in diff_plugins:
        plugin["differences"](lbom, rbom, product_object_id, variant_filter, result, bomfilter)

    return result.values()


def has_differences(lbom, rbom, product_object_id=None):
    return any(
        (
            plugin["predicate"](lbom, rbom, product_object_id)
            for plugin in diff_plugins
        )
    )


# -- quantity differences -----------------------------------------------------

def get_quantity_diffs(lbom, rbom, product_object_id, variant_filter, result, bomfilter):
    data = get_differences_data(lbom, rbom, variant_filter, bomfilter)

    for r in data:
        result[(r["teilenummer"], r["t_index"])] = dict(r)


def has_quantity_difference(lcomp, rcomp, product_object_id):
    return lcomp["menge"] != rcomp["menge"]


def get_differences_data(lbom, rbom, variant_filter=None, bomfilter=None):
    # compute the quantities in the left bom
    left_quantities = bomqueries.quantities(lbom, variant_filter=variant_filter,
                                            bomfilter=bomfilter, bomfilter_func=bomfilter_func)

    # compute the quantities in the right bom
    right_quantities = bomqueries.quantities(rbom, variant_filter=variant_filter,
                                             bomfilter=bomfilter, bomfilter_func=bomfilter_func)

    default = {"quantity": 0,
               "bom_level": sys.maxint}
    differences = {}
    for teilenummer, t_index in set(left_quantities.keys() + right_quantities.keys()):
        lhs = left_quantities.get((teilenummer, t_index), default)
        rhs = right_quantities.get((teilenummer, t_index), default)

        lbom_quantity = lhs["quantity"]
        rbom_quantity = rhs["quantity"]
        if lbom_quantity != rbom_quantity:
            differences[(teilenummer, t_index)] = {"teilenummer": teilenummer,
                                                   "t_index": t_index,
                                                   "lbom_quantity": lbom_quantity,
                                                   "rbom_quantity": rbom_quantity,
                                                   "bom_level": min(lhs["bom_level"],
                                                                    rhs["bom_level"])}

    result = []
    filter_rule = objects.Rule.ByKeys(FILTER_RULE)

    # Optimization: fetch items in chunks
    for keys in _chunked(differences.keys(), 300):
        condition = " OR ".join(["(teilenummer='%s' AND t_index='%s')" % key
                                 for key in keys])

        stmt = """
            SELECT ts.*,
                CASE
                    WHEN NOT EXISTS (
                        SELECT * FROM einzelteile et
                            WHERE et.baugruppe=ts.teilenummer
                                AND et.b_index=ts.t_index
                    ) THEN 1
                    ELSE 0
                END is_leaf
            FROM teile_stamm ts
            WHERE %s """ % condition

        for item in items.Item.SQL(stmt):
            if not filter_rule.match(item):
                differences[(item.teilenummer, item.t_index)].update({
                    "t_kategorie": item.t_kategorie_name,
                    "label": item.designation[''],
                    "item_object_id": item.cdb_object_id,
                    "is_leaf": _is_leaf(item),
                })
                result.append(differences[(item.teilenummer, item.t_index)])

    return result


# -- predicates differences ---------------------------------------------------

def has_predicate_difference(lcomp, rcomp, product_object_id):
    def signature(comp):
        signatures = predicate_signatures(product_object_id)
        return set([
            ";".join(sorted(terms))
            for terms in signatures[(
                comp["baugruppe"],
                comp["b_index"],
                comp["teilenummer"],
                comp["variante"],
                comp["position"]
            )].values()
        ])

    return signature(lcomp) != signature(rcomp)


def get_predicate_diffs(lbom, rbom, product_object_id, variant_filter, result, bomfilter):
    if product_object_id and not variant_filter:
        # compare bom predicates
        l_assemblies = bomqueries.flat_bom_dict(lbom, bomfilter=bomfilter, bomfilter_func=bomfilter_func)
        r_assemblies = bomqueries.flat_bom_dict(rbom, bomfilter=bomfilter, bomfilter_func=bomfilter_func)

        for lcomp, rcomp, level in compare_bom_predicates(lbom, rbom, product_object_id):
            baugruppe, b_index, teilenummer, t_index, _, _, _ = lcomp
            r_baugruppe, r_b_index, r_teilenummer, r_t_index, _, _, _ = rcomp

            # FIXME: if filter is set, check for all parents
            if bomfilter:
                if (baugruppe, b_index) not in l_assemblies.keys() or (r_baugruppe, r_b_index) not in r_assemblies.keys():
                    continue

            diff = result[(teilenummer, t_index)]
            if not diff:
                # In case the component was not found by the quantity comparison
                # we must set also the other attributes
                item = items.Item.ByKeys(teilenummer=teilenummer, t_index=t_index)
                diff.update({
                    "teilenummer": teilenummer,
                    # "obj_icon": item.GetObjectIcon(),
                    "t_index": t_index,
                    "bom_level": level,
                    "t_kategorie": item.t_kategorie,
                    "label": item.designation[''],
                    "item_object_id": item.cdb_object_id,
                    "is_leaf": not item.Components
                })
            diff["predicates"] = 1


def compare_bom_predicates(lbom, rbom, product_object_id):
    # FIXME: check if integrating predicate usages in 1- gives better performance
    result = []

    # 1- get the mapping using one sql query
    bom_mapping, _, _ = mapping.compute_mapping(
        lbom, rbom, tagname="mbom_mapping_tag")

    # 2- compare the predicate signatures
    signatures = predicate_signatures(product_object_id)

    def _get_signature(comps):
        if not isinstance(comps, list):
            comps = list([comps])

        terms = []
        for comp in comps:
            baugruppe, b_index, teilenummer, _t_index, position, variante, _auswahlmenge = comp
            for _sigs in signatures[(baugruppe, b_index, teilenummer, variante, position)].values():
                terms.extend(_sigs)

        return set([";".join(sorted(terms))])

    for lcomp, rcomps in bom_mapping.iteritems():
        for rcomp, level in rcomps:
            if _get_signature(lcomp) != _get_signature(rcomp):
                result.append((lcomp, rcomp, level))

    return result


# diff_plugins can be extended to add some other logic of computing differences
diff_plugins = [
    {
        "differences": get_quantity_diffs,
        "predicate": has_quantity_difference
    }, {
        "differences": get_predicate_diffs,
        "predicate": has_predicate_difference
    }
]


# check_bomfilter can be overwritten to add some other logic of filtering
def bomfilter_func(comp, bomfilter):
    """
    component is a dictionary of prefetched attributes
    for optimiziation reasons
    """

    result = all((comp[attr] == value
                    for attr, value in bomfilter.items()
                    if value and attr in comp and comp[attr]))
    return result


# -- utils ----------------------------------------------------------------

def _is_leaf(item):
    # objects coming from _bom_info contains the key is_leaf in their record
    # this way we can avoid many sql queries
    def getRecord(obj):
        if isinstance(obj, sqlapi.Record):
            return obj
        else:
            return obj.GetRecord()

    try:
        r = getRecord(item)
        return r.is_leaf
    except AttributeError:
        return not item.Components


@lru_cache.lru_cache(maxsize=5)
def predicate_signatures(product_object_id, comps=None):
    def keys(comp):
        if isinstance(comp, tuple):
            baugruppe, b_index, teilenummer, _t_index, position, variante, _auswahlmenge = comp
        else:
            baugruppe = comp.baugruppe
            b_index = comp.b_index
            teilenummer = comp.teilenummer
            position = comp.position
            variante = comp.variante
        return (baugruppe, b_index, teilenummer, variante, position)

    if comps is None:
        comps = []
    elif not isinstance(comps, list):
        comps = [comps]

    conditions = ["(product_object_id='%s')" % sqlapi.quote(product_object_id)]

    table_info = util.tables["cdbvp_bom_term"]
    for comp in comps:
        attrs = ["baugruppe", "b_index", "teilenummer", "variante", "position"]
        for attr, value in zip(attrs, keys(comp)):
            conditions.append("(%s=%s)" % (attr, sqlapi.make_literal(table_info, attr, value)))

    terms = sqlapi.RecordSet2(
        table="cdbvp_bom_term",
        columns=[
            "baugruppe", "b_index", "teilenummer", "variante",
            "position", "predicate_id", "term_id", "property_id", "enum_value",
            "operator"
        ],
        condition=" AND ".join(conditions)
    )
    result = collections.defaultdict(lambda: collections.defaultdict(list))
    for term in terms:
        result[(
            term.baugruppe,
            term.b_index,
            term.teilenummer,
            term.variante,
            term.position
        )][term.predicate_id].append("%s%s%s" % (
            term.property_id,
            term.operator,
            term.enum_value
        ))

    # also check string predicates
    string_predicates = sqlapi.RecordSet2(
        table="cdbvp_bom_predicate",
        columns=[
            "baugruppe", "b_index", "teilenummer", "variante",
            "position", "predicate_id", "expression"
        ],
        condition="cdb_classname='%s' AND %s" % (
            bomlinks.BOM_String_Predicate.__classname__,
            " AND ".join(conditions)
        )
    )
    for predicate in string_predicates:
        result[(
            predicate.baugruppe,
            predicate.b_index,
            predicate.teilenummer,
            predicate.variante,
            predicate.position
        )][predicate.predicate_id].append(predicate.expression)

    return result


class HintImpl(object):
    def __init__(self):
        pass

    def calculate(self, diffs, litem, ritem):
        result = map(dict, diffs)
        for values in result:
            if 'lbom_quantity' in values and 'rbom_quantity' in values:
                diff_amount = values['lbom_quantity'] - values["rbom_quantity"]
                has_index = self._has_index(result, values)
                values["hint"] = "%s%d" % ("+" if diff_amount > 0 else "",
                                           diff_amount)
                if has_index:
                    values["hint"] += ", " + util.get_label("cdbvp_elink_diffutil_index_exchange")
            if values.get("predicates"):
                values["hint"] = values.get("hint", "")
                if values["hint"]:
                    values["hint"] += ", "
                values["hint"] += util.get_label("cdbvp_bom_synchronise_predicates")
        return result

    def _has_index(self, differences, source_diff):
        for difference in differences:
            if difference["teilenummer"] == source_diff["teilenummer"] and \
                    difference["t_index"] != source_diff["t_index"]:
                return True
        return False


_hint_impl = HintImpl


def set_hint_impl(cls):
    global _hint_impl
    _hint_impl = cls


def calculate_hints(diffs, litem, ritem):
    return _hint_impl().calculate(diffs, litem, ritem)


# -----------------------------------------------------------------------------

def find_differences(item, lbom, rbom, product_object_id=None, variant_filter=None, bomfilter=None, bomfilter_func=None):
    # for bom in [lbom, rbom]:
    # - visit bom (only item usages)
    #     + for each position, if the position is not in the result: compute mapped position and check difference
    #     + if it has no mapping, it is a difference
    #     + if it has a mapping and it is a difference, add it to the result

    flat_bom = bomqueries.flat_bom_dict(
        lbom, rbom, searched_item=item,
        product_object_id=product_object_id, variant_filter=variant_filter,
        bomfilter=bomfilter, bomfilter_func=bomfilter_func
    )

    def visit(lpath):
        lcomp = lpath[-1]

        # iterate only through the usages of searched_item
        for comp in flat_bom[(lcomp.teilenummer, lcomp.t_index)]:
            if bomqueries.get_item_attr(comp, "item_object_id") == item.cdb_object_id:
                # FIXME: think about what should happen, when more than one path is found
                rpaths = mapping.mapped_paths(lpath + [comp], rbom, variant_filter=variant_filter,
                                              bomfilter=bomfilter, bomfilter_func=bomfilter_func)
                if len(rpaths) == 0:
                    yield (lpath + [comp], "left")
                else:
                    rpath = rpaths[0]
                    if has_differences(comp, rpath[-1], product_object_id=product_object_id):
                        yield (lpath + [comp], "left")
                        yield (rpath, "right")

                    for rpath in rpaths[1:]:
                        yield (rpath, "right")
            else:
                for x in visit(lpath + [comp]):
                    yield x

    for x in visit([lbom]):
        yield x

    def find_right_unmapped(rpath):
        rcomp = rpath[-1]

        # iterate only through the usages of searched_item
        for comp in flat_bom[(rcomp.teilenummer, rcomp.t_index)]:
            if bomqueries.get_item_attr(comp, "item_object_id") == item.cdb_object_id:
                # FIXME: think about what should happen, when more than one path is found
                lpaths = mapping.mapped_paths(rpath + [comp], lbom)
                if len(lpaths) == 0:
                    yield (rpath + [comp], "right")
            else:
                for x in find_right_unmapped(rpath + [comp]):
                    yield x

    for x in find_right_unmapped([rbom]):
        yield x


def get_parents(lbom, rbom, comp):
    parents = set()

    def _walk(comp, flat_bom):
        for r in flat_bom:
            if (r.teilenummer, r.t_index) == comp:
                parents.add(r)
                _walk((r.baugruppe, r.b_index), flat_bom)

    _walk(comp, lbom)
    _walk(comp, rbom)

    return parents
