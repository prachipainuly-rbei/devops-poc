#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
"""
Module cs.vp.bom.diffutil.pages
"""

import collections
import json
import operator
import re
import urllib

import cdbwrapc
from cdb import constants
from cdb import elink
from cdb import sqlapi
from cdb import transactions
from cdb import util
from cdb import lru_cache
from cdb import fls
from cdb.objects.core import CDBClassDef
from cdb.objects.util import paginated
from cdb.objects import fields
from cdb.objects import Object
from cdb.objects import Rule
from cdb.objects import org
from cdb.platform import mom
from cdb.platform.mom import SimpleArguments
from cdb.platform.mom import operations as mom_operations

from cs.vp import bom
from cs.vp import items
from cs.vp import products
from cs.vp import variants
from cs.vp.bom import bomqueries
from cs.vp.bom import diffutil
from cs.vp.bom import mapping
from cs.vp.bom import usages as usages_tools
from cs.vp.bom.diffutil import differences
from cs.vp.bom.diffutil import router
from cs.vp.variants import filter as vfilter
from cs.vp.variants import bomlinks
from cs.vp.bom.diffutil import misc


__docformat__ = "restructuredtext en"
__revision__ = "$Id: pages.py 176685 2018-05-02 11:34:27Z gda $"

URLSEPARATOR = ";"
BOM_POSITION_OFFSET = 10
BOM_NODE_TAG = None
LIFECYCLECONF = "part"

PREVIEW_3D_RULE = "mBOM Manager: 3D documents"
PREVIEW_2D_RULE = "mBOM Manager: 2D documents"


def get_bomnode_tag():
    global BOM_NODE_TAG
    if BOM_NODE_TAG is None:
        from cdb.platform.gui import Message
        from cdb.objects.core import parse_raw
        msg = Message.ByKeys('mbom_diffmerge_node_tag')
        if msg:
            dtag = msg.Text['']
        else:
            dtag = ""
            cldef = None
            try:
                cldef = CDBClassDef('bom_item')
                dtag = cldef.getObjDescriptionPattern()
            except RuntimeError:
                pass
        if not dtag:
            dtag = 'position + ": " + menge + "x " + teilenummer + "/" + t_index'
        BOM_NODE_TAG = parse_raw(dtag)
    return BOM_NODE_TAG


class _BomItemAttributeAccessor:

    def __init__(self, bom_item, item):
        self.bom_item = bom_item
        self.item = item

    def __getitem__(self, name):
        fd = bom.AssemblyComponent.GetFieldByName(name)

        if isinstance(fd, fields.MultiLangAttributeDescriptor):
            fd = fd.getLanguageField()
        if isinstance(fd, fields.JoinedAttributeDescriptor) and \
                fd.source_adef.getClassDef().getPrimaryTable() == 'teile_stamm':
            v = self.item.__getitem__(fd.source_adef.getName())
        else:
            if isinstance(fd, fields.MappedAttributeDescriptor):
                v = fd.eval(self.bom_item)
            else:
                v = self.bom_item.__getitem__(name)
        if v is None:
            return u""
        else:
            if isinstance(v, str):
                return unicode(v)
            return v


THREED_SYNC_PLUGIN_ID = None

# FIXME: do this after bootstrap!
if bom.is_installed("cs.threed.viewer.webgl"):
    from cs.threed.viewer.webgl import pages as threed_pages
    plugin = {
        "types": ["maxbom", "ebom", "mbom", "variant"],
        "id": "MBOM",
        "icon": "cdbvp_elink_diffutil",
        "label": "cdbvp_elink_diffutil_op_name"
    }
    THREED_SYNC_PLUGIN_ID = threed_pages.register_plugin(plugin)


class MainPage(elink.VirtualPathTemplate):
    __template__ = "index.html"

    @staticmethod
    def statecolors():
        """
        Similar behaviour as cdb.objects.Object._getObjectStateColor.
        Reimplemented for performance reasons (we don't want to do
        an SQL-query for every item).
        """

        from cdb.platform import olc

        lifecycleconf = olc.WorkflowClass.ByKeys(objclass=LIFECYCLECONF)

        lifecycles = ", ".join(["'%s'" % _fp(oa)
                                for oa in lifecycleconf.Workflows.objektart])

        colors = sqlapi.RecordSet2(sql="SELECT a.objektart, a.statusnummer, b.* "
                                       "FROM objektstati a, farben b "
                                       "WHERE a.statusfarbe = b.bezeichnung "
                                       "AND a.objektart IN (%s)" % (lifecycles))

        result = collections.defaultdict(lambda: collections.defaultdict(list))
        for color in colors:
            result[color.objektart][color.statusnummer] = (color.rot_anteil,
                                                           color.gruen_anteil,
                                                           color.blau_anteil)

        return result

    @staticmethod
    def labels():  # Returns the labels to be used in javascript code.
        keys = [
            'cdbvp_elink_diffutils_name',
            'cdbvp_elink_diffutils_selection',
            'cdbvp_elink_diffutils_differences',
            'cdbvp_elink_diffutils_search',
            'cdbvp_elink_diffutils_left_bom',
            'cdbvp_elink_diffutils_right_bom',
            'cdbvp_elink_diffutils_mbom_select',
            'cdbvp_elink_diffutils_no_differences',
            'cdbvp_elink_diffutils_item_ops',
            'cdbvp_elink_diffutils_bom_item_ops',
            'cdbvp_elink_diffutils_preview',
            'cdbvp_elink_diffutils_operations',
            'cdbvp_elink_diffutil_part_no',
            'cdbvp_elink_diffutil_idx',
            'cdbvp_elink_diffutils_category',
            'cdbvp_elink_diffutils_cnt_fbom',
            'cdbvp_elink_diffutils_cnt_sbom',
            'cdbvp_elink_diffutils_act_right_bom',
            'cdbvp_elink_diffutils_nopreview',
            'cdbvp_elink_diffutils_filter',
            'cdbvp_elink_diffutils_change',
            'cdbvp_elink_diffutils_cancel',
            'cdbvp_elink_diffutils_variant_id',
            'cdbvp_elink_diffutils_variant_name',
            'cdbvp_elink_diffutils_selected_variant',
            'cdbvp_elink_diffutils_select_variant',
            'cdbvp_elink_diffutils_product',
            'cdbvp_bom_show_assemblies',
            'cdbvp_bom_show_leaves',
            'cdbvp_elink_diffutil_all',
            'cdbvp_diffutil_ignored',
            'cdbvp_diffutil_ignored_difference',
            'cdbvp_diffutil_ignored_item',
            'cdbvp_elink_diffutil_level',
            'cdbvp_diffutil_selected_element',
            'cdbvp_elink_diffutils_mbom_no_mbom_available',
            'cdbvp_elink_diffutil_refresh',
            'cdbvp_elink_diffutil_open_2d_preview',
            'cdbvp_elink_diffutil_open_3d_preview',
            'cdbvp_elink_diffutil_open_synched_cockpit',
            'cdbvp_elink_diffutils_update_table',
            'cdbvp_elink_diffutil_load_usages',
            'cdbvp_elink_diffutil_load_differences',
            'cdbvp_elink_diffutil_load_difference_table',
            'cdbvp_elink_diffutil_load_predicates',
            'cdbvp_elink_diffutil_load_items',
            'cdbvp_elink_diffutil_load_item_details',
            'cdbvp_elink_diffutil_load_boms',
            'cdbvp_elink_diffutil_load_variants',
            'cdbvp_elink_diffutil_load_preview_link',
            'cdbvp_elink_diffutil_load_search_result'
        ]

        return {key: util.Labels()[key] for key in keys}

    def render(self, context):
        vpath = self.get_path_segments(cleanup=True)

        litem = None
        if len(vpath) >= 1:
            litem_nr, litem_index = get_item_details(vpath[0])
            litem = items.Item.ByKeys(teilenummer=litem_nr, t_index=litem_index)

        app_root = self.application.getURLPaths()["approot"]
        api_root = "%sapi/part/" % app_root
        localres = self.application.getURLPaths()["localres"]

        if litem:
            selector = "".join([litem.teilenummer, URLSEPARATOR, litem.t_index])

            from cs.vp.bom import AssemblyComponent
            cmsg = AssemblyComponent.MakeCdbcmsg('cdbvp_mbom_manager_show_preview')

            product_object_id, variant, signature = _get_preselected_elements(vpath)

            return {"template_url_root": "%shbs/" % localres,
                    "api_root": api_root,
                    "app_data": api_root + selector + "/meta",
                    "page_title": util.get_label('cdbvp_elink_diffutil_main_title'),
                    "labels": json.dumps(self.labels()),
                    "statecolors": json.dumps(self.statecolors()),
                    "product_object_id": product_object_id,
                    "variant": json.dumps(variant),
                    "signature": signature,
                    "error_msg": None,
                    "previewurl": cmsg.cdbwin_url()}
        else:
            return {"page_title": util.get_label('cdbvp_elink_diffutil_main_title'),
                    "error_msg": util.get_label('cdbvp_elink_diffutils_no_litem')}


def _get_preselected_elements(vpath):
    product_object_id = ""
    variant = ""
    signature = ""

    if len(vpath) == 3:
        product_object_id = vpath[1]
        product = products.Product.ByKeys(cdb_object_id=product_object_id)
        if product:
            regex = "^[0-9]+$"
            if re.match(regex, vpath[2]):
                variant_id = vpath[2]
                signature = ""
                _variant = variants.Variant.ByKeys(product_object_id=product_object_id,
                                                   id=variant_id)
                if _variant:
                    _variant = _variant.get_filter_variant()
                    variant = {"product_object_id": _variant.product_object_id,
                               "vid": _variant.id,
                               "name": _variant.name,
                               "info": _variant.InfoTxt[''],
                               "description": _variant.GetDescription()}
                    variant.update({pv.id: pv.EnumValue.ValueText[""]
                                    for pv in _variant.PropertyValues})
            else:
                signature = vpath[2]
                variant_id = ""
                if signature:
                    text = variants.Variant.getVariantTextFromSignature(product_object_id,
                                                                        signature)
                    variant = {"product_object_id": product_object_id,
                               "signature": signature,
                               "description": text}

    return product_object_id, variant, signature


class BOMPreview(elink.Template):
    __template__ = "bompreview.html"


class DataProviderBase(elink.VirtualPathTemplate):

    __text__ = "${result}"

    def _render(self, req):
        self.content_type("application/json")
        super(DataProviderBase, self)._render(req)

    def make_link(self, path=[]):
        if isinstance(path, basestring):
            path = path.split("/")
        paths = map(unicode, path + [""])
        return "%sapi/%s" % (self.application.getURLPaths()["approot"],
                             "/".join(paths))

    def get_form_data(self, keyname, default=None):
        form_data = getattr(self.request, 'form_data', {}).copy()
        result = form_data.get(keyname, default)
        if isinstance(result, str):
            result = self._convert_to_unicode(result)
        elif isinstance(result, collections.Iterable) and \
                not isinstance(result, basestring):
            result = [self._convert_to_unicode(url) for url in result]
        return result

    def _convert_to_unicode(self, bs):
        # Ensure that the text parameters are converted to unicode objects.
        if isinstance(bs, str):
            charset = getattr(self.request, "charset", None)
            if not charset:
                charset = elink.ELINK_ENCODING

            return bs.decode(charset)
        else:
            return bs


class DataPage(DataProviderBase):

    def render(self, context, **varkw):
        vpath = self.get_path_segments(cleanup=True)
        result = router.handle_request(self, vpath)
        return {"result": result}


def get_item_details(part_nr_idx):
    part_nr = ""
    part_idx = ""
    part_nr_idx_list = part_nr_idx.split(URLSEPARATOR)
    if len(part_nr_idx_list):
        part_nr = part_nr_idx_list[0]
    if len(part_nr_idx_list) > 1:
        part_idx = part_nr_idx_list[1]
    return part_nr, part_idx


@lru_cache.lru_cache(clear_after_ue=False)
def _org_desc(site_object_id):
    organization = org.Organization.ByKeys(cdb_object_id=site_object_id)
    return organization.GetDescription() if organization else ""


def _item_info(page, item):
    # return the representation of item, needed by the javascript code
    if item is not None:
        return {"cdb_object_id": item.cdb_object_id,
                "nr": item.teilenummer,
                "idx": item.t_index,
                "is_assembly": not differences._is_leaf(item),
                "is_mbom": item.is_mbom if item.is_mbom else "",
                "cdb_depends_on": item.cdb_depends_on,
                "object_type": item.cdb_objektart,
                "status": item.status,
                "operations": _get_ops(page, "part")}


def _item_details(item):
    if item is not None:
        org_desc = _org_desc(item.site_object_id)
        item_desc = item.GetDescription()
        return {
            "cdb_object_id": item.cdb_object_id,
            "link": item.MakeURL(),
            "description": item_desc,
            "tooltip": util.get_label(
                "cdbvp_elink_diffutils_item_tooltip") % item_desc,
            "state_icon": item.GetObjectIcon(),
            "mbom_desc": util.get_label(
                "cdbvp_elink_diffutils_mbom_label") % (item_desc, org_desc),
        }


def _predicates_info(baugruppe, b_index, teilenummer, variante, position):
    predicates = bomlinks.BOM_Predicate.KeywordQuery(
        baugruppe=baugruppe,
        b_index=b_index,
        teilenummer=teilenummer,
        variante=variante,
        position=position,
    )

    def item_object_id(predicate):
        parts = sorted(predicate.Parts, key=lambda part: part.t_index)
        if parts:
            return parts[-1].cdb_object_id
        else:
            return ""

    return [{
        "baugruppe": baugruppe,
        "b_index": b_index,
        "teilenummer": teilenummer,
        "variante": variante,
        "position": position,
        "text": predicate.PredicateText[''],
        "icon": predicate.GetObjectIcon(),
        "item_object_id": item_object_id(predicate)
    } for predicate in predicates]


def _bom_info(page, assembly, vfilter=None, bomfilter={}):
    bom_node_tag = get_bomnode_tag()

    # Optimization: use a special SQL query to find out, if an item
    # is an assembly or a component

    stmt = (
        "SELECT ts.*, "
        "    CASE "
        "        WHEN NOT EXISTS ("
        "            SELECT * FROM einzelteile et"
        "            WHERE et.baugruppe=ts.teilenummer"
        "                AND et.b_index=ts.t_index"
        "        ) THEN 1"
        "        ELSE 0"
        "    END is_leaf "
        "FROM teile_stamm ts "
        "WHERE EXISTS ("
        "   SELECT 42 "
        "   FROM einzelteile e "
        "   WHERE e.teilenummer=ts.teilenummer AND e.t_index=ts.t_index "
        "       AND e.baugruppe='%s' AND e.b_index='%s'"
        ")"
    ) % (sqlapi.quote(assembly.teilenummer),
         sqlapi.quote(assembly.t_index))

    comp_Item = {(it.teilenummer, it.t_index): it
                 for it in sqlapi.RecordSet2(sql=stmt)}

    result = []

    # Optimization: only evaluate filter for assembly components which have
    # some predicate
    bom_predicates_components = bom.AssemblyComponent.SQL("""
        SELECT *
        FROM einzelteile e
        WHERE baugruppe='{baugruppe}' AND b_index='{b_index}' AND
            EXISTS (
                SELECT 42
                FROM cdbvp_bom_predicate p
                WHERE e.baugruppe=p.baugruppe
                    AND e.b_index=p.b_index
                    AND e.teilenummer=p.teilenummer
                    AND e.variante=p.variante
                    AND e.position=p.position
            )
    """.format(baugruppe=assembly.teilenummer,
               b_index=assembly.t_index))

    def _has_predicates(_comp):
        return _comp in bom_predicates_components

    for comp in assembly.Components:
        item = comp_Item.get((comp.teilenummer, comp.t_index))
        if item:

            has_predicates = _has_predicates(comp)
            in_variant = (vfilter is None or
                        not has_predicates or
                        vfilter.eval(baugruppe=comp.baugruppe,
                                    b_index=comp.b_index,
                                    teilenummer=comp.teilenummer,
                                    t_index=comp.t_index,
                                    variante=comp.variante,
                                    position=comp.position))

            if bomfilter:
                in_variant = in_variant and differences.bomfilter_func(item, bomfilter)

            description = bom_node_tag % _BomItemAttributeAccessor(comp, item)
            result.append(
                {
                    "item": _item_info(page, item),
                    "item_object_id": item.cdb_object_id,
                    "description": description,
                    "tooltip": util.get_label("cdbvp_elink_diffutils_item_tooltip") % description,
                    "baugruppe": comp.baugruppe,
                    "b_index": comp.b_index,
                    "teilenummer": comp.teilenummer,
                    "t_index": comp.t_index,
                    "position": comp.position,
                    "variante": comp.variante,
                    "auswahlmenge": unicode(comp.auswahlmenge),
                    "bom_icon": _get_bom_icon(
                        item.t_kategorie,
                        comp.cdbvp_positionstyp,
                        comp.cdbvp_has_condition),
                    "has_predicates": has_predicates,
                    "operations": _get_ops(page, "bom_item"),
                    "in_variant": in_variant,
                    "mbom_mapping_tag": comp.mbom_mapping_tag
                })
    return sorted(result, key=lambda x: (x["position"], x["description"]))


def _get_icon(page, opi):
    """Returns icon url for an operation."""
    iconurl = opi.get_icon_urls()
    if iconurl:
        baseuri = page.application.getURLPaths()["base_uri"]
        return baseuri + iconurl[0]
    else:
        # Fallback: default operation icon
        from cdb.objects import IconCache
        return IconCache.getIcon("cdb_operation")


def _get_bom_icon(category, position_type, has_condition):
    from cdb.objects import IconCache
    kwargs = {"t_kategorie": category,
              "cdbvp_positionstyp": position_type,
              "cdbvp_has_condition": has_condition}
    return IconCache.getIcon("cdbvp_part", **kwargs)


@lru_cache.lru_cache(clear_after_ue=False)
def _get_operation_info(classname, name):
    return mom_operations.OperationInfo(classname, name)


@lru_cache.lru_cache(clear_after_ue=False)
def _get_ops(page, classname):
    result = collections.defaultdict(list)
    for operation in _PLUGINS:
        if (classname == "part" and operation["is_item_op"]) or \
                (classname == "bom_item" and not operation["is_item_op"]):
            opcfg = _get_operation_info(classname, operation["name"])
            op_dict = {"name": operation["name"],
                       "label": opcfg.get_label(),
                       "icon": _get_icon(page, opcfg),
                       "needsReload": operation["needsReload"],
                       "unselect": operation["unselect"],
                       "multi_select_op": operation["multi_select_op"]}

            if operation["multi_select_op"]:
                op_dict.update(get_custom_op_info(page,
                                                  operation,
                                                  operation.get("dialog_text"),
                                                  operation.get("dlg_btns")))

            if operation["is_ebom_op"]:
                result["ebom_ops"].append(op_dict)
            else:
                result["mbom_ops"].append(op_dict)
    return result


def get_custom_op_info(page, operation, dlg_txt=None, dlg_btns=None):
    """
    Generates a custom operation (link) which calls the JSON method 'custom_operation'. If dlg_txt
    is set, then a modal dialog is shown which has to be confirmed in order to call the JSON method.
    """
    if dlg_btns is None:
        dlg_btns = {}

    from cs.vp.bom import AssemblyComponent
    result = {
        "custom_url": "%scustom_operation" % (page.make_link().replace("api/", "")),
        "opname": operation["name"],
        "dialogText": util.get_label(dlg_txt) if dlg_txt else None,
        "dialogBtns": json.dumps({key: util.get_label(value)
            for key, value in dlg_btns.iteritems()})
    }
    return result


# =======================
# handle data api request
# =======================


@router.json("part/:item_nr_idx/meta")
def meta_data_item(page, item_nr_idx):
    item_nr, item_idx = get_item_details(item_nr_idx)
    item = items.Item.ByKeys(teilenummer=item_nr, t_index=item_idx)

    if item.cdb_depends_on:
        # item is the right bom
        ritem = item
        litem = items.Item.ByKeys(cdb_object_id=item.cdb_depends_on)
    else:
        litem = item
        ritem = None

    return _meta_data(page, litem, ritem)


@router.json("part/:litem_nr_idx/:ritem_nr_idx/meta")
def meta_data(page, litem_nr_idx, ritem_nr_idx):
    litem_nr, litem_idx = get_item_details(litem_nr_idx)
    litem = items.Item.ByKeys(teilenummer=litem_nr, t_index=litem_idx)

    ritem = None
    if ritem_nr_idx:
        ritem_nr, ritem_idx = get_item_details(ritem_nr_idx)
        ritem = items.Item.ByKeys(teilenummer=ritem_nr, t_index=ritem_idx)

    return _meta_data(page, litem, ritem)


def _meta_data(page, litem, ritem=None):
    if litem is not None:
        ritems = items.Item.KeywordQuery(cdb_depends_on=litem.cdb_object_id)
        itemList = [_item_info(page, item) for item in ritems]
        itemDetails = [_item_details(item) for item in ritems]
        itemDetails.append(_item_details(litem))
        products_info = [_get_product(product.cdb_object_id)
                         for product in set(reduce(operator.add,
                                                   [item.Products
                                                    for item
                                                    in [litem] + list(ritems)]))
                         if product.status != products.Product.INVALID.status]
        categories = items.ItemCategory.Query().name
        result = dict(litem=_item_info(page, litem),
                      itemList=itemList,
                      itemDetails=itemDetails,
                      products=products_info,
                      categories=categories)
    else:
        raise util.ErrorMessage("cdbvp_elink_diffutils_item_not_available")

    if ritem:
        result["ritem"] = _item_info(page, ritem)

    if THREED_SYNC_PLUGIN_ID is not None:
        result["threed_plugin_id"] = THREED_SYNC_PLUGIN_ID

    return result


@router.json("part/diff_table")
@router.json("part/:litem_nr_idx/diff_table")
@router.json("part/:litem_nr_idx/:ritem_nr_idx/diff_table")
def diff_table(page, litem_nr_idx='', ritem_nr_idx=''):
    # return differences between the lbom and the rbom
    litem_nr, litem_idx = get_item_details(litem_nr_idx)
    litem = items.Item.ByKeys(teilenummer=litem_nr, t_index=litem_idx)

    bomfilter = json.loads(page.get_form_data("filter") or "{}")
    if not bomfilter:
        bomfilter = None

    ritem = None
    if ritem_nr_idx:
        ritem_nr, ritem_idx = get_item_details(ritem_nr_idx)
        ritem = items.Item.ByKeys(teilenummer=ritem_nr, t_index=ritem_idx)

    if litem and ritem:
        # Build variant filter
        product_oid = page.get_form_data("product_oid", None)
        variant_id = page.get_form_data("variant_id", None)
        signature = page.get_form_data("signature", None)
        if product_oid and variant_id:
            variant_filter = vfilter.VariantBOMFilter(product_oid, variant_id)
        elif product_oid and signature:
            variant_filter = vfilter.VirtualVariantBOMFilter(product_oid,
                                                             signature)
        else:
            variant_filter = None

        content = []
        diffs = differences.get_differences(litem, ritem, product_oid,
                                            variant_filter, bomfilter)
        ignored_diffs = diffutil.IgnoredDifferences.KeywordQuery(context_teilenummer=ritem_nr)
        for values in differences.calculate_hints(diffs, litem, ritem):
            if any((diff.teilenummer == values["teilenummer"] and
                    diff.ignored_difference == '' for diff in ignored_diffs)):
                ignored = util.get_label('cdbvp_diffutil_ignored_item')
            elif any((diff.teilenummer == values["teilenummer"] and
                      diff.ignored_difference == values.get("hint")
                      for diff in ignored_diffs)):
                ignored = util.get_label('cdbvp_diffutil_ignored_difference')
            else:
                ignored = ""

            content.append({
                # "obj_icon": values["obj_icon"],
                "name": values["teilenummer"],
                "idx": values["t_index"],
                "level": values["bom_level"],
                "caption": values["label"],
                "category": values["t_kategorie"],
                "cnt_fbom": values.get("lbom_quantity", ""),
                "cnt_sbom": values.get("rbom_quantity", ""),
                "item_object_id": values["item_object_id"],
                "act_sbom": values.get("hint"),
                "is_leaf": values["is_leaf"],
                "predicates": values.get("predicates", 0),
                "ignored": ignored
            })
    else:
        content = []

    return content


@router.json("part/:cdb_object_id/product_variants")
def variants_by_product_id(page, cdb_object_id):
    prod = products.Product.ByKeys(cdb_object_id=cdb_object_id)
    if prod and prod.CheckAccess('read'):
        return _getProductVariantInfo(page, prod)


@router.json("part/:cdb_object_id/product_variants_meta")
def variants_meta_by_product_id(page, cdb_object_id):
    prod = products.Product.ByKeys(cdb_object_id=cdb_object_id)
    searchstr = page.get_form_data("searchStr")
    if prod:
        return _getProductVariantCount(prod, searchstr)


@router.json("part/:cdb_object_id/product_properties")
def properties_by_product_id(page, cdb_object_id):
    prod = products.Product.ByKeys(cdb_object_id=cdb_object_id)
    if prod:
        return map(lambda x: dict(id=x.id,
                                  name=x.Name['']),
                   prod.AllProperties)


@router.json("part/:cdb_object_id/item")
def item_by_id(page, cdb_object_id):
    # return informations about an item, given its cdb_object_id

    item = items.Item.ByKeys(cdb_object_id=cdb_object_id)
    if item is not None:
        return _item_info(page, item)
    else:
        raise util.ErrorMessage("cdbvp_elink_diffutils_item_not_available")


@router.json("part/items")
def items_by_ids(page):
    # return informations about many items, given their cdb_object_ids

    oids = page.get_form_data("oids[]")
    if isinstance(oids, basestring):
        oids = [oids]

    result = []

    for oid in oids:
        item = items.Item.ByKeys(cdb_object_id=oid)
        if item:
            result.append(_item_info(page, item))

    return result


@router.json("part/:cdb_object_id/itemdetails")
def item_by_id(page, cdb_object_id):
    item = items.Item.ByKeys(cdb_object_id=cdb_object_id)
    if item is not None:
        return _item_details(item)
    else:
        raise util.ErrorMessage("cdbvp_elink_diffutils_item_not_available")


@router.json("part/itemsdetails")
def items_by_ids(page):
    oids = page.get_form_data("oids[]")
    if isinstance(oids, basestring):
        oids = [oids]

    result = []
    for oid in oids:
        item = items.Item.ByKeys(cdb_object_id=oid)
        if item:
            result.append(_item_details(item))
    return result


@router.json("part/:cdb_object_id/bom")
def bom_by_item_id(page, cdb_object_id):
    # return informations about an item, given its cdb_object_id
    product_object_id = page.get_form_data("product_object_id")
    variant_id = page.get_form_data("variant_id")
    signature = page.get_form_data("signature")
    bomfilter = json.loads(page.get_form_data("filter") or "{}")

    if product_object_id and variant_id:
        vfilter = variants.filter.VariantBOMFilter(product_object_id, variant_id)
    elif product_object_id and signature:
        vfilter = variants.filter.VirtualVariantBOMFilter(product_object_id,
                                                          signature)
    else:
        vfilter = None
    item = items.Item.ByKeys(cdb_object_id=cdb_object_id)
    if item is not None:
        return _bom_info(page, item, vfilter, bomfilter)
    else:
        return []


@router.json("part/:pkeys/bom_predicates")
def bom_predicates(page, pkeys):
    baugruppe, b_index, teilenummer, variante, position = pkeys.split(";")
    return _predicates_info(
        baugruppe=baugruppe,
        b_index=b_index,
        teilenummer=teilenummer,
        variante=variante,
        position=int(position)
    )


@router.json("part/bom_predicates_list")
def bom_predicates_list(page):
    pkeys_list = page.get_form_data("pkeys[]")
    if isinstance(pkeys_list, basestring):
        pkeys_list = [pkeys_list]

    result = {}
    for pkeys in pkeys_list:
        result[pkeys] = (bom_predicates(page, pkeys))
    return result


@router.json("part/boms")
def boms_by_item_ids(page):
    oids = page.get_form_data("oids[]")
    if isinstance(oids, basestring):
        oids = [oids]

    product_object_id = page.get_form_data("product_object_id")
    variant_id = page.get_form_data("variant_id")
    signature = page.get_form_data("signature")
    bomfilter = json.loads(page.get_form_data("filter") or "{}")

    if product_object_id:
        if signature:
            vfilter = variants.filter.VirtualVariantBOMFilter(product_object_id,
                                                              signature)
        elif variant_id:
            vfilter = variants.filter.VariantBOMFilter(product_object_id,
                                                       variant_id)
        else:
            vfilter = None
    else:
        vfilter = None
    if isinstance(oids, basestring):
        oids = [oids]

    result = []

    for item in items.Item.Query(items.Item.cdb_object_id.one_of(*oids)):
        result.append([item.cdb_object_id, _bom_info(page, item, vfilter, bomfilter)])

    return result


@router.json("part/:item_object_id/:lbom_object_id/:rbom_object_id/usages")
def usages(page, item_object_id, lbom_object_id, rbom_object_id):
    # return a list of items which use a given item

    lbom = items.Item.ByKeys(cdb_object_id=lbom_object_id)
    rbom = items.Item.ByKeys(cdb_object_id=rbom_object_id)
    item = items.Item.ByKeys(cdb_object_id=item_object_id)

    if lbom and rbom and item:
        return usages_tools.get_usages([item], lbom, rbom)
    else:
        raise util.ErrorMessage("cdbvp_elink_diffutils_item_not_available")


def _raise_on_cyclic_reference(src_item, dst_item):
    for child_bom_item in src_item.Components:
        if child_bom_item.Item == dst_item:
            raise util.ErrorMessage("cdbvp_elink_diffutil_cyclic_bom_not_allowed")
        _raise_on_cyclic_reference(child_bom_item.Item, dst_item)


def sync_device_tag(source, target):
    _run(constants.kOperationModify, target, **{target.Item.get_mbom_mapping_attribute(target, source.Item): getattr(source, source.Item.get_mbom_mapping_attribute(target, source.Item))})


@router.json("part/:target_object_id/:drop_mode/dropitems")
def dropitems(page, target_object_id, drop_mode):
    # Allocate license for feature "Bom: Manage Manufacturing Boms"
    fls.allocate_license("BOM_003")

    bom_items = sorted(json.loads(page.get_form_data("bomitems")),
                       key=lambda x: x["position"])
    if not isinstance(bom_items, collections.Iterable):
        bom_items = [bom_items]
    for bom_item in bom_items:
        bom_item["parent"] = items.Item.ByKeys(cdb_object_id=bom_item["parent_node_id"])
    target = items.Item.ByKeys(cdb_object_id=target_object_id)

    if not target or not all(bom_item["parent"] for bom_item in bom_items):
        raise util.ErrorMessage("cdbvp_elink_diffutils_item_not_available")

    with transactions.Transaction():
        for bom_item in bom_items:
            src_bom_item = bom.AssemblyComponent.ByKeys(
                baugruppe=bom_item["parent"].teilenummer,
                b_index=bom_item["parent"].t_index,
                teilenummer=bom_item['teilenummer'],
                t_index=bom_item['t_index'],
                position=bom_item['position'],
                variante=bom_item['variante'],
                auswahlmenge=bom_item['auswahlmenge'])
            if src_bom_item:

                if drop_mode == "copy_device_tag":

                    target_bom_item = bom.AssemblyComponent.ByKeys(
                        baugruppe=bom_item['target_bom_item_baugruppe'],
                        b_index=bom_item['target_bom_item_b_index'],
                        teilenummer=bom_item['target_bom_item_teilenummer'],
                        t_index=bom_item['target_bom_item_t_index'],
                        position=bom_item['target_bom_item_position'],
                        variante=bom_item['target_bom_item_variante'],
                        auswahlmenge=bom_item['target_bom_item_auswahlmenge'])

                    sync_device_tag(src_bom_item, target_bom_item)

                else:

                    _raise_on_cyclic_reference(src_bom_item.Item, target)
                    _run(constants.kOperationCopy,
                         src_bom_item,
                         baugruppe=target.teilenummer,
                         b_index=target.t_index,
                         position=src_bom_item.position)
                    if drop_mode == "move":
                        if bom_item["parent"] == target:
                            raise util.ErrorMessage(
                                "cdbvp_elink_diffutil_moving_inside_asm_not_allowed")
                        _run(constants.kOperationDelete,
                             src_bom_item,
                             baugruppe=target.teilenummer,
                             b_index=target.t_index,
                             position=src_bom_item.position)


@router.json("part/:item_object_id/:mode/previewlink")
def preview_link(page, item_object_id, mode):
    item = items.Item.ByKeys(cdb_object_id=item_object_id)

    doc = _get_preview_doc(item, mode)
    if not doc:
        ebom = items.Item.ByKeys(cdb_object_id=item.cdb_depends_on)
        if ebom:
            doc = _get_preview_doc(ebom, mode)

    if doc:
        result = _get_preview_url(page.request.base_uri, doc)
        return result


@router.json("part/:item_object_id/:lbom_object_id/:rbom_object_id/syncbom")
def syncbom(page, item_object_id, lbom_object_id, rbom_object_id):
    item = items.Item.ByKeys(cdb_object_id=item_object_id)
    lbom = items.Item.ByKeys(cdb_object_id=lbom_object_id)
    rbom = items.Item.ByKeys(cdb_object_id=rbom_object_id)

    is_ebom = page.get_form_data("is_ebom", "true") == "true"
    _path = json.loads(page.get_form_data("path", "[]"))
    if _path:
        path = [bom.AssemblyComponent.ByKeys(**keys) for keys in _path[1:]]

    else:
        path = []

    if is_ebom:
        return rbom_partner(item, lbom, rbom, path)
    else:
        return lbom_partner(item, lbom, rbom, path)


@router.json("part/:lbom_object_id/:rbom_object_id/threed_url")
def threed_url(page, lbom_object_id, rbom_object_id):
    if bom.is_installed("cs.threed.viewer.webgl"):
        rbom = items.Item.ByKeys(cdb_object_id=rbom_object_id)

        from cs.threed.viewer import webgl
        app = webgl._getapp()
        url = app.getModuleURL() + "index/%s" % rbom.cdb_object_id

        return url


def rbom_partner(item, lbom, rbom, path):
    if item and lbom and rbom:
        if item.materialnr_erp:
            partners = items.Item.KeywordQuery(materialnr_erp=item.materialnr_erp)
        else:
            partners = item.ManufacturingViews
    else:
        raise util.ErrorMessage("cdbvp_elink_diffutils_item_not_available")

    usages = usages_tools.get_usages(partners, lbom, rbom)
    rpaths = mapping.mapped_paths(path, rbom)

    return {"partners": partners.cdb_object_id, "usages": usages,
            "paths": rpaths}


def lbom_partner(item, lbom, rbom, path):
    if item and lbom and rbom:
        partner = item.EngineeringView if item.is_mbom else item
        if not partner:
            return {"partners": [], "usages": [], "path": []}
        # partners contains also the old indexes of partner
        partners = items.Item.KeywordQuery(teilenummer=partner.teilenummer)

        usages = usages_tools.get_usages(partners, lbom, rbom)
        lpaths = mapping.mapped_paths(path, lbom)

        return {"partners": partners.cdb_object_id,
                "usages": usages,
                "paths": lpaths}
    else:
        raise util.ErrorMessage("cdbvp_elink_diffutils_item_not_available")


@router.json("part/:item_object_id/stringsearch")
def stringsearch(page, item_object_id):
    item = items.Item.ByKeys(cdb_object_id=item_object_id)
    if item:
        condition = page.get_form_data("condition", "")
        results, usages = search_in_bom(item, condition, item.GetDescription())

        return {"results": results, "usages": usages}


def _get_product(product_object_id):
    from cs.vp.products import Product
    product = Product.ByKeys(cdb_object_id=product_object_id)
    if product.CheckAccess('read'):
        return dict(cdb_object_id=product_object_id,
                    description=product.GetDescription(),
                    variantCount=_getProductVariantCount(product))


def custom_operation(opname, keys):
    keys_list = json.loads(keys)
    for key_dict in keys_list:
        cls = items.Item if "cdb_object_id" in key_dict else bom.AssemblyComponent
        obj = cls.ByKeys(**key_dict)
        op = cdbwrapc.Operation(opname, obj.ToObjectHandle(), SimpleArguments())
        op.run()


def _get_flat_bom(item):
    # returns sqlapi.Record instead of cdb.object.Object for performance reasons

    keys = ", ".join(["{table}" + fd.name
                      for fd in bom.AssemblyComponent.GetTableKeys()])

    _cte = """
    WITH flat_bom ({keys}) AS (
        SELECT {einzelteile_keys}
        FROM einzelteile
        WHERE baugruppe='{baugruppe}' AND b_index='{b_index}'
        UNION ALL
        SELECT {e_keys}
        FROM einzelteile e
        INNER JOIN flat_bom f
        ON f.teilenummer=e.baugruppe AND f.t_index=e.b_index
    )
    """
    cte = _cte.format(baugruppe=item.teilenummer, b_index=item.t_index,
                      keys=keys.format(table=""),
                      einzelteile_keys=keys.format(table="einzelteile."),
                      e_keys=keys.format(table="e."))

    stmt = cte + "SELECT * FROM flat_bom"
    flat_bom = sqlapi.RecordSet2(sql=stmt)

    stmt = cte + """
    SELECT *
    FROM teile_stamm
    WHERE EXISTS (
        SELECT 42 FROM flat_bom
        WHERE flat_bom.teilenummer=teile_stamm.teilenummer
        AND flat_bom.t_index=teile_stamm.t_index
    )
    """
    comp_items = {(comp_item.teilenummer, comp_item.t_index): comp_item
                  for comp_item in sqlapi.RecordSet2(sql=stmt)}
    return flat_bom, comp_items


def search_in_bom(item, condition, description):
    results = []
    bom_node_tag = get_bomnode_tag()

    # Check condition
    if condition.lower() in description.lower():
        results.append(item.GetRecord())

    part_attributes = [fd.name for fd in items.Item.GetTableKeys()]
    for comp in bomqueries.flat_bom(item, part_attributes=part_attributes):
        description = bom_node_tag % _BomItemAttributeAccessor(comp, comp)
        if condition.lower() in description.lower():
            results.append(comp)

    found_items = items.Item.FromRecords(set(results))
    usages = set()
    if found_items:
        for _results in misc._chunked(found_items):
            usages.update(usages_tools.get_usages(_results, item))

    return _to_json(results, bom.AssemblyComponent), list(usages)


@router.json("part/:item_object_id/:lbom_object_id/:rbom_object_id/find_differences")
@router.json("part/:item_object_id/:lbom_object_id/:rbom_object_id/:product_object_id/find_differences")
def find_differences_json(page, item_object_id, lbom_object_id, rbom_object_id, product_object_id=None):
    item, lbom, rbom = [items.Item.ByKeys(cdb_object_id=oid)
                        for oid in [item_object_id, lbom_object_id, rbom_object_id]]

    # Build variant filter
    variant_id = page.get_form_data("variant_id", None)
    signature = page.get_form_data("signature", None)

    bomfilter = json.loads(page.get_form_data("filter") or "{}")
    if not bomfilter:
        bomfilter = None

    if product_object_id and variant_id:
        variant_filter = vfilter.VariantBOMFilter(product_object_id, variant_id)
    elif product_object_id and signature:
        variant_filter = vfilter.VirtualVariantBOMFilter(product_object_id, signature)
    else:
        variant_filter = None

    diffs = differences.find_differences(
        item, lbom, rbom, product_object_id=product_object_id,
        variant_filter=variant_filter, bomfilter=bomfilter, bomfilter_func=differences.bomfilter_func
    )
    left = []
    right = []
    for path, side in diffs:
        if side == "left":
            left.append(_to_json(path, bom.AssemblyComponent))
        else:
            right.append(_to_json(path, bom.AssemblyComponent))
    return {"left": left, "right": right}


@router.json("part/:context_teilenummer/:teilenummer/ignore")
@router.json("part/:context_teilenummer/:teilenummer/:difference/ignore")
def ignore_difference(page, context_teilenummer, teilenummer, difference=''):
    from cs.vp.bom.diffutil import IgnoredDifferences

    diff = IgnoredDifferences.ByKeys(context_teilenummer=context_teilenummer,
                                     teilenummer=teilenummer)
    if diff:
        diff.ignored_difference = difference
    else:
        IgnoredDifferences.Create(context_teilenummer=context_teilenummer,
                                  teilenummer=teilenummer,
                                  ignored_difference=difference)

    if difference == '':
        result = util.get_label("cdbvp_diffutil_ignored_item")
    else:
        result = util.get_label("cdbvp_diffutil_ignored_difference")
    return {"ignored": result}


@router.json("part/:context_teilenummer/:teilenummer/delete_ignore")
def ignore_difference(page, context_teilenummer, teilenummer, difference=''):
    from cs.vp.bom.diffutil import IgnoredDifferences

    diff = IgnoredDifferences.ByKeys(context_teilenummer=context_teilenummer,
                                     teilenummer=teilenummer)
    if diff:
        diff.Delete()

    return {"ignored": ""}


@router.json("part/:opname/:context/operation_url")
def get_operation_url(page, opname, context):
    if context == "item":
        oid = page.get_form_data('cdb_object_id')
        obj = items.Item.ByKeys(cdb_object_id=oid)
    elif context == "bom":
        keys = {"baugruppe": page.get_form_data('baugruppe'),
                "b_index": page.get_form_data('b_index'),
                "teilenummer": page.get_form_data('teilenummer'),
                "t_index": page.get_form_data('t_index'),
                "position": page.get_form_data('position'),
                "variante": page.get_form_data('variante'),
                "auswahlmenge": page.get_form_data('auswahlmenge')}
        obj = bom.AssemblyComponent.ByKeys(**keys)

    if obj:
        return obj.MakeURL(opname)


# -- help functions -----------------------------------------------------------

def _getProductVariantInfo(page, product):
    result = []
    paginator_page_startIdx = int(page.get_form_data("startIdx", None))
    paginator_page_size = int(page.get_form_data("pageSize", None))
    if paginator_page_size > 0:
        paginator_page = paginator_page_startIdx / paginator_page_size
    search_str = page.get_form_data("searchStr", "").lower()
    maxbomview = product.MaxBOMView if product.MaxBOMView else product
    InfoTxtlocalizedFieldName = variants.Variant.InfoTxt[''].name
    _variants = maxbomview.Variants.Query("LOWER({field}) LIKE '%{searchstr}%'"
                                          " OR LOWER(name) LIKE '%{searchstr}%'".format(field=InfoTxtlocalizedFieldName,
                                                                                        searchstr=sqlapi.quote(search_str)),
                                          order_by=variants.Variant.id)
    table_page = []
    try:
        table_page = paginated(_variants,
                               pagesize=paginator_page_size,
                               startpage=paginator_page).next()
    except (TypeError, StopIteration):
        table_page_idx = 0
        for p in paginated(_variants,
                           pagesize=paginator_page_size):
            if table_page_idx == paginator_page:
                table_page = p
                break
            table_page_idx += 1
    for variant in table_page:
        args = {"product_object_id": variant.product_object_id,
                "vid": variant.id,
                "name": variant.name,
                "info": variant.InfoTxt[''],
                "description": variant.GetDescription()}
        args.update({pv.id: pv.EnumValue.ValueText[""]
                     for pv in variant.PropertyValues})
        result.append(args)
    result_dict = dict(results=result)
    return result_dict


def _getProductVariantCount(product, searchstr=""):
    maxbomview = product.MaxBOMView if product.MaxBOMView else product
    InfoTxtlocalizedFieldName = variants.Variant.InfoTxt[''].name
    _variants = maxbomview.Variants.Query("LOWER({field}) LIKE '%{searchstr}%'"
                                          " OR LOWER(name) LIKE '%{searchstr}%'".format(field=InfoTxtlocalizedFieldName,
                                                                                        searchstr=sqlapi.quote(searchstr.lower())))
    return len(_variants)


def _to_json(collection, clazz=None):
    pkeys = None
    if clazz is not None:
        pkeys = clazz.GetTablePKeys()

    result = []
    for obj in collection:
        result.append({
            fd.name: unicode(getattr(obj, fd.name))
            for fd in pkeys or obj.GetTablePKeys()
            if hasattr(obj, fd.name)
        })

    return result


def _get_preview_doc(item, modus):
    rulename = PREVIEW_2D_RULE if modus == "2D" else PREVIEW_3D_RULE
    rule = Rule.ByKeys(rulename)
    if rule:
        doc = None
        for _doc in item.Documents:
            if rule.match(_doc):
                doc = _doc
                break
        return doc


def _get_preview_url(base_uri, doc):
    from cdb.apps import preview
    preview_app = preview._getapp()

    pic = doc.GetPreviewFile()
    if pic:
        return u"%spic?cdb_file_id=%s" % (
            preview_app.getModuleURL(),
            pic.cdb_object_id
        )
    return u""


def _run(operation, cls_or_obj, **args):
    if isinstance(cls_or_obj, Object):
        cls_or_obj = cls_or_obj.ToObjectHandle()

    op = cdbwrapc.Operation(operation,
                            cls_or_obj,
                            mom.SimpleArguments(**args))
    op.run()

    result = op.getObjectResult()
    return result


def _fp(value):  # Format a Parameter for an sql query
    if value is None:
        return ''
    return sqlapi.quote(value)


# -- Operation plugins --------------------------------------------------------

_PLUGINS = []


def register_operation(operation):
    """ Register a plugin for an operation in the mBOM Manager

        :param operation: a dictionary with the following keys
            - name            name of cdb operation
                              ordered descending
            - needsReload     flag for reloading of page (optional) (default True)
            - unselect        flag if object should be unselected after executing
                              of operation (optional) (default False)
            - is_ebom_op      a flag to determine if operation is for eBOM or mBOM
            - is_item_op      a flag to determine if operation is for item or bom
            - multi_select_op a flag to determine if operation is available when multipe objects
                              are selected

        :type operation: dict
    """
    mandatory_keys = ["name", "is_ebom_op", "is_item_op"]
    if not set(mandatory_keys).issubset(set(operation)):
        raise Exception("Mandatory operation keys are missing (%s)" % mandatory_keys)
    operation.setdefault("needsReload", True)
    operation.setdefault("unselect", False)
    operation.setdefault("multi_select_op", False)
    _PLUGINS.append(operation)

# -- EBOM operation registers -------------------------------------------------

register_operation({"name": "CDB_ShowObject",
                    "needsReload": False,
                    "is_ebom_op": True,
                    "is_item_op": True})
register_operation({"name": "CDB_ProductStructure",
                    "needsReload": False,
                    "unselect": False,
                    "is_ebom_op": True,
                    "is_item_op": True})
register_operation({"name": "CDB_ProductUtilization",
                    "needsReload": False,
                    "is_ebom_op": True,
                    "is_item_op": True})
register_operation({"name": "CDB_ShowObject",
                    "needsReload": False,
                    "is_ebom_op": True,
                    "is_item_op": False})
register_operation({"name": "cdbvp_elink_diffutil",
                    "needsReload": False,
                    "is_ebom_op": True,
                    "is_item_op": True})

# -- MBOM operation registers -------------------------------------------------

register_operation({"name": "CDB_Modify",
                    "is_ebom_op": False,
                    "is_item_op": True})
register_operation({"name": "CDB_ShowObject",
                    "needsReload": False,
                    "is_ebom_op": False,
                    "is_item_op": True})
register_operation({"name": "CDB_ProductStructure",
                    "needsReload": False,
                    "is_ebom_op": False,
                    "is_item_op": True})
register_operation({"name": "CDB_ProductUtilization",
                    "needsReload": False,
                    "is_ebom_op": False,
                    "is_item_op": True})
register_operation({"name": "CDB_Workflow",
                    "is_ebom_op": False,
                    "is_item_op": True})
register_operation({"name": "cdbvp_diffutil_new_stl_position",
                    "is_ebom_op": False,
                    "is_item_op": True})
register_operation({"name": "CDB_Modify",
                    "is_ebom_op": False,
                    "is_item_op": False})
register_operation({"name": "CDB_ShowObject",
                    "needsReload": False,
                    "is_ebom_op": False,
                    "is_item_op": False})
register_operation({"name": "CDB_Delete",
                    "unselect": True,
                    "is_ebom_op": False,
                    "is_item_op": False,
                    "multi_select_op": True,
                    "dialog_text": "cdbvp_elink_diffutil_delete_objects",
                    "dlg_btns": {"ok": "cdbvp_elink_diffutil_dlg_yes",
                                 "cancel": "cdbvp_elink_diffutil_dlg_cancel"}})
register_operation({"name": "cdb_create_mbom_and_replace",
                    "is_ebom_op": False,
                    "is_item_op": False})
register_operation({"name": "cdbvp_elink_diffutil",
                    "needsReload": False,
                    "is_ebom_op": False,
                    "is_item_op": True})
