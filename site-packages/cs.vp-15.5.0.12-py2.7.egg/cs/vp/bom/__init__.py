# !/usr/bin/env powerscript
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 2013 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

__revision__ = "$Id: __init__.py 171229 2018-01-09 09:35:08Z gda $"


from cdb import sqlapi
from cdb import ue
from cdb import sig
from cdb import util
from cdb import constants
from cdb import cdbuuid
from cdb import kernel

from cdb.classbody import classbody

from cdb.objects import Object
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import ReferenceMethods_N
from cdb.objects import ReferenceMapping_N
from cdb.objects import Forward
from cdb.objects import ByID

from cs.vp.items import Item
from cs.tools.batchoperations import WithBatchOperations

AssemblyComponent = Forward(__name__ + ".AssemblyComponent")


def is_installed(module):
    try:
        __import__(module)
        return True
    except ImportError:
        return False


class AssemblyComponent(Object, WithBatchOperations):
    __maps_to__ = "einzelteile"
    __classname__ = "bom_item"

    Assembly = Reference_1(Item, AssemblyComponent.baugruppe, AssemblyComponent.b_index)

    Item = Reference_1(Item, AssemblyComponent.teilenummer, AssemblyComponent.t_index)

    def on_cdb_create_mbom_and_replace_pre_mask(self, ctx):

        # parent assembly must be a mbom
        if not self.Assembly.is_mbom:
            raise ue.Exception('cdb_replace_ebom_err', self.Assembly.GetDescription())

        # component must not be a mbom
        if self.Item.is_mbom:
            raise ue.Exception('cdb_create_mbom_on_mbom_err', self.Item.GetDescription())

        # check access
        if not self.CheckAccess("delete") or not self.CheckAccess("create"):
            raise ue.Exception("just_a_replacement", util.get_ac_check_msg())

        # Wenn es genau eine Fertigungssicht zum Teil gibt, diese vorbelegen.
        # Wenn es keine Fertigungsssicht gibt, das Auswahlfeld disablen.
        mboms = list(self.Item.ManufacturingViews)
        if len(mboms) == 1:
            ctx.set("mbom_selection", mboms[0].cdb_object_id)
        elif len(mboms) == 0:
            ctx.set_readonly('mbom_selection')

        # Wenn es gar keine Fertigungssicht gibt, auch nicht zu Vorversionen des Teils,
        # die Checkbox 'Neue Fertigungssicht erzeugen' aktivieren.
        oids = set(Item.KeywordQuery(teilenummer=self.Item.teilenummer).cdb_object_id)
        all_mboms = Item.Query("cdb_depends_on in (%s) and is_mbom=1" % ", ".join(["'%s'" % oid for oid in oids]))
        if len(all_mboms) == 0:
            ctx.set("create_new_mbom", "1")

        # Wenn es keine mbom Kandidaten zur Übernahme von älteren EBOM Ständen gibt, das Auswahlfeld disablen.
        take_over_candidates = set(all_mboms) - set(mboms)
        if len(take_over_candidates) == 0:
            ctx.set_fields_readonly(['mbom_carry_over'])

    def on_cdb_create_mbom_and_replace_post_mask(self, ctx):
        selected_mbom = None
        if ctx.dialog.mbom_selection:
            selected_mbom = ByID(ctx.dialog.mbom_selection)
        elif ctx.dialog.mbom_carry_over:
            selected_mbom = ByID(ctx.dialog.mbom_carry_over)

        if selected_mbom and not selected_mbom.is_mbom:
            raise ue.Exception('cdb_selected_item_is_not_a_mbom', selected_mbom.GetDescription())

        if not selected_mbom and ctx.dialog.create_new_mbom == "0":
            raise ue.Exception('cdb_create_mbom_and_replace_no_selection')

    def on_cdb_create_mbom_and_replace_now(self, ctx):
        """
        Replaces the EBOM at the current BOM position (self)
        by the selected MBOM (ctx.dialog.mbom_selection) or by a newly created MBOM
        if the user has not selected a MBOM.
        """
        if ctx.dialog.mbom_selection:
            # Replace by selected existing MBOM
            selected_mbom_item = ByID(ctx.dialog.mbom_selection)
            self.teilenummer = selected_mbom_item.teilenummer
            self.t_index = selected_mbom_item.t_index
        elif ctx.dialog.mbom_carry_over:
            # Create a new MBOM from selected MBOM
            # Note that BOM Position is modified by the
            # Item index post UE (see _handle_mbom_replace_bom_item)
            args = {"cdb::argument.mbom_selection": ctx.dialog.mbom_carry_over,
                    "cdb::argument.mbom_replace_bom_item_id": self.ID()}
            ctx.url(self.Item.MakeURL("cdb_create_mbom_from_mbom", **args))
        elif ctx.dialog.create_new_mbom == "1":
            # Create a new MBOM from EBOM.
            # Note that BOM Position is modified by the
            # Item create post UE (see _handle_mbom_replace_bom_item)
            args = {"cdb::argument.mbom_replace_bom_item_id": self.ID()}
            ctx.url(self.Item.MakeURL("cdb_create_mbom", **args))
        else:
            raise ue.Exception('cdb_create_mbom_and_replace_no_selection')

    def on_cdb_create_mbom_and_replace_dialogitem_change(self, ctx):
        if ctx.changed_item == 'create_new_mbom':
            ctx.set("mbom_selection", "")
            ctx.set("mbom_carry_over", "")
        elif ctx.changed_item == 'mbom_selection':
            ctx.set("create_new_mbom", "0")
            ctx.set("mbom_carry_over", "")
        elif ctx.changed_item == 'mbom_carry_over':
            ctx.set("create_new_mbom", "0")
            ctx.set("mbom_selection", "")

    def make_mbom_mapping_tag(self, ctx):
        if not self.Assembly or not self.Assembly.is_mbom:
            obj = self.getPersistentObject()
            obj.mbom_mapping_tag = cdbuuid.create_uuid()

    event_map = {
        (("create", "copy"), "post"): "make_mbom_mapping_tag"
    }


@classbody
class Item(object):
    Usage = Reference_N(AssemblyComponent,
                        AssemblyComponent.teilenummer == Item.teilenummer,
                        AssemblyComponent.t_index == Item.t_index)

    Components = Reference_N(AssemblyComponent,
                             AssemblyComponent.baugruppe == Item.teilenummer,
                             AssemblyComponent.b_index == Item.t_index,
                             order_by=AssemblyComponent.position)

    ComponentsByPosition = ReferenceMapping_N(AssemblyComponent,
                                              AssemblyComponent.baugruppe == Item.teilenummer,
                                              AssemblyComponent.b_index == Item.t_index,
                                              indexed_by=AssemblyComponent.position,
                                              order_by=AssemblyComponent.position)

    def _getSubparts(self):
        """
        Method to get all parts which belong to the BOM of the current part

        :return: a list of part objects (1, n, none)
        """
        return [component.Item for component in self.Components]

    Subparts = ReferenceMethods_N(Item, _getSubparts)

    def _getAssembly(self):
        """
        Method to get the assemblies which contain the current part

        :return: a list of assemblies (1, n, none)
        """
        return [component.Assembly for component in self.Usage]

    Assemblies = ReferenceMethods_N(Item, _getAssembly)

    def resolveComponents(self, depth=0, result=None):
        """
        Resolves all Items of the product structure down to
        the given depth. Default depth 0 resolves the complete
        product structure.
        """
        if not result:
            result = []
        if self.isAssembly():
            for comp in self.Components:
                if comp.Item not in result:
                    result.append(comp.Item)
                    if (depth != 1) and comp.Item.isAssembly():
                        comp.Item.resolveComponents(depth - 1, result)
        return result

    def maxPosition(self):
        result = 0
        if self.isAssembly():
            t = sqlapi.SQLselect("max(position) from einzelteile where baugruppe = '%s' and b_index = '%s'"
                                 % (self.teilenummer, self.t_index))
            result = sqlapi.SQLinteger(t, 0, 0)
        return result

    def handle_mbom_replace_bom_item(self, ctx):
        """
        Replaces the item at bom position `mbom_replace_bom_item_id` by self, if
        operation is running in context of a cdb_create_mbom
        or cdb_create_mbom_from_mbom operation.
        """
        if "mbom_replace_bom_item_id" in ctx.sys_args.get_attribute_names():
            bom_item_id = ctx.sys_args["mbom_replace_bom_item_id"]
            bom_item = ByID(bom_item_id)
            bom_item.Update(teilenummer=self.teilenummer,
                            t_index=self.t_index)

    @sig.connect(Item, 'create', 'post')
    @sig.connect(Item, 'index', 'post')
    def _handle_mbom_replace_bom_item(self, ctx):
        self.handle_mbom_replace_bom_item(ctx)

    @sig.connect(Item, 'query_catalog', 'pre')
    def _handle_mbom_catalog(self, ctx):
        if ctx.catalog_name == "cdb_mbom_browser":
            item = Item.ByKeys(ctx.catalog_invoking_op_object.teilenummer, ctx.catalog_invoking_op_object.t_index)
            ctx.set("cdb_depends_on", item.cdb_object_id)

    @sig.connect(Item, 'query_catalog', 'pre')
    def _handle_mbom_carry_over_catalog(self, ctx):
        if ctx.catalog_name == "cdb_mbom_carry_over_browser":
            item = Item.ByKeys(ctx.catalog_invoking_op_object.teilenummer, ctx.catalog_invoking_op_object.t_index)
            oids = set(Item.KeywordQuery(teilenummer=item.teilenummer).cdb_object_id)
            oids.discard(item.cdb_object_id)
            if oids:
                ctx.set_additional_query_cond("cdb_depends_on in (%s)" % ", ".join(["'%s'" % oid for oid in oids]))
            else:
                ctx.set_additional_query_cond("cdb_depends_on = '-1'")

    @sig.connect(Item, 'delete', 'post')
    def _delete_ignored_differences(self, ctx):
        self.delete_ignored_differences(ctx)

    def delete_ignored_differences(self, ctx):
        if not Item.Query("teilenummer='%s' AND t_index!='%s'" % (self.teilenummer, self.t_index)):
            from cs.vp.bom import diffutil
            diffutil.IgnoredDifferences.KeywordQuery(context_teilenummer=self.teilenummer).Delete()

    def on_cdbvp_diffutil_new_stl_position_now(self, ctx):
        cmsg = AssemblyComponent.MakeCdbcmsg(constants.kOperationNew,  # @UndefinedVariable
                                             baugruppe=self.teilenummer,
                                             b_index=self.t_index)
        ctx.url(cmsg.get_url())


class Plantfilter(kernel.TableFilter):
    def execute(self, data, filter_info=None):
        if (filter_info and filter_info.getClassname() == "bom_item") or not filter_info:
            site_object_id = self.get_filter_id()

            colindex = {}
            for col in range(sqlapi.SQLcols(data)):
                name = sqlapi.SQLname(data, col)
                colindex[name] = col

            def get(name, row):
                return sqlapi.SQLstring(data, colindex[name], row)

            deletions = []
            for row in range(sqlapi.SQLrows(data)):

                item = Item.ByKeys(get("teilenummer", row), get("t_index", row))

                if item and item.site_object_id and item.site_object_id != site_object_id:
                    deletions.append(row)

            deletions.reverse()
            for x in deletions:
                ref = data.rowof(x)
                data.remove(ref)
