# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Collections of methods for efficiently querying a product structure.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: bomqueries.py 177876 2018-05-29 13:36:34Z gda $"

# Some imports
import collections
import operator
import sys

from cdb import sqlapi
from cdb import lru_cache
from cdb import objects

from cs.vp import bom
from cs.vp import items

# Exported objects
__all__ = [
    "complete_flat_bom",
    "flat_bom",
    "flat_bom_dict",
    "quantities",
    "get_components",
    "get_item_attr"
]


default_part_attributes = [
    "is_mbom",
    "cdb_depends_on",
    "materialnr_erp",
    "site_object_id"
]


def flat_bom(*roots, **kwargs):
    """ Return a RecordSet of all the bom positions present in the product
        structure of one of the roots. Computes the result efficiently
        making only one database query.

        :param positional arguments: instances of cs.vp.items.Item of which the flat boms
            have to be computed

        :param additional_condition: an sql condition which can be used
            to filter the result

        :param searched_item: If given, only the bom positions in the usages
            structure of searched_item are returned
        :type searched_item: cs.vp.items.Item

        :param variant_filter: if given the filter is applied and only
            the bom position in the filtered structure are navigated

        :param bomfilter: if given the filter is forwarded to bomfilter_func
            and applied and only the bom position in the filtered structure are navigated

        :param bomfilter_func: if given the function is called to apply the
            bomfilter

        :param part_attributes: Attributes from the relation teile_stamm, which have
            to be joined in the result.

        :returns: a record set containing all the bom position in the product
            structure of one of the given roots
    """
    bom_keys = [fd.name for fd in bom.AssemblyComponent.GetTableKeys()]
    part_keys = [fd.name for fd in items.Item.GetTableKeys()]
    keys = ", ".join(["{table}" + name for name in bom_keys])

    part_attributes = []
    part_attributes.extend(default_part_attributes)
    part_attributes.extend([
        attr for attr in kwargs.get("part_attributes", [])
        if attr in part_keys and attr not in bom_keys and attr not in part_attributes
    ])

    additional_condition = kwargs.get("additional_condition", "1=1")
    product_object_id = kwargs.get("product_object_id", None)
    variant_filter = kwargs.get("variant_filter", None)
    bomfilter = kwargs.get("bomfilter", None)
    bomfilter_func = kwargs.get("bomfilter_func", lambda a, b: True)

    if product_object_id is None and variant_filter is not None:
        product_object_id = variant_filter.product_object_id

    searched_item = kwargs.get("searched_item")

    bom_predicates_attr = ""
    if product_object_id is not None:
        bom_predicates_attr = """,
                (
                    CASE WHEN EXISTS (
                        SELECT 42
                        FROM cdbvp_bom_predicate bp
                        WHERE flat_bom.baugruppe=bp.baugruppe AND
                            flat_bom.b_index=bp.b_index AND
                            flat_bom.teilenummer=bp.teilenummer AND
                            flat_bom.variante=bp.variante AND
                            flat_bom.position=bp.position AND
                            bp.product_object_id='{product_object_id}'
                    )
                    THEN 1
                    ELSE 0
                    END
                ) has_bom_predicates
        """.format(product_object_id=product_object_id)

    if searched_item is not None:
        QUERYSTR = """
            WITH usages ({keys})
            AS (
                SELECT {einzelteile_keys}
                FROM einzelteile
                WHERE {items_condition}
                UNION ALL
                SELECT {einzelteile_keys}
                FROM einzelteile
                INNER JOIN usages
                ON einzelteile.teilenummer=usages.baugruppe AND einzelteile.t_index=usages.b_index
            ),
            flat_bom ({keys})
            AS (
                SELECT {einzelteile_keys}
                FROM einzelteile
                WHERE {root_condition}
                UNION ALL
                SELECT {einzelteile_keys}
                FROM einzelteile
                INNER JOIN flat_bom
                ON flat_bom.teilenummer=einzelteile.baugruppe AND
                    flat_bom.t_index=einzelteile.b_index
            )
            SELECT DISTINCT {flat_bom_keys},
                teile_stamm.cdb_object_id item_object_id,
                {part_attrs}
                {bom_predicates_attr}
            FROM flat_bom INNER JOIN teile_stamm
            ON flat_bom.teilenummer=teile_stamm.teilenummer
                AND flat_bom.t_index=teile_stamm.t_index
            WHERE {additional_condition}
            ORDER BY flat_bom.baugruppe, flat_bom.b_index, flat_bom.position
        """

        item_pkeys = [
            (x.teilenummer, x.t_index) for x in searched_item.ManufacturingViews
        ] + [(searched_item.teilenummer, searched_item.t_index)]
        if searched_item.EngineeringView:
            engview = searched_item.EngineeringView
            item_pkeys.append((engview.teilenummer, engview.t_index))

        items_condition = " OR ".join(["(teilenummer='%s' AND t_index='%s')" % key
                                       for key in item_pkeys])

        query = QUERYSTR.format(
            root_condition=make_root_condition(*roots),
            keys=keys.format(table=""),
            einzelteile_keys=keys.format(table="einzelteile."),
            flat_bom_keys=keys.format(table="flat_bom."),
            additional_condition=additional_condition,
            items_condition=items_condition,
            bom_predicates_attr=bom_predicates_attr,
            part_attrs=", ".join(["teile_stamm.%s" % attr for attr in part_attributes])
        )
    else:
        QUERYSTR = """
            WITH flat_bom ({keys})
            AS (
                SELECT {einzelteile_keys}
                FROM einzelteile
                WHERE {root_condition}
                UNION ALL
                SELECT {einzelteile_keys}
                FROM einzelteile
                INNER JOIN flat_bom
                ON flat_bom.teilenummer=einzelteile.baugruppe AND
                    flat_bom.t_index=einzelteile.b_index
            )
            SELECT DISTINCT {flat_bom_keys},
                teile_stamm.cdb_object_id item_object_id,
                {part_attrs}
                {bom_predicates_attr}
            FROM flat_bom INNER JOIN teile_stamm
            ON flat_bom.teilenummer=teile_stamm.teilenummer
                AND flat_bom.t_index=teile_stamm.t_index
            WHERE {additional_condition}
            ORDER BY flat_bom.baugruppe, flat_bom.b_index, flat_bom.position
        """
        query = QUERYSTR.format(
            root_condition=make_root_condition(*roots),
            keys=keys.format(table=""),
            einzelteile_keys=keys.format(table="einzelteile."),
            flat_bom_keys=keys.format(table="flat_bom."),
            additional_condition=additional_condition,
            bom_predicates_attr=bom_predicates_attr,
            part_attrs=", ".join(["teile_stamm.%s" % attr for attr in part_attributes])
        )

    result = sqlapi.RecordSet2(sql=query)

    if product_object_id is not None and variant_filter is not None:
        result = [
            comp
            for comp in result
            if not comp.has_bom_predicates or variant_filter.eval(
                baugruppe=comp.baugruppe,
                b_index=comp.b_index,
                teilenummer=comp.teilenummer,
                t_index=comp.t_index,
                variante=comp.variante,
                position=comp.position
            )
        ]

    if bomfilter is not None:
        result = [
            comp
            for comp in result
            if bomfilter_func(comp, bomfilter)
            ]

    return result


def flat_bom_dict(*roots, **kwargs):
    """ Same as flat_bom but returns a dictionary.
        The keys are of the form (teilenummer, t_index) and the values are
        the children of the given item in the product structure.
    """
    components = flat_bom(*roots, **kwargs)
    result = collections.defaultdict(list)
    for comp in components:
        result[(comp.baugruppe, comp.b_index)].append(comp)
    return result


# -----------------------------------------------------------------------------

def quantities(*roots, **kwargs):
    """ Computes for every part in the product structures of the roots the
        aggregated quantity.

        Uses a recursive query if variant_filter is not given, otherwise
        steps through the structures.

        :param roots: instances of cs.vp.items.Item of which the bom quantities
            have to be computed

        :param variant_filter: if given the filter is applied and only
            the bom position in the filtered structure are navigated

        :param bomfilter: if given the filter is forwarded to bomfilter_func
            and applied and only the bom position in the filtered structure are navigated

        :param bomfilter_func: if given the function is called to apply the
            bomfilter

        :returns: a record set containing all the bom position in the product
            structure of one of the given roots
    """
    variant_filter = kwargs.get("variant_filter", None)
    bomfilter = kwargs.get("bomfilter", None)
    bomfilter_func = kwargs.get("bomfilter_func", lambda a, b: True)

    if variant_filter is None and bomfilter is None:
        # Maximum BOM
        return _quantities_query(*roots)
    else:
        # 100% BOM

        quantities = collections.defaultdict(int)
        levels = collections.defaultdict(lambda: sys.maxint)

        for teilenummer, t_index, quantity, bom_level in \
            _quantity_recursive(roots, variant_filter, bomfilter=bomfilter,
                                bomfilter_func=bomfilter_func):
            quantities[(teilenummer, t_index)] += quantity
            levels[(teilenummer, t_index)] = min(
                levels[(teilenummer, t_index)], bom_level)

        return {
            (teilenummer, t_index): {
                "teilenummer": teilenummer,
                "t_index": t_index,
                "quantity": quantities[(teilenummer, t_index)],
                "bom_level": levels[(teilenummer, t_index)]
            } for teilenummer, t_index in quantities
        }


def _quantities_query(*roots):
    QUERYSTR = """
        WITH path_quantities (root_number, root_index, leaf_number,
           leaf_index, quantity, bom_level)
        AS (
            SELECT baugruppe, b_index, teilenummer, t_index,
               COALESCE(menge, 0), 1 bom_level
            FROM einzelteile
            WHERE {root_condition}
            UNION ALL
            SELECT p.root_number, p.root_index, e.teilenummer, e.t_index,
               COALESCE(e.menge, 0) * p.quantity, p.bom_level + 1
            FROM einzelteile e
            INNER JOIN path_quantities p
            ON p.leaf_number=e.baugruppe AND p.leaf_index=e.b_index
        ),
        parts (teilenummer, t_index, ebom_teilenummer, ebom_t_index, is_mbom)
        AS (
            SELECT mboms.teilenummer, mboms.t_index, eboms.teilenummer,
               eboms.t_index, mboms.is_mbom
            FROM teile_stamm mboms
                LEFT JOIN teile_stamm eboms
                ON eboms.cdb_object_id=mboms.cdb_depends_on
        )
        SELECT teilenummer, t_index,
               SUM(quantity) quantity,
               MIN(bom_level) bom_level
        FROM (
            SELECT
                COALESCE(ebom_teilenummer, leaf_number) teilenummer,
                COALESCE(ebom_t_index, leaf_index) t_index,
                quantity, bom_level
            FROM path_quantities
                INNER JOIN parts
                ON path_quantities.leaf_number=parts.teilenummer
                    AND path_quantities.leaf_index=parts.t_index
            WHERE {condition}
        ) x
        GROUP BY teilenummer, t_index
    """

    condition = " OR ".join([
        "(root_number='%s' AND root_index='%s')" % (root.teilenummer, root.t_index) for root in roots])
    query = QUERYSTR.format(
        root_condition=make_root_condition(*roots),
        condition=condition
    )

    rset = sqlapi.RecordSet2(sql=query)
    return {(r.teilenummer, r.t_index): r for r in rset}


def _quantity_recursive(roots, variant_filter, data=None, bomfilter=None, bomfilter_func=None):
    result = []

    if data is None:
        data = {}
        data["flat_bom"] = flat_bom_dict(*roots, variant_filter=variant_filter,
                                         bomfilter=bomfilter, bomfilter_func=bomfilter_func)

    components = reduce(operator.add, [
        data["flat_bom"][(root.teilenummer, root.t_index)]
        for root in roots
    ], [])

    for comp in components:
        menge = comp.menge if comp.menge else 0

        key = (comp.teilenummer, comp.t_index, menge, 1)
        if get_item_attr(comp, "is_mbom"):
            cdb_depends_on = get_item_attr(comp, "cdb_depends_on")
            if cdb_depends_on:
                engineering_view = items.Item.ByKeys(cdb_object_id=cdb_depends_on)
                if engineering_view:
                    key = (engineering_view.teilenummer,
                           engineering_view.t_index,
                           menge, 1)

        result.append(key)

    for comp in components:
        menge = comp.menge if comp.menge else 0
        result.extend([
            (leaf_number, leaf_index, menge * quantity, bom_level + 1)
            for leaf_number, leaf_index, quantity, bom_level
            in _quantity_recursive([comp], variant_filter, data, bomfilter, bomfilter_func)
        ])

    return result


# -----------------------------------------------------------------------------

@lru_cache.lru_cache()
def complete_flat_bom(*roots, **kwargs):
    """
    Return a dictionary containg the flat boms of **all** the assemblies in
    the product structure of the roots.

    The keys have the form:

        (assembly_nr, assembly_idx)

    The values are lists of Records, containing the flat bom.

    :param positional arguments: instances of cs.vp.items.Item of which the flat boms
        have to be computed

    :param additional_condition: an sql condition which can be used
        to filter the result
    """

    result = collections.defaultdict(list)

    keys = ", ".join(["{table}" + fd.name
                      for fd in bom.AssemblyComponent.GetTableKeys()])

    additional_condition = kwargs.get("additional_condition", "1=1")

#            SELECT flat_bom.assembly_nr, flat_bom.assembly_idx, {einzelteile_keys}
    QUERYSTR = """
        WITH flat_bom (assembly_nr, assembly_idx, {keys})
        AS (
            SELECT einzelteile.baugruppe, einzelteile.b_index, {einzelteile_keys}
            FROM einzelteile
            WHERE {root_condition}
            UNION ALL
            SELECT einzelteile.baugruppe, einzelteile.b_index, {einzelteile_keys}
            FROM einzelteile
            INNER JOIN flat_bom
            ON flat_bom.teilenummer=einzelteile.baugruppe AND
                flat_bom.t_index=einzelteile.b_index
            UNION ALL
            SELECT flat_bom.assembly_nr, flat_bom.assembly_idx, {einzelteile_keys}
            FROM einzelteile
            INNER JOIN flat_bom
            ON flat_bom.teilenummer=einzelteile.baugruppe AND
                flat_bom.t_index=einzelteile.b_index
        )
        SELECT DISTINCT flat_bom.assembly_nr, flat_bom.assembly_idx,
            {flat_bom_keys},
            teile_stamm.cdb_object_id item_object_id,
            teile_stamm.is_mbom,
            teile_stamm.cdb_depends_on
        FROM flat_bom INNER JOIN teile_stamm
        ON flat_bom.teilenummer=teile_stamm.teilenummer
            AND flat_bom.t_index=teile_stamm.t_index
        WHERE {additional_condition}
        ORDER BY baugruppe, b_index, position
    """
    query = QUERYSTR.format(root_condition=make_root_condition(*roots),
                            keys=keys.format(table=""),
                            einzelteile_keys=keys.format(table="einzelteile."),
                            flat_bom_keys=keys.format(table="flat_bom."),
                            additional_condition=additional_condition
                            )

    for r in sqlapi.RecordSet2(sql=query):
        result[(r.assembly_nr, r.assembly_idx)].append(r)

    return result


# -----------------------------------------------------------------------------

@lru_cache.lru_cache()
def get_components(item_or_component, searched_item=None, make_object=True):
    """
    Given an item or a bom position return a list of its bom positions.
    Some part attributes can be accessed efficiently from the result of this
    method using the method ``get_item_attr``.

    :param item_or_component: an item or a bom position. It can be an instance
        of ``cdb.objects.Object`` or of ``cdb.sqlapi.Record``

    :param searched_item: If specified only the bom positions in the usages
        structure of searched_item are returned. Must be an instance of
        ``cdb.objects.Object``

    :param make_object: if true instances of ``cdb.objects.Object`` are returned,
        otherwise instances of ``cdb.sqlapi.Record`` are returned.
        Setting it to ``False`` will give better performance.
    """
    if searched_item is not None:
        QUERYSTR = """
        WITH usages (baugruppe, b_index, teilenummer, t_index)
        AS (
            SELECT baugruppe, b_index, teilenummer, t_index
            FROM einzelteile
            WHERE {items_condition}
            UNION ALL
            SELECT e.baugruppe, e.b_index, e.teilenummer, e.t_index
            FROM einzelteile e
            INNER JOIN usages u
            ON e.teilenummer=u.baugruppe AND e.t_index=u.b_index
        )
        SELECT einzelteile.*,
          teile_stamm.cdb_object_id item_object_id,
          teile_stamm.is_mbom,
          teile_stamm.cdb_depends_on
        FROM einzelteile INNER JOIN teile_stamm
        ON einzelteile.teilenummer=teile_stamm.teilenummer
          AND einzelteile.t_index=teile_stamm.t_index
        WHERE einzelteile.baugruppe='{teilenummer}' AND einzelteile.b_index='{t_index}'
        AND EXISTS (
            SELECT 42 FROM usages
            WHERE usages.teilenummer=einzelteile.teilenummer
                AND usages.t_index=einzelteile.t_index
        )
        ORDER BY einzelteile.position
        """

        keys = [(x.teilenummer, x.t_index) for x in searched_item.ManufacturingViews] + \
            [(searched_item.teilenummer, searched_item.t_index)]
        if searched_item.EngineeringView:
            engview = searched_item.EngineeringView
            keys.append((engview.teilenummer, engview.t_index))

        items_condition = " OR ".join(["(teilenummer='%s' AND t_index='%s')" % key
                                       for key in keys])

        stmt = QUERYSTR.format(teilenummer=item_or_component.teilenummer,
                               t_index=item_or_component.t_index,
                               items_condition=items_condition)
    else:
        stmt = """
        SELECT einzelteile.*,
          teile_stamm.cdb_object_id item_object_id,
          teile_stamm.is_mbom,
          teile_stamm.cdb_depends_on
        FROM einzelteile INNER JOIN teile_stamm
        ON einzelteile.teilenummer=teile_stamm.teilenummer
          AND einzelteile.t_index=teile_stamm.t_index
        WHERE einzelteile.baugruppe='{teilenummer}' AND einzelteile.b_index='{t_index}'
        ORDER BY einzelteile.position
        """.format(teilenummer=item_or_component.teilenummer, t_index=item_or_component.t_index)

    if make_object:
        return bom.AssemblyComponent.SQL(stmt)
    else:
        return sqlapi.RecordSet2(sql=stmt)


# -- utils --------------------------------------------------------------------

def get_item_attr(comp, attr):
    """ Retrieves a part attribute from the bom position.

        If the bom position has been constructed using get_components,
        it retrieves the attributes item_object_id, is_mbom and cdb_depends_on
        efficiently.
    """
    try:
        if isinstance(comp, objects.Object):
            r = comp.GetRecord()
        elif isinstance(comp, sqlapi.Record):
            r = comp
        return getattr(r, attr)
    except AttributeError:
        item = comp.Item
        if item:
            if attr == "item_object_id":
                attr = "cdb_object_id"
            return getattr(item, attr)


def make_root_condition(*roots):
    return " OR ".join([
        "(baugruppe='{number}' AND b_index='{index}')"
        .format(number=root.teilenummer, index=root.t_index)
        for root in roots
    ])


_BOM_KEYS = None


def _cmp_bom_item(lhs, rhs):
    global _BOM_KEYS
    if _BOM_KEYS is None:
        _BOM_KEYS = bom.AssemblyComponent.GetTablePKeys()

    keys = [fd.name for fd in _BOM_KEYS]
    return all((getattr(lhs, key) == getattr(rhs, key) for key in keys))
