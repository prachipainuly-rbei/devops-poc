# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2017 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Module make_mbom_mapping_tag

This is the documentation for the make_mbom_mapping_tag module.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: make_mbom_mapping_tag.py 179433 2018-06-22 08:51:06Z gda $"


# Some imports
import argparse
import collections
import operator

from cdb import sqlapi
from cdb import objects
from cdb import lru_cache
from cdb import cdbuuid

from cs.vp import bom
from cs.vp import items


def compute_mapped_pairs(litem, ritem, item=None):
    if item is not None:
        QUERYSTR = """
            WITH usages (baugruppe, b_index, teilenummer, t_index)
            AS (
                SELECT baugruppe, b_index, teilenummer, t_index
                FROM einzelteile
                WHERE {items_condition}
                UNION ALL
                SELECT e.baugruppe, e.b_index, e.teilenummer, e.t_index
                FROM einzelteile e
                INNER JOIN usages u
                ON e.teilenummer=u.baugruppe AND e.t_index=u.b_index
            ),
            numbers (teilenummer, t_index) AS (
                SELECT teilenummer, t_index
                FROM usages
                WHERE (baugruppe='{l_number}' AND b_index='{l_index}')
                    OR (baugruppe='{r_number}' AND b_index='{r_index}')
                UNION ALL
                SELECT e.teilenummer, e.t_index
                FROM usages e
                INNER JOIN numbers i
                ON i.teilenummer=e.baugruppe AND i.t_index=e.b_index
            ),
            parts (teilenummer, t_index, cdb_object_id, cdb_depends_on) AS (
                SELECT numbers.teilenummer, numbers.t_index,
                    teile_stamm.cdb_object_id, teile_stamm.cdb_depends_on
                FROM numbers LEFT JOIN teile_stamm
                ON numbers.teilenummer=teile_stamm.teilenummer
                    AND numbers.t_index=teile_stamm.t_index
            )
            SELECT DISTINCT lhs.teilenummer lhs_nr, lhs.t_index lhs_idx,
                rhs.teilenummer rhs_nr, rhs.t_index rhs_idx
            FROM parts lhs INNER JOIN parts rhs
            ON rhs.cdb_depends_on=lhs.cdb_object_id
        """

        keys = [(x.teilenummer, x.t_index) for x in item.ManufacturingViews] + \
            [(item.teilenummer, item.t_index)]
        if item.EngineeringView:
            engview = item.EngineeringView
            keys.append((engview.teilenummer, engview.t_index))

        items_condition = " OR ".join(["(teilenummer='%s' AND t_index='%s')" % key
                                       for key in keys])

        query = QUERYSTR.format(l_number=litem.teilenummer,
                                l_index=litem.t_index,
                                r_number=ritem.teilenummer,
                                r_index=ritem.t_index,
                                items_condition=items_condition)
    else:
        QUERYSTR = """
            WITH numbers (teilenummer, t_index) AS (
                SELECT teilenummer, t_index
                FROM einzelteile
                WHERE (baugruppe='{l_number}' AND b_index='{l_index}')
                    OR (baugruppe='{r_number}' AND b_index='{r_index}')
                UNION ALL
                SELECT e.teilenummer, e.t_index
                FROM einzelteile e
                INNER JOIN numbers i
                ON i.teilenummer=e.baugruppe AND i.t_index=e.b_index
            ),
            parts (teilenummer, t_index, cdb_object_id, cdb_depends_on) AS (
                SELECT numbers.teilenummer, numbers.t_index,
                    teile_stamm.cdb_object_id, teile_stamm.cdb_depends_on
                FROM numbers LEFT JOIN teile_stamm
                ON numbers.teilenummer=teile_stamm.teilenummer
                    AND numbers.t_index=teile_stamm.t_index
            )
            SELECT DISTINCT lhs.teilenummer lhs_nr, lhs.t_index lhs_idx,
                rhs.teilenummer rhs_nr, rhs.t_index rhs_idx
            FROM parts lhs INNER JOIN parts rhs
            ON rhs.cdb_depends_on=lhs.cdb_object_id
        """

        query = QUERYSTR.format(l_number=litem.teilenummer,
                                l_index=litem.t_index,
                                r_number=ritem.teilenummer,
                                r_index=ritem.t_index)

    rs = sqlapi.RecordSet2(sql=query)

    mapping = collections.defaultdict(list)
    for r in rs:
        mapping[(r.lhs_nr, r.lhs_idx)].append((r.rhs_nr, r.rhs_idx))

    return mapping


@lru_cache.lru_cache()
def _get_components(item_or_component, searched_item=None, make_object=True):
    if searched_item is not None:
        QUERYSTR = """
        WITH usages (baugruppe, b_index, teilenummer, t_index)
        AS (
            SELECT baugruppe, b_index, teilenummer, t_index
            FROM einzelteile
            WHERE {items_condition}
            UNION ALL
            SELECT e.baugruppe, e.b_index, e.teilenummer, e.t_index
            FROM einzelteile e
            INNER JOIN usages u
            ON e.teilenummer=u.baugruppe AND e.t_index=u.b_index
        )
        SELECT einzelteile.*,
          teile_stamm.cdb_object_id item_object_id,
          teile_stamm.is_mbom,
          teile_stamm.cdb_depends_on
        FROM einzelteile INNER JOIN teile_stamm
        ON einzelteile.teilenummer=teile_stamm.teilenummer
          AND einzelteile.t_index=teile_stamm.t_index
        WHERE einzelteile.baugruppe='{teilenummer}' AND einzelteile.b_index='{t_index}'
        AND EXISTS (
            SELECT 42 FROM usages
            WHERE usages.teilenummer=einzelteile.teilenummer
                AND usages.t_index=einzelteile.t_index
        )
        ORDER BY einzelteile.position
        """

        keys = [(x.teilenummer, x.t_index) for x in searched_item.ManufacturingViews] + \
            [(searched_item.teilenummer, searched_item.t_index)]
        if searched_item.EngineeringView:
            engview = searched_item.EngineeringView
            keys.append((engview.teilenummer, engview.t_index))

        items_condition = " OR ".join(["(teilenummer='%s' AND t_index='%s')" % key
                                       for key in keys])

        stmt = QUERYSTR.format(teilenummer=item_or_component.teilenummer,
                               t_index=item_or_component.t_index,
                               items_condition=items_condition)
    else:
        stmt = """
        SELECT einzelteile.*,
          teile_stamm.cdb_object_id item_object_id,
          teile_stamm.is_mbom,
          teile_stamm.cdb_depends_on
        FROM einzelteile INNER JOIN teile_stamm
        ON einzelteile.teilenummer=teile_stamm.teilenummer
          AND einzelteile.t_index=teile_stamm.t_index
        WHERE einzelteile.baugruppe='{teilenummer}' AND einzelteile.b_index='{t_index}'
        ORDER BY einzelteile.position
        """.format(teilenummer=item_or_component.teilenummer, t_index=item_or_component.t_index)

    if make_object:
        return bom.AssemblyComponent.SQL(stmt)
    else:
        return sqlapi.RecordSet2(sql=stmt)


def _get_item_attr(comp, attr):
    try:
        if isinstance(comp, objects.Object):
            r = comp.GetRecord()
        elif isinstance(comp, sqlapi.Record):
            r = comp
        return getattr(r, attr)
    except AttributeError:
        item = comp.Item
        if item:
            if attr == "item_object_id":
                attr = "cdb_object_id"
            return getattr(item, attr)


def compute_mapping(litem, ritem, mapped_pairs=None, searched_item=None):
    """ Compute a mapping between the assembly components of litem and ritem.
        The mappings are returned in form of paths starting respectively
        from litem or ritem.

        This function will recurse into those mbom assemblies which do not
        have an ebom counterpart. Therefore the paths can have length > 1.
    """
    if mapped_pairs is None:
        mapped_pairs = compute_mapped_pairs(litem, ritem, searched_item)

    mapping = collections.defaultdict(list)

    # Build a list of the components on the left and on the right.
    # On the right navigate into pure mboms assemblies

    # resolve the pure mboms assemblies on the right and return paths
    # to the components in it
    def _get_component_paths(item):
        result = []
        for _comp in _get_components(item, searched_item):
            is_mbom = _get_item_attr(_comp, "is_mbom")
            cdb_depends_on = _get_item_attr(_comp, "cdb_depends_on")
            if is_mbom and not cdb_depends_on:
                result.extend([[_comp] + path
                              for path in _get_component_paths(_comp.Item)])
            else:
                result.append([_comp])
        return result

    lcomps = collections.defaultdict(list)
    for _comp in _get_components(litem, searched_item):
        lcomps[(_comp.teilenummer, _comp.t_index)].append(_comp)

    rpaths = _get_component_paths(ritem)
    rcomps = collections.defaultdict(list)
    for _path in rpaths:
        _comp = _path[-1]
        rcomps[(_comp.teilenummer, _comp.t_index)].append(_path)

    def _cmp(lhs, rhs):
        # compares paths for sorting
        if lhs == [] and rhs == []:
            return 0
        elif lhs == []:
            # rhs != []
            return -1
        elif rhs == []:
            # lhs != []
            return 1
        elif lhs[0].position < rhs[0].position:
            return -1
        elif lhs[0].position > rhs[0].position:
            return 1
        else:
            # lhs and rhs are not empty and have the same first position number
            return _cmp(lhs[1:], rhs[1:])

    for teilenummer, t_index in lcomps:
        occurrences = lcomps[(teilenummer, t_index)]

        keys = mapped_pairs[(teilenummer, t_index)] + [(teilenummer, t_index)]
        counterparts = reduce(operator.add, [rcomps[key] for key in keys])
        counterparts.sort(cmp=_cmp)

        for occurrence, counterpart in zip(occurrences, counterparts):
            mapping[occurrence].append(counterpart)

            # recurse into mapped pair
            # this is necessary to be able find out the runmapped paths
            recurse_mapping, _, _ = compute_mapping(occurrence.Item, counterpart[-1].Item)
            mapping.update(recurse_mapping)

    lunmapped = [
        comp
        for comp in reduce(operator.add, lcomps.values(), [])
        if comp not in mapping.keys()
    ]
    runmapped = [path for path in rpaths if path not in mapping.values()]

    return (mapping, lunmapped, runmapped)


def make_mbom_mapping_tag(ebom, mbom, safe=True, verbose=False):
    mapping, lunmapped, runmapped = compute_mapping(ebom, mbom)

    def update_tag(obj, tag):
        if not safe or not obj.mbom_mapping_tag:
            if verbose:
                print "%s: Setting tag to %s" % (obj.GetDescription(), tag)
            obj.mbom_mapping_tag = tag

    for lcomp, rpaths in mapping.iteritems():
        if lcomp.mbom_mapping_tag is not None and lcomp.mbom_mapping_tag != '':
            mapping_tag = lcomp.mbom_mapping_tag
        else:
            mapping_tag = cdbuuid.create_uuid()
            update_tag(lcomp, mapping_tag)

        for rpath in rpaths:
            rcomp = rpath[-1]
            update_tag(rcomp, mapping_tag)

    for lcomp in lunmapped:
        update_tag(lcomp, cdbuuid.create_uuid())


# Guard importing as main module
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=(
            "Create a persistent mapping betweem EBOM und MBOM positions using "
            "a heuristic. CAUTION! This may produce a wrong result, always check "
            "the outcome."
        )
    )

    parser.add_argument(
        "ebom_nr", nargs="?", default="",
        help="Attribute 'teilenummer' of the ebom part. Necessary if you don't use --all."
    )
    parser.add_argument(
        "ebom_idx", nargs="?", default="",
        help="Attribute 't_index' of the ebom part"
    )
    parser.add_argument(
        "mbom_nr", nargs="?", default="",
        help="Attribute 'teilenummer' of the mbom part."
    )
    parser.add_argument(
        "mbom_idx", nargs="?", default="",
        help="Attribute 't_index' of the mbom part."
    )
    parser.add_argument(
        "--all", action="store_true",
        help="Create a mapping tag for every bom position in the system."
    )
    parser.add_argument(
        "--safe", action="store_true",
        help="Do not overwrite existing mapping."
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true",
        help="Do not overwrite existing mapping."
    )

    args = parser.parse_args()
    if args.all is True:
        print "Updating every bom position in the system. This may take a long time."

        # create mapping for every ebom
        eboms = items.Item.Query(items.Item.is_mbom != 1)
        for ebom in eboms:
            for mbom in ebom.ManufacturingViews:
                make_mbom_mapping_tag(ebom, mbom, args.safe, args.verbose)
    else:
        ebom = items.Item.ByKeys(teilenummer=args.ebom_nr, t_index=args.ebom_idx)
        if ebom is not None:
            if args.mbom_nr:
                mbom = items.Item.ByKeys(teilenummer=args.mbom_nr, t_index=args.mbom_idx)
                if mbom is not None:
                    make_mbom_mapping_tag(ebom, mbom, args.safe, args.verbose)
            else:
                for mbom in ebom.ManufacturingViews:
                    make_mbom_mapping_tag(ebom, mbom, args.safe, args.verbose)
