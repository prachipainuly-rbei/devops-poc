# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2016 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Compute a mapping between two product structures.
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: mapping.py 179977 2018-07-04 14:24:29Z gda $"

# Some imports
import collections

from cdb import sqlapi
from cdb import lru_cache

from cs.vp import bom
from cs.vp.bom import bomqueries

# Exported objects
__all__ = [
    "compute_mapping",
    "mapped_path"
]


# ----------------------------------------------------------------------------

@lru_cache.lru_cache()
def compute_mapping(litem, ritem, tagname="mbom_mapping_tag"):
    """ Compute a mapping between the assembly components of litem and ritem
        by comparing the device tag.
        The mapping is returned as a dictionary where keys have the format
            (baugruppe, b_index, teilenummer, t_index, position, variante, auswahlmenge)
        and values are lists of tuples with the same format.

        :return: (mapping, lunmapped, runmapped)
    """
    attrs = [
        "baugruppe", "b_index", "teilenummer", "t_index", "position",
        "variante", "auswahlmenge", "mbom_mapping_tag"
    ]
    keys = ", ".join(["{table}" + attr for attr in attrs])
    aliased_keys = ", ".join(["{table}" + attr + " {prefix}_" + attr for attr in attrs])

    # union of two queries because sqlite does not support
    # full outer joins
    QUERYSTR = """
        WITH lflat_bom ({keys}, lvl)
        AS (
            SELECT {einzelteile_keys}, 1 lvl
            FROM einzelteile
            WHERE (baugruppe='{lroot_number}' AND b_index='{lroot_index}')
            UNION ALL
            SELECT {einzelteile_keys}, (lvl + 1) lvl
            FROM einzelteile
            INNER JOIN lflat_bom
            ON lflat_bom.teilenummer=einzelteile.baugruppe AND
                lflat_bom.t_index=einzelteile.b_index
        ),
        rflat_bom ({keys}, lvl)
        AS (
            SELECT {einzelteile_keys}, 1 lvl
            FROM einzelteile
            WHERE (baugruppe='{rroot_number}' AND b_index='{rroot_index}')
            UNION ALL
            SELECT {einzelteile_keys}, (lvl + 1) lvl
            FROM einzelteile
            INNER JOIN rflat_bom
            ON rflat_bom.teilenummer=einzelteile.baugruppe AND
                rflat_bom.t_index=einzelteile.b_index
        )
        SELECT DISTINCT {lflat_bom_keys}, {rflat_bom_keys},
            CASE WHEN lfb.lvl < rfb.lvl THEN lfb.lvl
                 ELSE rfb.lvl
            END AS lvl
        FROM lflat_bom lfb LEFT OUTER JOIN rflat_bom rfb
        ON lfb.{tagname} = rfb.{tagname}
        UNION
        SELECT DISTINCT {lflat_bom_keys}, {rflat_bom_keys},
            CASE WHEN lfb.lvl < rfb.lvl THEN lfb.lvl
                 ELSE rfb.lvl
            END AS lvl
        FROM rflat_bom rfb LEFT OUTER JOIN lflat_bom lfb
        ON lfb.{tagname} = rfb.{tagname}
    """.format(
        lroot_number=sqlapi.quote(litem.teilenummer),
        lroot_index=sqlapi.quote(litem.t_index),
        rroot_number=sqlapi.quote(ritem.teilenummer),
        rroot_index=sqlapi.quote(ritem.t_index),
        keys=keys.format(table=""),
        einzelteile_keys=keys.format(table="einzelteile."),
        lflat_bom_keys=aliased_keys.format(table="lfb.", prefix="lfb"),
        rflat_bom_keys=aliased_keys.format(table="rfb.", prefix="rfb"),
        tagname=tagname
    )
    rs = sqlapi.RecordSet2(sql=QUERYSTR)

    lunmapped = []
    runmapped = []
    mapping = collections.defaultdict(set)
    for r in rs:
        entry = dict(r)
        level = entry["lvl"]
        lhs = (
            entry["lfb_baugruppe"], entry["lfb_b_index"],
            entry["lfb_teilenummer"], entry["lfb_t_index"],
            entry["lfb_position"], entry["lfb_variante"], entry["lfb_auswahlmenge"]
        )
        rhs = (
            entry["rfb_baugruppe"], entry["rfb_b_index"],
            entry["rfb_teilenummer"], entry["rfb_t_index"],
            entry["rfb_position"], entry["rfb_variante"], entry["rfb_auswahlmenge"]
        )
        if entry["lfb_teilenummer"] is None:
            runmapped.append((rhs, level))
        elif entry["rfb_teilenummer"] is None:
            lunmapped.append((lhs, level))
        else:
            mapping[lhs].add((rhs, level))
            mapping[rhs].add((lhs, level))

    return mapping, lunmapped, runmapped


# ----------------------------------------------------------------------------

# compute the flat bom for the rassembly
# find in the flat bom the position with the same mapping tag
# compute for this position all the paths to the rassembly
# find the path the corresponds to the lpath

def mapped_paths(lpath, rassembly, variant_filter=None, bomfilter=None, bomfilter_func=None):
    """
    Compute the correspondent path(s) to lpath inside rassembly

    :returns: a list of paths
    """
    result = []

    if lpath:
        lcomp = lpath[-1]
        tag = lcomp["mbom_mapping_tag"]
        materialnr_erp = bomqueries.get_item_attr(lcomp, "materialnr_erp")

        # compute the flat bom for the rassembly
        flat_bom_dict = bomqueries.flat_bom_dict(rassembly, variant_filter=variant_filter,
                                                 bomfilter=bomfilter, bomfilter_func=bomfilter_func)
        flat_bom = []

        def visit(teilenummer, t_index):
            components = flat_bom_dict[(teilenummer, t_index)]
            flat_bom.extend(components)
            for comp in components:
                visit(comp.teilenummer, comp.t_index)

        visit(rassembly.teilenummer, rassembly.t_index)

        usage_dict = collections.defaultdict(list)
        for comp in flat_bom:
            usage_dict[(comp.teilenummer, comp.t_index)].append(comp)

        def paths_to_rassembly(comp):
            result = []
            parents = usage_dict[(comp.baugruppe, comp.b_index)]

            if parents:
                for parent in parents:
                    for p in paths_to_rassembly(parent):
                        p.append(comp)
                        result.append(p)
            else:
                result.append([comp])

            return result

        # find in the flat bom the position with the same mapping tag
        # Theorem: all the paths starts with rassembly
        paths = []
        for comp in flat_bom:
            if (
                bomqueries.get_item_attr(comp, "materialnr_erp") == materialnr_erp and
                comp["mbom_mapping_tag"] == tag
            ):
                # compute for this position all the paths to the rassembly
                paths.extend([
                    # [dict(rassembly)] + path for path in paths_to_rassembly(comp)
                    [rassembly] + path for path in paths_to_rassembly(comp)
                ])

        # find the path the corresponds to the lpath
        # HEURISTIC: we'll take the path which has the biggest intersection
        # with lpath
        def tags(path):
            def make_tag(x):
                return (bomqueries.get_item_attr(x, "materialnr_erp"), getattr(x, "mbom_mapping_tag", ""))

            return set(map(make_tag, path))

        spaths = sorted(paths, key=lambda path: (-1) * len(tags(path).intersection(tags(lpath))))
        result.extend(spaths)

    return result
