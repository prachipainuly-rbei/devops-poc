#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbHfor behave
# All rights reserved.
# http://www.contact.de/
#

import operator
import cdbwrapc
import sys
import time
import datetime
import os
import io
import re

from selenium import webdriver
from selenium.common.exceptions import WebDriverException

from cdb import sqlapi
from cdb import util
from cdb import CADDOK
from cdb.objects import org
from cdb.plattools import killableprocess
from cdb.uberserver import usutil
from cdb.uberserver.management import Management
from cdb.validationkit import generateUser
from cdb.validationkit.SwitchRoles import _switch_roles
from cdb.validationkit.util import login_webdriver, logout_webdriver, get_server_url


__docformat__ = "restructuredtext en"
__revision__ = "$Id: environment.py 182289 2018-08-15 11:40:49Z gda $"


TIMEOUT = 20
WEB_DRIVER_ROLES = {
    # Mapping: Gherkin tag <> CDB role
    "productmanager": ["public", "cs.vptests", "Product: Manager"],
    "engineering": ["public", "cs.vptests", "Engineering"]
}


def terminate_proc(proc_name=None, proc_id=None):
    """Kill a process by name or id after checking if it is running"""
    assert proc_name or proc_id, "Neither 'proc_name' nor 'proc_id' are passed."
    if sys.platform == "win32":
        if proc_name:
            query = ['/fi', 'IMAGENAME eq %s' % proc_name]
        elif proc_id:
            query = ['/fi', 'PID eq %s' % proc_id]
        output = killableprocess.check_output(
            ['tasklist',
             '/nh',  # don't display column headers
             '/fo', 'CSV']  # --> "MyApp.exe","4380","Console","1","395.604 K"
            + query)
        output = output.decode(sys.getfilesystemencoding())
        proc_ids = []
        for line in output.decode(sys.getfilesystemencoding()).split("\n"):
            line = line.replace("\r", "")
            if '"' in line:
                proc_ids.append(eval('[%s]' % line)[1])
        for id in proc_ids:
            killableprocess.call(['taskkill', '/f', '/t', '/pid', id])
    else:
        pass  # necessary ?


def ensure_running_service_daemon(context):
    """If a service daemon isn't already running, then a temporary one gets started"""
    svc = Management()
    if svc._check_if_its_up(usutil.UBERSERVER):
        context.temp_service_daemon = None
    else:
        svc.start()
        context.temp_service_daemon = svc


def terminate_temp_service_daemon(context):
    if context.temp_service_daemon:
        try:
            context.temp_service_daemon.shutdown()
        except Exception as ex:
            print ex
            if sys.platform == "win32":
                # workaround for shutdown method not functioning properly (on windows)
                killableprocess.call(['taskkill', '/f', '/t',
                                      '/pid', '%s' % context.temp_service_daemon.cdbsvcd.pid])


def setup_webdriver(context, browser="firefox"):
    try:
        if browser == "ie":
            driver = webdriver.Ie()
        elif browser == "chrome":
            driver = webdriver.Chrome()
        else:
            driver = webdriver.Firefox()
    except WebDriverException as ex:
        print "IEDriver not installed or in path? Using Firefox as fallback.\n%s" % ex
        driver = webdriver.Firefox()

    driver.implicitly_wait(TIMEOUT)
    context.webdriver = driver
    driver.maximize_window()

    context.webdriver_logged_in = login_webdriver(driver)


def get_platform_version():
    from cdb.comparch.packages import Package
    version = Package.ByKeys("cs.platform").version
    exp = re.compile("(?P<major>\d*)\.(?P<minor>\d*)\.(?P<sl>.*)")

    match = exp.match(version)
    if match is not None:
        return {
            group: int(match.group(group)) if not match.group(
                group).startswith('dev') else 999
            for group in ["major", "minor", "sl"]
        }


def switch_login_webdriver(context, username=None, password=''):
    logout_webdriver(context.webdriver)
    login_webdriver(context.webdriver, username, password)


class EventListener(util.DBEventListener):
    __listener = None

    def __init__(self):
        super(EventListener, self).__init__()
        self.__events = []

    def notify(self, relation, event):
        self.__events.append(
            (event.m_event,
             relation,
             event.m_keys.items()))

    def rollback(self):
        def generateWhere(relation, keys):
            table_info = util.TableInfo(relation)
            where = []
            for key, value in keys:
                where.append(
                    "%s=%s" % (key, sqlapi.make_literal(table_info, key, value))
                )
            return " AND ".join(where)

        try:
            self.doUnregister()
            self.__events.reverse()
            for t, relation, keys in self.__events:
                if t == util.kRecordInserted and relation != "cdb_global_subj":
                    sqlapi.SQLdelete("FROM %s where %s" % (relation,
                                     generateWhere(relation, keys)))
        finally:
            self.clear()
            self.doRegister()

    def clear(self):
        self.__events = []

    @classmethod
    def getListener(cls):
        if not EventListener.__listener:
            EventListener.__listener = EventListener()
        return EventListener.__listener


def before_scenario(context, scenario):
    listener = EventListener.getListener()
    listener.doRegister()

    tags = set(scenario.tags + scenario.feature.tags)
    driver_roles = reduce(lambda lhs, rhs: lhs.union(rhs),
                          [WEB_DRIVER_ROLES[tag]
                           for tag in WEB_DRIVER_ROLES
                           if tag in tags], set(["public"]))
    old_roles = getattr(context, "_old_roles") if hasattr(context, "_old_roles") else []
    if driver_roles != set(old_roles):
        _switch_roles(driver_roles)
        context._old_roles = driver_roles
        if hasattr(context, "webdriver"):
            switch_login_webdriver(context)


def after_step(context, step):
    if step.status == "failed" and hasattr(context, "webdriver"):
        driver = context.webdriver
        timestamp = datetime.datetime.now().toordinal()
        filename = "%s--line--%s--%s.png" % (context.scenario.name, str(step.line), timestamp)
        try:
            logdir = getattr(CADDOK, "LOGDIR")
        except KeyError:
            logdir = CADDOK.TMPDIR

        filepath = os.path.join(logdir, filename)
        print "saving screenshot to %s" % filepath
        try:
            driver.get_screenshot_as_file(filepath)
        except:
            print "cannot save screenshot!"

        filename = "%s--line--%s--%s.log" % (context.scenario.name, str(step.line), timestamp)
        filepath = os.path.join(logdir, filename.replace("?", ""))
        print "saving browser log to %s" % filepath
        log = [
            u"%(level)s %(message)s" % err
            for err in driver.get_log("browser")
        ]
        with io.open(filepath, "w") as f:
            f.write(u"\n".join(log))


def after_scenario(context, scenario):
    cleanup_after_scenario()
    listener = EventListener.getListener()
    listener.rollback()
    listener.doUnregister()


def cleanup_after_scenario():
    # Since the EventListener does not delete content created during a web
    # session, we need to delete it manually here
    from cs.vp import bom

    # Delete every assembly component created by behave_test
    for comp in bom.AssemblyComponent.KeywordQuery(cdb_cpersno="behave_test"):
        comp.VPMProperties.Delete()
        comp.VPMPredicates.Delete()
        comp.Delete()

    # Delete ignored differences
    from cs.vp import items
    from cs.vp.bom import diffutil
    for item in items.Item.KeywordQuery(cdb_cpersno="behave_test"):
        diffutil.IgnoredDifferences.KeywordQuery(teilenummer=item.teilenummer).Delete()
        item.Delete()

    # Delete products
    from cs.vp import products
    for product in products.Product.KeywordQuery(cdb_cpersno="behave_test"):
        product.Delete()


def before_all(context):
    util.init_counter("Organizations", "cdb_org", "org_id")

    # Create a new User to use for testing and login as this one
    users = org.User.KeywordQuery(personalnummer="behave_test")
    if len(users) > 0:
        context.user = users[0]
    else:
        context.user = generateUser("behave_test", force_pwdchange=0)

    # Remove all role assigments
    org.CommonRoleSubject.KeywordQuery(subject_id="behave_test").Query("role_id != 'public'").Delete()

    # Log him in
    assert cdbwrapc.set_user(context.user.personalnummer), \
        "The User couldn't be logged in"

    # run CDB server
    ensure_running_service_daemon(context)

    # setup webdriver
    context.server_url = get_server_url()
    if "--tags=nobrowser" not in sys.argv:
        setup_webdriver(context, browser="chrome")


def after_all(context):
    # Logout Elink Session
    if hasattr(context, "webdriver"):
        context.webdriver.get(context.server_url + "server/__quit__")
        context.webdriver.quit()

    # shutdown CDB server
    terminate_temp_service_daemon(context)

    # Delete the created user
    if hasattr(context, "user"):
        context.user.Delete()
        org.CommonRoleSubject.KeywordQuery(subject_id="behave_test").Delete()

    # workaround for eventually ophaned cdbsrv and selenium processes
    if sys.platform == "win32":
        terminate_proc("cdbsrv.exe")
