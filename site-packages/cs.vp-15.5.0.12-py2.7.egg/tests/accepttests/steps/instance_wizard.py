#!/usr/bin/env python
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# https://www.contact-software.com/
#

import common
import datetime
import math
import re
import time

from cdb.validationkit import given, when, then, operation, run_with_added_roles

from cs.vp.items import Item


@given("^a product with (?P<mbom_len>\d*?) (?P<maxbom>maxbom|indexed maxbom) and (?P<variant_len>\d*?) variant and "
       "(?P<instantiation_len>\d*?) instantiation for this variant exists$")
def step(context, mbom_len, maxbom, variant_len, instantiation_len):
    mbom_len = int(mbom_len)
    variant_len = int(variant_len)
    instantiation_len = int(instantiation_len)

    context.product = common.get_instance_wizard_test_product()
    assert len(
        context.product.Variants) >= variant_len, \
        "minimum product variants number doesn't matches the existing: need %d, but have %d" % (
            variant_len, len(context.product.Variants))
    context.variant = context.product.Variants[0]
    assert len(
        context.product.MaxBoms) >= mbom_len, \
        "minimum product mboms number doesn't matches the existing: need %d, but have %d" % (
            mbom_len, len(context.product.MaxBoms))

    if maxbom == "maxbom":
        context.maxbom = context.product.MaxBoms[0]
    else:
        context.maxbom = context.product.MaxBoms[1]

    context.instantiated_parts_len = len(common.get_instantiations_for_bom(context.maxbom))

    # create needed instantiations for the given variant if there aren't enough
    if context.instantiated_parts_len < instantiation_len:
        new_variant_instantiations = instantiation_len - context.instantiated_parts_len
        for _ in xrange(new_variant_instantiations):
            common.open_instance_wizard(context.webdriver, context.server_url, context.variant, context.maxbom)
            common.submit_instance_wizard(context.webdriver)
        context.instantiated_parts_len = len(common.get_instantiations_for_bom(context.maxbom))
    assert context.instantiated_parts_len >= instantiation_len, \
        "minimum instantiations number doesn't matches the existing: need %d, but have %d" % (
            1, context.instantiated_parts_len)

    context.item_len = len(Item.Query())
    time.sleep(1)  # database does only store seconds, so we have to wait
    context.start_date = datetime.datetime.now()


@given("^a product with an outdated maxbom and (?P<nvar>\d*) variants? exists$")
@run_with_added_roles(["Engineering", "Design Release", "Product: Manager"])
def step(context, nvar):
    nvar = int(nvar)

    context.product = common.generateProduct()
    context.maxbom = common.generateItem()
    context.instantiated_parts_len = 0
    context.start_date = datetime.datetime.now()

    # obsolete maxbom
    review = common.getStateName(context.maxbom.cdb_objektart, "Review")
    released = common.getStateName(context.maxbom.cdb_objektart, "Released")

    operation("CDB_Workflow", context.maxbom, user_input={"zielstatus": review})
    operation("CDB_Workflow", context.maxbom, user_input={"zielstatus": released})
    context.newindex = operation("CDB_Index", context.maxbom)
    operation("CDB_Workflow", context.newindex, user_input={"zielstatus": review})
    operation("CDB_Workflow", context.newindex, user_input={"zielstatus": released})

    context.maxbom.Reload()
    assert context.maxbom.status == 180

    # variants
    nprops = int(math.ceil(math.log(nvar, 2))) + 1
    for _ in range(nprops):
        common.generateProductProperty(context.product)
    context.variants = common.generateNVariants(context.product, nvar)
    context.variant = context.variants[0]


@given("^the user opens the instance wizard for variant 1$")
def step(context):
    common.open_instance_wizard(context.webdriver, context.server_url, context.variant, context.maxbom)


@when("^the user clicks on the button to instantiate the variant$")
def step(context):
    common.submit_instance_wizard(context.webdriver)


@when("^the user selects an existing article in the dropdown$")
def step(context):
    driver = context.webdriver
    open_dropdown = driver.find_element_by_css_selector("button.dropdown-toggle")
    open_dropdown.click()
    common.waitForAjax(driver)
    menu_entries = open_dropdown.find_element_by_xpath("..").find_element_by_tag_name("ul").find_elements_by_tag_name(
        "li")
    menu_entry = menu_entries[1]
    context.selected_part_description = menu_entry.find_element_by_tag_name("a").text
    menu_entry.find_element_by_tag_name("a").click()


@then("^a new instantiated variant exists using (?P<new>a new|an existing) article for the variable part$")
def step(context, new):
    use_existing = new == "an existing"
    new_items_count = 1
    if not use_existing:
        new_items_count = 2

    # check number of new variants
    assert context.instantiated_parts_len == len(
        common.get_instantiations_for_bom(context.maxbom)) - 1, "variant was not instantiated"

    # check newly instantiated variant for correct instantiation (cdb_copy_of_item_id)
    new_items = common.get_parts_since(context.start_date)
    new_items_len = len(new_items)
    assert new_items_len == new_items_count, "wrong amount of newly generated items. Should be %d, but was %d" % (
        new_items_count, new_items_len)


@then("^the maxbom is (?P<outcome>instantiated|not instantiated)$")
@then("^a new instantiated variant exists$")
def step(context, outcome=None):
    if outcome is None:
        outcome = "instantiated"

    if outcome == "instantiated":
        # check number of new variants
        assert context.instantiated_parts_len == len(
            common.get_instantiations_for_bom(context.maxbom)) - 1, "maxbom was not instantiated"
    elif outcome == "not instantiated":
        assert context.instantiated_parts_len == len(
            common.get_instantiations_for_bom(context.maxbom)), "maxbom was instantiated"


@when("^the user clicks on the table heading of the todo list$")
def step(ctx):
    driver = ctx.webdriver

    ctx.js_errors = [
        entry["message"] for entry in driver.get_log('browser')
    ]

    el = driver.find_element_by_css_selector(".todoList th")
    el.click()


@then("^no javascript error is produced$")
def step(ctx):
    driver = ctx.webdriver

    blacklist = []
    errors = [
        entry for entry in driver.get_log('browser')
        if entry["level"] == "SEVERE" and all(not b.search(entry["message"]) for b in blacklist)
        and entry["message"] not in ctx.js_errors
    ]
    assert len(errors) == 0, "there have been errors:\n%s" % "\n".join([
        entry["message"] for entry in errors
    ])


@when("^the user searches for a part in the search field$")
def step(ctx):
    driver = ctx.webdriver

    ctx.searched_part_no = "9502664"
    el = driver.find_element_by_css_selector(".tree-search-form input")
    el.send_keys("%s\n" % ctx.searched_part_no)


@then("^the part is navigated$")
def step(ctx):
    driver = ctx.webdriver

    el = driver.find_element_by_css_selector(".simple-backend-text-search-match")
    assert ctx.searched_part_no in el.text, "wrong part has been navigated %s" % el.text
