#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

import common
import cdbwrapc

from cdb.validationkit import given, when, then, run_with_added_roles, operation, \
    run_with_roles, log, getStateNumber
from cs.vp.items import Item
from cs.vp.bom import AssemblyComponent
from cs.vp.variants import bomlinks
from cs.vp.items import ProcessPartReference
from cs.workflow.processes import Process


# ------------------------------------------------------------
# Scenario: Create New item
#
# ------------------------------------------------------------
@when("^(?P<role>.*?) creates a new item$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_roles(roles)
    def create(context):
        context.item_len = len(Item.Query())
        try:
            common.generateItem()
        except Exception, e:
            log("Error creating an item, details: %s" % str(e))
    return create(context)


@then("^a new item is (?P<state>(?:not )?generated)$")
def step(context, state):
    if state == "generated":
        assert len(Item.Query()) - context.item_len == 1, \
            "No item created"
    elif state == "not generated":
        assert len(Item.Query()) - context.item_len == 0, \
            "An item was created"
    else:
        assert False, "Unknown state"


# ------------------------------------------------------------
# Scenario: Create New item With Predefines
#
# ------------------------------------------------------------
@when("^(?P<role>.*?) creates a new item with$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_roles(roles)
    def create(context):
        context.attrs = context.table[0].items()
        attrs = {"benennung": "Blech",
                 "t_kategorie": common.ITEM_CATEGORY,
                 "mengeneinheit": "kg"}
        attrs.update(dict(context.attrs))
        try:
            context.item = operation("CDB_Create", Item, preset=attrs)
        except Exception, e:
            log("Error creating an item, details: %s" % str(e))
    return create(context)


@then("^the predefined attributes are (?P<state>(?:not )?set) on the item$")
def step(context, state):
    if state == "set":
        if hasattr(context, "attrs"):
            s_attrs = set(context.attrs)
            assert s_attrs.issubset(
                set(context.item.items())
            ), "The Attributes differ"
    elif state == "not set":
        assert not hasattr(context, "item"), "There is a document"
    else:
        assert False, "Unknown state"


# ------------------------------------------------------------
# Scenario: Change Item
#
# ------------------------------------------------------------
@given("^an item exists$")
@run_with_added_roles(["Engineering"])
def step(context):
    context.item = common.generateItem()
    context.item_len = len(Item.Query())


def getItemAttributesToChange():
    return {"techdaten": "other"}


@when("^(?P<role>.*?) changes this item$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_roles(roles)
    def change(context):
        try:
            operation("CDB_Modify",
                      context.item,
                      user_input=getItemAttributesToChange())
        except Exception, e:
            log("Error changing the item, details: %s" % e)
    return change(context)


@then("^the changed item is (?P<state>(?:not )?saved)$")
def step(context, state):
    item = Item.ByKeys(context.item.teilenummer, context.item.t_index)
    s_attrs = set(getItemAttributesToChange().items())
    if state == "saved":
        assert s_attrs.issubset(
            set(item.items())
        ), "The attributes differ"
    elif state == "not saved":
        assert not s_attrs.issubset(
            set(item.items())
        ), "The attributes differ"
    else:
        assert False, "Unknown state"


# ------------------------------------------------------------
# Scenario: Copy Item
#
# ------------------------------------------------------------
@when("^(?P<role>.*?) copies this item$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_roles(roles)
    def copy(context):
        try:
            context.item_len = len(Item.Query())
            context.copy = operation("CDB_Copy", context.item)
        except Exception, e:
            log("Error coping the item, details: %s" % e)
    return copy(context)


@then("^the item is (?P<state>(?:not )?copied|(?:not )?deleted)$")
def step(context, state):
    res = Item.ByKeys(context.item.teilenummer, context.item.t_index)
    if state == "copied":
        assert len(Item.Query()) - context.item_len == 1, \
            "No item was created"
    elif state == "not copied":
        assert len(Item.Query()) - context.item_len == 0, \
            "An item was created"
    elif state == "deleted":
        assert res is None, "The item isn't deleted"
    elif state == "not deleted":
        assert res is not None, "The item is deleted"
    else:
        assert False, "Unknown state"


# ------------------------------------------------------------
# Scenario: Delete Item
#
# ------------------------------------------------------------
@when("^(?P<role>.*?) deletes (?P<what>this item|the assembly)$")
def step(context, role, what):
    roles = set(role.split(", "))

    if what == "this item":
        obj = context.item
    elif what == "the assembly":
        obj = context.assembly

    @run_with_roles(roles)
    def delete(context):
        try:
            operation("CDB_Delete", obj)
        except Exception, e:
            log("Error deleting the item, details: %s" % e)
    return delete(context)


@then("^the parts list position is (?P<state>deleted|not deleted)$")
def step(context, state):
    cdef = cdbwrapc.CDBClassDef("bom_item")
    args = {key: getattr(context.assemblyComponent, key) for key in cdef.getKeyNames()}
    ac = AssemblyComponent.ByKeys(**args)

    if state == "deleted":
        assert ac is None, "the parts list position has not been deleted"
    else:
        assert ac is not None, "the parts list position has been deleted"


@then("^the bom predicate is (?P<state>deleted|not deleted)$")
def step(context, state):
    cdef = cdbwrapc.CDBClassDef("cdbvp_bom_predicate")
    args = {key: getattr(context.predicate, key) for key in cdef.getKeyNames()}
    predicate = bomlinks.BOM_Predicate.ByKeys(**args)

    cdef = cdbwrapc.CDBClassDef("cdbvp_bom_term")
    args = {key: getattr(context.term, key) for key in cdef.getKeyNames()}
    term = bomlinks.BOM_Term.ByKeys(**args)

    if state == "deleted":
        assert predicate is None, "the bom predicate has not been deleted"
        assert term is None, "the bom term has not been deleted"
    else:
        assert predicate is not None, "the bom predicate has been deleted"
        assert term is not None, "the bom term has been deleted"


# ------------------------------------------------------------
# Scenario: Generate An Index Of An Item
#
# ------------------------------------------------------------
@given("^a released item exists$")
@run_with_added_roles(["Engineering", "Design Release"])
def step(context):
    context.item = common.generateItem()
    context.item_len = len(Item.Query())
    stateName1 = common.getStateName(context.item.cdb_objektart, "Review")
    stateName2 = common.getStateName(context.item.cdb_objektart, "Released")
    operation("CDB_Workflow", context.item,
              user_input={"zielstatus": stateName1})
    operation("CDB_Workflow", context.item,
              user_input={"zielstatus": stateName2})


@when("^(?P<role>.*?) generates an index of this item$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_roles(roles)
    def index(context):
        try:
            context.newindex = operation("CDB_Index", context.item)
        except Exception, e:
            log("Error indexing the item, details: %s" % e)
    return index(context)


@then("^an index of the original item is (?P<action>(?:not )?generated)$")
def step(context, action):
    if action == "generated":
        assert len(Item.Query()) - context.item_len == 1, \
            "No item created"
        assert context.item.teilenummer == context.newindex.teilenummer, \
            "The new index has not the same number"
    elif action == "not generated":
        assert len(Item.Query()) - context.item_len == 0, \
            "An item was created"
    else:
        assert False, "Unknown state"


@then("^the original item is (?P<state>Released|Revision|Obsolete)$")
def step(context, state):
    res = Item.ByKeys(context.item.teilenummer, context.item.t_index)
    assert (res.status
            ==
            getStateNumber("part_ERP", state)
            ), "The item is not in state %s" % state


# ------------------------------------------------------------
# Scenario: Change State Of An Item
#
# ------------------------------------------------------------
@when("^(?P<role>.*?) changes the state of this item$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_roles(roles)
    def state(context):
        context.to = context.table[0]["TO"]
        context.frm = context.table[0]["FROM"]
        try:
            operation("CDB_Workflow", context.item,
                      user_input={"zielstatus":
                                  common.getStateName(context.item.cdb_objektart,
                                               context.to)})
        except Exception, e:
            log("Error changing the state of the item, details: %s" % e)
    return state(context)


@then("^the state of the item is (?P<action>(?:not )?saved)$")
def step(context, action):
    res = Item.ByKeys(context.item.teilenummer, context.item.t_index)
    if action == "saved":
        assert (res.status
                ==
                getStateNumber("part_ERP", context.to)
                ), "The state of the item hasn't changed"
    elif action == "not saved":
        if res is not None:
            assert (res.status
                    ==
                    getStateNumber("part_ERP", context.frm)
                    ), "The state of the item has changed"
    else:
        assert False, "Unknown state"


# ------------------------------------------------------------
# Scenario: Allocate An Item To A Parts List Position
#
# ------------------------------------------------------------
@given("^an assembly exists$")
@run_with_added_roles(["Engineering"])
def step(context):
    context.assembly = common.generateItem()


@when("^(?P<role>.*?) allocates this item to the assembly$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_roles(roles)
    def allocate(context):
        try:
            operation(
                "CDB_Create",
                AssemblyComponent,
                user_input={"position": 10},
                preset={"teilenummer": context.item.teilenummer,
                        "t_index": context.item.t_index,
                        "baugruppe": context.assembly.teilenummer,
                        "b_index": context.assembly.t_index})
        except Exception, e:
            log("Error allocating the item to the assembly, details: %s" % e)
    return allocate(context)


@then("^the item is (?P<state>(?:not )?allocated) to the assembly$")
def step(context, state):
    assembly = Item.ByKeys(context.assembly.teilenummer,
                           context.assembly.t_index)
    if state == "allocated":
        assert context.item in assembly.Components, \
            "The item is not allocated"
    elif state == "not allocated":
        assert context.item not in assembly.Components, \
            "The item is allocated"
    else:
        assert False, "Unknown state"


# ------------------------------------------------------------
# Scenario Release An Index
#
# ------------------------------------------------------------

@given("^an index of this item exists$")
def step(context):
    context.old_item = context.item

    @run_with_added_roles(["Engineering"])
    def create(context):
        context.index = operation("CDB_Index", context.item)
    return create(context)


@when("^(?P<role>.*?) releases the index of the item$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_roles(roles)
    def release(context):
        stateName1 = common.getStateName(context.index.cdb_objektart, "Review")
        stateName2 = common.getStateName(context.index.cdb_objektart, "Released")
        try:
            operation("CDB_Workflow", context.index,
                      user_input={"zielstatus": stateName1})
            operation("CDB_Workflow", context.index,
                      user_input={"zielstatus": stateName2})
        except Exception, e:
            log("Error releasing state the item, details: %s" % str(e))
    return release(context)


@then("^the index of the item is (?P<state>(?:not )?Released)$")
def step(context, state):
    if state == "Released":
        assert (context.index.status
                ==
                getStateNumber("part_ERP", "Released")
                ), "The document is not Released"
    elif state == "not Released":
        assert (context.index.status
                !=
                getStateNumber("part_ERP", "Released")
                ), "The document is Released"
    else:
        assert False, "Unknown state"


@then("^the state of the original item is (?P<state>Obsolete|Revision)$")
def step(context, state):
    res = Item.ByKeys(context.item.teilenummer, context.item.t_index)
    assert (res.status
            ==
            getStateNumber("part_ERP", state)
            ), "The original document is not %s" % state


# ------------------------------------------------------------
# Scenario: Copy an Item Allocated to a CAD-Document
#
# ------------------------------------------------------------
@then("^no new document is generated$")
def step(context):
    assert len(common.Model.Query()) - context.cad_document_len == 0, \
        "A new document was generated"


@then("^the copy is (?P<state>(?:not )?allocated) to the document$")
def step(context, state):
    if state == "allocated":
        assert context.cad_document in context.copy.Documents, \
            "The document is not allocated"
    elif state == "not allocated":
        if hasattr(context, "copy"):
            assert context.cad_document not in context.copy.Documents
        else:
            return True


# ------------------------------------------------------------
# Scenario: Create Manufacturing View
#
# ------------------------------------------------------------
@when("creating a manufacturing view (?P<with_or_without>with|without) the first BOM level")
@run_with_added_roles(["Engineering"])
def step(ctx, with_or_without):  # @DuplicatedSignature
    ebom = Item.ByKeys(teilenummer=ctx.ebom.teilenummer,
                       t_index=ctx.ebom.t_index)
    from cdb import constants
    args = {"cdb::argument.cdb_create_mbom": 1,
            "cdb::argument.item_object_id": ebom.cdb_object_id,
            "cdb::argument.question_copy_stl_relship_1st_level": 1 if with_or_without == 'with' else 0}
    mbom = operation(constants.kOperationNew,  # @UndefinedVariable
                     ebom,
                     preset=args)
    ctx.mbom = mbom if mbom else None


@then("the EBOM has a MBOM (?P<with_or_without>with|without) a copy of the first BOM level")
def step(ctx, with_or_without):  # @DuplicatedSignature
    ebom = Item.ByKeys(teilenummer=ctx.ebom.teilenummer,
                       t_index=ctx.ebom.t_index)
    assert ctx.mbom is not None, 'mbom missing'
    mbom = Item.ByKeys(teilenummer=ctx.mbom.teilenummer,
                       t_index=ctx.mbom.t_index)
    mbom = ebom.ManufacturingViews.KeywordQuery(cdb_object_id=mbom.cdb_object_id)
    assert mbom, 'mbom missing'
    mbom = mbom[0]

    for ebom_comp in ebom.Components:
        mbom_comp = mbom.Components.KeywordQuery(position=ebom_comp.position, t_index=ebom_comp.t_index,
                                                 teilenummer=ebom_comp.teilenummer,
                                                 variante=ebom_comp.variante,
                                                 auswahlmenge=ebom_comp.auswahlmenge)
        if with_or_without == 'with':
            assert mbom_comp, 'mbom component missing'
        else:
            assert len(mbom_comp) == 0, 'mbom component does wrongly exist %d' % len(mbom_comp)
