#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

import cdbwrapc
import sys

from cdb import sqlapi
from cdb import util
from cdb.platform import mom
from cdb.platform.olc import StateDefinition
from cdb.validationkit import operation, log
from cdb.validationkit.op import make_argument_list
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support import wait

from cs.documents import DocumentCategory, Document
from cs.vp.bom import AssemblyComponent
from cs.vp.variants import bomlinks
from cs.vp.classification import PropertySet, Property
from cs.vp.items import Item
from cs.vp.products import Product
from cs.vp.variants import vpmsolvers
from cs.vp.variants.properties import Property as VariantProperty
from cs.vp.variants.properties import EnumDefinition
from cs.vp.variants.properties import PropertyFolder
from cs.vp.variants import ProductVariant
from cs.vp.variants.productviews import ProductView
from cs.vp.variants import constraints
from cs.tools import batchoperations

__docformat__ = "restructuredtext en"
__revision__ = "$Id: common.py 181951 2018-08-09 13:26:11Z gda $"

ITEM_CATEGORY = "Baukasten"

INSTANCE_WIZARD_TEST_PRODUCT_CODE = "TEST_NEW_ELINK"
VARIANT_MATRIX_TEST_PRODUCT_CODE = "TEST"

XPATH_PARENT = ".."

# How long should we wait after an ajax call is finished
# to continue testing. This is currently very high, but
# needed for the buildbot.
AJAX_STABILITY = 5

# Maximal timeout of webdriver queries. This is currently very high, but
# needed for the buildbot.
WEB_DRIVER_TIMEOUT = 120


class Document(Document):
    def __eq__(self, other):
        if hasattr(other, "z_nummer") and hasattr(other, "z_index"):
            return (other.z_nummer == self.z_nummer and
                    other.z_index == self.z_index)
        else:
            return False


class Model(Document):
    __classname__ = "model"


class Item(Item):
    def __eq__(self, other):
        if hasattr(other, "teilenummer") and hasattr(other, "t_index"):
            return (other.teilenummer == self.teilenummer and
                    other.t_index == self.t_index)
        else:
            return False


class PropertySet(PropertySet):
    def __eq__(self, other):
        if hasattr(other, "pset_id"):
            return self.pset_id == other.pset_id
        else:
            return False


def generateCADDocument(item, presets_custom={}, user_input_custom={}):
    preset = {
        "teilenummer": item.teilenummer,
        "t_index": item.t_index,
        "z_categ1": 144,  # Produkt/Teil
        "z_categ2": 177  # CAD-Zeichnung
    }
    preset.update(presets_custom)
    user_input = {}
    user_input.update(user_input_custom)
    return operation("CDB_Create", Model,
                     preset=preset,
                     user_input=user_input)


def generateItem(presets_custom={}, user_input_custom={}):
    preset = {"benennung": "Blech",
              "t_kategorie": ITEM_CATEGORY,
              "t_bereich": "Engineering",
              "mengeneinheit": "qm"}
    preset.update(presets_custom)
    user_input = {}
    user_input.update(user_input_custom)
    return operation("CDB_Create", Item,
                     preset=preset,
                     user_input=user_input)


def generateDocument(presets_custom={}, user_input_custom={}):
    doc_maincateg = DocumentCategory.KeywordQuery(parent_id='')[0]
    doc_categ = DocumentCategory.KeywordQuery(parent_id=doc_maincateg.categ_id)[0]

    preset = {"z_categ1": doc_maincateg.categ_id,
              "z_categ2": doc_categ.categ_id}
    preset.update(presets_custom)
    user_input = {"titel": "Test"}
    user_input.update(user_input_custom)
    return operation("CDB_Create", Document,
                     user_input=user_input,
                     preset=preset)


def generateCharacteristicBar(presets_custom={}, user_input_custom={}):
    preset = {}
    preset.update(presets_custom)
    user_input = {"pset_id": "Test"}
    user_input.update(user_input_custom)
    return operation("CDB_Create", PropertySet,
                     preset=preset, user_input=user_input)


def generateAssemblyComponent(assembly, item=None, presets_custom={}, user_input_custom={}):
    if item is None:
        item = generateItem()

    preset = {"teilenummer": item.teilenummer,
              "t_index": item.t_index,
              "baugruppe": assembly.teilenummer,
              "b_index": assembly.t_index}
    preset.update(presets_custom)
    user_input = {}
    user_input.update(user_input_custom)
    return operation("CDB_Create", AssemblyComponent,
                     preset=preset, user_input=user_input)


def generateAssemblyComponentPredicate(assembly_component, product,
                                       presets_custom={}, user_input_custom={}):
    preset = {"baugruppe": assembly_component.baugruppe,
              "b_index": assembly_component.b_index,
              "teilenummer": assembly_component.teilenummer,
              "variante": assembly_component.variante,
              "position": assembly_component.position,
              "product_object_id": product.cdb_object_id,
              "predicate_id": bomlinks.BOM_Term_Predicate.newID()}
    preset.update(presets_custom)
    user_input = {}
    user_input.update(user_input_custom)
    return operation("CDB_Create", bomlinks.BOM_Term_Predicate,
                     preset=preset, user_input=user_input)


def generateStringPredicate(assembly_component, product, expression, presets_custom={}, user_input_custom={}):
    preset = {"baugruppe": assembly_component.baugruppe,
              "b_index": assembly_component.b_index,
              "teilenummer": assembly_component.teilenummer,
              "variante": assembly_component.variante,
              "position": assembly_component.position,
              "product_object_id": product.cdb_object_id,
              "predicate_id": bomlinks.BOM_Term_Predicate.newID()}
    preset.update(presets_custom)
    user_input = {
        "expression": expression
    }
    user_input.update(user_input_custom)
    return operation("CDB_Create", bomlinks.BOM_String_Predicate,
                     preset=preset, user_input=user_input)


def generatePredicateTerm(predicate, prop, prop_value, presets_custom={},
                          user_input_custom={}):
    preset = {"baugruppe": predicate.baugruppe,
              "b_index": predicate.b_index,
              "teilenummer": predicate.teilenummer,
              "variante": predicate.variante,
              "position": predicate.position,
              "product_object_id": predicate.product_object_id,
              "predicate_id": predicate.predicate_id}
    preset.update(presets_custom)
    user_input = {"property_name_de": prop.name_de,
                  "property_id": prop.id,
                  "enumvalue_txt_de": prop_value.value_txt_de,
                  "enum_value": prop_value.value,
                  "operator": "="}
    user_input.update(user_input_custom)
    return operation("CDB_Create", bomlinks.BOM_Term,
                     preset=preset, user_input=user_input)


def generateSMLProperty(presets_custom={}, user_input_custom={}):
    preset = {}
    preset.update(presets_custom)
    user_input = {"din4001_mm_mk": "Test", "din4001_mm_dt": "T",
                  "din4001_mm_v1": 1, "din4001_mm_n1": 0}
    user_input.update(user_input_custom)
    return operation("CDB_Create", Property,
                     preset=preset,
                     user_input=user_input)


def generateProduct(preset={}, user_input={}):
    preset_default = {'code': 'Test product',
                      'objektart': 'cdbvp_product',
                      'cdb_status_txt': 'Draft',
                      'status': 0}
    preset_default.update(preset)
    user_input_default = {}
    user_input_default.update(user_input)
    return operation("CDB_Create", Product,
                     preset=preset_default,
                     user_input=user_input_default)


def generateProductProperty(product, preset={}, user_input={}):
    preset_default = {'product_object_id': product.cdb_object_id}
    preset_default.update(preset)

    user_input_default = {'data_type': 'boolean',
                          'name_de': 'Test property'}
    user_input_default.update(user_input)
    return operation("CDB_Create", VariantProperty,
                     preset=preset_default,
                     user_input=user_input_default)


def generateProductPropertyValue(prop, preset={}, user_input={}):
    preset_default = {
        "product_object_id": prop.product_object_id,
        "id": prop.id
    }
    preset_default.update(preset)

    user_input_default = {}
    user_input_default.update(user_input)

    return operation(
        "CDB_Create", EnumDefinition,
        preset=preset_default,
        user_input=user_input_default
    )


def generateProductPropertyFolder(product, preset={}, user_input={}):
    preset_default = {
        "product_object_id": product.cdb_object_id,
    }
    preset_default.update(preset)

    user_input_default = {}
    user_input_default.update(user_input)

    return operation(
        "CDB_Create", PropertyFolder,
        preset=preset_default,
        user_input=user_input_default
    )


def generateProductView(product, preset={}, user_input={}):
    preset_default = {
        "product_object_id": product.cdb_object_id,
        "name_de": "Sicht",
        "name_en": "View"
    }
    preset_default.update(preset)
    user_input_default = {}
    user_input_default.update(user_input)
    return operation("CDB_Create", ProductView,
                     preset=preset_default,
                     user_input=user_input_default)


def generateConstraint(product, preset={}, user_input={}):
    preset_default = {
        "product_object_id": product.cdb_object_id,
    }
    preset_default.update(preset)
    user_input_default = {}
    user_input_default.update(user_input)
    return operation(
        "CDB_Create",
        constraints.Constraint,
        preset=preset_default,
        user_input=user_input_default
    )


def generatePredicate(constraint, preset={}, user_input={}):
    preset_default = {
        "product_object_id": constraint.product_object_id,
        "constraint_id": constraint.constraint_id
    }
    preset_default.update(preset)
    user_input_default = {}
    user_input_default.update(user_input)
    return operation(
        "CDB_Create",
        constraints.Predicate,
        preset=preset_default,
        user_input=user_input_default
    )


def generateTerm(predicate, preset={}, user_input={}):
    preset_default = {
        "product_object_id": predicate.product_object_id,
        "constraint_id": predicate.constraint_id,
        "predicate_id": predicate.predicate_id
    }
    preset_default.update(preset)
    user_input_default = {}
    user_input_default.update(user_input)
    return operation(
        "CDB_Create",
        constraints.Term,
        preset=preset_default,
        user_input=user_input_default
    )


def generateNVariants(product, N):
    solver = vpmsolvers.BasicVPMSolver(product, product.VariantDrivingProperties)

    result = []
    for values, _ in zip(solver.iterate(), range(N)):
        result.append(ProductVariant.CreateVariant(values, product.cdb_object_id))

    return result


def generateOrganization(**args):
    from cdb.objects import operations
    from cdb.objects.org import Organization

    org_type = sqlapi.RecordSet2("cdb_org_type", "id='5'")[0]
    defaults = {
        "org_id": "%s" % util.nextval("Organizations"),
        "name": "TEST",
        "org_type": org_type.shorttext,
    }
    defaults.update(args)

    return operations.operation(
        "CDB_Create",
        Organization,
        **defaults
    )


def generateItemBatchOperation(preset={}, user_input={}):
    preset_default = {
        "id": util.nextval("cdb_bfolder"),
        "type_id": "teile_stamm",
        "operation": "PartStateChange"
    }
    preset_default.update(preset)

    user_input_default = {}
    user_input_default.update(user_input)

    return operation(
        "CDB_Create", batchoperations.BatchOperation,
        preset=preset_default,
        user_input=user_input_default
    )


def assignItemToBatchOperation(bop, item, preset={}, user_input={}):
    from cs.vp.items.batchoperations import BatchOperationItemAssignment

    preset_default = {
        "id": bop.id,
        "teilenummer": item.teilenummer,
        "t_index": item.t_index
    }
    preset_default.update(preset)

    user_input_default = {}
    user_input_default.update(user_input)

    return operation(
        "CDB_Create",
        BatchOperationItemAssignment,
        preset=preset_default,
        user_input=user_input_default
    )


def getStateName(objektart, statename_en):
    state = StateDefinition.KeywordQuery(objektart=objektart,
                                         statusbez_en=statename_en)
    assert len(state) > 0, \
        "no german statename found for %s/%s" % (objektart, statename_en)
    return state[0].statusbez_de


def waitForSuccessfulLogin(driver, stability=AJAX_STABILITY):
    def check_successful_login(driver):
        href_last_segment = driver.execute_script("""return window.location.href.split('/').pop()""")
        return href_last_segment != 'login'

    if stability == 1:
        wait.WebDriverWait(driver, WEB_DRIVER_TIMEOUT).until(check_successful_login)
    else:
        waitUntilXTimes(driver, check_successful_login, stability)


def waitForElink(driver):
    loader = driver.find_element_by_id("elink_waiting")
    wait.WebDriverWait(driver, WEB_DRIVER_TIMEOUT).until_not(EC.visibility_of(loader))


def waitForAjax(driver, stability=AJAX_STABILITY):
    def check_active_ajax(driver):
        res = driver.execute_script('return jQuery.active===0')
        return res

    if stability == 1:
        wait.WebDriverWait(driver, WEB_DRIVER_TIMEOUT).until(check_active_ajax)
    else:
        waitUntilXTimes(driver, check_active_ajax, stability)


def waitForDiffutil(driver, stability=AJAX_STABILITY):
    def check_active_diffutil(driver):
        res = driver.execute_script('return App._ajaxCount===0')
        return res

    waitUntilXTimes(driver, check_active_diffutil, stability)
    waitForElink(driver)


def waitForElementVisibility(driver, element):
    wait.WebDriverWait(driver, WEB_DRIVER_TIMEOUT).until(EC.visibility_of(element))


def waitUntilXTimes(driver, method, x=0, fail_message=''):
    import time
    from selenium.common.exceptions import TimeoutException
    assert x >= 0, 'at least one time required'
    end_time = time.time() + WEB_DRIVER_TIMEOUT
    while (True):
        try:
            value = method(driver)
            if value and x == 0:
                return value
            elif value and x > 0:
                x -= 1
        except wait.IGNORED_EXCEPTIONS:
            pass
        time.sleep(wait.POLL_FREQUENCY)
        if (time.time() > end_time):
            break
    raise TimeoutException(fail_message)


def setupDataTablesWait(driver):
    driver.execute_script("""
    $(window).on('preXhr.dt', function(){
        window.dt_finished=false;
    });
    $(window).on('draw.dt', function(){
        window.dt_finished=true;
    });
    """)


def waitForDataTables(driver):
    def check_active_dt(driver):
        res = driver.execute_script("""
        return window.dt_finished === true
        """)
        return res

    wait.WebDriverWait(driver, WEB_DRIVER_TIMEOUT + 20).until(check_active_dt)


def get_product_by_code(code):
    """
    Gets a product by its code

    :param code: code of the product
    :return: the product, None, if it could not be found
    """
    products = Product.KeywordQuery(code=code)
    return products[0] if len(products) == 1 else None


def get_instance_wizard_test_product():
    """
    :return: default product for testing the instance wizard
    """
    return get_product_by_code(INSTANCE_WIZARD_TEST_PRODUCT_CODE)


def get_variant_matrix_test_product():
    """
    :return: default product for testing the variant matrix
    """
    return get_product_by_code(VARIANT_MATRIX_TEST_PRODUCT_CODE)


def get_instantiations_for_bom(bom):
    """
    Collects all instantiations for a given variant
    :param bom: a bom
    :return: list of instantiations for the product variant
    """
    bom.Reload()  # reload to refresh references
    return bom.Instantiations


def open_instance_wizard(driver, server_url, variant, bom):
    if bom.t_index == "":
        url = server_url + "byname/instance_wizard/%s/%s/%s" % (
            variant.Product.cdb_object_id, variant.id, bom.teilenummer)
    else:
        url = server_url + "byname/instance_wizard/%s/%s/%s/%s" % (
            variant.Product.cdb_object_id, variant.id, bom.teilenummer, bom.t_index)
    driver.get(url)
    waitForAjax(driver)


def submit_instance_wizard(driver):
    driver.find_element_by_css_selector("#navbar-head > div > button").click()
    waitForAjax(driver)
    driver.find_element_by_css_selector("div.fade.in.modal > div > div > div.modal-footer > button").click()


def get_parts_since(since):
    return Item.Query("cdb_cdate > %s" % sqlapi.SQLdbms_date(since))


def find_property_checkbox(context, property_name):
    """
    Gets the checkbox for a given property name to click
    :param context: the context from behave
    :param property_name: the property name
    :return: the checkbox to select the given property name
    """
    property_name = property_name.strip()
    child_property = len(property_name) != 1  # according to test data, property is now a child property

    property_span = find_property_span(context, property_name, name_is_prefix=True)
    property_checkbox = get_property_checkbox(context, property_span, child_property, property_name)
    return None if property_checkbox is None else property_checkbox


def get_property_spans(driver):
    properties = driver.find_elements_by_css_selector(
        "div.table-shadow > table > tbody > tr > td.table-cell.property-cell.table-cell-fixed > div > "
        "span.table-cell-text")
    properties.extend(driver.find_elements_by_css_selector(
        "div.table-shadow > table > tbody > tr > td.table-cell.property-cell.table-cell-fixed > div > "
        "span.table-cell-text-without-icon"))
    return properties


def find_property_span(context, property_name, name_is_prefix=False):
    property_name = property_name.strip()
    property_spans = get_property_spans(context.webdriver)

    for property_span in property_spans:
        property_span_text = property_span.text.strip()
        if name_is_prefix and property_name.startswith(property_span_text):
            return property_span
        elif property_span_text == property_name:
            return property_span

    return None


def get_property_checkbox(context, property_span, child_property, property_name):
    if child_property:
        dropdown_toggle = property_span.find_element_by_xpath(XPATH_PARENT).find_element_by_class_name(
            "table-cell-icon")
        if "glyphicon-chevron-down" not in dropdown_toggle.find_element_by_class_name("pointer-events").get_attribute(
                "class"):
            dropdown_toggle.click()
        property_span = find_property_span(context, property_name)
        assert property_span is not None, "property '%s' could not be found" % property_name

    table_row = property_span.find_element_by_xpath(XPATH_PARENT).find_element_by_xpath(
        XPATH_PARENT).find_element_by_xpath(XPATH_PARENT)
    table_data = table_row.find_element_by_class_name("check-cell")
    checkbox = table_data.find_element_by_tag_name("input")
    return checkbox


def click_property_checkbox(context, checkbox_name):
    checkbox = find_property_checkbox(context, checkbox_name)
    assert checkbox is not None, "checkbox for property '%s' could not be found" % checkbox_name
    if not checkbox.is_selected():
        checkbox.click()


def get_newest_variant():
    return ProductVariant.Query("cdb_cdate IN (SELECT max(cdb_cdate) FROM cdbvp_variant)")[0]


def find_dropdown_for_checkbox(checkbox):
    td = checkbox.find_element_by_xpath("../../../../..")
    return td.find_element_by_class_name("value-cell").find_element_by_tag_name("button")


def select_value_in_dropdown(dropdown, value):
    assert dropdown is not None and value is not None
    dropdown.click()

    dropdown_entry_list = dropdown.find_element_by_xpath(XPATH_PARENT).find_element_by_tag_name("ul")
    dropdown_entry = dropdown_entry_list.find_element_by_link_text(value)
    dropdown_entry.click()


def create_variant_with_name(driver, name):
    new_variant_button = driver.find_element_by_css_selector(".table-shadow #add-variant-button:not([disabled])")
    assert new_variant_button is not None, "button for creating a new variant could not be found"
    new_variant_button.click()

    name_input = driver.find_element_by_css_selector("div.fade.in.modal > div > div > div.modal-body > div > input")
    assert name_input is not None, "modal window could not be found"
    name_input.send_keys(name)

    submit_button = driver.find_element_by_css_selector(
        "div.fade.in.modal > div > div > div.modal-footer > button:nth-child(1)")
    assert submit_button is not None, "submit button could not be found"
    submit_button.click()

    waitForAjax(driver)


def deselect_all_checkboxes(driver):
    checkboxes = driver.find_elements_by_css_selector("input[type=checkbox]")
    for checkbox in checkboxes:
        if checkbox.is_displayed() and checkbox.is_selected():
            checkbox.click()


def select_variant_properties(context, variant_definition):
    variant_properties = variant_definition.split(",")  # step separates variants with ','

    for variant_property in variant_properties:
        variant_property = variant_property.split(":")  # step separates property values with ':'
        if len(variant_property) == 1:
            variant_property = variant_property[0]
            click_property_checkbox(context, variant_property)
        else:
            property_name = variant_property[0]
            property_value = variant_property[1]
            checkbox = find_property_checkbox(context, property_name)
            dropdown = find_dropdown_for_checkbox(checkbox)
            select_value_in_dropdown(dropdown, property_value)


def multiselect_operation(opname, objs, preset=None, user_input=None):
    if preset is None:
        preset = {}
    if user_input is None:
        user_input = {}

    dlg_args = make_argument_list(None, user_input)
    op_args = make_argument_list(None, preset)

    handles = [obj.ToObjectHandle() for obj in objs]
    op = cdbwrapc.Operation(opname, handles, mom.SimpleArgumentList())
    op.runAsTest(op_args, dlg_args, "True")

    while op is not None:
        # Operations may return an URL which defines a follow-up operation
        # Try to execute such operations (or operation-chains)
        urlresult = op.getUrlResult()
        if urlresult is not None:
            url = urlresult[0]
            try:
                op = cdbwrapc.createOperationFromCMSGUrl(url)
            except ValueError, exc:
                op = None
                if url.find("byname") != -1:
                    sys.stderr.write(
                        "ERROR: Could not create an operation from URL '%s', "
                        "details: '%s'\n" % (url, exc)
                    )
                else:
                    sys.stdout.write(
                        "WARNING: Cannot interpret URL '%s' skipping the follow-up operation, "
                        "details: '%s'\n" % (url, exc)
                    )
        else:
            op = None

        if op is not None:
            empty_list = make_argument_list(None, {})
            op.runAsTest(empty_list, empty_list, "True")

    for obj in objs:
        obj.Reload()

    return objs
