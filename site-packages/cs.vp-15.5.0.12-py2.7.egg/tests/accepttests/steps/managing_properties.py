#!/usr/bin/env python
# -*- python -*- coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

from cdb.validationkit import given, when, then, run_with_added_roles, log, \
    operation, getNewNumber
from cs.vp.classification import Property, PropertyReference
from common import generateSMLProperty


# Scenario Create New Property

@when("^(?P<role>.*?) creates a new property$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_added_roles(roles)
    def create(context):
        try:
            context.property_len = len(Property.Query())
            context.property = generateSMLProperty()
        except Exception, e:
            log("Error creating the property, details: %s" % e)
    return create(context)


@then("^a new property is (?P<creation>(?:not )?generated)$")
def step(context, creation):
    if creation == "generated":
        assert len(Property.Query()) - context.property_len == 1, \
            "No Property was created"
    elif creation == "not generated":
        assert len(Property.Query()) - context.property_len == 0, \
            "A Property was created"


# Scenario Change Property

def getSMLPropertyAttributesToChange():
    return {"din4001_mm_v1": 5}


@given("^a property exists$")
@run_with_added_roles(["Administrator"])
def step(context):
    context.property = generateSMLProperty()
    context.property_len = len(Property.Query())


@when("^(?P<role>.*?) changes this property$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_added_roles(roles)
    def change(context):
        try:
            operation("CDB_Modify",
                      context.property,
                      user_input=getSMLPropertyAttributesToChange())
        except Exception, e:
            log("Error changing the property, details: %s" % e)
    return change(context)


@then("^the changed property is (?P<status>(?:not )?saved)$")
def step(context, status):
    context.property.Reload()
    s_attrs = set(getSMLPropertyAttributesToChange().items())
    if status == "saved":
        assert s_attrs.issubset(
            set(context.property.items())
        ), "The attributes differ"
    elif status == "not saved":
        assert not s_attrs.issubset(
            set(context.property.items())
        ), "The attributes don't differ"


# Scenario Copy Property

@when("^(?P<role>.*?) copies this property$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_added_roles(roles)
    def copy(context):
        try:
            operation("CDB_Copy", context.property)
        except Exception, e:
            log("Error coping the property, details: %s" % e)
    return copy(context)


@then("^the property is (?P<status>(?:not )?copied|(?:not )?deleted)$")
def step(context, status):
    if status == "copied":
        assert len(Property.Query()) - context.property_len == 1, \
            "No new property was created"
    elif status == "not copied":
        assert len(Property.Query()) - context.property_len == 0, \
            "A new property was created"
    elif status == "deleted":
        assert len(Property.Query()) - context.property_len == -1, \
            "The property isn't deleted"
    elif status == "not deleted":
        assert len(Property.Query()) - context.property_len == 0, \
            "The property is deleted"


# Scenario Delete Property

@when("^(?P<role>.*?) deletes this property$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_added_roles(roles)
    def delete(context):
        try:
            operation("CDB_Delete", context.property)
        except Exception, e:
            log("Error deleting the property, details: %s" % e)
    return delete(context)


# Scenario Allocate A Property To A Characteristic Bar

@when("^(?P<role>.*?) allocates this property to the characteristic bar$")
def step(context, role):
    roles = set(role.split(", "))

    @run_with_added_roles(roles)
    def allocate(context):
        try:
            operation("CDB_Create",
                      PropertyReference,
                      preset={"pset_id": context.propertySet.pset_id,
                              "prop_id": context.property.prop_id,
                              "prop_mk": context.property.din4001_mm_mk})
        except Exception, e:
            log("Error allocating the property to the characteristic bar, "
                "details: %s" % e)
    return allocate(context)


@then("^the property is "
      "(?P<allocation>(?:not )?allocated) to the characteristic bar$")
def step(context, allocation):
    context.property.Reload()
    found = False
    for propertyRef in context.property.PropertyReferences:
        if propertyRef.PropertySet == context.propertySet:
            found = True
            break
    if allocation == "allocated":
        assert found, "The characteristic bar isn't allocated to the property"
    elif allocation == "not allocated":
        assert not found, "The characteristic bar is allocated to the property"
