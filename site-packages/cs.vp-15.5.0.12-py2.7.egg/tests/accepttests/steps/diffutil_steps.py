#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2014 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#
"""
Module diffutil_steps

This is the documentation for the diffutil_steps module.
"""

from cdb import util
from cdb.objects import org
from cdb.platform.mom import operations
from cdb.validationkit import given
from cdb.validationkit import operation
from cdb.validationkit import run_with_added_roles
from cdb.validationkit import then
from cdb.validationkit import when

from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select
from selenium.webdriver.support.wait import WebDriverWait
from selenium.common import exceptions as selenium_exceptions

import common
from cs.vp import items
from cs.vp import bom
from cs.vp import variants
from cs.vp.bom.diffutil import pages
from cs.vp.variants.product_extensions import ProductAssemblyLink


__docformat__ = "restructuredtext en"
__revision__ = "$Id: diffutil_steps.py 180676 2018-07-18 09:18:58Z gda $"


WEB_DRIVER_DIFFUTIL_URL = "cdbgate/powerscript/cs.vp.bom.diffutil"
WEB_DRIVER_VARIANT_EDITOR_URL = "cdbgate/powerscript/cs.vp.variants.apps.generatorui"


@given("^an EBOM exists$")
@given("^the product has a maxbom$")
@run_with_added_roles(["Engineering"])
def an_ebom_exists(ctx):
    # ebom
    #  |---- ebom-a
    #  |      |---- ebom-c
    #  |      |---- ebom-d
    #  |---- ebom-b
    #  |      |2x-- ebom-c
    #  |      |---- ebom-d
    #  |---- ebom-c
    #  |---- ebom-d

    ctx.ebom = common.generateItem(user_input_custom={"benennung": "EBOM",
                                                      "benennung_en": "EBOM"})
    ctx.maxbom = ctx.ebom
    ctx.ebom_a = common.generateItem()
    ctx.ebom_b = common.generateItem()
    ctx.ebom_c = common.generateItem()
    ctx.ebom_d = common.generateItem()

    ctx.bom_item_a = common.generateAssemblyComponent(ctx.ebom, ctx.ebom_a)
    ctx.bom_item_b = common.generateAssemblyComponent(ctx.ebom, ctx.ebom_b)
    common.generateAssemblyComponent(ctx.ebom_a, ctx.ebom_c)
    common.generateAssemblyComponent(ctx.ebom_a, ctx.ebom_d)
    common.generateAssemblyComponent(ctx.ebom_b, ctx.ebom_c,
                                     user_input_custom={"menge": 2})
    common.generateAssemblyComponent(ctx.ebom_b, ctx.ebom_d)
    ctx.bom_item_c = common.generateAssemblyComponent(ctx.ebom, ctx.ebom_c)
    ctx.bom_item_d = common.generateAssemblyComponent(ctx.ebom, ctx.ebom_d)


@given("^the EBOM has an MBOM$")
@run_with_added_roles(["Engineering"])
def the_ebom_has_an_mbom(ctx):
    # mbom
    #  |---- mbom-1
    #  |      |---- ebom-a
    #  |      |      |---- ebom-c
    #  |      |      |---- ebom-d
    #  |      |---- ebom-b
    #  |             |2x-- ebom-c
    #  |             |---- ebom-d
    #  |---- ebom-c
    #  |---- ebom-d

    ebom = items.Item.ByKeys(teilenummer=ctx.ebom.teilenummer,
                             t_index=ctx.ebom.t_index)
    from cdb import constants
    mbom = operation(constants.kOperationNew,  # @UndefinedVariable
                     ebom,
                     preset={"cdb::argument.cdb_create_mbom": 1,
                             "cdb::argument.item_object_id": ebom.cdb_object_id,
                             "cdb::argument.question_copy_stl_relship_1st_level": 1})
    if mbom:
        ctx.mbom = mbom
        ctx.mbom_1 = common.generateItem(user_input_custom={"is_mbom": 1})
        ctx.mbom_comp_1 = common.generateAssemblyComponent(ctx.mbom,
                                                           ctx.mbom_1,
                                                           user_input_custom={"position": 1})

        for teilenummer, t_index in [(ctx.ebom_a.teilenummer, ctx.ebom_a.t_index),
                                     (ctx.ebom_b.teilenummer, ctx.ebom_b.t_index)]:
            comp = bom.AssemblyComponent.ByKeys(baugruppe=ctx.mbom.teilenummer,
                                                b_index=ctx.mbom.t_index,
                                                teilenummer=teilenummer,
                                                t_index=t_index)
            if comp:
                operation(constants.kOperationCopy,
                          comp,
                          preset={"baugruppe": ctx.mbom_1.teilenummer,
                                  "b_index": ctx.mbom_1.t_index})
                operation(constants.kOperationDelete,
                          comp)
    else:
        ctx.mbom = None
        ctx.mbom_1 = None
        ctx.mbom_comp_1 = None


@given("^EBOM and MBOM are both assigned to the same product$")
@run_with_added_roles(["Product: Manager"])
def ebom_and_mbom_are_both_assigned_to_the_same_product(ctx):
    ctx.product = common.generateProduct()
    ctx.epal = ProductAssemblyLink.Create(teilenummer=ctx.ebom.teilenummer,
                                          t_index=ctx.ebom.t_index,
                                          product_object_id=ctx.product.cdb_object_id)
    ctx.mpal = ProductAssemblyLink.Create(teilenummer=ctx.mbom.teilenummer,
                                          t_index=ctx.mbom.t_index,
                                          product_object_id=ctx.product.cdb_object_id)
    ctx.product.Reload()


@given("^the product has (?P<n>\d*\s?)variants$")
@run_with_added_roles(["Product: Manager"])
def the_product_has_variants(ctx, n):
    ctx.variants = []
    from cs.vp.variants.varianttableadapters import SyncStatus
    if n != '':
        n = int(n)
    else:
        n = None
    if n is None:  # old behavior
        ctx.variant = variants.ProductVariant.Create(id=variants.Variant.NewVariantID(ctx.product.cdb_object_id),
                                                     product_object_id=ctx.product.cdb_object_id,
                                                     solver_status=SyncStatus.ok.value)
        variants.properties.PropertyValue.Create(product_object_id=ctx.product.cdb_object_id,
                                                 variant_id=ctx.variant.id,
                                                 id=ctx.property1.id,
                                                 value=ctx.prop1_value_1.value)
        variants.properties.PropertyValue.Create(product_object_id=ctx.product.cdb_object_id,
                                                 variant_id=ctx.variant.id,
                                                 id=ctx.property2.id,
                                                 value=ctx.prop2_value_1.value)
        ctx.is_stored_variant = True
        ctx.variant.updateInfoText()
        ctx.variant.updateSignature()
        # Product -> Variant -> [Property=PropertyValue,..]
    else:  # new behavior
        props = ctx.product.VariantDrivingProperties
        solver = variants.vpmsolvers.NestedVPMFilteredSolver(ctx.product,
                                                             props,
                                                             [], [])
        all_solutions = solver.solve()
        variants_count = 0

        for i in range(0, n if n <= len(all_solutions) else len(all_solutions)):
            variant = variants.ProductVariant.Create(id=variants.Variant.NewVariantID(ctx.product.cdb_object_id),
                                                     product_object_id=ctx.product.cdb_object_id,
                                                     solver_status=SyncStatus.ok.value)
            variant.updateInfoText()
            variant.updateSignature()
            setattr(ctx,
                    'variant%d' % i,
                    variant)
            setattr(ctx,
                    'is_stored_variant%d' % i,
                    True)
            variants_count += 1
            ctx.variants.append(variant)
        ctx.variants_count = variants_count
        assert variants_count == n, "variants generated %d" % variants_count


@given("^the EBOM and MBOM contain different selection predicates$")
@run_with_added_roles(["Product: Manager"])
def the_ebom_and_mbom_contain_different_selection_predicates(ctx):
    ctx.ebom_item_2_sel_predicate = common.generateAssemblyComponentPredicate(ctx.bom_item_a,
                                                                              ctx.product)
    common.generatePredicateTerm(ctx.ebom_item_2_sel_predicate,
                                 ctx.property1,
                                 ctx.prop1_value_1)
    common.generatePredicateTerm(ctx.ebom_item_2_sel_predicate,
                                 ctx.property2,
                                 ctx.prop2_value_1)

    ctx.mbom_item_a = ctx.mbom_1.Components.KeywordQuery(teilenummer=ctx.bom_item_a.teilenummer,
                                                         t_index=ctx.bom_item_a.t_index)[0]

    ctx.mbom_item_2_sel_predicate = common.generateAssemblyComponentPredicate(ctx.mbom_item_a,
                                                                              ctx.product)
    common.generatePredicateTerm(ctx.mbom_item_2_sel_predicate,
                                 ctx.property1,
                                 ctx.prop1_value_2)
    common.generatePredicateTerm(ctx.mbom_item_2_sel_predicate,
                                 ctx.property2,
                                 ctx.prop2_value_2)


@when("^the product is selected$")
def the_product_is_selected(ctx):
    driver = ctx.webdriver
    common.waitForElink(driver)
    common.waitForAjax(driver)
    product_selector = driver.find_element_by_class_name("diff-table-select")
    product_selection = Select(product_selector)
    product_selection.select_by_visible_text(ctx.product.GetDescription())


@when("^a variant is selected$")
def a_variant_is_selected(ctx):
    driver = ctx.webdriver
    variant_button = driver.find_elements(By.CSS_SELECTOR,
                                          ".variant-button")[0]
    variant_button.click()
    common.waitForAjax(driver)
    variant_table_first_row = driver.find_elements(By.CSS_SELECTOR,
                                                   ".modal-variants "
                                                   ".ember-table-body-container "
                                                   ".ember-table-table-row:nth-child(1) "
                                                   ".ember-view")[0]
    variant_table_first_row.click()


@then("^the EBOM and MBOM structures are filtered$")
def the_ebom_and_mbom_structures_are_filtered(ctx):
    driver = ctx.webdriver
    common.waitForAjax(driver)

    # Expand nodes
    _selector = ".second-view .tree-action:not(.invisible) " \
                "[data-ember-action]:not(.hide)"
    button = driver.find_elements_by_css_selector(_selector)[1]
    button.click()

    common.waitForAjax(driver)
    first_level_selector = "div.bom-tree-node:not(.not-in-variant)"
    ebom_tree_nodes = driver.find_elements(By.CSS_SELECTOR,
                                           ".first-view %s" % first_level_selector)
    mbom_tree_nodes = driver.find_elements(By.CSS_SELECTOR,
                                           ".second-view %s" % first_level_selector)
    if ctx.is_stored_variant:
        assert len(ebom_tree_nodes) == 5, \
            "variant based nodes are filtered (should be 5 is %d)" % len(ebom_tree_nodes)
        assert len(mbom_tree_nodes) == 5, \
            "variant based nodes are not filtered (should be 5 is %d)" % len(mbom_tree_nodes)
    else:
        assert len(ebom_tree_nodes) == 4, \
            "variant based nodes are filtered (should be 4 is %d)" % len(ebom_tree_nodes)
        assert len(mbom_tree_nodes) == 6, \
            "variant based nodes are not filtered (should be 6 is %d)" % len(mbom_tree_nodes)


@then("^the differences are filtered$")
def the_differences_are_filtered(ctx):
    driver = ctx.webdriver
    differences = [el for el in driver.find_elements(By.CSS_SELECTOR,
                                                     ".diff-table "
                                                     ".ember-table-body-container "
                                                     ".ember-table-table-row")
                   if el. is_displayed()]
    assert len(differences) == 3, "wrong differences count %d %d" % (len(differences),
                                                                     driver.execute_script("return App.__container__.lookup('controller:index').get('differences.length')"))

    for diff in differences:
        teilenummer = diff.find_element_by_css_selector("span"
                                                        ".ember-table-content"
                                                        ".name").text
        cnt_fbom = diff.find_element_by_css_selector("span"
                                                     ".ember-table-content"
                                                     ".cnt_fbom").text
        cnt_sbom = diff.find_element_by_css_selector("span"
                                                     ".ember-table-content"
                                                     ".cnt_sbom").text

        if teilenummer == ctx.ebom_a.teilenummer:
            if ctx.is_stored_variant:
                expected_cnt_fbom = '1'
                expected_cnt_sbom = '0'
            else:
                # in case of virtual variant fbom and sbom counts are different'
                expected_cnt_fbom = '0'
                expected_cnt_sbom = '1'
        elif teilenummer == ctx.ebom_c.teilenummer:
            if ctx.is_stored_variant:
                expected_cnt_fbom = '4'
                expected_cnt_sbom = '3'
            else:
                # in case of virtual variant fbom and sbom counts are different'
                expected_cnt_fbom = '3'
                expected_cnt_sbom = '4'
        else:
            if ctx.is_stored_variant:
                expected_cnt_fbom = '3'
                expected_cnt_sbom = '2'
            else:
                # in case of virtual variant fbom and sbom counts are different'
                expected_cnt_fbom = '2'
                expected_cnt_sbom = '3'
        assert cnt_fbom == expected_cnt_fbom, \
            "differences have not been filtered correctly " \
            "cnt_fbom:'%s'" % cnt_fbom
        assert cnt_sbom == expected_cnt_sbom, \
            "differences have not been filtered correctly " \
            "cnt_sbom:'%s'" % cnt_sbom

    # close second window and switch to default window
    if hasattr(ctx, 'default_window'):
        driver.close()
        driver.switch_to.window(ctx.default_window)


@given("^the quantity of an MBOM position is changed$")
@when("^the quantity of an MBOM position is changed$")
def the_quantity_of_an_mbom_position_is_changed(ctx):
    poss = ctx.mbom_1.Components.KeywordQuery(teilenummer=ctx.bom_item_b.teilenummer,
                                              t_index=ctx.bom_item_b.t_index)
    if poss:
        pos = poss[0]
    else:
        raise RuntimeError("No position found")
    pos.menge = 3
    if hasattr(ctx, "search_string_entered"):
        specific_pos = ctx.mbom_1.Components.KeywordQuery(teilenummer=ctx.bom_item_e.teilenummer,
                                                          t_index=ctx.bom_item_e.t_index)
        if specific_pos:
            spec_pos = specific_pos[0]
        else:
            raise RuntimeError("No position found")
        spec_pos.menge = 3


@then("^the difference in the position and in its children is computed$")
def the_difference_in_the_position_and_in_its_children_is_computed(ctx):
    from cs.vp.bom.diffutil import differences

    diffs = differences.get_differences(ctx.ebom, ctx.mbom)

    assert len(diffs) == 3, "Wrong number of differences"

    for diff in diffs:
        if (diff["teilenummer"] == ctx.ebom_c.teilenummer and
                diff["t_index"] == ctx.ebom_c.t_index):
            assert diff["lbom_quantity"] == 4, "Wrong quantity on left bom"
            assert diff["rbom_quantity"] == 8, "Wrong quantity on right bom"
        elif (diff["teilenummer"] == ctx.ebom_d.teilenummer and
                diff["t_index"] == ctx.ebom_d.t_index):
            assert diff["lbom_quantity"] == 3, "Wrong quantity on left bom"
            assert diff["rbom_quantity"] == 5, "Wrong quantity on right bom"
        elif (diff["teilenummer"] == ctx.ebom_b.teilenummer and
                diff["t_index"] == ctx.ebom_b.t_index):
            assert diff["lbom_quantity"] == 1, "Wrong quantity on left bom"
            assert diff["rbom_quantity"] == 3, "Wrong quantity on right bom"
        else:
            raise RuntimeError("Wrong number of differences")


@given("^the user wants to perform a (?P<search_type>diff_search|tree_search)$")
def step(ctx, search_type):
    if search_type == "diff_search":
        ctx.ebom_e = common.generateItem(user_input_custom={"benennung": "Spezifisches Blech"})
        ctx.bom_item_e = common.generateAssemblyComponent(ctx.ebom, ctx.ebom_e)
    else:
        ctx.ebom_e = common.generateItem(user_input_custom={"benennung": "Spezifisches Blech"})
        ctx.bom_item_e = common.generateAssemblyComponent(ctx.ebom, ctx.ebom_e)
        ctx.mbom_e = common.generateItem(user_input_custom={"benennung": "Spezifisches Blech"})
        ctx.mbom_item_e = common.generateAssemblyComponent(ctx.mbom, ctx.mbom_e)


# -------------------------------------------------------------
# Scenario: Cookie for expanded items
# -------------------------------------------------------------

@given("^the user has opened the mBOM Manager(?P<plant> for the same plant| for a different plant)?$")
@when("^the user has opened the mBOM Manager(?P<plant> for the same plant| for a different plant)?$")
def the_user_has_opened_the_mbom_manager(ctx, plant=""):
    url = ctx.server_url + WEB_DRIVER_DIFFUTIL_URL + \
        "/index/" + ctx.ebom.teilenummer

    if plant == " for a different plant":
        url += "?_filtertext=TEST&site_object_id=%s" % ctx.plant_2.cdb_object_id
    elif plant == " for the same plant":
        url += "?_filtertext=TEST&site_object_id=%s" % ctx.plant_1.cdb_object_id

    ctx.webdriver.get(url)
    common.waitForElink(ctx.webdriver)


@when("^a bom item is expanded$")
def a_bom_item_is_expanded(ctx):
    driver = ctx.webdriver
    common.waitForAjax(driver)
    button = driver.find_elements(By.CSS_SELECTOR,
                                  ".tree-action:not(.invisible) [data-ember-action]:not(.hide)")
    ctx.expanded_items = driver.find_elements(By.CSS_SELECTOR,
                                              ".tree-child-nodes.collapse.in")
    button[1].click()
    common.waitForAjax(driver)
    # Find child item before refresh
    driver.find_element_by_xpath(
        "//div[@class='tree-current-node' and contains(@title,'" +
        ctx.bom_item_a.teilenummer + "')]")


@when("^the page is refreshed$")
def the_page_is_refreshed(ctx):
    ctx.webdriver.refresh()


@then("^the item will still be expanded$")
def the_item_will_still_be_expanded(ctx):
    driver = ctx.webdriver
    common.waitForAjax(driver)
    total_expanded_items = driver.find_elements(By.CSS_SELECTOR,
                                                ".tree-child-nodes.collapse.in")
    assert len(total_expanded_items) > 0 and \
        len(total_expanded_items) > len(ctx.expanded_items), \
        "Item not expanded!"


# -------------------------------------------------------------
# Scenario: Operation registration
# -------------------------------------------------------------

@given("^the user registers an operation$")
def step(ctx):
    ctx.plugins = pages._PLUGINS
    ctx.original_plugin_length = len(pages._PLUGINS)
    pages.register_operation({"name": "CDB_Index",
                              "is_ebom_op": False,
                              "is_item_op": True})


@then("^the operation is added to the list of all mBOM Manager operations$")
def step(ctx):
    result = [operation for operation in ctx.plugins
              if operation['name'] == "CDB_Index"]
    assert len(ctx.plugins) > ctx.original_plugin_length and result, \
        "Operation was not registered!"
    # needed for further tests
    pages._PLUGINS.pop()


# -------------------------------------------------------------
# Scenario: Have multi select operations available
# -------------------------------------------------------------


@when("^two mbom items are selected$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForElink(driver)
    ctx.mbom_view = driver.find_element_by_class_name("second-view")
    selector_c = './/div[div/text()="%s"]' % \
        pages.get_bomnode_tag() % pages._BomItemAttributeAccessor(ctx.bom_item_c,
                                                                  ctx.bom_item_c.Item)
    item_node_c = ctx.mbom_view.find_element_by_xpath(selector_c)
    selector_d = './/div[div/text()="%s"]' % \
        pages.get_bomnode_tag() % pages._BomItemAttributeAccessor(ctx.bom_item_d,
                                                                  ctx.bom_item_d.Item)
    item_node_d = ctx.mbom_view.find_element_by_xpath(selector_d)
    action = ActionChains(driver)
    action.click(item_node_c.find_element_by_css_selector(".bom-tree-node"))
    action.key_down(Keys.CONTROL)
    action.click(item_node_d.find_element_by_css_selector(".bom-tree-node"))
    action.key_up(Keys.CONTROL)
    action.move_to_element(item_node_c)
    action.perform()

    ctx.tree_node = item_node_c


@when("^the operation drop down button is pressed$")
def step(ctx):
    driver = ctx.webdriver
    if hasattr(ctx, "tree_node"):
        button = ctx.tree_node.find_element_by_xpath(
            './/button[@class="btn btn-mini dropup-button dropdown-toggle"]')
    else:
        button = driver.find_element_by_xpath(
            './/button[@class="btn btn-mini dropup-button dropdown-toggle"]')
    common.waitForElementVisibility(driver, button)
    button.click()


@then("^the mbom multi select operations are available$")
def step(ctx):
    from cs.vp.bom import AssemblyComponent
    menu = ctx.mbom_view.find_element_by_xpath(
        './/ul[@class="dropdown-menu btn-mini drop-menu"]')
    menu_ops = set()
    for menu_item in menu.find_elements_by_xpath('.//li[not(@class="head")]'):
        menu_ops.add(menu_item.text)
    assert len(menu_ops) > 0
    plugin_ops = set()
    clsname = AssemblyComponent._getClassname()
    for op in pages._PLUGINS:
        if op["multi_select_op"] and not op["is_ebom_op"] and not op["is_item_op"]:
            opinfo = operations.OperationInfo(clsname, op["name"])
            plugin_ops.add(opinfo.get_label().strip())
    assert set(plugin_ops) <= set(menu_ops)


# -------------------------------------------------------------
# Scenario: Compute Predicate differences
# -------------------------------------------------------------

@then("^the product is automatically selected$")
def the_product_is_automatically_selected(ctx):
    common.waitForAjax(ctx.webdriver)
    span = ctx.webdriver.find_element_by_css_selector(".product-description")
    assert span.text != "-", "Product has not been selected"


@then("^the part list position with different predicates is shown in the table$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForAjax(driver)

    table = driver.find_element_by_css_selector(".diff-table .table_container")

    differences = [el for el in driver.find_elements(By.CSS_SELECTOR,
                                                     ".diff-table "
                                                     ".ember-table-body-container "
                                                     ".ember-table-table-row")
                   if el.is_displayed()]

    assert len(differences) >= 1, "No differences found"
    assert len(differences) <= 1, "Too many differences found"

    td = table.find_element_by_css_selector(".diff-table "
                                            "span.ember-table-content.act_sbom")
    assert td.text == util.get_label("cdbvp_bom_synchronise_predicates"), \
        "Different predicates are not recognised. "\
        "Text should be [%s], but was [%s]" % (
            util.get_label("cdbvp_bom_synchronise_predicates"),
            td.text
        )


# -------------------------------------------------------------
# Scenario: Search differences
# -------------------------------------------------------------

@when("^the user clicks on a difference in the difference table$")
def step(ctx):
    teilenummer = ctx.ebom_c.teilenummer

    table = ctx.webdriver\
        .find_element_by_css_selector(".diff-table "
                                      ".ember-table-body-container")

    selector = ".//span[@class='name ember-table-content'][text()='%s']"
    cell = table.find_element_by_xpath(selector % teilenummer)
    cell.click()


@then("^only the relevant occurrences are found$")
def step(ctx):
    driver = ctx.webdriver
    left = driver.find_elements_by_css_selector(".first-view .node-found")
    right = driver.find_elements_by_css_selector(".second-view .node-found")

    assert len(left) == 1, "Wrong number of occurrences found on the left"
    assert len(right) == 1, "Wrong number of occurrences found on the right"


# -------------------------------------------------------------
# Scenario: Drag and drop tests
# -------------------------------------------------------------

@when("^one ebom item is selected$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForElink(driver)
    ctx.ebom_view = driver.find_element_by_class_name("first-view")
    ctx.selected_item = ctx.ebom_view.find_element_by_xpath(
        './/div[text()="%s"]' % pages.get_bomnode_tag() % pages._BomItemAttributeAccessor(ctx.bom_item_b,
                                                                                          ctx.bom_item_b.Item))
    ctx.selected_item.click()


@when("^one mbom item is selected$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForElink(driver)
    ctx.mbom_view = driver.find_element_by_class_name("second-view")
    ctx.selected_item = ctx.mbom_view.find_element_by_xpath(
        './/div[text()="%s"]' % pages.get_bomnode_tag() % pages._BomItemAttributeAccessor(ctx.bom_item_c,
                                                                                          ctx.bom_item_c.Item))
    ctx.selected_item.click()


@when("^the selection is dragged and dropped on an mbom item$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    ctx.mbom_view = driver.find_element_by_class_name("second-view")
    drop_target_item = ctx.mbom_view.find_element_by_xpath(
        './/div[text()="%s"]' % ctx.mbom.GetDescription())
    action = ActionChains(driver)
    ctx.old_mbom_comps_count = len(ctx.mbom.Components)
    action.drag_and_drop(ctx.selected_item, drop_target_item).perform()


@when("^the selection is dragged and dropped on a second mbom item$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    drop_target_item = ctx.mbom_view.find_element_by_xpath(
        './/div[text()="%s"]' % pages.get_bomnode_tag() % pages._BomItemAttributeAccessor(ctx.mbom_comp_1,
                                                                                          ctx.mbom_comp_1.Item))
    action = ActionChains(driver)
    ctx.old_mbom_comps_count = len(ctx.mbom.Components)
    ctx.old_target_comps_count = len(ctx.mbom_1.Components)
    action.drag_and_drop(ctx.selected_item, drop_target_item).perform()


@then("^the ebom item is copied underneath the mbom item$")
def step(ctx):
    common.waitForDiffutil(ctx.webdriver)
    ctx.mbom.Reload()
    new_components = len(ctx.mbom.Components)
    old_components = ctx.old_mbom_comps_count
    assert new_components > old_components, \
        "wrong number of components (new %s, old %s)" % (new_components,
                                                         old_components)


@then("^the mbom item is moved underneath the second mbom item$")
def step(ctx):
    common.waitForDiffutil(ctx.webdriver)
    ctx.mbom.Reload()
    assert len(ctx.mbom.Components) < ctx.old_mbom_comps_count
    ctx.mbom_1.Reload()
    assert len(ctx.mbom_1.Components) > ctx.old_target_comps_count


# -------------------------------------------------------------
# Scenario: Open mBOM Manager from context of stored variant
# -------------------------------------------------------------

@when("^the user has opened the mBOM Manager in context of stored variant$")
def step(ctx):
    url = ctx.server_url + WEB_DRIVER_DIFFUTIL_URL + \
        "/index/%s;/%s/%s" % (ctx.ebom.teilenummer,
                              ctx.product.cdb_object_id,
                              ctx.variant.id)
    ctx.webdriver.get(url)


@then("^the variant is automatically selected$")
def step(ctx):
    driver = ctx.webdriver
    variant_info = driver.find_element(By.CSS_SELECTOR,
                                       ".context-metadata "
                                       ".variant-description")

    assert variant_info and \
        variant_info.text.split(':')[0] == "%s" % ctx.variant.id, \
        "Variant is not selected!"


# -----------------------------------------------------------------------------
# Scenario: Open mBOM Manager from context of VariantEditor with stored variant
# -----------------------------------------------------------------------------

@given("^the user has opened the variant editor$")
@when("^the user has opened the Variant Editor$")
def the_user_has_opened_the_variant_editor(ctx):
    url = ctx.server_url + WEB_DRIVER_VARIANT_EDITOR_URL + \
        "/view?cdb_object_id=%s" % ctx.product.cdb_object_id
    ctx.webdriver.get(url)


@when("^the user selects a stored variant$")
@when("^the user selects a variant$")
def the_user_selects_a_variant(ctx):
    driver = ctx.webdriver
    common.setupDataTablesWait(driver)
    common.waitForAjax(driver)
    # Deactivate fixed columns to avoid conflicts
    fix_columns_button = driver.find_element_by_id("fix_columns_button")
    fix_columns_button.click()

    common.waitForDataTables(driver)
    variant_text = driver.find_elements(By.CSS_SELECTOR,
                                        ".display tr.odd td")[1].text
    ctx.is_stored_variant = variant_text != ""

    virtual_odd = driver.find_element(By.CSS_SELECTOR,
                                      ".display tr.odd")

    virtual_odd.click()

    maxbom = driver.find_element_by_id("maxbom_radio_button")
    maxbom.click()


@when("^the user opens the mBOM Manager in context of variant$")
def the_user_opens_the_mbom_manager_in_context_of_a_variant(ctx):
    driver = ctx.webdriver
    dropdown_button = driver.find_element_by_id("show_in_cad_button_drop")
    dropdown_button.click()
    mbom_entry = driver.find_element_by_css_selector(".cad_entry[data-button-json='show_mbom_manager']")
    mbom_entry.click()
    ctx.default_window = driver.window_handles[0]
    driver.switch_to.window(driver.window_handles[1])


# -----------------------------------------------------------------------------
# Scenario: Show Variant Dialog and step across all variant pages
# -----------------------------------------------------------------------------

@given("^the product has (?P<n>\d*\s?)properties$")
@run_with_added_roles(["Product: Manager"])
def the_product_has_properties(ctx, n):  # @DuplicatedSignature
    if n != '':
        n = int(n)
    else:
        n = 2  # default behavior for the old tests
    for i in range(1, n + 1):
        prop = common.generateProductProperty(ctx.product,
                                              user_input={'name_de': 'Property%d' % i})
        setattr(ctx, 'property%d' % i, prop)
        setattr(ctx, 'prop%d_value_1' % i, prop.EnumValues[0])
        setattr(ctx, 'prop%d_value_2' % i, prop.EnumValues[1])


@when("^the variant selection dialog is opened$")
def step(ctx):
    driver = ctx.webdriver
    # only ensure that dialog has been opened - actually this is done by product is
    # selected
    variant_table_first_tr = driver.find_elements(By.CSS_SELECTOR,
                                                  ".modal-variants tbody tr")


@then("^the first variant page is activated$")
def step(ctx):
    driver = ctx.webdriver
    # only ensure that dialog has been opened - actually this is done by product is
    # selected
    activated_page = driver.find_element(By.CSS_SELECTOR,
                                         ".modal-variants-paginator.pagination li.active a")
    text = driver\
        .execute_script('return $(".modal-variants-paginator.pagination li.active a").text().trim()')
    assert text == '1', \
        'the first page was not automatically preselected (%s)' % text


@then("^the each variant can be found by stepping across all variant pages$")
def step(ctx):
    driver = ctx.webdriver
    wait = WebDriverWait(driver, 120)
    known_variant_ids = [i for i in range(1, ctx.variants_count + 1)]
    pages = driver.find_elements(By.CSS_SELECTOR, ".modal-variants-paginator.pagination li a")
    for page in pages:
        def check_actual_page_selected(driver):
            activePage = driver.find_element(By.CSS_SELECTOR,
                                             ".modal-variants-paginator.pagination li.active a")
            return activePage.text == page.text
        page.click()
        wait.until(check_actual_page_selected)
        visible_variants = driver.find_elements(By.CSS_SELECTOR,
                                                ".modal-variants tbody tr td.vid")
        for variant in visible_variants:
            known_variant_ids.remove(int(variant.text))
    assert len(known_variant_ids) == 0, 'not all variants found by stepping accross all variant pages'


@then("^no variant page has more than (?P<n>\d+) entries$")
def step(ctx, n):
    pageSize = int(n)
    driver = ctx.webdriver
    wait = WebDriverWait(driver, 120)
    pages = driver.find_elements(By.CSS_SELECTOR, ".modal-variants-paginator.pagination li a")
    for page in pages:
        def check_actual_page_selected(driver):
            activePage = driver.find_element(By.CSS_SELECTOR,
                                             ".modal-variants-paginator.pagination li.active a")
            return activePage.text == page.text
        page.click()
        wait.until(check_actual_page_selected)
        visible_variants = driver.find_elements(By.CSS_SELECTOR,
                                                ".modal-variants tbody tr td.vid")
        assert len(visible_variants) <= pageSize, 'a page has more than %d entries' % pageSize


# -----------------------------------------------------------------------------
# Scenario: Call operation on tree node
# -----------------------------------------------------------------------------

@when("^the user hovers over a (?P<node_type>.*?) node$")
def step(ctx, node_type):
    driver = ctx.webdriver
    ctx.node_type = node_type
    if node_type == "EBOM":
        ebom_view = driver.find_element_by_class_name("first-view")
        ctx.tree_node = ebom_view.find_elements_by_css_selector(".ebom-node "
                                                                ".tree-node-structure "
                                                                ".tree-child-nodes "
                                                                ".tree-node "
                                                                ".tree-current-node")[0]
    else:
        mbom_view = driver.find_element_by_class_name("second-view")
        ctx.tree_node = mbom_view.find_elements_by_css_selector(".mbom-node "
                                                                ".tree-node-structure "
                                                                ".tree-child-nodes "
                                                                ".tree-node "
                                                                ".tree-current-node")[0]
    hover = ActionChains(driver).move_to_element(ctx.tree_node)
    hover.perform()


@then("^the tree node operations are available$")
def step(ctx):
    common.waitForDiffutil(ctx.webdriver)
    op_button = ctx.tree_node.find_element_by_xpath(".//div[@class='btn-group "
                                                    "pull-right dropdown open']")
    assert op_button.is_displayed(), "Operations menu not displayed!"
    menu = ctx.tree_node.find_element_by_xpath(
        './/ul[@class="dropdown-menu btn-mini drop-menu"]')
    menu_ops = set()
    for menu_item in menu.find_elements_by_xpath('.//li[not(@class="head")]'):
        menu_ops.add(menu_item.text)
    assert len(menu_ops) > 0, "No menu operations available!"
    plugin_ops = set()
    for op in pages._PLUGINS:
        if ctx.node_type == "EBOM":
            if op["is_ebom_op"] and op["is_item_op"]:
                opinfo = operations.OperationInfo("part", op["name"])
                plugin_ops.add(opinfo.get_label().strip())
            elif op["is_ebom_op"] and not op["is_item_op"]:
                opinfo = operations.OperationInfo("bom_item", op["name"])
                plugin_ops.add(opinfo.get_label().strip())
        else:
            if not op["is_ebom_op"] and op["is_item_op"]:
                opinfo = operations.OperationInfo("part", op["name"])
                plugin_ops.add(opinfo.get_label().strip())
            elif not op["is_ebom_op"] and not op["is_item_op"]:
                opinfo = operations.OperationInfo("bom_item", op["name"])
                plugin_ops.add(opinfo.get_label().strip())
    assert menu_ops == plugin_ops, "Menu operations differ from plugin operations!"


# -----------------------------------------------------------------------------
# Scenario Outline: Show only assembly or component differences
# -----------------------------------------------------------------------------

@when("^the user filters out the (?P<what>assembly|component) differences$")
def step(ctx, what):
    driver = ctx.webdriver
    if what == "assembly":
        button = driver.find_element_by_css_selector(".show-assemblies-button")
    elif what == "component":
        button = driver.find_element_by_css_selector(".show-components-button")
    button.click()


@then("^the (?P<what>assembly|component) differences are filtered out$")
def step(ctx, what):
    if what == "assembly":
        _items = [ctx.ebom_c, ctx.ebom_d]  # we expect to find only components
    elif what == "component":
        _items = [ctx.ebom_a, ctx.ebom_b]  # we expect to find only assemblies
    nrs = [item.teilenummer for item in _items]

    driver = ctx.webdriver
    found_nrs = [el.text for el in driver.find_elements_by_css_selector(".ember-table-content.name") if el.text]

    assert set(found_nrs) <= set(nrs), "The differences are not filtered out"


# -----------------------------------------------------------------------------
# Scenario Outline: Show only assembly or component differences
# -----------------------------------------------------------------------------

@when("^the user tags a (?P<what>item|difference) as ignored$")
def step(ctx, what):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)

    ctx.difference = driver.find_element_by_css_selector(".ember-table-table-row:not(.ember-table-header-row)")

    if what == "item":
        cell = ctx.difference.find_element_by_css_selector(".ember-table-cell.name")
    elif what == "difference":
        cell = ctx.difference.find_element_by_css_selector(".ember-table-cell.act_sbom")

    hover = ActionChains(driver).move_to_element(cell)
    hover.perform()

    button = cell.find_element_by_css_selector(".ignore-button")
    button.click()


def _show_ignored_rows(driver):
    cell = driver.find_element_by_css_selector(".ember-table-header-cell.ignored")
    button = cell.find_element_by_css_selector(".dropdown.filter-menu i")
    button.click()
    checkbox = cell.find_element_by_xpath(".//li[text()='%s']/input" % util.get_label('cdbvp_elink_diffutil_all'))
    checkbox.click()
    button.click()


@then("^the (?P<what>item|difference) is tagged as ignored$")
def step(ctx, what):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    _show_ignored_rows(driver)

    if what == "item":
        expected = util.get_label("cdbvp_diffutil_ignored_item")
    elif what == "difference":
        expected = util.get_label("cdbvp_diffutil_ignored_difference")

    cell = ctx.difference.find_element_by_css_selector(".ember-table-content.ignored")
    assert cell.text == expected, "The row has not been tagged as ignored %s %s" % (cell.text, expected)


# -----------------------------------------------------------------------------
# Scenario Outline: Tag a difference as not ignored
# -----------------------------------------------------------------------------

@when("^the user tags the row as not ignored$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    _show_ignored_rows(driver)
    cell = ctx.difference.find_element_by_css_selector(".ember-table-cell.ignored")
    hover = ActionChains(driver).move_to_element(cell)
    hover.perform()

    button = cell.find_element_by_css_selector(".ignore-button")
    button.click()


@then("^the row is not ignored anymore$")
def step(ctx):
    common.waitForDiffutil(ctx.webdriver)
    cell = ctx.difference.find_element_by_css_selector(".ember-table-content.ignored")
    assert cell.text == "", "The row is still tagged as ignored"


# -----------------------------------------------------------------------------
# Scenario: Filter differences by category
# -----------------------------------------------------------------------------

@when("^the user filters out a category$")
def step(ctx):
    driver = ctx.webdriver
    cell = driver.find_element_by_css_selector(".ember-table-header-cell.category")
    button = cell.find_element_by_css_selector(".dropdown.filter-menu i")
    button.click()
    checkbox = cell.find_element_by_xpath(".//li[text()='%s']/input" % common.ITEM_CATEGORY)
    checkbox.click()
    button.click()


@then("^the differences are filtered out$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    differences = [el for el in driver.find_elements(By.CSS_SELECTOR,
                                                     ".diff-table "
                                                     ".ember-table-body-container "
                                                     ".ember-table-table-row")
                   if el.is_displayed()]

    if hasattr(ctx, "search_string_entered"):
        assert len(differences) == 1, "The specific difference is not filtered"
    else:
        assert len(differences) == 0, "The differences are not filtered out"


# -----------------------------------------------------------------------------
# Scenario Outline: Filter differences by search field
# -----------------------------------------------------------------------------

@when("^the user enters a search string$")
def step(ctx):
    driver = ctx.webdriver
    diff_search_field = driver.find_element_by_class_name("search_field")
    diff_search_field.send_keys("Spezifisches Blech")
    ctx.search_string_entered = True


# -----------------------------------------------------------------------------
# Scenario Outline: Search node in tree views by search field
# -----------------------------------------------------------------------------

@when("^the user enters a search string for (?P<tree>eBOM|mBOM)$")
def step(ctx, tree):
    driver = ctx.webdriver
    ctx.tree = tree
    tree_search_fields = driver.find_elements_by_class_name("ember-text-field")
    if tree == "eBOM":
        tree_search_field = tree_search_fields[0]
    else:
        tree_search_field = tree_search_fields[1]
    ctx.search_string = "Spezifisches Blech"
    tree_search_field.send_keys("Spezifisches Blech")
    tree_search_field.send_keys(Keys.ENTER)


@then("^the node is found$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    if ctx.tree == "eBOM":
        tree_view = driver.find_element_by_class_name("first-view")
    else:
        tree_view = driver.find_element_by_class_name("second-view")
    result_node = tree_view.find_element_by_class_name("node-navigated")
    assert result_node is not None and \
        ctx.search_string in result_node.text, "Node not found!"


# -----------------------------------------------------------------------------
# Scenario Outline: Search node in tree views by search field
# -----------------------------------------------------------------------------

@given("^the EBOM has (?P<count>no|two) corresponding mBOM$")
def step(ctx, count):
    if count == "two":
        ebom = items.Item.ByKeys(teilenummer=ctx.ebom.teilenummer,
                                 t_index=ctx.ebom.t_index)
        from cdb import constants
        for i in range(2):
            operation(constants.kOperationNew,  # @UndefinedVariable
                      ebom,
                      preset={"cdb::argument.cdb_create_mbom": 1,
                              "cdb::argument.item_object_id": ebom.cdb_object_id,
                              "cdb::argument.question_copy_stl_relship_1st_level": 1})


@then("^(?P<message>no_mBOM|multiple_mBOMs) is shown$")
def step(ctx, message):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    info_message = driver.find_element_by_class_name("alert")
    if message == "no_mBOM":
        assert info_message.text == util.get_label("cdbvp_elink_diffutils_mbom_no_mbom_available"), "Wrong label!"
    else:
        assert info_message.text == util.get_label("cdbvp_elink_diffutils_mbom_select"), "Wrong label!"


# -----------------------------------------------------------------------------
# Scenario: mBOM description is shown in dropdown menu
# -----------------------------------------------------------------------------

@then("^the mBOM description is shown in dropdown menu$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    dropdown_menu = driver.find_element_by_class_name("ember-select")
    organization = org.Organization.ByKeys(cdb_object_id=ctx.mbom.site_object_id)

    dropdown_text = dropdown_menu.text.strip()
    expected = (util.get_label("cdbvp_elink_diffutils_mbom_label") % (
        ctx.mbom.GetDescription(),
        organization.GetDescription() if organization else ""
    )).strip()
    assert dropdown_text == expected


# -----------------------------------------------------------------------------
# Scenario: mBOM is properly loaded
# -----------------------------------------------------------------------------

@when("^the user selects a mBOM$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    dropdown_menu = driver.find_element_by_class_name("ember-select")
    first_mbom = dropdown_menu.find_elements_by_tag_name("option")[1]
    ctx.mbom_choosen = ctx.ebom.ManufacturingViews[0]
    first_mbom.click()


@then("^the mBOM is properly loaded$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    script = """
    var c = App.__container__.lookup('controller:index');
    return c.get('ritem_object_id');
    """
    ritem_object_id = driver.execute_script(script)
    assert ritem_object_id and ritem_object_id == ctx.mbom_choosen.cdb_object_id, "Object ids differ!"


# -----------------------------------------------------------------------------
# Scenario: Data reload
# -----------------------------------------------------------------------------

@when("^a part list position is added to the EBOM$")
@run_with_added_roles(["Engineering"])
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    ctx.ebom_e = common.generateItem()
    ctx.bom_item_e = common.generateAssemblyComponent(ctx.ebom, ctx.ebom_e)


@when("^a part list position is deleted from the mBOM$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    ctx.deleted_mbom_position = bom.AssemblyComponent.ByKeys(baugruppe=ctx.mbom.teilenummer,
                                                             b_index=ctx.mbom.t_index,
                                                             teilenummer=ctx.ebom_d.teilenummer,
                                                             t_index=ctx.ebom_d.t_index)
    ctx.deleted_mbom_position.Delete()


@when("^a state of a part list position is changed$")
@run_with_added_roles(["Engineering"])
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    ctx.ebom_d.ChangeState(100)
    ctx.bom_item_d.Reload()
    ctx.state_changed_item = ctx.ebom_d
    ctx.state_changed_bom_item = ctx.bom_item_d


@when("^a description of a part list position is changed$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    ctx.ebom_c.Update(benennung="changed",
                      eng_benennung="changed")
    ctx.ebom_c.Reload()
    ctx.description_changed_item = ctx.ebom_c
    ctx.description_changed_bom_item = ctx.bom_item_c


@when("^the users clicks the reload button$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    reload_icon = driver.find_element_by_class_name("icon-refresh")
    reload_icon.click()


@then("^the EBOM contains the added part list position$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    item_node_e = driver.find_element_by_xpath('.//div[div/text()="%s"]' %
                                               pages.get_bomnode_tag() % pages._BomItemAttributeAccessor(ctx.bom_item_e,
                                                                                                         ctx.bom_item_e.Item))
    assert item_node_e, 'added part list position was not found'


@then("^the mBOM does not contain the deleted part list position$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    ctx.mbom_view = driver.find_element_by_class_name("second-view")
    driver.implicitly_wait(5)
    try:
        ctx.mbom_view.find_element_by_xpath('.//div[div/text()="%s"]' %
                                            pages.get_bomnode_tag() % pages._BomItemAttributeAccessor(ctx.deleted_mbom_position,
                                                                                                      ctx.deleted_mbom_position.Item))
        found = True
    except selenium_exceptions.NoSuchElementException:
        found = False
    driver.implicitly_wait(common.WEB_DRIVER_TIMEOUT)
    assert found is False, 'the mBOM contains the deleted part list position'


@then("^the state changed part list position has the correct state$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    bom_item = driver.find_element_by_xpath('.//div[div/text()="%s"]' %
                                            pages.get_bomnode_tag() % pages._BomItemAttributeAccessor(ctx.state_changed_bom_item,
                                                                                                      ctx.state_changed_bom_item.Item))
    icon = bom_item.find_element_by_class_name("state-icon")
    itemcolor = icon.value_of_css_property('background-color')
    correct_colors = "rgba(%s, %s, %s, 1)" % ctx.state_changed_item._getObjectStateColor()
    assert itemcolor == correct_colors, 'the state changed part list position has not the correct state color %s %s' % (itemcolor, correct_colors)


@then("^the description changed part list position has the correct description$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    bom_items = driver.find_elements_by_xpath('.//div[div/text()="%s"]' %
                                              pages.get_bomnode_tag() % pages._BomItemAttributeAccessor(ctx.description_changed_bom_item,
                                                                                                        ctx.description_changed_bom_item.Item))
    assert len(bom_items) == 2, 'not enough or to much bom items found'


@then("^the difference table has (?P<howmany>\d+) differences$")
def step(ctx, howmany):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    differences = [el for el in driver.find_elements(By.CSS_SELECTOR,
                                                     ".diff-table "
                                                     ".ember-table-body-container "
                                                     ".ember-table-table-row")
                   if el. is_displayed()]

    n = int(howmany)
    assert len(differences) == n, 'not enough or to much differences, expected %s, got %s' % (n, len(differences))


# -----------------------------------------------------------------------------
# Scenario Outline: Search Variants in variant table dialog
# -----------------------------------------------------------------------------

@given("^the product (?P<has_or_has_not>has|has not) a variant named (?P<name>[\w\s]*)$")
def step(ctx, has_or_has_not, name):
    import random
    if has_or_has_not and ctx.variants:
        variant = random.choice(ctx.variants)
        variant.Update(name=name)


@when("^the user search variants with (?P<searchstr>[\w\s]*)$")
def step(ctx, searchstr):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    variant_button = driver.find_elements(By.CSS_SELECTOR,
                                          ".variant-button")[0]
    variant_button.click()
    common.waitForAjax(driver)
    search_field = driver.find_element_by_css_selector(".modal-variants .ember-text-field")
    search_field.send_keys(searchstr)
    search_field.send_keys(Keys.ENTER)


@then("^the variant table has (?P<num>\d+) variants$")
def step(ctx, num):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    row_count = driver.execute_script("return $('.modal-variants "
                                      ".ember-table-left-table-block "
                                      ".ember-table-table-row"
                                      ":visible:not(.ember-table-header-row)').length;")
    assert int(row_count) == int(num), 'variant table has %s instead of %s variants' % (row_count, num)


# -----------------------------------------------------------------------------
# Scenario: Compute Predicate differences and split an EBOM position in two
# MBOM positions
# -----------------------------------------------------------------------------

@given("^the MBOM has two different positions for the same EBOM position$")
@run_with_added_roles(["Product: Manager"])
def the_mbom_has_two_different_positions(ctx):
    # make predicate for ebom position
    ctx.ebom_item_2_sel_predicate = common.generateAssemblyComponentPredicate(
        ctx.bom_item_a, ctx.product)
    common.generatePredicateTerm(ctx.ebom_item_2_sel_predicate,
                                 ctx.property1,
                                 ctx.prop1_value_1)
    common.generatePredicateTerm(ctx.ebom_item_2_sel_predicate,
                                 ctx.property2,
                                 ctx.prop2_value_1)

    ctx.bom_item_a.menge = 2

    # make predicate for mbom position
    ctx.mbom_item_a = ctx.mbom_1.Components.KeywordQuery(teilenummer=ctx.bom_item_a.teilenummer,
                                                         t_index=ctx.bom_item_a.t_index)[0]

    ctx.mbom_item_2_sel_predicate = common.generateAssemblyComponentPredicate(ctx.mbom_item_a,
                                                                              ctx.product)
    common.generatePredicateTerm(ctx.mbom_item_2_sel_predicate,
                                 ctx.property1,
                                 ctx.prop1_value_1)
    common.generatePredicateTerm(ctx.mbom_item_2_sel_predicate,
                                 ctx.property2,
                                 ctx.prop2_value_1)

    # copy mbom position
    from cdb import constants
    from cdb.objects import operations

    ctx.mbom_position_copy = operations.operation(
        constants.kOperationCopy,
        ctx.mbom_item_a,
        position=1000
    )


@then("^the EBOM position is not shown the table$")
def step(ctx):
    driver = ctx.webdriver
    common.waitForAjax(driver)

    table = driver.find_element_by_css_selector(".diff-table .table_container")

    def is_predicate_difference(diff):
        if not diff.is_displayed():
            return False

        act_sbom = diff.find_element_by_css_selector(".act_sbom")
        return u"Auswahlprdikate abgleichen" in act_sbom.text

    differences = [el for el in driver.find_elements(By.CSS_SELECTOR,
                                                     ".diff-table "
                                                     ".ember-table-body-container "
                                                     ".ember-table-table-row")
                   if is_predicate_difference(el)]

    assert len(differences) == 0, "Too many differences found"


# -----------------------------------------------------------------------------
# Scenario Outline: Search Variants in variant table dialog
# -----------------------------------------------------------------------------

@given("^the MBOM has a plant-specific bom position$")
def step(ctx):
    ctx.plant_1 = common.generateOrganization(name="PLANT1")
    ctx.plant_2 = common.generateOrganization(name="PLANT2")
    ctx.mbom_1.site_object_id = ctx.plant_1.cdb_object_id


@then("^the plant-specific position is(?P<yesorno> not)? disabled$")
def step(ctx, yesorno=None):
    driver = ctx.webdriver
    common.waitForDiffutil(driver)
    node_text = (
        pages.get_bomnode_tag() % pages._BomItemAttributeAccessor(ctx.mbom_comp_1, ctx.mbom_1)
    )
    bom_node = driver.find_element_by_xpath('.//div[text()="%s"]' % node_text)

    if yesorno == " not":
        assert "not-in-variant" not in bom_node.get_attribute("class"), "the position is disabled"
    else:
        assert "not-in-variant" in bom_node.get_attribute("class"), "the position is not disabled"


# -----------------------------------------------------------------------------
# Scenario:Points in the item number
# -----------------------------------------------------------------------------

@given(u'the MBOM has an assembly with points in the item number')
def step(ctx):
    ctx.mbom_assembly = common.generateItem()
    ctx.mbom_assembly.teilenummer += ".test"

    common.generateAssemblyComponent(ctx.mbom, item=ctx.mbom_assembly)
    common.generateAssemblyComponent(ctx.mbom_assembly)


@when(u'the user expands the MBOM assembly')
def step(ctx):
    driver = ctx.webdriver
    common.waitForAjax(driver)

    assembly_node = driver.find_element_by_xpath(
        "//div[@class='tree-current-node' and contains(@title,'" +
        ctx.mbom_assembly.teilenummer + "')]"
    )

    ancestor = assembly_node.find_element_by_xpath("./../..")

    button = ancestor.find_element(
        By.CSS_SELECTOR, ".tree-action:not(.invisible) [data-ember-action]:not(.hide)")
    button.click()
    common.waitForAjax(driver)


@when(u'the MBOM assembly is expanded')
@then(u'the MBOM assembly is expanded')
def step(ctx):
    driver = ctx.webdriver
    comp = ctx.mbom_assembly.Components[0]
    node = driver.find_element_by_xpath(
        "//div[@class='tree-current-node' and contains(@title,'" +
        comp.teilenummer + "')]"
    )


@then("^the difference is found$")
def step(ctx):
    driver = ctx.webdriver

    common.waitForDiffutil(driver)
    tree_view = driver.find_element_by_class_name("first-view")

    result_node = tree_view.find_element_by_class_name("node-navigated")
    assert result_node is not None
