#!/usr/bin/env python
# -*- mode: python; coding: iso-8859-1 -*-
#
# Copyright (C) 1990 - 2012 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

"""
Test Module test_sml

This is the documentation for the tests.

"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: test_sml.py 128692 2015-07-30 11:59:22Z heiko $"

import unittest


def setup():
    from cdb import testcase
    testcase.run_level_setup()


# Tests
class test_sml(unittest.TestCase):
    """
    Test the generation of suitable labels for TableAttributes
    and data dictionary labels using sml.trimLabel
    """
    def setUp(self):
        from cdb import util
        self.max_len = util.tables["tabellen"].column("beschriftung_d").length()

    def tearDown(self):
        pass

    def _check_length(self, new_name, old_name):
        """
        Checks the length of new_name against the
        corresponding database column length.
        """
        if new_name:
            self.assertTrue(len(new_name) <= self.max_len,
                            "New attribute name '%s' is too long. Generated from '%s'" % (new_name, old_name))

    def _generateLabel(self, label, expected_result, max_len=None):
        """
        Generates a label and compares the label with the expected result if expected_result is not ``None``.
        Returns the generated label. Uses the length of tabellen.beschriftung_d if no lenght is given in
        `max_len`.
        """
        from cs.vp.classification import sml
        if max_len is None:
            max_len = self.max_len
        new_label = sml.trimLabel(label, max_len)
        self._check_length(new_label, label)
        if new_label:
            self.assertTrue(isinstance(new_label, basestring),
                            "The generated label for '%s' is a '%s' instead of a string" % (label, type(new_label)))
        if expected_result is not None:
            self.assertEqual(new_label, expected_result,
                             "Label generation failed for '%s' and length %d: '%s' != '%s'" % (label, max_len, new_label, expected_result))
        return new_label

    def test01_simple_labels(self):
        """
        Label should be shortened
        """
        self._generateLabel("", "")
        self._generateLabel("A simple label", "A simple label")
        # Exactly matching the maximum number
        self._generateLabel("0123456789", "0123456789", 10)
        # Dots at the end if the label has to be shorten
        self._generateLabel("0123456789", "0123...", 7)
        # Do not append dots if the label is too small
        self._generateLabel("0123456789", "012", 3)
        # Not really a use case - length 0
        self._generateLabel("A label", "", 0)
        # None should also work
        self._generateLabel(None, None)

    def test02_multiline_labels(self):
        """
        The longest line should be shortened
        """
        self._generateLabel("123\\n345\\n678", "123\\n345\\n678", 100)
        # The standard SML use case - two short ones and a long line that should be shortened
        label = "short\\n" + self.max_len * 'L' + "\\nshort2"
        # The length will be checked by _generate Label
        new_label = self._generateLabel(label, None)
        splitted = new_label.split("\\n")
        self.assertEqual(len(splitted), 3,
                         "New label '%s' generated from '%s' should contain 3 lines" % (new_label, label))
        self.assertEqual(splitted[0], "short",
                         "First line of '%s' differs from 'short'" % (new_label))
        self.assertEqual(splitted[2], "short2",
                         "Third line of '%s' differs from 'short2'" % (new_label))
        many_short_lines = "\\n".join(["S" for i in range(0, self.max_len)])
        new_label = self._generateLabel(many_short_lines, None)
        # \\n is used between the lines so there are onle lines-1 occurences.
        # We add 2 to max_len to take care of this aspect
        expected_lines = (self.max_len + 2) / 3
        self.assertEqual(len(new_label.split("\\n")), expected_lines,
                         "The label '%s' does not contain the expected number of lines (%d)" % (new_label, expected_lines))


# Allow running this testfile directly
if __name__ == "__main__":
    unittest.main()
