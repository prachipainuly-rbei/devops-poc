#!/usr/bin/env powerscript
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

__docformat__ = "restructuredtext en"
__revision__ = "$Id: test_settings.py 182362 2018-08-16 09:16:49Z cso $"

import os
import unittest
from tempfile import NamedTemporaryFile
from cdb import auth
from cdb import sig
from cdb import sqlapi
from cdb import testcase
from cs.taskmanager import settings

TEST_REGISTER_TABLE_SETTINGS = sig.signal()


def setUpModule():
    testcase.run_level_setup()


class TestFile(object):
    def __init__(self, suffix, contents):
        self.suffix = suffix
        self.contents = contents

    def _create(self):
        self._file = NamedTemporaryFile(
            mode="w+b",
            suffix=self.suffix,
            delete=False)
        self._file.write(self.contents)

    def __enter__(self):
        self._create()
        self._file.close()
        return self._file

    def __exit__(self, a, b, c):
        os.unlink(self._file.name)


class UtilityTestCase(testcase.RollbackTestCase):
    def test_read_and_write_settings(self):
        id1 = "cs.taskmanager"
        id2 = "nosetests"
        persno = auth.persno
        data1 = {"key": "value"}
        data2 = {"key": "secret"}

        # TODO cache seems not to be used?
        settings.write_settings(id1, id2, data1, persno)
        self.assertEqual(settings.read_settings(id1, id2, persno), data1)
        settings.write_settings(id1, id2, data2, persno)
        self.assertEqual(settings.read_settings(id1, id2, persno), data2)

        sqlapi.SQLupdate(
            "cdb_usr_setting_long_txt "
            "SET text='--no json' "
            "WHERE setting_id='{}' "
            "AND setting_id2='{}' "
            "AND personalnummer='{}'".format(id1, id2, persno))

        with self.assertRaises(ValueError):
            settings.read_settings(id1, id2, persno)

        sqlapi.SQLupdate(
            "cdb_usr_setting_long_txt "
            "SET text='JSON, but no dict' "
            "WHERE setting_id='{}' "
            "AND setting_id2='{}' "
            "AND personalnummer='{}'".format(id1, id2, persno))

        with self.assertRaises(ValueError):
            settings.read_settings(id1, id2, persno)


class AbstractSettingsBaseTestCase(testcase.RollbackTestCase):
    def read(self, persno=None):
        return self.__cls__.read(persno, use_cache=False)

    def _read_and_write(self):
        "to be used by subclasses"
        data = {"default": "yes"}
        data2 = {"default": "nope"}

        # set for default user
        self.__cls__.write(data)
        self.assertEqual(self.read(), data)

        # set non-JSON-deserializable value for logged-on user
        self.__cls__.write("", persno=auth.persno)
        # logged-on user gets default
        self.assertEqual(self.read(persno=auth.persno), data)

        # logged-on user gets own settings
        self.__cls__.write(data2, persno=auth.persno)
        self.assertEqual(self.read(persno=auth.persno), data2)

        # default user keeps default
        self.assertEqual(self.read(), data)


class SettingsBaseTestCase(AbstractSettingsBaseTestCase):
    __cls__ = settings.SettingsBase

    def test_read(self):
        with self.assertRaises(AttributeError):
            settings.SettingsBase.read()

    def test_write(self):
        with self.assertRaises(AttributeError):
            settings.SettingsBase.write(None)


class AppSettingsTestCase(AbstractSettingsBaseTestCase):
    __cls__ = settings.AppSettings

    def test_read_and_write(self):
        self._read_and_write()

    def test_create_default_settings(self):
        self.__cls__.create_default_settings()
        self.assertEqual(self.read(), {
            "notificationInterval": 900000,
        })


def load_all_settings(self):
    """
    Use custom signal for easily disconnecting all handlers registering
    whenever
    """
    sig.emit(TEST_REGISTER_TABLE_SETTINGS)(self._register_file)
    for filepath in self.files:
        self.loaded_settings.update(self.load_file(filepath))


class TableSettingsTestCase(AbstractSettingsBaseTestCase):
    __cls__ = settings.TableSettings

    def _clear_default(self, table_settings):
        table_settings.files.difference_update(
            set([table_settings.__default_settings__]))
        table_settings.write({
            "lastUsed": "###CSWEB_DEFAULT_TABLE_SETTINGS###",
            "configurations": {},
        })
        table_settings.load_all_settings = lambda: load_all_settings(
            table_settings)

    def _test_data(self):
        base = os.path.dirname(os.path.abspath(__file__))
        return (base,
                os.path.join(base, "testdata", "valid.json"),
                os.path.join(base, "testdata", "invalid.json"))

    def test_read_and_write(self):
        self._read_and_write()

    def test_register_file(self):
        instance = self.__cls__()
        self._clear_default(instance)
        self.assertEqual(instance.files, set())
        for fname in ["a", "b", "a", 1, None]:
            instance._register_file(fname)
        self.assertEqual(instance.files, set(["a", "b", 1, None]))

    def test_register_file_by_signal(self):
        instance = self.__cls__()
        self._clear_default(instance)
        self.assertEqual(instance.files, set())

        @sig.connect(TEST_REGISTER_TABLE_SETTINGS)
        def new(func):
            func("NEW")

        @sig.connect(TEST_REGISTER_TABLE_SETTINGS)
        def old(func):
            func("OLD")

        result = set()
        sig.emit(TEST_REGISTER_TABLE_SETTINGS)(lambda fname: result.add(fname))

        self.assertEqual(set(["NEW", "OLD"]).difference(result), set())

    def test_load_file(self):
        _, valid, invalid = self._test_data()

        self.assertEqual(self.__cls__().load_file(valid), {"key": "value"})

        with self.assertRaises(ValueError):
            self.__cls__().load_file(invalid)

    def test_load_all_settings(self):
        _, valid, _ = self._test_data()
        instance = self.__cls__()
        self._clear_default(instance)
        instance.load_all_settings()
        self.assertEqual(instance.loaded_settings, {})

        instance.files.add(valid)

        instance.load_all_settings()
        self.assertEqual(instance.files, set([valid]))
        self.assertEqual(instance.loaded_settings, {"key": "value"})

    def test_create_default_settings(self):
        _, valid, _ = self._test_data()
        instance = self.__cls__()
        self._clear_default(instance)

        instance.files = set([valid])
        instance.create_default_settings()
        self.assertEqual(instance.files, set([valid]))

        self.assertEqual(instance.loaded_settings, {"key": "value"})
        self.assertEqual(instance.read(use_cache=False), {
            "lastUsed": "###CSWEB_DEFAULT_TABLE_SETTINGS###",
            "configurations": {"key": "value"},
        })

    def test_extend_user_settings(self):
        _, valid, _ = self._test_data()
        instance = self.__cls__()
        self._clear_default(instance)

        # prepare different user settings
        instance.write({"noconf": "val"}, persno="noconf")
        instance.write({"configurations": {"other": "val"}}, persno="nokey")
        instance.write({"configurations": {"key": "original"}},
                       persno="original")

        instance.files = set([valid])
        instance.load_all_settings()
        instance.extend_user_settings()
        self.assertEqual(instance.files, set([valid]))

        # all user settings have "configurations.key" now
        self.assertEqual(instance.read(persno="noconf", use_cache=False), {
            "noconf": "val",
            "configurations": {"key": "value"},
        })
        self.assertEqual(instance.read(persno="nokey", use_cache=False), {
            "configurations": {
                "other": "val",
                "key": "value",
            },
        })
        self.assertEqual(instance.read(persno="original", use_cache=False), {
            "configurations": {"key": "original"},
        })


# Allow running this testfile directly
if __name__ == "__main__":
    unittest.main()
