#!/usr/bin/env powerscript
# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
"""
Measure performance (runtime) of initial fetch and render.

"""
# TODO record number of SQL statements in web session
# TODO add relationship data to test tasks for more realistic runtimes
import sys
import time
from selenium import webdriver
from selenium.webdriver.support import wait
from pyperf.bench import Bench
from pyperf.timer import Timer
from cdb import sqlapi
from cdb import testcase
from cdb import transactions
from cdb import validationkit
from cdb.objects.org import CommonRoleSubject
from cdb.plattools import killableprocess
from cdb.uberserver import usutil
from cdb.uberserver.management import Management
from cs.taskmanager.conditions import getConditions
from cs.taskmanager.settings import DebugMode
from cs.taskmanager.web.main import MOUNTEDPATH
from cs.taskmanagertest import TestTaskOLC


def ensure_running_svcd():
    svc = Management()
    if svc._check_if_its_up(usutil.UBERSERVER):
        return None
    else:
        svc.start()
        return svc


def terminate_svcd(svcd):
    if svcd:
        try:
            svcd.shutdown()
        except Exception as ex:
            print ex
            if sys.platform == "win32":
                # workaround for shutdown method not functioning properly (on
                # windows)
                killableprocess.call(
                    ['taskkill', '/f', '/t', '/im', 'cdbsvcd.exe'])


class InitialLoadTestCase(Bench):
    """
    Loads a large number of simple test tasks and measures the time it takes
    to fetch and render them.
    """
    __url__ = "{{}}{}".format(MOUNTEDPATH.strip("/"))
    __webdriver_timeout__ = 60
    __fetch_timeout__ = 600

    def setUpClass(self):
        testcase.run_level_setup()
        self.svcd = None
        self.logged_in = None
        self.user = None
        self.originals = []
        self.backup = []

        try:
            self.create_testdata()
        except:
            self.tearDownClass()
            raise

        self.svcd = ensure_running_svcd()
        self.base_url = validationkit.util.get_server_url()
        self.url = self.__url__.format(self.base_url)
        self.login()

    def tearDownClass(self):
        self.remove_testdata()
        self.logout()
        terminate_svcd(self.svcd)

    __test_user__ = "tasks_perftest"
    __test_task_prefix__ = "Test Task"

    def create_testdata(self):
        with transactions.Transaction():
            sqlapi.SQLupdate("cs_tasks_test_class SET active=0 WHERE name IN "
                             "('Simple Test 1', 'Simple Test 2')")
            self.user = validationkit.util.generateUser(self.__test_user__)
            DebugMode.activate(self.user.personalnummer)
            self.originals = TestTaskOLC.Query()
            self.backup = self.originals.status
            self.originals.Update(status=42)

            for i in range(self.args["number_of_tasks"]):
                TestTaskOLC.Create(
                    name="{} {}".format(self.__test_task_prefix__, i + 1),
                    status=0,
                    cdb_status_txt="NEW",
                    subject_id=self.__test_user__,
                    subject_type="Person",
                )

    def remove_testdata(self):
        with transactions.Transaction():
            sqlapi.SQLupdate("cs_tasks_test_class SET active=1 WHERE name IN "
                             "('Simple Test 1', 'Simple Test 2')")
            if self.user:
                CommonRoleSubject.KeywordQuery(
                    subject_id=self.user.personalnummer).Delete()
                self.user.Delete()

            TestTaskOLC.Query("name LIKE '{} %%'".format(
                self.__test_task_prefix__)).Delete()

            for i, original in enumerate(self.originals):
                original.Update(status=self.backup[i])

    def getWebElement(self, **kwargs):
        """
        Locates a single element by means of WebDriverWait and
        find_element_by... functions.

        `kwargs` must contain at least one of these keys:

        +-----------+-------------------------------+
        | key       | mapped function               |
        +===========+===============================+
        | byID      | find_element_by_id            |
        +-----------+-------------------------------+
        | byClass   | find_element_by_class_name   |
        +-----------+-------------------------------+

        The first key containing a non-empty value will be used.
        """
        def _locate(function):
            # may raise selenium.common.exceptions.TimeoutException
            return wait.WebDriverWait(
                self.driver, self.__webdriver_timeout__).until(function)

        locators = [
            ("byId", "find_element_by_id"),
            ("byClass", "find_element_by_class_name"),
        ]

        for arg, locator in locators:
            value = kwargs.get(arg, None)
            if value:
                return _locate(lambda d: getattr(d, locator)(value))

    def login(self):
        self.driver = webdriver.Chrome()
        self.logged_in = validationkit.util.login_webdriver(
            self.driver, username=self.user.login, password=self.user.password)
        assert self.logged_in, "user could not be logged in"

    def logout(self):
        if self.logged_in and self.driver:
            validationkit.util.logout_webdriver(self.driver)
            self.driver.quit()

    def _open_taskmanager(self):
        self.driver.get(self.url)
        fetch_info = self.getWebElement(
            byClass="cs-taskmanager-web-debug-info__fetching")

        now = time.clock()
        end = now + self.__fetch_timeout__

        while True:
            if fetch_info.get_attribute("data-fetching") == "false":
                break
            time.sleep(.2)
            now = time.clock()
            if now > end:
                raise RuntimeError("timed out waiting for data fetch")

        tasks_info = self.getWebElement(
            byClass="cs-taskmanager-web-debug-info__tasks")
        loaded_tasks = int(tasks_info.get_attribute("data-tasks"))

        assert loaded_tasks == self.args["number_of_tasks"], (
            "found {} tasks, expected {}".format(loaded_tasks,
                                                 self.args["number_of_tasks"]))

    def _warmup(self):
        self._open_taskmanager()

    def bench_load_uniform_tasks(self):
        times = []
        self._warmup()

        for _ in range(self.args["iterations"]):

            with Timer() as t:
                self._open_taskmanager()

            times.append(t.elapsed.total_seconds())

        self.storeResult(times, name="bench_runtime", type="time_series")
