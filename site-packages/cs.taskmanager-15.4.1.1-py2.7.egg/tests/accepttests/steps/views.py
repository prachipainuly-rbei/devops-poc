#!/usr/bin/env powerscript
# -*- python -*- coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/
#

import json
from contextlib import contextmanager
from cdb import sqlapi
from cdb.validationkit import given
from cdb.validationkit import then
from cdb.validationkit import when
from cs.taskmanager.settings import AppSettings
from cs.taskmanager.user_views import UserView
from cs.taskmanager.web.webdriver_support import IS_BUILDBOT

CONDITION_TABLE = "cs_tasks_user_view_condition"


@contextmanager
def dialog(driver, open_modal):
    open_modal(driver)
    driver.WaitUntilModalOpened()
    yield True
    driver.confirmModal()
    driver.WaitUntilModalClosed()


def openViewsMenu(driver):
    driver.GetAndClick(byClass="cs-taskmanager-web-user-views")
    # fails if we have so many views a submenu is used


def getViewsFromMenu(driver):
    openViewsMenu(driver)
    # fails if we have so many views a submenu is used
    return driver.GetElement(
        multi=True,
        byCSS=".custom-breadcrumb "
              ".cs-taskmanager-web-user-views "
              ".dropdown-menu "
              ".cs-web-components-base-menu__item"
    )


def openManageViewsModal(driver):
    openViewsMenu(driver)
    driver.GetAndClick(byClass="cs-taskmanager-web-open-view-dialog")


def openSaveViewAsModal(driver):
    openViewsMenu(driver)
    driver.GetAndClick(byClass="cs-taskmanager-web-save-current-view-as")


@given('^user view "(?P<view_name>.+)" exists$')
def userViewExists(context, view_name):
    view = UserView.Create(
        name_de=view_name,
        name_en=view_name,
        subject_id=context.user.personalnummer,
        subject_type="Person",
        category="user",
    )
    sqlapi.Record(
        CONDITION_TABLE,
        cdb_object_id=view.cdb_object_id,
        zeile=0,
        text=json.dumps({
            "contexts": [],
            "roles": False,
            "deadline": None,
            "users": [context.user.personalnummer],
            "types": [],
        })
    ).insert()


@given('^user view "(?P<view_name>.+)" filters type "(?P<classname_de>.+)"$')
def viewFiltersByType(context, view_name, classname_de):
    classes = sqlapi.RecordSet2(
        "switch_tabelle",
        "d_ueberschrift='{}'".format(classname_de)
    )

    if not classes:
        raise AssertionError("class '{}' does not exist".format(classname_de))

    condition = {
        "contexts": [],
        "roles": False,
        "deadline": None,
        "users": [context.user.personalnummer],
        "types": [c.classname for c in classes],
    }

    views = UserView.KeywordQuery(name_de=view_name)

    if not views:
        raise AssertionError("view '{}' does not exist".format(view_name))

    for view in views:
        sqlapi.SQLdelete("FROM {} WHERE cdb_object_id='{}'".format(
            CONDITION_TABLE, view.cdb_object_id
        ))
        sqlapi.Record(
            CONDITION_TABLE,
            cdb_object_id=view.cdb_object_id,
            zeile=0,
            text=json.dumps(condition)
        ).insert()


@given('^the current view is "(?P<view_name>.+)"$')
def givenCurrentViewIs(context, view_name):
    # simple "by name", ignores access, may break with custom data
    for view in UserView.KeywordQuery(name_de=view_name):
        settings = AppSettings.read(context.user.personalnummer)
        settings["currentUserView"] = view.cdb_object_id
        AppSettings.write(settings, context.user.personalnummer)
        return None

    raise AssertionError("view '{}' does not exist".format(view_name))


@when('^user switches the view to "(?P<view_name>.+)"$')
def userSwitchesViewTo(context, view_name):
    views = getViewsFromMenu(context.webdriver)

    for view in views:
        if view.text == view_name:
            context.webdriver.Click(view)
            context.webdriver.waitForAsyncActions()
            return None

    raise AssertionError("view '{}' not found".format(view_name))


@when('^user renames view "(?P<view_name>.+)" to "(?P<new_name>.+)"$')
def userRenamesView(context, view_name, new_name):
    tr_selector = "tr[data-view-name='{}']".format(view_name)

    with dialog(context.webdriver, openManageViewsModal):
        context.webdriver.GetAndClick(
            byCSS="{} .cs-taskmanager-web-manage-views-name__label".format(
                tr_selector
            )
        )
        context.webdriver.WaitForAnimation()  # wait for input to be rendered
        view_input = context.webdriver.GetElement(
            byCSS="{} input".format(tr_selector)
        )
        view_input.clear()
        context.webdriver.SendKeys(view_input, new_name)
        view_input.send_keys(context.webdriver.Keys.RETURN)
        context.webdriver.waitForAsyncActions()


@when('^user saves the current view$')
def userSavesCurrentView(context):
    openViewsMenu(context.webdriver)
    context.webdriver.GetAndClick(byClass="cs-taskmanager-web-save-current-view")
    context.webdriver.waitForAsyncActions()


@when('^user saves the current view as "(?P<new_name>.+)"$')
def userSavesCurrentViewAs(context, new_name):
    with dialog(context.webdriver, openSaveViewAsModal):
        name_input = context.webdriver.GetElement(byName="save-as")
        context.webdriver.SendKeys(name_input, new_name)

    context.webdriver.waitForAsyncActions()


@when('^user (?P<action>delete|revert)s the view "(?P<view_name>.+)"$')
def userDeletesOrRevertsView(context, action, view_name):
    with dialog(context.webdriver, openManageViewsModal):
        context.webdriver.GetAndClick(
            byCSS="tr[data-view-name='{}'] "
                  ".cs-taskmanager-web-manage-views__{}".format(
                      view_name, action
                  )
        )

    context.webdriver.waitForAsyncActions()


@then('^the current view is "(?P<view_name>.+)"$')
def thenCurrentViewIs(context, view_name):
    views = context.webdriver.GetElement(byClass="cs-taskmanager-web-user-views")
    assert views.text == view_name, "current view '{}' != '{}'".format(
        views.text, view_name
    )


@then('^the current view is not edited$')
def currentViewIsNotEdited(context):
    view_children = context.webdriver.GetElement(
        multi=True,
        byCSS="#cs-taskmanager-web-user-views > span"
    )
    edited_class = ".cs-taskmanager-web-user-views__edited"

    for child in view_children:
        if child.get_attribute("class").find(edited_class) > -1:
            raise AssertionError("current view is edited")


@then('^the (?P<filter_name>type|context) filter is "(?P<expected>.+)"$')
def thenFilterValueIs(context, filter_name, expected):
    filter_dropdown = context.webdriver.GetElement(
        byCSS="#cs-taskmanager-web-{}-filter > span".format(filter_name)
    )
    assert filter_dropdown.text == expected, (
        "current {} filter is '{}', expected '{}'".format(
            filter_name, filter_dropdown.text, expected
        )
    )


@then('^the view "(?P<view_name>.+)" is (?P<action>deletable|revertable)$')
def viewIsDeletableOrRevertable(context, view_name, action):
    if action == "deletable":
        expected = "cs-taskmanager-web-manage-views__delete"
    elif action == "revertable":
        expected = "cs-taskmanager-web-manage-views__revert"

    with dialog(context.webdriver, openManageViewsModal):
        button = context.webdriver.GetElement(
            byCSS="tr[data-view-name='{}']"
                  " > :last-child"
                  ".cs-taskmanager-web-manage-views-button-col"
                  " > button".format(view_name)
        )
        assert button.get_attribute("class").find(expected) > -1, (
            "view is not {}".format(action)
        )


@then('^the view "(?P<view_name>.+)" does not exist$')
def viewDoesNotExist(context, view_name):
    views = getViewsFromMenu(context.webdriver)

    for view in views:
        if view.text == view_name:
            raise AssertionError("view '{}' does exist".format(view_name))
