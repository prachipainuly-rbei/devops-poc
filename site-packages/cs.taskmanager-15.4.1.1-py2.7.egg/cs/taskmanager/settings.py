# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#
# Version:  $Id: settings.py 180930 2018-07-23 15:17:07Z cso $

"""
Handle access to cdb_usr_setting
"""
import os
import json
from cdb import misc
from cdb import sig
from cdb import sqlapi
from cdb import transaction
from cdb import util
from cdb.lru_cache import lru_cache

REGISTER_TABLE_SETTINGS = sig.signal()


def update_all_settings():
    with transaction.Transaction():
        AppSettings.create_default_settings()
        TableSettings().extend_user_settings()


def read_settings(id1, id2, persno, use_cache=True):
    """
    Read user setting identified by ``id1`` and ``id2`` for user ID ``persno``.

    If ``use_cache`` is ``False``, invalidate the settings cache just before
    accessing the settings.
    """
    p = util.PersonalSettings()

    if not use_cache:
        p.invalidate()

    result_str = p.getValueOrDefaultForUser(id1, id2, None, persno)

    try:
        result = json.loads(result_str)
    except (TypeError, ValueError):
        raise ValueError("invalid settings '{}', no JSON".format(result_str))

    if not isinstance(result, dict):
        raise TypeError("invalid settings '{}', need dict".format(result))

    return result


def write_settings(id1, id2, cdb_setting, persno):
    """
    Write user setting identified by ``id1`` and ``id2`` for user ``persno``.
    Settings will always be written as ``cdb_usr_setting_long`` objects,
    regardless of the value's length.

    The value of ``cdb_setting`` has to be JSON-serializable.
    """
    value = json.dumps(cdb_setting)
    where = ("setting_id='{}' AND setting_id2='{}' "
             "AND personalnummer='{}'".format(sqlapi.quote(id1),
                                              sqlapi.quote(id2),
                                              sqlapi.quote(persno)))

    with transaction.Transaction():
        for table in ["cdb_usr_setting", "cdb_usr_setting_long_txt"]:
            sqlapi.SQLdelete("FROM {} WHERE {}".format(table, where))

        new_settings = sqlapi.Record(
            "cdb_usr_setting",
            setting_id=id1,
            setting_id2=id2,
            personalnummer=persno,
            value="",
            cdb_classname="cdb_usr_setting_long")
        new_settings.insert()
        util.text_write(
            "cdb_usr_setting_long_txt",
            ["setting_id", "setting_id2", "personalnummer"],
            [id1, id2, persno],
            value)


class SettingsBase(object):
    __default_user__ = "cs.taskmanager.dflt"

    @classmethod
    def read(cls, persno=None, use_cache=True):
        persno = persno or cls.__default_user__
        try:
            result = read_settings(cls.__id1__, cls.__id2__, persno, use_cache)
        except (ValueError, TypeError):
            if persno == cls.__default_user__:
                misc.log_error("no default settings {}.{}".format(
                    cls.__id1__, cls.__id2__))
                return {}
            else:
                # get default value, persist for persno and return it
                default = read_settings(
                    cls.__id1__, cls.__id2__, cls.__default_user__, use_cache)
                cls.write(default, persno=persno)
                return default

        return result

    @classmethod
    def write(cls, cdb_setting, persno=None):
        persno = persno or cls.__default_user__
        write_settings(cls.__id1__, cls.__id2__, cdb_setting, persno)


class AppSettings(SettingsBase):
    """Application-level settings for cs.taskmanager"""
    __id1__ = "cs.taskmanager"
    __id2__ = "settings"
    __fallback__ = {
        "notificationInterval": 900000,  # 15 min
    }

    @classmethod
    def read(cls, persno=None, use_cache=True):
        result = super(AppSettings, cls).read(persno, use_cache)

        if not result:
            result = cls.__fallback__
            misc.log_error("resorting to fallback '{}'".format(result))
            cls.write(result, persno)

        return result

    @classmethod
    def create_default_settings(cls):
        cls.write(cls.__fallback__)


class TableSettings(SettingsBase):
    """
    Tasks table settings for cs.taskmanager

    To register a default settings file from a plugin:

    .. code-block:: python

        import os
        import sys
        from cdb import sig
        from cs.taskmanager import settings

        APPDIR = os.path.dirname(__file__.decode(sys.getfilesystemencoding()))

        @sig.connect(settings.REGISTER_TABLE_SETTINGS)
        def register_table_settings(register_file):
            register_file(os.path.join(APPDIR, "table_settings.json"))
    """
    __id1__ = "cs.webcomponents.table"
    __id2__ = "cs-taskmanager-web-tasks-table"
    __default_settings__ = os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        "table_settings.json")

    @classmethod
    def _get_fallback(cls):
        from cs.taskmanager.conf import Column
        return {
            "lastUsed": "###CSWEB_DEFAULT_TABLE_SETTINGS###",
            "configurations": {
                "": {
                    "orderedColumns": Column.Query().name,
                },
            },
        }

    @classmethod
    def read(cls, persno=None, use_cache=True):
        result = super(TableSettings, cls).read(persno, use_cache)

        if not result:
            result = cls._get_fallback()
            misc.log_error("resorting to fallback '{}'".format(result))
            cls.write(result, persno)

        return result

    REGISTER = staticmethod(REGISTER_TABLE_SETTINGS)  # compatibility

    def __init__(self):
        self.files = set([self.__default_settings__])
        self.loaded_settings = {}

    @classmethod
    def register_file(cls, fname):
        """for compatibility with older plugins"""
        misc.log_error("outdated tasks_plugin detected; please use the "
                       "callback given in the signal parameters")

    def _register_file(self, fname):
        """called by tasks_plugins when self.REGISTER is emitted"""
        self.files.add(fname)

    @classmethod
    @lru_cache(maxsize=20, clear_after_ue=False)
    def load_file(cls, filepath):
        """return json string read from filepath"""
        with open(filepath, "r") as f:
            result = json.load(f)
        return result

    def load_all_settings(self):
        """
        emit signal for plugins to register their table setting files and load
        them
        """
        sig.emit(REGISTER_TABLE_SETTINGS)(self._register_file)
        for filepath in self.files:
            self.loaded_settings.update(self.load_file(filepath))

    def create_default_settings(self):
        self.load_all_settings()
        self.write({
            "lastUsed": "###CSWEB_DEFAULT_TABLE_SETTINGS###",
            "configurations": self.loaded_settings,
        })

    def extend_user_settings(self):
        """
        Extend existing user settings by adding new keys from default settings.
        Already existing keys will neither be removed nor modified.
        """
        config = "configurations"
        self.create_default_settings()
        default_settings = self.read(use_cache=False)
        default_config = default_settings[config] or {}

        users = sqlapi.RecordSet2(
            sql="SELECT personalnummer FROM cdb_usr_setting "
                "WHERE setting_id='{0.__id1__}' "
                "AND setting_id2='{0.__id2__}'".format(self))

        for existing in users:
            usr_settings = self.read(persno=existing.personalnummer)

            if config not in usr_settings.keys():
                usr_settings[config] = {}

            # extend existing value with new keys
            for k in default_config.keys():
                if k not in usr_settings[config].keys():
                    usr_settings[config][k] = default_config[k]

            self.write(usr_settings, persno=existing.personalnummer)


class DebugMode(SettingsBase):
    """
    Enables or disables frontend debug mode for a single user.

    .. code-block:: python

        from cs.taskmanager.settings import DebugMode

        DebugMode.activate("caddok")
        DebugMode.deactivate("caddok")

    """
    __id1__ = "cs.taskmanager"
    __id2__ = "debugMode"

    @classmethod
    def _set(cls, active, persno=None):
        cls.write({"active": active}, persno)

    @classmethod
    def activate(cls, persno=None):
        cls._set(True, persno)

    @classmethod
    def deactivate(cls, persno=None):
        cls._set(False, persno)
