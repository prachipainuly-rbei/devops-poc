# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#
# Version:  $Id: conf.py 182922 2018-08-28 08:44:43Z cso $
# pylint: disable=W0212

"""
cs.taskmanager configuration
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: conf.py 182922 2018-08-28 08:44:43Z cso $"

from collections import defaultdict

from cdb import auth
from cdb import kernel
from cdb import misc
from cdb import sqlapi
from cdb import transaction
from cdb import ue
from cdb import util
from cdb.lru_cache import lru_cache
from cdb.objects import ByID
from cdb.objects import ClassNameBrowser
from cdb.objects import Forward
from cdb.objects import Object
from cdb.objects import Reference_1
from cdb.objects import Reference_N
from cdb.objects import ReferenceMethods_1
from cdb.objects.core import ClassRegistry
from cdb.platform.gui import Message
from cs.taskmanager.eval import evaluate

fTaskClass = Forward(__name__ + ".TaskClass")
fContext = Forward(__name__ + ".TaskClassContext")
fRelship = Forward(__name__ + ".TaskClassRelship")
fAttribute = Forward(__name__ + ".Attribute")
fColumn = Forward(__name__ + ".Column")
fRule = Forward("cdb.objects.Rule")
fObject = Forward("cdb.objects.Object")
fClassDef = Forward("cdb.platform.mom.entities.Class")

SYSTEM_COLUMN_OIDS = set([
    "96e333a1-3deb-11e6-bec7-00aa004d0001",  # deadline
    "5204d021-3dde-11e6-b91d-00aa004d0001",  # read_status
    "ef25d8de-76d7-11e6-a4bf-68f7284ff046",  # overdue
])
SYSTEM_COLUMN_NAMES = set([
    "cs_tasks_col_deadline",
    "cs_tasks_col_read_status",
    "cs_tasks_col_overdue",
])


@lru_cache(maxsize=None, clear_after_ue=False)
def get_cache():
    """returns pseudo-singleton Cache instance"""
    return Cache()


class TaskClass(Object):
    """
    Defines a class of task-like objects and how to display them.

    Tasks matching this class definition are identified using an Object Rule,
    which has to be queryable, since it is compiled to a view
    ``cs_tasks_headers_v`` to support fast access.

    - **name**: Unique name.
    - **classname**: Name of an Elements class.
    - **rule_id**: Name of an Object Rule identifying tasks to be displayed for
      a user. Will usually involve a user-specific variable, such as
      ``$(role)`` or ``$(persno)``.
    - **activities_context**: (Optional) Name of a Powerscript Reference_1 to
      be used as the channel for the task's activity stream. If empty, the task
      itself will be used.

    The mapping to the tasks table is derived from the :ref:`cs-tasks-attr`
    relationship containing the class's attribute definitions.

    TaskClasses may also specify a number of different :ref:`cs-tasks-plugins`,
    a :ref:`cs-tasks-context`, and :ref:`cs-tasks-relships`.
    """
    __maps_to__ = "cs_tasks_class"
    __classname__ = "cs_tasks_class"

    Attributes = Reference_N(
        fAttribute,
        fAttribute.tclass_object_id == fTaskClass.cdb_object_id)
    Rule = Reference_1(fRule, fTaskClass.rule_id)
    ObjectsClass = ReferenceMethods_1(
        fObject, lambda self: self.getClassObjectByClassName(self.classname))
    ClassDef = Reference_1(fClassDef, fTaskClass.classname)

    Context = Reference_N(
        fContext,
        fContext.tclass_object_id == fTaskClass.cdb_object_id,
        order_by="position")
    Relships = Reference_N(
        fRelship,
        fRelship.tclass_object_id == fTaskClass.cdb_object_id,
        order_by="position")

    def validate(self, ctx=None):
        """raise Exception if TaskClass configuration is invalid"""
        from cs.taskmanager.mapping import HEADER_VIEW

        # identify propnames (persistent or volatile)
        attrs = [a.propname for a in self.Attributes]
        if ctx:
            keys = [
                x for x in ctx.dialog.get_attribute_names()
                if x.startswith("cs_tasks_col_")]
            if keys:
                attrs = [ctx.dialog[x] for x in keys if ctx.dialog[x]]

        # get object to test with
        task_oids = sqlapi.RecordSet2(
            sql="SELECT cdb_object_id FROM {} "
                "WHERE persno='{}' "
                "AND task_classname='{}'".format(
                    HEADER_VIEW, auth.persno, self.name
                )
        )
        obj = ByID(task_oids[0].cdb_object_id) if task_oids else None

        def _validate(condition, error, *args):
            if not condition:
                return Message.GetMessage(error, *args)

        # perform actual tests
        errors = [
            # REST API activated for task's classdef?
            _validate(
                (self.ClassDef.rest_visible_name and
                 self.ClassDef.rest_api_active),
                "cs_tasks_validator_rest_api"
            ),
            _validate(attrs, "cs_tasks_validator_no_attributes")
        ]

        # interface fully available? either from mixin or custom implementation
        for attr in attrs:
            errors.append(
                _validate(
                    # note: false positives possible, because evaluate may
                    # correctly return a None, False, 0, or "" value
                    obj and evaluate(obj, attr),
                    "cs_tasks_validator_interface",
                    attr
                )
            )

        errors = [e for e in errors if e is not None]

        for sysattr in self.Attributes.KeywordQuery(
                column_object_id=SYSTEM_COLUMN_OIDS):
            misc.log_error("Remove obsolete system attribute mapping for "
                           "column '{}' in task class '{}'.".format(
                               sysattr.Column.name, self.name))

        if errors:
            raise ue.Exception("just_a_replacement", "\n".join(errors))

    def runValidate(self, ctx):
        if not ctx.error:
            ctx.set_followUpOperation("cs_tasks_validate")

    def runWizard(self, ctx):
        if not ctx.error:
            ctx.set_followUpOperation("cs_tasks_wizard", op_object=self)

    def presetWizard(self, ctx):
        for attr in self.Attributes:
            ctx.set(attr.mapped_column_name, attr.propname)
            col = attr.Column
            ctx.set(attr.mapped_column_name + "_c", col.plugin_component)

    def wizard(self, ctx):
        """help the user complete this task class definition """
        attrs = ctx.dialog.get_attribute_names()
        with transaction.Transaction():
            for col in Column.Query():
                if col.name in attrs:
                    query = {
                        "column_object_id": col.cdb_object_id,
                        "tclass_object_id": self.cdb_object_id,
                    }
                    new = dict(query)
                    new.update({
                        "propname": ctx.dialog[col.name].strip(),
                        "cdb_module_id": ctx.dialog.cdb_module_id,
                    })
                    empty = not new["propname"]
                    old = Attribute.KeywordQuery(**query)
                    if old:
                        if empty:
                            old[0].Delete()
                        else:
                            old[0].Update(**new)
                    else:
                        if not empty:
                            Attribute.Create(**new)

    def getClassObjectByClassName(self, classname):
        tbl = kernel.getPrimaryTableForClass(classname)
        if tbl:
            base_cls = ClassRegistry().find(tbl)
            if base_cls:
                return base_cls._FindLeafClass({"cdb_classname": classname})
        return None

    def checkClass(self, ctx):
        cls = self.getClassObjectByClassName(ctx.dialog.classname)
        if not cls:
            raise ue.Exception("cs_tasks_class_missing", ctx.dialog.classname)
        try:
            list(cls.KeywordQuery(cdb_object_id="--test--"))
        except:
            raise ue.Exception("cs_tasks_oid_missing", ctx.dialog.classname)

    def recompileView(self, ctx):
        if getattr(ctx, "error", None):
            return

        from cs.taskmanager import TaskHeaders
        TaskHeaders.compileToView()

    event_map = {
        ("cs_tasks_validate", "pre_mask"): "validate",
        ("cs_tasks_wizard", "pre_mask"): "presetWizard",
        ("cs_tasks_wizard", "now"): "wizard",
        ("cs_tasks_wizard", "post"): "runValidate",
        (("create", "copy"), "pre"): "checkClass",
        (("create", "copy"), "post"): "runWizard",
        (("create", "copy", "modify", "delete"), "post"): "recompileView",
    }


class TaskClassContext(Object):
    """
    Defines a :ref:`cs-tasks-class`'s context path, which is an ordered list of
    Powerscript Reference names of cardinality 1, into a list of objects,
    resolving the references depth-first:

    - Try to resolve each reference name (once; we don't go down the whole
      rabbit hole) using the object last resolved as the referer.
    - If an object could be resolved, add it to a list of resolved objects.
    - Return the reversed list of the resolved objects.

    For a task class with context ``10: Parent``, ``20: Sibling``,
    ``30: Project``, the context of a task ``T`` would resolve like this
    (actual results are reversed; first path to not include any `None` values
    is returned):

    #. ``T``, ``T.Parent``, ``T.Parent.Sibling``, ``T.Parent.Task.Project``
    #. ``T``, ``T.Parent``, ``T.Parent.Sibling``
    #. ``T``, ``T.Parent``, ``T.Parent.Project``
    #. ``T``, ``T.Parent``
    #. ``T``, ``T.Sibling``, ``T.Sibling.Project``
    #. ``T``, ``T.Project``
    #. ``T``, ``T.Sibling``
    #. ``T``

    - **tclass_object_id**: ``cdb_object_id`` of a task class definition.
    - **position**: Integer, must be unique for this task class.
    - **reference_name**: Name of a Powerscript Reference of cardinality 1.
    """
    __maps_to__ = "cs_tasks_class_context"
    __classname__ = "cs_tasks_class_context"

    TaskClass = Reference_1(fTaskClass, fContext.tclass_object_id)

    def presetPosition(self, ctx):
        ctx.set("position", 10 * (1 + len(self.KeywordQuery(
            tclass_object_id=ctx.dialog.tclass_object_id))))

    event_map = {
        (("create", "copy"), "pre_mask"): "presetPosition",
    }


class TaskClassRelship(Object):
    """
    A :ref:`cs-tasks-class`'s relationship entries are resolved when rendering
    a task's details. If any related objects could be resolved, a ContentBlock
    showing the related objects is rendered.

    - **tclass_object_id**: ``cdb_object_id`` of a TaskClass.
    - **position**: Integer, must be unique for this TaskClass.
    - **reference_name**: Name of a Powerscript Reference.
    - **label**: ID of an Elements label to be used as the ContentBlock's
      title.
    """
    __maps_to__ = "cs_tasks_class_relship"
    __classname__ = "cs_tasks_class_relship"

    TaskClass = Reference_1(fTaskClass, fRelship.tclass_object_id)

    def presetPosition(self, ctx):
        ctx.set("position", 10 * (1 + len(self.KeywordQuery(
            tclass_object_id=ctx.dialog.tclass_object_id))))

    event_map = {
        (("create", "copy"), "pre_mask"): "presetPosition",
    }


class Attribute(Object):
    """
    Attribute mapping of a :ref:`cs-tasks-class`. For each :ref:`cs-tasks-col`
    and TaskClass, up to one Attribute may exist, telling the system how to map
    the Column to tasks of this TaskClass.

    - **tclass_object_id**: ``cdb_object_id`` of a task class definition.
    - **column_object_id**: ``cdb_object_id`` of a column definition.
    - **propname**: An attribute, property, or method of any object of this
      task class. Will be evaluated at runtime using ``cs.taskmanager.eval``.
    """
    __maps_to__ = "cs_tasks_attribute"
    __classname__ = "cs_tasks_attribute"

    TaskClass = ReferenceMethods_1(fTaskClass,
                                   lambda self: ByID(self.tclass_object_id))
    Column = Reference_1(fColumn, fAttribute.column_object_id)

    def initDialog(self, ctx):
        # some setup for the browser "cs_tasks_attributes"
        ClassNameBrowser.Scan(scan_props=True)
        tbl = kernel.getPrimaryTableForClass(self.mapped_cdb_classname)
        if tbl:
            base_cls = ClassRegistry().find(tbl)
            ctx.set("fqpyname", base_cls.GetFQPYName())

    event_map = {
        (("create", "copy", "modify"), "pre_mask"): "initDialog",
    }


class Column(Object):
    """
    Columns define the schema of the tasks table. They may also define a custom
    frontend component to render its cells. If you want to render complex
    values (e.g. no simple strings or numbers), you will want to specify a
    plugin.

    - **name**: ID of a label naming this column.
    - **tooltip**: ID of a label with a more detailed description of this
      column.
    - **plugin_component**: Name of a React component registered in the
      frontend registry. Note that you can only use components of libraries
      already included in the application's header, usually only
      ``cs-taskmanager-web`` itself.
    """
    __maps_to__ = "cs_tasks_column"
    __classname__ = "cs_tasks_column"

    Attributes = Reference_N(
        fAttribute,
        fAttribute.column_object_id == fColumn.cdb_object_id)

    def getTooltip(self):
        if self.tooltip:
            return util.get_label(self.tooltip)


class FilterableContext(Object):
    """
    Class entries representing a context class that is filterable in
    cs-taskmanager-web to be shipped with client modules.
    """
    __maps_to__ = "cs_tasks_context"
    __classname__ = "cs_tasks_context"


class Cache(object):
    """
    Holds everything needed for mapping tasks as a singleton cache to maximize
    backend performance.

    Note: Updates to configuration objects (TaskClass, Column, Attribute)
    during a cdbsrv session have no effect unless the cache is explicitely
    refreshed:

    .. code-block:: python

        from cs.taskmanager import Cache
        Cache.refresh()

    The cache is structured like this:

    .. code-block:: python

        {
            columns: {"column_object_id": ColumnObject},
            classes: {"task_classname": TaskClassObject},
            classnames: ["classname1", ...]
            attributes: {"task_classname": [AttributeObject]},
            context_classnames: ["context_classname1", ...],
        }

    """
    def __init__(self):
        self.initialize()

    @classmethod
    def refresh(cls):
        get_cache().initialize()

    def initialize(self):
        classes = {}
        columns = {c.cdb_object_id: c for c in Column.Query()}
        attributes = defaultdict(list)

        task_classes = TaskClass.Query()

        for task_class in task_classes:
            classes[task_class.name] = task_class
            for attr in task_class.Attributes:
                attributes[task_class.name].append(attr)

        self.classes = classes
        self.classnames = task_classes.classname
        self.columns = columns
        self.attributes = attributes
        self.context_classnames = FilterableContext.Query().classname
