# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#
# Version:  $Id: mapping.py 185258 2018-10-18 11:15:26Z cso $

"""
cs.taskmanager mapping and post-mapping conditions

"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: mapping.py 185258 2018-10-18 11:15:26Z cso $"

from cdb import misc
from cdb import sqlapi
from cdb.lru_cache import lru_cache
from cdb.objects import ByID as _ByID
from cs.taskmanager import HEADER_VIEW
from cs.taskmanager import TaskHeaders
from cs.taskmanager.conditions import applyPostMappingConditions
from cs.taskmanager.conf import get_cache
from cs.taskmanager.conf import TaskClass
from cs.taskmanager.eval import evalDate
from cs.taskmanager.eval import evaluate
from cs.taskmanager.eval import ISOStringToDateTime


def uncachedByID(cdb_object_id):
    obj = _ByID(cdb_object_id)
    if obj and obj.CheckAccess("read"):
        return obj


@lru_cache(maxsize=500)
def ByID(cdb_object_id):
    return uncachedByID(cdb_object_id)


def getMappedTasks(condition):
    """
    public API for cs.taskmanager.web.rest_app

    returns mapped data of all tasks matching given condition the logged in
    user has read access to

    task objects are needed to include task links in rest app view
    """
    ByID.cache_clear()
    task_objects = []
    mapped_tasks = []
    cache = get_cache()

    headers, read_status, deadline = _getHeadersByClass(condition)

    for task_clsname, query in headers.items():
        task_cls = cache.classes.get(task_clsname, None)

        if not task_cls:
            misc.log_error("no task class '{}' found".format(task_clsname))
            continue

        for task in task_cls.ObjectsClass.Query(
                "cdb_object_id IN (SELECT cdb_object_id FROM {} WHERE "
                "{})".format(HEADER_VIEW, query),
                access="read"
        ):
            mapped = _getMappedTaskData(
                task_cls,
                task,
                read_status.get(task.cdb_object_id, False),
                deadline.get(task.cdb_object_id, None),
                cache)

            matches = applyPostMappingConditions(task, condition.contexts)

            if matches and task and mapped:
                task_objects.append(task)
                mapped_tasks.append(mapped)

    return task_objects, mapped_tasks


def getMappedTask(task_object_id):
    """
    public API for cs.taskmanager.web.rest_app_model to reload a single task
    after proceeding it

    get mapped data of single task of user identified by persno
    """
    cache = get_cache()
    header = _getTaskHeader(task_object_id)

    if header:
        task_cls = cache.classes[header.task_classname]
        task = uncachedByID(header.cdb_object_id)

        return _getMappedTaskData(
            task_cls,
            task,
            header.read_status,
            header.deadline,
            cache)

    return None


def TaskClassByTaskOID(task_oid):
    header = _getTaskHeader(task_oid)

    if header:
        for taskClass in TaskClass.KeywordQuery(name=header.task_classname):
            return taskClass


def _getActivitiesContext(task, task_class):
    """return object representing task's configured AS context"""
    context = evaluate(task, task_class.activities_context)

    if isinstance(context, basestring):
        context = ByID(context)

    if not context:
        return task  # fallback to task itself
    else:
        return context


def _getDeadline(deadline):
    if isinstance(deadline, basestring):
        return ISOStringToDateTime(deadline)

    return deadline


def _getAttributeMapping(task, attribute):
    try:
        return evaluate(task, attribute.propname)
    except AttributeError:
        misc.log_traceback("_getAttributeMapping failed")
        return None


def _getMappedTaskData(task_class, task, read, deadline_dt, cache):
    """internal API; get mapped task data from given task record"""
    if not task:
        return None

    result = {
        attr.mapped_column_name: _getAttributeMapping(task, attr)
        for attr in cache.attributes[task_class.name]
    }
    deadline = evalDate(deadline_dt)

    result.update({
        "cdb_object_id": task.cdb_object_id,
        "task_class": task_class.name,
        "activities_context": _getActivitiesContext(task, task_class),
        "cs_tasks_col_read_status": 1 if read else 0,
        "cs_tasks_col_overdue": (deadline.get("overdue", None)
                                 if deadline else False),
        "cs_tasks_col_deadline": deadline,
    })

    return result


def _getTaskHeader(task_object_id):
    """
    internal API

    return a single header for task with cdb_object_id task_object_id.
    """
    stmt = "cdb_object_id='{}'".format(sqlapi.quote(task_object_id))

    for header in TaskHeaders.selectHeaderView(condition=stmt):
        return header

    return None


def _getHeadersByClass(condition):
    """
    internal API

    performance optimization to enable selecting all tasks of each class in one
    go

    return 3-tuple:
    1. headers matching condition grouped by task_classname
    2. read_status grouped by task cdb_object_ids
    3. deadline grouped by task cdb_object_ids
    """
    headers_by_class = sqlapi.RecordSet2(
        sql="SELECT * FROM {} WHERE {} ORDER BY task_classname".format(
            HEADER_VIEW, condition.condition))

    headers = {}
    read_status = {}
    deadline = {}

    for header in headers_by_class:
        query = "task_classname='{}' AND {}".format(
            header.task_classname, condition.condition)
        headers[header.task_classname] = query
        read_status[header.cdb_object_id] = header.read_status
        deadline[header.cdb_object_id] = _getDeadline(header.deadline)

    return headers, read_status, deadline
