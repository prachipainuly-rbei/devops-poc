# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

__revision__ = "$Id: "
__docformat__ = "restructuredtext en"

import json
from cdb import auth
from cdb import CADDOK
from cdb import i18n
from cdb import util
from cdb.objects import ByID
from cdb.objects import Forward
from cdb.objects import ReferenceMethods_1
from cdb.objects import ReferenceMapping_1
from cdb.objects.org import WithSubject
from cdb.platform.gui import CDBCatalog

CATEG_DEFAULT = "default"
CATEG_PRECONFIGURED = "preconfigured"
CATEG_USER = "user"
CATEGORIES = [CATEG_DEFAULT, CATEG_PRECONFIGURED, CATEG_USER]

CURRENT = "currentUserView"
RECENT = "recentUserViews"

fUserView = Forward("{}.UserView".format(__name__))


def resolveUserVariable(user_id):
    variables = {
        "$(persno)": auth.persno,
    }
    return variables.get(user_id, user_id)


class UserView(WithSubject):
    """
    UserView represents a persistent combination of filter values for
    |cs.taskmanager|. They can be marked as defaults and may be user- or
    role-specific.

    Access Control:
    ^^^^^^^^^^^^^^^

    +---------------+-------------------------------+
    | Access Right  | Granted for                   |
    +===============+===============================+
    | read          | - Subjects of user view       |
    +---------------+-------------------------------+
    | FULL ACCESS   | - Owner of personal user view |
    |               | - Common Role "Administrator" |
    +---------------+-------------------------------+
    """
    __maps_to__ = "cs_tasks_user_view"
    __classname__ = "cs_tasks_user_view"
    __condition_attr__ = "cs_tasks_user_view_condition"

    def _get_customizes(self):
        if self.customizes:
            return ByID(self.customizes)

    Customizes = ReferenceMethods_1(fUserView, _get_customizes)
    CustomizedForUser = ReferenceMapping_1(
        fUserView,
        fUserView.customizes == fUserView.cdb_object_id,
        fUserView.subject_type == "Person",
        indexed_by=fUserView.subject_id
    )

    __default_view_queries__ = [
        # subject_id, subject_type
        ("='{}'".format(auth.persno), "='Person'"),
        ("!='public'", "!='Person'"),
        ("='public'", "='Common Role'"),
    ]

    def getCustomizedOrSelf(self):
        if self.category != CATEG_USER:
            customized = self.CustomizedForUser[auth.persno]

            if customized and customized.CheckAccess("read"):
                return customized

        return self

    @classmethod
    def GetCustomAttributes(cls, name=None, condition=None):
        result = {
            "category": CATEG_USER,
            "subject_id": auth.persno,
            "subject_type": "Person",
        }

        if name:
            for isolang in i18n.getActiveGUILanguages():
                attr = "name_{}".format(isolang)
                result[attr] = name

        if condition:
            result[cls.__condition_attr__] = condition

        return result

    def toDict(self):
        result = dict(self)
        result[self.__condition_attr__] = self.GetText(self.__condition_attr__)
        return result

    def getCustomCopyAttributes(self, name=None, condition=None):
        result = self.GetCustomAttributes(
            None,
            condition or self.GetText(self.__condition_attr__)
        )
        result["customizes"] = self.cdb_object_id

        for isolang in i18n.getActiveGUILanguages():
            attr = "name_{}".format(isolang)

            if name and isolang == CADDOK.ISOLANG:
                result[attr] = name
            else:
                result[attr] = self[attr]

        return result

    @classmethod
    def GetDefaultView(cls):
        """
        Returns the default view for the current user. It is the first user
        view the current user has read access to in the following list:

        1. The personal default view for the user
        2. The first default view for any role but 'public'
        3. The default view for Common Role 'public'

        If the returned view is customized for the user, the customizes view is
        returned instead.

        :returns: The default view for the current user.
        :rtype: cs.taskmanager.user_views.UserView
        """
        for query in cls.__default_view_queries__:
            query_str = (
                "customizes='' AND category='{}' AND "
                "subject_id{} AND subject_type{}".format(
                    CATEG_DEFAULT, *query
                )
            )
            for default_view in cls.Query(query_str, access="read"):
                return default_view.getCustomizedOrSelf()

    @classmethod
    def ForUser(cls):
        """
        Returns all non-default user views readable by the current user.
        Customized views will be favored over non-customized ones.

        :param cdb_person_id: ID of the user to get the views for. Defaults to
            logged in user's ID.
        :type cdb_person_id: str

        :returns: Set of all UserView objects the current user is granted read
            access for.
        :rtype: set(cs.taskmanager.user_views.UserView)
        """
        all_views = cls.Query(
            # condition is a performance optimization
            # read access is checked and expected to match subject assignment
            "category!='{}' AND "
            "customizes='' AND "
            "(subject_type!='Person' OR subject_id='{}')".format(
                CATEG_DEFAULT, auth.persno
            ),
            access="read",
        )

        return set([
            view.getCustomizedOrSelf()
            for view in all_views
        ])

    def toJSON(self, request=None):
        """
        Returns additional data required by the frontend at runtime. No access
        is checked.

        :returns: JSON dict for with additional frontend runtime data.
        :rtype: dict
        """
        from cs.taskmanager.web.util import classname2restID
        from cs.taskmanager.web.util import oid2restID
        from cs.taskmanager.web.util import userID2restID

        def replace_user(id_or_var, request):
            return userID2restID(resolveUserVariable(id_or_var), request)

        cond = json.loads(self.GetText(self.__condition_attr__))

        # condition holds several lists of object representations:
        #   - types are simple classnames
        #   - contexts are cdb_object_ids
        #   - users are either user IDs or the variable $(persno)
        # all of these are replaced with rest links for the frontend
        for attr, replace_func in [("contexts", oid2restID),
                                   ("types", classname2restID),
                                   ("users", replace_user)]:
            cond[attr] = [
                replace_func(oid, request)
                for oid in cond.get(attr, [])
            ]

        return {
            "edited": False,  # changes in frontend only
            "condition": cond,
        }

    event_map = {
        ("create", "pre"): "fillInTranslations",
        (("create", "copy", "modify"), "pre"): "validate",
    }

    def fillInTranslations(self, ctx=None):
        """
        Utility method for filling in empty internationalized names using the
        name in the current language.

        Relies on ``self.name`` to be filled because it should be mandatory in
        creation dialog.

        :returns: Nothing
        :rtype: None
        """
        non_empty_names = {
            "name_{}".format(attr): value or self.name
            for attr, value in self.GetLocalizedValues("name").items()
        }

        self.Update(**non_empty_names)

    def validate(self, ctx):
        self.Reload()
        errors = []
        categ_is_user = self.category == CATEG_USER

        for attr in [self.__condition_attr__]:
            try:
                json.loads(ctx.dialog[attr])
            except (ValueError, TypeError):
                errors.append(
                    unicode(util.ErrorMessage("cs_tasks_invalid_json", attr)))

        if self.Customizes:
            ctx.set("category", CATEG_USER)
            categ_is_user = True

            if self.Customizes.category == CATEG_USER:
                errors.append(
                    unicode(util.ErrorMessage(
                        "cs_tasks_user_view_no_cust_usr"))
                )

        if categ_is_user:
            if ctx.dialog.subject_type != "Person":
                errors.append(
                    unicode(util.ErrorMessage(
                        "cs_tasks_user_view_no_usr_role"))
                )

        if errors:
            raise util.ErrorMessage("just_a_replacement", "\n".join(errors))


class UserViewCategoryBrowser(CDBCatalog):
    def __init__(self):
        CDBCatalog.__init__(self)

    def handlesSimpleCatalog(self):
        return True

    def getCatalogEntries(self):
        return CATEGORIES
