# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#
# Version:  $Id: mixin.py 183194 2018-08-31 12:19:41Z cso $

"""
provides mixin class to extend custom task classes with
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: mixin.py 183194 2018-08-31 12:19:41Z cso $"

from cdb import auth
from cdb import i18n
from cdb import ue
from cdb import util
from cdb.lru_cache import lru_cache
from cdb.objects import Forward
from cdb.objects import MixIn
from cdb.objects import ReferenceMethods_N
from cdb.objects.org import Subject
from cdb.platform.olc import StateChangeDefinition
from cdb.platform.olc import StatusInfo

from cs.activitystream import PostingRuleChecker
from cs.activitystream.objects import SystemPosting
from cs.platform.web.rest.generic.model import Workflow
from cs.taskmanager.userdata import Tags
from cs.taskmanager.conf import TaskClass

fTaskClass = Forward("cs.taskmanager.conf.TaskClass")


@lru_cache(maxsize=500, clear_after_ue=True)
def getCsTasksObject(obj):
    if obj and obj.CheckAccess("read"):
        return obj


class WithTasksIntegration(MixIn):
    """
    MixIn to include in classes to be displayed by cs.taskmanager for easy
    setup. Mainly provides getters for composite attributes and the "proceed"
    operation.
    """
    __mixin_active__ = True
    __cs_tasks_proceed_access__ = None
    __cs_tasks_delegate_msg__ = "cs_tasks_delegate"

    def _getCsTasksTaskClasses(self):
        classes = [self.GetClassname()]
        classes.extend(self.GetClassDef().getBaseClassNames())
        return TaskClass.KeywordQuery(classname=classes)

    CsTasksTaskClasses = ReferenceMethods_N(fTaskClass, _getCsTasksTaskClasses)

    event_map = {
        ("cs_tasks_delegate", "pre_mask"): "preset_csTasksDelegate",
        ("cs_tasks_delegate", "now"): "csTasksDelegate",
    }

    def csTasksDelegate_get_project_manager(self):
        """
        Usable by tasks with Project reference (not used by cs.taskmanager
        itself).

        The delegation dialog has to contain the context ID (cdb_project_id)
        attribute (usually hidden).
        """
        from cs.pcs.projects import kProjectManagerRole  # pylint: disable=no-name-in-module
        name = self.Project.getProjectManagerName()
        if name:
            return kProjectManagerRole, "PCS Role", name

        return "", "", ""

    def csTasksDelegate_get_default(self):
        """
        Overwrite this for task objects having an "80%" correct delegation
        target, e.g. a person managing the parent object.

        Always return a 3-tuple of subject_id, subject_type, subject_name. If
        subject_id is not empty, the values will be used to preset the
        operation.
        """
        return "", "", ""

    def preset_csTasksDelegate(self, ctx):
        subj_id, subj_type, subj_name = self.csTasksDelegate_get_default()
        if subj_id:
            ctx.set("subject_id", subj_id)
            ctx.set("subject_type", subj_type)
            ctx.set("subject_name", subj_name)

    def csTasksDelegate(self, ctx):
        """
        Overwrite this for task objects without "subject logic", e.g. those,
        that use other attributes to identify responsible user(s).

        Note that you will also have to modify the operation dialog for these
        task classes.
        """
        old = {}

        if self.Subject:
            subject_id = self.Subject.SubjectID()
            old = {
                "subject_id": subject_id[0],
                "subject_type": self.Subject.SubjectType()
            }

        new = {
            "subject_id": ctx.dialog.subject_id,
            "subject_type": ctx.dialog.subject_type,
        }

        # only update if old and new values differ
        if old != new:
            # delegate, fire post actions (cs.web operation does not do so)
            self.Update(**new)
            self._csTasksDelegatePost(ctx, old, new)

    def _csTasksSysPostingVals(self, old, new):
        def _adapt_value(attribute, attr_value):
            try:
                attr_value = attr_value[:util.tables["cdbblog_posting"].column(
                    attribute).length()]
            except (ValueError, AttributeError):
                pass
            return attr_value.replace("\\n", "\n")

        values = {
            "context_object_id": self.cdb_object_id,
            "type": "update",
        }

        old_values = dict(self)
        old_values.update(old)
        new_values = dict(self)
        new_values.update(new)

        old_handle = Subject.findSubject(
            SubjectFromContext(**old_values)).ToObjectHandle()
        new_handle = Subject.findSubject(
            SubjectFromContext(**new_values)).ToObjectHandle()

        # Generate a text for all active languages
        for lang in i18n.getActiveGUILanguages():
            msg = util.CDBMsg(util.CDBMsg.kNone,
                              self.__cs_tasks_delegate_msg__)
            msg.addReplacement(old_handle.getDesignation("", lang))
            msg.addReplacement(new_handle.getDesignation("", lang))
            value = msg.getText(lang, True)
            attrname = "title_" + lang
            values[attrname] = _adapt_value(attrname, value)

        return values

    def _csTasksDelegatePost(self, ctx, old, new):
        # it is strongly advised to always create these postings
        if PostingRuleChecker().checkRules(self.ToObjectHandle()):
            SystemPosting.do_create(**self._csTasksSysPostingVals(old, new))

        # send email notification if task class supports it
        if hasattr(self, "sendNotification"):
            self.sendNotification(ctx=None)

    def _csTasksProceedNow(self, proceed_to, **kwargs):
        """
        Overwrite this for task objects without OLC (like checklist items,
        where this will call the "rate" operation).

        A return value of None is treated as a success, others as errors. If
        you want users to see a nice error message, return a dict like this:

        {"error": "nice error message in user's language"}
        """
        try:
            self.ChangeState(proceed_to["status"], **kwargs)
        except RuntimeError, error:
            return {"error": error.message}

    def csTasksProceed(self, proceed_to, request=None, **kwargs):
        """check access if it is specified for this class"""
        if self.__cs_tasks_proceed_access__ and not self.CheckAccess(
                self.__cs_tasks_proceed_access__):
            raise ue.Exception("cs_tasks_proceed_access_denied")
        return self._csTasksProceedNow(proceed_to, **kwargs)

    def getCsTasksType(self, request=None):
        """default implementation for cs_tasks_col_type"""
        return {
            "icon": self.GetClassIcon(),
            "tooltip": self.GetClassDef().getDesignation(),
        }

    def getCsTasksTags(self, request=None):
        """default implementation for cs_tasks_col_tags"""
        return Tags.getTaskTags(auth.persno, self.cdb_object_id)

    def getCsTasksResponsible(self, request=None):
        return getCsTasksObject(self.Subject)

    def getCsTasksStatusData(self, status=None, request=None):
        """
        default implementation for cs_tasks_col_status

        Overwrite this for classes without an Object Lifecycle, that feature
        an alternative status-like attribute.

        Potentially raises an AttributeError if self is missing attribute
        "status" or given status and self's object kind don't correspond to a
        configured OLC status.
        """
        if status is None:
            status = self.status
        else:
            status = status[0]

        info = StatusInfo(self.GetObjectKind(), status)

        return {
            "data": {
                "status": status,
                "label": info.getLabel(),
                "color": info.getCSSColor(),
                "attributes": self.getProceedAttributes(status),
            }
        }

    def getCsTasksProceedData(self, request=None, targets=False):
        """
        Default implementation for cs_tasks_col_proceed

        Returns dict containing the current status's values. If ``targets`` is
        True, the return value also contains values for all possible target
        statuses. If it is False, targets will be resolved asynchronously when
        the user first opens this task's "proceed" dropdown.

        Overwrite this for classes without an Object Lifecycle.

        Potentially raises an AttributeError if self is missing one of the keys
        "cdb_objektart", or "status".
        """
        if not self.GetClassDef().has_workflow():
            return None

        kind = self.GetObjectKind()
        status = self.status

        def _get_prio(target_status):
            sd = StateChangeDefinition.ByKeys(kind, status, target_status)
            return 999999 if sd.rang is None else sd.rang

        wf = Workflow(self)

        targets = [] if not targets else [
            self.getCsTasksStatusData([num], request)
            for num, _ in wf.next_steps()]  # unused "label"

        for t in targets:
            t["data"]["priority"] = _get_prio(t["data"]["status"])

        targets.sort(key=lambda x: (x["data"]["priority"],
                                    x["data"]["status"]))

        return {
            "current": self.getCsTasksStatusData(),
            "targets": targets,
        }

    def getProceedAttributes(self, status):
        """
        Returns a dict of attributes settable when changing the status of task
        ``self`` to ``status``. The dict's keys are the attribute names, its
        values are bools determining if the attribute is mandatory for the
        status change or not.

        For each attribute, a text input is generated. Mandatory attributes
        have to be non-empty in order to allow the status change.

        Example dict:

        .. code-block:: python
            {
                "comment": {
                    "mandatory": True,
                    "label": "Kommentar",  # in current language
                },
                "unnecessary": {
                    "mandatory": False,
                    "label": "unnötig",
                },
            }

        """
        return {}

    def getPluginDiscriminator(self, std_name):
        """
        Returns the name of an additional discriminator that should be used to
        find plugins. `std_name` is the name that is used by the standard if
        this function returns ``None`` or if no specific plugin is configured.
        The plugin in selected by its priority.
        """
        return None

    def getCsTasksContexts(self):
        """
        Returns a list of objects representing the task's context. Used for the
        context filter. Will issue a warning if any object returned is not
        filterable because of missing configuration.
        """
        return []


class SubjectFromContext(object):
    def __init__(self, **kwargs):
        for attr, val in kwargs.items():
            setattr(self, attr, val)
        self._refcache = {}
