# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#
# Version:  $Id: conditions.py 182922 2018-08-28 08:44:43Z cso $
# pylint: disable=C1801,W0212

"""
cs.taskmanager conditions

"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: conditions.py 182922 2018-08-28 08:44:43Z cso $"

from collections import defaultdict
from collections import namedtuple
from datetime import date
from datetime import timedelta

from cdb import misc
from cdb import sqlapi

from cs.taskmanager.eval import ISOStringToDateTime

# Condition tuples contain
# - **users**: A non-empty list of user IDs,
# - **contexts: A list of context IDs (defaults to []) to be applied
#   post-mapping and
# - **condition**: An SQL condition querying for user, type and deadline
CONDITION = namedtuple('TasksCondition', ['users', 'contexts', 'condition'])
PERSONAL_TASKS = "(subject_type IN ('', 'Person') OR subject_type IS NULL)"


# public API for cs.taskmanager.mapping
def getConditions(users, roles=False, types=None, contexts=None,
                  days=None, start=None, end=None):
    if not (isinstance(users, (list, set)) and (len(users) > 0)):
        raise ValueError("users")

    users = [sqlapi.quote(persno) for persno in users]
    types = [sqlapi.quote(classname) for classname in types or []]

    return CONDITION(
        users,
        _getContextCondition(contexts),
        " AND ".join([
            _joinSQLConditions("persno IN ('{}')", users),
            "1=1" if roles else PERSONAL_TASKS,
            _joinSQLConditions("classname IN ('{}')", types),
            _getDeadlineCondition(days, start, end),
        ])
    )


def applyPostMappingConditions(task, contexts=None):
    # if any value in task_row values is of the same type as a context, but has
    # a different oid, return None
    # contexts is either Falsy or a dict {classname: list of keydicts}
    from cs.taskmanager.conf import get_cache
    filterable_classes = get_cache().context_classnames

    if not task:
        return False

    if contexts:
        task_contexts = task.getCsTasksContexts() if hasattr(
            task, "getCsTasksContexts") else []

        for task_context in task_contexts:
            if task_context:
                task_context_class = task_context.GetClassname()
                if task_context_class in filterable_classes:
                    for context_keys in contexts.get(task_context_class, []):
                        if task_context._key_dict() == context_keys:
                            return True
                else:
                    misc.log_error(
                        "class is missing in cs_tasks_context: '{}'".format(
                            task_context_class))
    else:
        return True


def _getContextCondition(contexts=None):
    from cs.taskmanager.mapping import ByID
    result = defaultdict(list)

    for context_object_id in contexts or []:
        context = ByID(context_object_id)
        result[context.GetClassname()].append(context._key_dict())

    return result


def _joinSQLConditions(pattern, conditions, separator=None):
    pattern = pattern or "('{}')"
    separator = separator or "', '"
    return pattern.format(separator.join(conditions)) if conditions else "1=1"


def startOfDay(dt, offset=0):
    return dt + timedelta(
        days=offset,
        hours=-dt.hour,
        minutes=-dt.minute,
        seconds=-dt.second,
        microseconds=-dt.microsecond,
    )


def _getDeadlineCondition(days=None, start=None, end=None):
    def datetimeCondition(dt, operator):
        return "deadline {} {}".format(operator, sqlapi.SQLdate_literal(dt))

    try:
        days = int(days)
    except (TypeError, ValueError):
        days = None

    start = ISOStringToDateTime(start)
    end = ISOStringToDateTime(end)

    deadline = []

    if days is not None:
        max_deadline = date.today() + timedelta(days=days + 1)
        deadline.append(datetimeCondition(max_deadline, "<"))

    if start:
        start = startOfDay(start)
        deadline.append(datetimeCondition(start, ">="))

    if end:
        end = startOfDay(end, 1)
        deadline.append(datetimeCondition(end, "<"))

    return _joinSQLConditions("({})", deadline, " AND ")
