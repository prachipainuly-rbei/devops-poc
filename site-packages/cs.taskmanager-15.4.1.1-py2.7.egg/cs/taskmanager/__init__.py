# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#
# Version:  $Id: __init__.py 183194 2018-08-31 12:19:41Z cso $
# pylint: disable=W0212

"""
cs.taskmanager header view
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: __init__.py 183194 2018-08-31 12:19:41Z cso $"

from cdb import ddl
from cdb import misc
from cdb import sig
from cdb import sqlapi
from cdb import ue
from cdb.objects.rules import Term
from cs.taskmanager.conf import TaskClass

HEADER_VIEW = "cs_tasks_headers_v"


def generate_cs_tasks_headers_v():
    """view containing current tasks and their read status for each user"""
    try:
        # dirty hack - object rule for pcs tasks contains Reference_N from
        # another package, so we have to import it manually
        # pylint: disable=W0612
        from cs.pcs.resources.pcs_extensions import Task
    except ImportError:
        pass
    stmt = TaskHeaders.getCombinedViewStatement()
    if stmt == "":
        # no task classes yet; return dummy statement so generation won't fail
        stmt = """
            SELECT
                name AS task_classname,
                classname,
                '' AS persno,
                0 AS read_status,
                '' AS cdb_object_id,
                '' AS subject_id,
                '' AS subject_type,
                NULL AS deadline
            FROM cs_tasks_class"""
    return stmt


class TaskHeaders(object):
    def __init__(self, task_class):
        self.task_class = task_class

    @classmethod
    def selectHeaderView(cls, *args, **kwargs):
        """
        Wrapper method for RecordSet2 which ensures that the targeted view
        already exists.
        """
        view = ddl.View(HEADER_VIEW)
        if not view.exists():
            cls.compileToView()
        if view.exists():
            return sqlapi.RecordSet2(HEADER_VIEW, *args, **kwargs)
        else:
            return []  # happens e.g. when no plugin is installed

    @classmethod
    def getCombinedViewStatement(cls):
        """union statements of all class instances"""
        return " UNION ".join(cls(t)._getViewStatement(i)
                              for i, t in enumerate(TaskClass.Query()))

    def _getViewStatement(self, index):
        """custom version of cdb.objects.Rule.stmt"""
        kwargs = {"persno": "caddok"}

        if not self.task_class.Rule:
            raise ue.Exception(
                "cs_tasks_invalid_rule",
                self.task_class.rule_id,
                self.task_class.name
            )

        cls = self.task_class.ObjectsClass
        root = self.task_class.Rule._GetNode(cls, **kwargs)
        angestellter = "angestellter{}".format(index)

        base_table = "{} {}".format(root.cls.GetTableName(), root.alias)
        join = root.build_join().split(base_table, 1)[1]

        deadline = ("{}.{}".format(root.alias, self.task_class.deadline)
                    if self.task_class.deadline else "NULL")

        tbl = ddl.Table(root.cls.GetTableName())

        def get_subject_attr(attr):
            return ("{}.{}".format(root.alias, attr)
                    if tbl.hasColumn(attr)
                    else "'' AS {}".format(attr))

        stmt = """
            SELECT
                '{task_class.name}' AS task_classname,
                '{task_class.classname}' AS classname,
                {angestellter}.personalnummer AS persno,
                r.read_status,
                {alias}.cdb_object_id,
                {subject_id},
                {subject_type},
                {deadline} AS deadline
            FROM
                {base_table}
            INNER JOIN angestellter {angestellter} ON 1=1
            {join}
            LEFT JOIN
                cs_tasks_read_status r
                ON r.persno={angestellter}.personalnummer
                AND r.task_object_id={alias}.cdb_object_id
            """.format(task_class=self.task_class,
                       deadline=deadline,
                       subject_id=get_subject_attr("subject_id"),
                       subject_type=get_subject_attr("subject_type"),
                       alias=root.alias,
                       base_table=base_table,
                       join=join,
                       angestellter=angestellter)

        stmt += (
            " WHERE {where} AND "
            "{angestellter}.cdb_classname='angestellter'".format(
                where=unicode(self.task_class.Rule.expr(cls, **kwargs)),
                angestellter=angestellter
            )
        )
        return stmt.replace(
            "'caddok'", "{}.personalnummer".format(angestellter))

    @classmethod
    def compileToView(cls, fail=False):
        """recreates tasks view from current object rules"""
        from cdb.platform.mom.relations import DDUserDefinedView
        view = DDUserDefinedView.ByKeys(HEADER_VIEW)

        try:
            view.rebuild()
            return True
        except RuntimeError:
            misc.log_traceback("compileToView failed")
            if fail:
                raise


@sig.connect(Term, "create", "post")
@sig.connect(Term, "copy", "post")
@sig.connect(Term, "delete", "post")
@sig.connect(Term, "modify", "post")
def compileCsTasksView(self, ctx):
    for x in TaskClass.KeywordQuery(rule_id=self.name):
        TaskHeaders(x).compileToView(ctx)
