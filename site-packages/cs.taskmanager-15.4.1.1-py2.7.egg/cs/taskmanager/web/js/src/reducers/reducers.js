/* -*- mode: javascript; coding: utf-8 -*-
 * $Id: reducers.js 185258 2018-10-18 11:15:26Z cso $
 *
 * Copyright (c) 1990 - 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 */

import Immutable from 'immutable';
import {classNames} from 'cs-web-components-externals';
import {Registry} from 'cs-web-components-base';
import * as helpers from '../helpers';
import * as actions from '../actions/actions';
import * as constants from '../constants';
import * as proptypes from '../proptypes';
import detailsReducer from '../details/reducers/reducers';
import mainReducer from '../main/reducers/reducers';
import tableReducer from '../table/reducers/reducers';

const INITIAL_STATE = proptypes.STORE_DEFAULT;

// attribute names (frontend and backend)
const IN_FLIGHT = 'inFlight';
const TABLE = 'table';
const ROWS = 'rows';
const COLUMNS = 'columns';
const SETTINGS = 'settings';
const USER_ID = 'userID';
const CLASSNAME = 'className';
const READ_STATUS = 'cs_tasks_col_read_status';
const CURRENT_SELECTION = 'currentSelection';
const DELTA = 'delta';
const PROCEEDING = 'proceeding';
const TEMPORARY_TASKS = 'temporaryTasks';
const MISSING_TASKS = 'missingTasks';
const NEW_TASKS = 'newTasks';
const CONTENT_RENDERER = 'contentRenderer';

const CSS_READ = helpers.prefixNS('task-read');
const CSS_UNREAD = helpers.prefixNS('task-unread');

export const getReadStatusCSSClasses = (read_status, oldClasses) => {
    const old = oldClasses ? (
        oldClasses.split(' ').filter(c => c !== CSS_READ && c !== CSS_UNREAD)
    ) : [];
    return classNames(old, {
        [CSS_READ]: read_status,
        [CSS_UNREAD]: !read_status
    });
};

export default function(state = INITIAL_STATE, action) {
    switch (action.type) {
        case actions.BACKEND_REQUEST_IN_FLIGHT:
            return backendRequestInFlight(state, action.payload);
        case actions.OPTIMISTIC_UPDATE_USER_SETTINGS:
            return saveUserSettings(state, {[SETTINGS]: action.payload});
        case actions.SHOW_TASKS_LOADING_INDICATOR:
            return showTasksLoadingIndicator(state);
        case actions.CLEAR_TASKS:
            return clearTasks(state);
        case actions.TASKS:
            return getTasks(state, action.payload, action.meta);
        case actions.NEW_TASKS:
            return getNewTasks(state, action.payload);
        case actions.SELECT_ROWS:
            return selectRows(state, action.payload);
        case actions.SAVE_USER_SETTINGS_RESPONSE:
            return saveUserSettings(state, action.payload);
        default: {
            // may one of our sub-reducers has an updated state
            for (const subReducer of [
                detailsReducer,
                mainReducer,
                tableReducer
            ]) {
                const subResult = subReducer(state, action);
                if (subResult !== state) {
                    return subResult;
                }
            }

            if (action.type.startsWith(componentNameSpace)) {
                console.warn('state unaltered', action.type);  // eslint-disable-line no-console
            }
            return state;
        }
    }
}

function backendRequestInFlight(state, payload) {
    if (payload.isInFlight) {
        return state.set(IN_FLIGHT, state.get(IN_FLIGHT)
            .add(payload.actionName));
    } else {
        return state.set(IN_FLIGHT, state.get(IN_FLIGHT)
            .delete(payload.actionName));
    }
}

const RENDERER_CACHE = {};

function getComponent(name) {
    if (!RENDERER_CACHE.hasOwnProperty(name)) {
        RENDERER_CACHE[name] = Registry.findComponent(name);
    }
    return RENDERER_CACHE[name];
}

function showTasksLoadingIndicator(state) {
    return state.setIn([TABLE, 'fetching'], true);
}

// temporary IDs are cdb_object_ids, not @ids
const getTemporaryIDs = (list) => (Immutable.Set(list.map(x => x.get(constants.CDB_OBJECT_ID))));

function clearTasks(state) {
    return state.setIn([TABLE, ROWS], Immutable.List())
        .setIn([TABLE, 'fetching'], false);
}

function getTasks(state, payload, meta) {
    if (payload[USER_ID] !== state.getIn([SETTINGS, USER_ID])) {
        // ignore tasks loaded for a different user
        return state;
    }

    // inject content renderer components
    payload[TABLE][COLUMNS].forEach(col => {
        col[CONTENT_RENDERER] = getComponent(col[CONTENT_RENDERER]);
    });

    // add content-specific CSS classes
    payload[TABLE][ROWS].forEach(row => {
        row[CLASSNAME] = getReadStatusCSSClasses(row[READ_STATUS]);
    });

    let temporaryTaskIDs = Immutable.Set();
    let temporaryTasks = Immutable.List();

    if (!meta.ignoreTemporary) {
        // temporary tasks are tasks matching all of these conditions:
        // they are currently shown
        temporaryTaskIDs = getTemporaryIDs(state.getIn([TABLE, ROWS]))
            // they are not part of the refresh
            .subtract(getTemporaryIDs(Immutable.fromJS(payload[TABLE][ROWS])))
            // they are not currently temporary tasks
            .subtract(state.getIn([DELTA, TEMPORARY_TASKS]))
            // they are not currently being "proceeded" (e.g. their status change triggered the reload)
            .subtract(state.getIn([DELTA, PROCEEDING]));

        temporaryTasks = state.getIn([TABLE, ROWS])
            .filter(row => temporaryTaskIDs.includes(row.get(constants.CDB_OBJECT_ID)))
            .map(row => row.set(CLASSNAME, classNames(row.get(CLASSNAME), 'deleted')));
    }

    // add temporary tasks first, then tasks from backend
    payload[TABLE][ROWS] = temporaryTasks.concat(Immutable.fromJS(payload[TABLE][ROWS]));

    return state.set(TABLE, Immutable.fromJS(payload[TABLE]))
        .set(constants.USER_TAGS, Immutable.List(payload[constants.USER_TAGS]))
        .set(DELTA, proptypes.DELTA_DEFAULT.set(TEMPORARY_TASKS, temporaryTaskIDs));
}

function getNewTasks(state, payload) {
    // payload is a list of cdb_object_ids with current tasks

    // the ones we currently don't have in our table (temporarily or not) are new
    const newOIDs = Immutable.Set(
        payload.filter(oid => helpers.getTaskIndex(state.getIn([TABLE, ROWS]), oid) === -1)
    );

    // we're missing any task currently shown that is neither part of the payload nor temp tasks
    const missingOIDs = getTemporaryIDs(state.getIn([TABLE, ROWS]))
        .subtract(payload)
        .subtract(state.getIn([DELTA, TEMPORARY_TASKS]));

    return state.setIn([DELTA, NEW_TASKS], newOIDs)
        .setIn([DELTA, MISSING_TASKS], missingOIDs);
}

function selectRows(state, payload) {
    return state.setIn(
        [CURRENT_SELECTION, constants.TASK_OIDS],
        Immutable.OrderedSet(payload[constants.TASK_OIDS])
    );
}

function saveUserSettings(state, payload) {
    return state.mergeIn([SETTINGS], payload[SETTINGS]);
}
