import React from 'react';
import moment from 'moment';
import {MenuItem, Form} from 'react-bootstrap';
import {connect, PropTypes, classNames} from 'cs-web-components-externals';
import {DayPicker, FormControl, getAppSetup, Button} from 'cs-web-components-base';
import {modifyCurrentView, DEADLINE} from '../actions/actions';
import {formatStr} from '../../i18n';
import * as helpers from '../../helpers';
import * as proptypes from '../../proptypes';
import {FilterDropdown, SimpleFilterItem} from './FilterDropdown';
import {getCurrentViewCondition} from '../views/selectors';

const DAYS = 'days';
const RANGE = 'range';

const MESSAGE_DEADLINE_FILTER = 'deadline_filter';
const MESSAGE_ALL_DEADLINES = 'all_deadlines';
const MESSAGE_DEADLINE_DAYS = 'deadline_days';
const MESSAGE_DEADLINE_RANGE = 'deadline_range';
const MESSAGE_CLEAR_RANGE = 'clear_range';

const DEADLINE_RANGE_MOMENT_PROPTYPES = PropTypes.shape({
    startMoment: PropTypes.object.isRequired,
    endMoment: PropTypes.object.isRequired
});

export function getDateFormat() {
    helpers.setupMoment();
    const appSetup = getAppSetup();
    return appSetup.getIn(['formats', 'dateFormat']);
}

export function formatMoment(momentObj) {
    const dateFormat = getDateFormat();
    return momentObj.format(dateFormat);
}

export function getDateRangeFromText(value) {
    const dates = value.split(' - ');

    if (dates.length === 2) {
        const dateFormat = getDateFormat();
        const startMoment = moment(dates[0], dateFormat);
        const endMoment = moment(dates[1], dateFormat);

        if (startMoment.isValid() && endMoment.isValid()) {
            return {startMoment, endMoment};
        }
    }

    return null;
}

function momentToISOString(momentObject) {
    // do not apply UTC offset
    return momentObject.toISOString(true);
}

function stopEvent(e) {
    helpers.stopEvent(e);
}

function stopEventPropagation(e) {
    e.stopPropagation();
}

class DaysCounter extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.inputRef = null;
        this.setInputRef = this.setInputRef.bind(this);
        this.focus = helpers.debounce(this.focus.bind(this), 0);
        this.activateDays = this.activateDays.bind(this);
    }

    setInputRef(element) {
        this.inputRef = element;
    }

    focus() {
        if (this.inputRef && this.inputRef.focus) {
            this.inputRef.focus();
        }
    }

    componentWillMount() {
        const {checked} = this.props;
        if (checked) {
            this.focus();
        }
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.checked && !this.props.checked) {
            this.focus();
        }
    }

    activateDays() {
        const {checked, activateDays} = this.props;
        activateDays(!checked);
    }

    render() {
        const {value, checked, onChange} = this.props;
        const name = helpers.prefixNS(DAYS);

        return (
            <SimpleFilterItem
                name={name}
                checked={checked}
                label={
                    <Form
                        className={classNames(name, {checked})}
                        onDragStart={stopEvent /* would prevent text selection from working */}
                        inline
                    >
                        <FormControl.NumericEdit
                            ref={this.setInputRef}
                            name={name}
                            type='number'
                            bsSize='sm'
                            label={formatStr(MESSAGE_DEADLINE_DAYS)}
                            value={value}
                            onClick={stopEventPropagation}
                            onValueChange={onChange}
                        />
                    </Form>
                }
                onChange={this.activateDays}
            />
        );
    }
}

DaysCounter.propTypes = {
    value: PropTypes.number,
    checked: PropTypes.bool,
    onChange: PropTypes.func.isRequired,
    activateDays: PropTypes.func.isRequired
};

class DateRangeSelector extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.state = {text: null};
        this.inputRef = null;
        this.emptySelection = [];
        this.setInputRef = this.setInputRef.bind(this);
        this.focus = helpers.debounce(this.focus.bind(this), 0);
        this.validateText = this.validateText.bind(this);
        this.rememberText = this.rememberText.bind(this);
        this.onTextChange = helpers.debounce(this.onTextChange.bind(this), 400);
        this.clearText = this.clearText.bind(this);
        this.activateRange = this.activateRange.bind(this);
        this.dayPickerChangeHandler = this.dayPickerChangeHandler.bind(this);
    }

    setInputRef(element) {
        this.inputRef = element;
    }

    focus() {
        if (this.inputRef && this.inputRef.focus) {
            this.inputRef.focus();
        }
    }

    componentWillMount() {
        const {dateRangeText, checked} = this.props;
        this.setState({text: dateRangeText});
        if (checked) {
            this.focus();
        }
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.checked && !this.props.checked) {
            this.focus();
        }

        if (nextProps.dateRangeText !== this.props.dateRangeText) {
            this.setState({text: nextProps.dateRangeText});
        }
    }

    validateText(value) {
        if (value) {
            if (getDateRangeFromText(value)) {
                return 'success';
            } else {
                return 'warning';
            }
        }
        return null;
    }

    rememberText(text) {
        this.setState({text});
        this.onTextChange(text);
    }

    onTextChange(value) {
        const {onChange} = this.props;
        const range = getDateRangeFromText(value);
        if (range) {
            onChange(
                momentToISOString(range.startMoment),
                momentToISOString(range.endMoment)
            );
        }
    }

    clearText(event) {
        this.rememberText('');
        stopEventPropagation(event);
    }

    activateRange() {
        const {checked, activateRange} = this.props;
        activateRange(!checked);
    }

    dayPickerChangeHandler(dateRange) {
        const {onChange} = this.props;
        onChange(
            momentToISOString(dateRange.startMoment),
            momentToISOString(dateRange.endMoment)
        );
    }

    render() {
        const {checked, dateRange, dateFormat} = this.props;
        const {text} = this.state;
        const name = helpers.prefixNS(RANGE);

        return (
            <React.Fragment>
                <SimpleFilterItem
                    name={name}
                    checked={checked}
                    label={
                        <Form
                            className={classNames(name, {checked})}
                            onDragStart={stopEvent /* would prevent text selection from working */}
                            inline
                        >
                            <FormControl.TextInput
                                ref={this.setInputRef}
                                name={name}
                                bsSize='sm'
                                autoComplete='off'
                                label={formatStr(MESSAGE_DEADLINE_RANGE)}
                                value={text}
                                placeholder={`${dateFormat} - ${dateFormat}`}
                                validationState={this.validateText(text)}
                                onClick={
                                    stopEventPropagation
                                    // click would toggle selection immediately
                                }
                                onKeyDown={
                                    stopEventPropagation
                                    // space would trigger parent's onChange
                                }
                                onChange={() => undefined}
                                onValueChange={this.rememberText}
                                afterControl={text ?
                                    <Button.CloseButton
                                        title={formatStr(MESSAGE_CLEAR_RANGE)}
                                        onClick={this.clearText}
                                    /> :
                                    ' '
                                }
                            />
                        </Form>
                    }
                    onChange={this.activateRange}
                />

                <DayPicker
                    currentDate={moment()}
                    selectedDates={dateRange ? [
                        dateRange.startMoment,
                        dateRange.endMoment
                    ] : this.emptySelection}
                    selectRange={true}
                    readOnly={false}
                    onChange={this.dayPickerChangeHandler}
                />
            </React.Fragment>
        );
    }
}

DateRangeSelector.propTypes = {
    checked: PropTypes.bool,
    dateRange: DEADLINE_RANGE_MOMENT_PROPTYPES,
    dateRangeText: PropTypes.string,
    dateFormat: PropTypes.string.isRequired,
    onChange: PropTypes.func.isRequired,
    activateRange: PropTypes.func.isRequired
};

function getDeadlineFilterTitle(activeDeadlineFilter, days, dateRangeText) {
    switch (activeDeadlineFilter) {
        case DAYS:
            return helpers.humanizeDays(days);
        case RANGE:
            return dateRangeText || formatStr(MESSAGE_ALL_DEADLINES);
        default:
            return formatStr(MESSAGE_ALL_DEADLINES);
    }
}

class DeadlineFilter extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.inputRefs = {
            [DAYS]: null,
            [RANGE]: null
        };
        this.setDaysRef = this.setDaysRef.bind(this);
        this.setRangeRef = this.setRangeRef.bind(this);
        this.focus = helpers.debounce(this.focus.bind(this), 0);
        this.onToggleHandler = this.onToggleHandler.bind(this);
        this.deactivateDays = this.deactivateDays.bind(this);
    }

    setDaysRef(element) {
        this.inputRefs[DAYS] = element;
    }

    setRangeRef(element) {
        this.inputRefs[RANGE] = element;
    }

    focus(event) {
        const {activeDeadlineFilter} = this.props;
        const inputRef = this.inputRefs[activeDeadlineFilter];

        if (inputRef && inputRef.focus) {
            inputRef.focus(event);
        }
    }

    onToggleHandler(isOpen, event) {
        if (isOpen === true) {
            this.focus(event);
        }
    }

    deactivateDays() {
        const {activateDays} = this.props;
        activateDays(false);
    }

    render() {
        const {
            activeDeadlineFilter,
            days,
            dateRangeText,
            dateRange,
            dateFormat,
            setDays,
            setDateRange,
            activateDays,
            activateRange
        } = this.props;

        return (
            <FilterDropdown
                onToggle={this.onToggleHandler}
                label={getDeadlineFilterTitle(activeDeadlineFilter, days, dateRangeText)}
                title={formatStr(MESSAGE_DEADLINE_FILTER)}
                id={helpers.prefixNS('deadline-filter')}
            >
                <SimpleFilterItem
                    name={MESSAGE_ALL_DEADLINES}
                    checked={!activeDeadlineFilter}
                    onChange={this.deactivateDays}
                    label={formatStr(MESSAGE_ALL_DEADLINES)}
                />

                <MenuItem divider />

                <DaysCounter
                    ref={this.setDaysRef}
                    value={days}
                    checked={activeDeadlineFilter === DAYS}
                    onChange={setDays}
                    activateDays={activateDays}
                />

                <MenuItem divider />

                <DateRangeSelector
                    ref={this.setRangeRef}
                    dateRange={dateRange}
                    dateRangeText={dateRangeText}
                    dateFormat={dateFormat}
                    checked={activeDeadlineFilter === RANGE}
                    onChange={setDateRange}
                    activateRange={activateRange}
                />

            </FilterDropdown>
        );
    }
}

DeadlineFilter.defaultProps = {
    activeDeadlineFilter: null
};

DeadlineFilter.propTypes = {
    activeDeadlineFilter: proptypes.ACTIVE_DEADLINE,
    days: PropTypes.number,
    dateRangeText: PropTypes.string,
    dateRange: DEADLINE_RANGE_MOMENT_PROPTYPES,
    dateFormat: PropTypes.string.isRequired,
    setDays: PropTypes.func.isRequired,
    setDateRange: PropTypes.func.isRequired,
    activateDays: PropTypes.func.isRequired,
    activateRange: PropTypes.func.isRequired
};

function mapStateToProps(state) {
    const deadlineCondition = getCurrentViewCondition(state, 'deadline');

    const activeDeadlineFilter = deadlineCondition && deadlineCondition.get('active');
    const startISO = deadlineCondition && deadlineCondition.getIn([RANGE, 'start']);
    const endISO = deadlineCondition && deadlineCondition.getIn([RANGE, 'end']);
    const startMoment = moment(startISO);
    const endMoment = moment(endISO);
    const validRange = (startISO && endISO && startMoment.isValid() && endMoment.isValid());

    const dateRange = validRange && {startMoment, endMoment};
    const dateRangeText = dateRange ?
        `${formatMoment(dateRange.startMoment)} - ${formatMoment(dateRange.endMoment)}` : // eslint-disable-line max-len
        '';

    return {
        activeDeadlineFilter,
        dateRange,
        dateRangeText,
        days: deadlineCondition && deadlineCondition.get(DAYS),
        dateFormat: getDateFormat()
    };
}

function mapDispatchToProps(dispatch) {
    return {
        setDays: (days) => {dispatch(
            modifyCurrentView(DEADLINE.SET_DAYS, {days: Number(days)})
        );},
        setDateRange: (start, end) => {
            const payload = start && end && {start, end};
            dispatch(modifyCurrentView(DEADLINE.SET_RANGE, payload));
        },
        activateDays: (active) => {
            const payload = {filterName: DAYS, active: active};
            dispatch(modifyCurrentView(DEADLINE.ACTIVATE, payload));
        },
        activateRange: (active) => {
            const payload = {filterName: RANGE, active: active};
            dispatch(modifyCurrentView(DEADLINE.ACTIVATE, payload));
        }
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(DeadlineFilter);
