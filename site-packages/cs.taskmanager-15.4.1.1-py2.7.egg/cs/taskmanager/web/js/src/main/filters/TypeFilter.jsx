import React from 'react';
import Immutable from 'immutable';
import {MenuItem} from 'react-bootstrap';
import {PropTypes, ImmutablePropTypes, connect} from 'cs-web-components-externals';
import {fetchTypes, SVGIconAndLabel} from 'cs-web-components-base';
import {modifyCurrentView, TYPE} from "../actions/actions";
import * as constants from '../../constants';
import * as helpers from '../../helpers';
import {formatStr} from '../../i18n';
import {FilterDropdown, FilterItem, SimpleFilterItem} from './FilterDropdown';
import {getCurrentViewCondition} from '../views/selectors';

const MESSAGE_TYPE_FILTER = 'type_filter';
const MESSAGE_ALL_TYPES = 'all_types';
const MESSAGE_HEADER_TYPES = 'header_type_filter';

class TypeFilterItem extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.toggleType = this.toggleType.bind(this);
    }

    toggleType() {
        const {typeID, checked, toggleType} = this.props;
        toggleType(typeID, checked);
    }

    render() {
        const {typeID, checked, icon, title} = this.props;
        return (
            <FilterItem
                key={typeID}
                name={typeID}
                checked={checked}
                label={
                    <SVGIconAndLabel
                        src={icon}
                        label={title}/>
                }
                onChange={this.toggleType}
            />
        );
    }
}

TypeFilterItem.propTypes = {
    typeID: PropTypes.string.isRequired,
    checked: PropTypes.bool,
    icon: PropTypes.string,
    title: PropTypes.string.isRequired,
    toggleType: PropTypes.func.isRequired
};

class TypeFilter extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.toggleType = this.toggleType.bind(this);
    }

    componentWillMount() {
        const {fetchTypes, taskClasses} = this.props;
        fetchTypes(taskClasses);
    }

    componentWillReceiveProps(nextProps) {
        const {fetchTypes, taskClasses} = nextProps;

        if (taskClasses !== this.props.taskClasses) {
            fetchTypes(taskClasses);
        }
    }

    toggleType(typeID, checked) {
        const {deselectType, selectType} = this.props;

        if (checked) {
            deselectType(typeID);
        } else {
            selectType(typeID);
        }
    }

    render() {
        const {resolvedTaskClasses, currentTypes, clearTypes} = this.props;

        if (!currentTypes) {
            return null;
        }

        const allChecked = currentTypes.size === 0;
        const filterLabel = allChecked ?
            formatStr(MESSAGE_ALL_TYPES) :
            resolvedTaskClasses.filter(x => currentTypes.includes(x.get(constants.ID)))
                .map(c => c.get('title'))
                .join(', ');

        return (
            <FilterDropdown
                label={filterLabel}
                title={formatStr(MESSAGE_TYPE_FILTER)}
                disabled={resolvedTaskClasses.size === 0}
                id={helpers.prefixNS('type-filter')}
            >

                <SimpleFilterItem
                    key={MESSAGE_ALL_TYPES}
                    name={MESSAGE_ALL_TYPES}
                    checked={allChecked}
                    label={formatStr(MESSAGE_ALL_TYPES)}
                    onChange={clearTypes} />

                <MenuItem divider />

                <MenuItem header>
                    {formatStr(MESSAGE_HEADER_TYPES)}
                </MenuItem>

                {resolvedTaskClasses.map(taskClass => {
                    const typeID = taskClass.get(constants.ID);

                    return (
                        <TypeFilterItem
                            key={typeID}
                            typeID={typeID}
                            checked={currentTypes.includes(typeID)}
                            icon={taskClass.get('icon')}
                            title={taskClass.get('title')}
                            toggleType={this.toggleType}
                        />
                    );
                })}
            </FilterDropdown>
        );
    }
}

TypeFilter.propTypes = {
    taskClasses: ImmutablePropTypes.list,
    resolvedTaskClasses: ImmutablePropTypes.list.isRequired,
    fetchTypes: PropTypes.func.isRequired,
    currentTypes: ImmutablePropTypes.set,
    selectType: PropTypes.func.isRequired,
    deselectType: PropTypes.func.isRequired,
    clearTypes: PropTypes.func.isRequired
};

// sort types by ascending title
function sortTypes(typeA, typeB) {
    const a = typeA.get('title');
    const b = typeB.get('title');
    if (a > b) {
        return 1;
    }
    if (a < b) {
        return -1;
    }
    return 0;
}

const EMPTY_CLASSES = Immutable.List();

function mapStateToProps(state) {
    const ownState = state[helpers.prefixNS('reducer')];
    const taskClasses = ownState.getIn(['settings', 'taskClasses']);
    const viewCondition = getCurrentViewCondition(state);

    return {
        taskClasses: taskClasses,
        resolvedTaskClasses: taskClasses ?
            taskClasses.map(x => state.typesById.get(x)).filter(x => x).sort(sortTypes) :
            EMPTY_CLASSES,
        currentTypes: viewCondition && viewCondition.get('types').toSet()
    };
}

function mapDispatchToProps(dispatch) {
    return {
        fetchTypes: (taskClasses) => {dispatch(fetchTypes(taskClasses))},
        selectType: (typeID) => {dispatch(
            modifyCurrentView(TYPE.SELECT, {typeID})
        );},
        deselectType: (typeID) => {dispatch(
            modifyCurrentView(TYPE.DESELECT, {typeID})
        );},
        clearTypes: () => {dispatch(modifyCurrentView(TYPE.CLEAR))}
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(TypeFilter);
