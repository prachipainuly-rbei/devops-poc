import React from 'react';
import {OverlayTrigger, Popover} from 'react-bootstrap';
import {connect, PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import {Registry} from 'cs-web-components-base';
import {formatStr} from '../i18n';
import * as helpers from '../helpers';
import {getTasks, getNewTasks} from '../actions/actions';
import {notify} from './actions/actions';
import * as proptypes from '../proptypes';
import {getCurrentViewCondition} from './views/selectors';

const DEBUG_MODE = helpers.debugMode();
const MINIMUM_INTERVAL = DEBUG_MODE ? 500 : 5000;
const HIDE_POPOVER_DELAY = DEBUG_MODE ? 10000 : 400;

const Icon = Registry.findComponent('cs-web-components-base-Icon');

const MESSAGE_NEW_TASKS = 'new_tasks';
const MESSAGE_MISSING_TASKS = 'missing_tasks';
const MESSAGE_UPDATES_AVAILABLE = 'updates_available';
const MESSAGE_LOAD_UPDATES = 'load_updates';

function UpdatedTasks({newTasks, missingTasks}) {
    return (
        <ul className={helpers.prefixNS('notification__text')}>
            {newTasks > 0 && (
                <li>
                    {`${newTasks} ${formatStr(MESSAGE_NEW_TASKS)}`}
                </li>
            )}
            {missingTasks > 0 && (
                <li>
                    {`${missingTasks} ${formatStr(MESSAGE_MISSING_TASKS)}`}
                </li>
            )}
        </ul>
    );
}

UpdatedTasks.propTypes = {
    newTasks: PropTypes.number.isRequired,
    missingTasks: PropTypes.number.isRequired
};

function UpdatePopover({reloadTasks, updatedTasks, ...others}) {
    return (
        <Popover
            id={helpers.prefixNS('notification__popover-info')}
            title={formatStr(MESSAGE_UPDATES_AVAILABLE)}
            className={helpers.prefixNS('notification__popover-info')}
            {...others}
        >
            <a
                href='#'
                onClick={reloadTasks}
            >
                {formatStr(MESSAGE_LOAD_UPDATES)}
                {updatedTasks}
            </a>
        </Popover>
    );
}

UpdatePopover.propTypes = {
    reloadTasks: PropTypes.func.isRequired,
    updatedTasks: PropTypes.element.isRequired
};

class Notifications extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.state = {
            notificationTimer: null,
            newTasks: 0,
            missingTasks: 0
        };
        this.popoverTrigger = null;
        this.checkForNewTasks = this.checkForNewTasks.bind(this);
        this.reloadTasks = this.reloadTasks.bind(this);
        this.setPopoverTrigger = this.setPopoverTrigger.bind(this);
        this.showPopover = this.showPopover.bind(this);
        this.hidePopover = this.hidePopover.bind(this);
    }

    startTimer(notificationInterval) {  //eslint-disable-line consistent-return
        if (typeof notificationInterval === 'number') {
            this.stopTimer();
            return {
                notificationTimer: setInterval(
                    this.checkForNewTasks,
                    Math.max(notificationInterval, MINIMUM_INTERVAL)
                )
            };
        }
    }

    stopTimer() {  //eslint-disable-line consistent-return
        if (this.state.notificationTimer) {
            clearInterval(this.state.notificationTimer);
            return {notificationTimer: null};
        }
    }

    componentWillReceiveProps(nextProps) {
        const {delta, notificationInterval} = nextProps;

        if (delta && delta !== this.props.delta) {
            const newTasks = delta.get('newTasks');
            const missingTasks = delta.get('missingTasks');
            this.setState({
                newTasks: newTasks ? newTasks.size : 0,
                missingTasks: missingTasks ? missingTasks.size : 0
            });
        }

        if (notificationInterval && notificationInterval !== this.props.notificationInterval) {
            this.setState(this.startTimer(notificationInterval));
        }
    }

    componentWillMount() {
        this.setState(this.startTimer(this.props.notificationInterval));
    }

    componentWillUnmount() {
        this.stopTimer();
    }

    checkForNewTasks() {
        const {getNewTasks, condition} = this.props;
        if (!document.hidden) {
            getNewTasks(condition);
        }
    }

    reloadTasks() {
        const {getTasks, condition} = this.props;
        getTasks(condition);
    }

    setPopoverTrigger(element) {
        this.popoverTrigger = element;
    }

    showPopover(event) {
        if (this.popoverTrigger) {
            this.popoverTrigger.handleMouseOver(event);
        }
    }

    hidePopover(event) {
        if (this.popoverTrigger) {
            this.popoverTrigger.handleMouseOut(event);
        }
    }

    render() {
        const {newTasks, missingTasks} = this.state;

        if (!newTasks && !missingTasks) {
            return null;
        }

        return (
            <div
                className={helpers.prefixNS('notification')}
                title={formatStr(MESSAGE_UPDATES_AVAILABLE)}
            >
                <OverlayTrigger
                    placement='top'
                    trigger={['hover', 'focus']}
                    delayShow={0}
                    delayHide={HIDE_POPOVER_DELAY}
                    animation={false}
                    shouldUpdatePosition /* re-position while open */
                    ref={this.setPopoverTrigger}
                    overlay={(
                        <UpdatePopover
                            reloadTasks={this.reloadTasks}
                            updatedTasks={
                                <UpdatedTasks
                                    newTasks={newTasks}
                                    missingTasks={missingTasks}
                                />
                            }
                            onMouseOver={this.showPopover}
                            onMouseOut={this.hidePopover}
                        />
                    )}
                >
                    <a
                        href='#'
                        tabIndex='0'
                        className={helpers.prefixNS('notification__focusable')}
                    >
                        <Icon
                            className={helpers.prefixNS('notification__icon')}
                            name='csweb_information'
                            size='sm'
                        />
                    </a>
                </OverlayTrigger>
            </div>
        );
    }
}

Notifications.propTypes = {
    notificationInterval: PropTypes.number.isRequired,
    condition: proptypes.VIEW_CONDITION,
    delta: ImmutablePropTypes.contains({
        newTasks: ImmutablePropTypes.set,
        missingTasks: ImmutablePropTypes.set,
        temporaryTasks: ImmutablePropTypes.set,
        proceeding: ImmutablePropTypes.set
    }).isRequired,
    getTasks: PropTypes.func.isRequired,
    addNotification: PropTypes.func.isRequired,
    getNewTasks: PropTypes.func.isRequired
};

function mapStateToProps(state) {
    const ownState = state[helpers.prefixNS('reducer')];

    return {
        notificationInterval: ownState.getIn(['settings', 'notificationInterval']),
        condition: getCurrentViewCondition(state),
        delta: ownState.get('delta')
    };
}

function mapDispatchToProps(dispatch) {
    return {
        getTasks: (condition) => {dispatch(getTasks(condition))},
        addNotification: (title, message) => {
            dispatch(notify(
                title, message, 'info', 'refreshNotification'
            ));
        },
        getNewTasks: (condition) => {dispatch(getNewTasks(condition))}
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(Notifications);
