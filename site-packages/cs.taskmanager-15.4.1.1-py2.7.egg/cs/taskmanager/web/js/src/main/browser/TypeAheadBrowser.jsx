import React from 'react';
import Immutable from 'immutable';
import {Label} from 'react-bootstrap';
import {ImmutablePropTypes, PropTypes, connect} from 'cs-web-components-externals';
import {Button, Registry, fetchObject} from 'cs-web-components-base';
import * as constants from '../../constants';
import * as helpers from '../../helpers';
import * as proptypes from '../../proptypes';
import {formatStr} from '../../i18n';

const ObjectSearch = Registry.findComponent('cs-web-components-base-ObjectSearch');

function SelectedObject({obj, getDescription, deselectObject, messageRemove}) {
    const objID = obj.get(constants.ID);

    return (
        <Label
            key={objID}
            bsStyle='primary'
            className={helpers.prefixNS('selected-obj')}>
            {getDescription(obj)}

            <Button.IconButton buttonStyle='link'
                size='sm'
                iconName='csweb_remove'
                title={formatStr(messageRemove)}
                className={helpers.prefixNS('selected-obj--remove')}
                onClick={() => deselectObject(objID)}
            />
        </Label>
    );
}

SelectedObject.propTypes = {
    obj: proptypes.OBJECT_PROPTYPE.isRequired,
    messageRemove: PropTypes.string.isRequired,
    deselectObject: PropTypes.func.isRequired,
    getDescription: PropTypes.func.isRequired
};

function _CurrentSelection({
    resolvedSelection, ignoredObjects, deselectObject, messageRemove, getDescription
}) {
    return (
        <div className={helpers.prefixNS('selected-objs')}>
            {resolvedSelection.map(obj => {
                if (obj) {
                    const objectID = obj.get(constants.ID);
                    if (!ignoredObjects.includes(objectID)) {
                        return (
                            <SelectedObject
                                key={objectID}
                                obj={obj}
                                deselectObject={deselectObject}
                                messageRemove={messageRemove}
                                getDescription={getDescription}
                            />
                        );
                    } else {
                        return null; // obj is ignored
                    }
                } else {
                    return null; // obj has not been loaded into the object store yet
                }
            })}
        </div>
    );
}

_CurrentSelection.propTypes = {
    currentSelection: PropTypes.oneOfType([
        ImmutablePropTypes.list,
        ImmutablePropTypes.set
    ]).isRequired,
    resolvedSelection: PropTypes.oneOfType([
        ImmutablePropTypes.list,
        ImmutablePropTypes.set
    ]).isRequired,
    ignoredObjects: ImmutablePropTypes.set.isRequired,
    messageRemove: PropTypes.string.isRequired,
    getDescription: PropTypes.func.isRequired,
    deselectObject: PropTypes.func.isRequired,
    fetchObject: PropTypes.func.isRequired
};

function mapStateToProps(state, ownProps) {
    return {
        resolvedSelection: ownProps.currentSelection
            .map(objID => state.objectsById.get(objID))
            .filter(obj => obj)
    };
}

const CurrentSelection = connect(mapStateToProps, {fetchObject})(_CurrentSelection);

/*
 * Wrapper for ObjectSearch. Includes display of selected objects as labels and automatically
 * fetches selected objects.
 */
class TypeAheadBrowser extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.inputRef = null;
        this.setInputRef = this.setInputRef.bind(this);
        this.focus = this.focus.bind(this);
        this.selectObject = this.selectObject.bind(this);
        this.deselectObject = this.deselectObject.bind(this);
    }

    setInputRef(element) {
        this.inputRef = element;
    }

    focus(event) {
        if (this.inputRef && this.inputRef.getWrappedInstance) {
            this.inputRef.getWrappedInstance().focus(event);
        }
    }

    selectObject(obj) {
        const {fetchObject, select} = this.props;
        const objID = obj.get('rest_url');
        fetchObject(objID);
        select(objID);
    }

    deselectObject(objID) {
        const {deselect} = this.props;
        deselect(objID);
    }

    render() {
        const {
            name,
            queryClassnames,
            currentSelection,
            ignoredObjects,
            //additionalFilter,
            messageRemove,
            messagePlaceholder,
            getDescription
        } = this.props;

        return (
            <React.Fragment>
                <CurrentSelection
                    currentSelection={currentSelection}
                    ignoredObjects={ignoredObjects}
                    messageRemove={messageRemove}
                    getDescription={getDescription}
                    deselectObject={this.deselectObject}
                />

                <ObjectSearch
                    className={helpers.prefixNS('object-search')}
                    id={name /*
                    ref={this.setInputRef}
                    additionalFilter={o => {
                        const notIgnored = !ignoredObjects.includes(o[constants.ID]);
                        const notSelected = !currentSelection.includes(o[constants.ID]);
                        const matchesAdditional = additionalFilter ? additionalFilter(o) : true;
                        return notIgnored && notSelected && matchesAdditional;
                    }}
                    */}
                    searchPlaceholder={formatStr(messagePlaceholder)}
                    searchClasses={queryClassnames}
                    hideDefaultTags={true}
                    onSelectItem={this.selectObject}
                />

            </React.Fragment>
        );
    }
}

TypeAheadBrowser.defaultProps = {
    currentSelection: Immutable.Set(),
    ignoredObjects: Immutable.Set(),
    getDescription: obj => obj.get(constants.DESCRIPTION)
};

TypeAheadBrowser.propTypes = {
    name: PropTypes.string.isRequired,
    queryClassnames: PropTypes.arrayOf(PropTypes.string).isRequired,
    currentSelection: PropTypes.oneOfType([
        ImmutablePropTypes.list,
        ImmutablePropTypes.set
    ]).isRequired,
    ignoredObjects: ImmutablePropTypes.set.isRequired,
    additionalFilter: PropTypes.func,
    select: PropTypes.func.isRequired,
    deselect: PropTypes.func.isRequired,
    messageRemove: PropTypes.string.isRequired,
    messagePlaceholder: PropTypes.string.isRequired,
    getDescription: PropTypes.func.isRequired,
    fetchObject: PropTypes.func.isRequired
};

export default connect(null, {fetchObject})(TypeAheadBrowser);
