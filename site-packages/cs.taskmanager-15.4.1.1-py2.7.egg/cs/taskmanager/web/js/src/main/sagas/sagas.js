/* -*- mode: javascript; coding: utf-8 -*-
 * $Id: sagas.js 185005 2018-10-12 11:30:19Z cso $
 *
 * Copyright (c) 1990 - 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 */

import Immutable from 'immutable';
import {ReduxSaga} from 'cs-web-components-externals';
const {select, put, call, takeEvery} = ReduxSaga.effects;
import {getAppSetup, fetchObject, receivedObject, Console} from 'cs-web-components-base';
import {backendRequest} from '../../sagas/sagas';
import {DELETE, POST} from '../../actions/actions';
import {fetchSettings} from '../../table/actions/actions';
import * as actions from '../actions/actions';
import * as constants from '../../constants';
import * as helpers from '../../helpers';
import {getViewPath, getViewID} from '../views/selectors';

const URL_NEW_VIEW = getAppSetup().getIn(['links', componentNameSpace, 'newUserView']);
const URL_REMEMBER_VIEW = getAppSetup().getIn(['links', componentNameSpace, 'rememberUserView']);
const URL_VIEW = getAppSetup().getIn(['links', componentNameSpace, 'userView']);

const getViewObjectID = restID => restID.split('/').pop();

const getUnresolvedFilterObjects = (state) => {
    const originalState = state[helpers.prefixNS('reducer')];
    let result = Immutable.List();

    ['contexts', 'users'].forEach(key => {
        result = result.concat(
            originalState
                .getIn(
                    getViewPath(state, 'current')
                        .concat(['condition', key]),
                    Immutable.List()
                )
                .filter(c => !state.objectsById.get(c))
        );
    });
    return result;
};

export function* fetchUnresolvedContexts() {
    // fetch unknown context objects and users asynchronously
    const contexts = yield select(getUnresolvedFilterObjects);
    for (const c of contexts) {
        yield put(fetchObject(c));
    }
}

export function* selectUserView(action) {
    const {viewID} = action.payload;
    const viewOID = getViewObjectID(viewID);
    // select view immediately
    yield put({
        type: actions.VIEW.DO_SELECT,
        payload: {viewID}
    });
    // remember view as new default selection for user
    try {
        yield call(
            backendRequest,
            POST,
            URL_REMEMBER_VIEW.replace("${view_object_id}", viewOID),
            actions.VIEW.SELECTED
        );
    } catch (error) {
        Console.error('could not update current view on server');
    }
}

const NEW_VIEW_ID = 'viewCurrentlyCreated';

const getCurrentViewObject = (state) => (
    state.objectsById.get(getViewID(state, 'current'))
);

function* temporaryRenameView(selector, name, viewID) {
    const view = yield select(selector);
    const tempViewID = viewID || view.get(constants.ID);
    yield put(receivedObject(tempViewID, view.set('name', name)));
}

export function* newUserView(action) {
    const {name, condition} = action.payload;
    // insert dummy object into object store as copy of current view with new name
    yield call(temporaryRenameView, getCurrentViewObject, name, NEW_VIEW_ID);

    yield put(actions.newUserViewOptimistic(NEW_VIEW_ID));
    yield call(
        backendRequest,
        POST,
        URL_NEW_VIEW,
        // substitute fetchSettings since we get the data directly
        actions.VIEW.NEW,
        {name, condition}
    );
    // TODO remove dummy object from object store (no public API in cs.web yet)
}

export function* saveUserView(action) {
    const {viewID, condition} = action.payload;
    const viewOID = getViewObjectID(viewID);
    // apply optimistic updates immediately
    yield put(actions.setViewEdited(viewID, false));

    try {
        yield call(
            backendRequest,
            POST,
            URL_VIEW.replace("${view_object_id}", viewOID),
            actions.VIEW.SAVED,
            {viewID, condition}
        );
    } catch (error) {
        yield put(actions.setViewEdited(viewID, true));
    }
}

export function* deleteUserView(action) {
    const {viewID} = action.payload;
    const viewOID = getViewObjectID(viewID);
    yield put(actions.deleteUserViewOptimistic(viewID));
    yield call(
        backendRequest,
        DELETE,
        URL_VIEW.replace("${view_object_id}", viewOID)
    );
    yield put(fetchSettings());
}

const getCurrentViewID = (state) => (
    getViewID(state, 'current')
);

export function* modifyCurrentView(action) {
    const {modification} = action.payload;
    const viewID = yield select(getCurrentViewID);
    yield put(actions.setViewEdited(viewID, true));
    yield put(modification);
}

const getViewObjectByID = viewID => state => (
    state.objectsById.get(viewID)
);

export function* renameView(action) {
    const {viewID, name} = action.payload;
    // rename view object immediately
    yield call(temporaryRenameView, getViewObjectByID(viewID), name);

    yield put(actions.renameUserViewOptimistic(viewID, name));
    const viewOID = getViewObjectID(viewID);
    yield call(
        backendRequest,
        POST,
        URL_VIEW.replace("${view_object_id}", viewOID),
        actions.VIEW.RENAMED,
        {viewID, name}
    );
}

export default function* setupSagas() {
    yield takeEvery(actions.VIEW.SETUP, fetchUnresolvedContexts);
    yield takeEvery(actions.VIEW.SELECT, selectUserView);
    yield takeEvery(actions.VIEW.SAVE, saveUserView);
    yield takeEvery(actions.VIEW.SAVE_AS, newUserView);
    yield takeEvery(actions.VIEW.DELETE, deleteUserView);
    yield takeEvery(actions.VIEW.MODIFY, modifyCurrentView);
    yield takeEvery(actions.VIEW.RENAME, renameView);
}
