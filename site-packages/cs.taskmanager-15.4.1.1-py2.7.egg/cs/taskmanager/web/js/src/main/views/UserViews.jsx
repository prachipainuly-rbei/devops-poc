import React from 'react';
import {connect, ImmutablePropTypes, PropTypes} from 'cs-web-components-externals';
import {NavDropdown, Dropdown} from 'react-bootstrap';
import {Console, Overlays} from 'cs-web-components-base';
import {
    setupViews, selectUserView, saveUserView, saveUserViewAs, renameUserView, deleteUserView,
    updateDocumentTitle
} from '../actions/actions';
import * as constants from '../../constants';
import * as helpers from '../../helpers';
import * as proptypes from '../../proptypes';
import * as selectors from './selectors';
import {formatStr} from '../../i18n';
import ManageUserViewsDialog, {MESSAGE_MANAGE_USER_VIEWS} from './ManageUserViewsDialog';
import SaveUserViewAsDialog, {MESSAGE_SAVE_USER_VIEW_AS} from './SaveUserViewAsDialog';

const MenuDivider = Overlays.MenuDivider;
const MenuHeader = Overlays.MenuHeader;
const MenuItem = Overlays.MenuItem;

const MAX_INLINE_VIEWS = 3; // maximum number of user views shown inline (else shown in submenu)

const MESSAGE_SELECT_USER_VIEW = 'select_user_view';
const MESSAGE_MORE_USER_VIEWS = 'more_user_views';
const MESSAGE_SAVE_USER_VIEW = 'save_user_view';
const MESSAGE_EDITED = 'edited';

function UserViewsLabel({viewName, edited}) {
    return (
        <React.Fragment>
            {viewName}
            {edited && (
                <span className={helpers.prefixNS('user-views__edited')}>
                    ({formatStr(MESSAGE_EDITED)})
                </span>
            )}
        </React.Fragment>
    );
}

UserViewsLabel.propTypes = {
    viewName: PropTypes.string.isRequired,
    edited: PropTypes.bool.isRequired
};

/* DefaultUserView and SelectUserView both have to pass the onSelect handler implicitely passed by
 * react-bootstrap's Dropdown to its direct children only in order to close the dropdown after
 * selecting an item.
 * https://github.com/react-bootstrap/react-bootstrap/issues/2429
 */
function DefaultUserView({defaultView, currentViewID, selectView, onSelect}) {
    return (
        defaultView && (
            <React.Fragment>
                <UserViewMenuItem
                    view={defaultView}
                    active={defaultView.get(constants.ID) === currentViewID}
                    onSelect={onSelect}
                    selectView={selectView} />

                <MenuDivider />
            </React.Fragment>
        )
    );
}

DefaultUserView.propTypes = {
    defaultView: proptypes.USER_VIEW,
    currentViewID: PropTypes.string,
    selectView: PropTypes.func.isRequired,
    onSelect: PropTypes.func
};

// submenus in bootstrap 3 and 4:
// https://stackoverflow.com/questions/18023493/bootstrap-dropdown-sub-menu-missing#18024991
class SelectUserView extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.renderUserViews = this.renderUserViews.bind(this);
    }

    renderUserViews(viewIDs) {
        if (viewIDs && viewIDs.size > 0) {
            const {currentViewID, selectView, onSelect} = this.props;
            return viewIDs.map(viewID => (
                <UserViewMenuItem
                    key={viewID}
                    viewID={viewID}
                    active={viewID === currentViewID}
                    onSelect={onSelect}
                    selectView={selectView} />
            ));
        } else {
            return null;
        }
    }

    render() {
        const {userViewIDs, recentViewIDs} = this.props;
        const {size} = userViewIDs;

        if (!size) {
            return null;
        }

        if (size <= MAX_INLINE_VIEWS) {
            return (
                <React.Fragment>
                    {this.renderUserViews(userViewIDs)}

                    <MenuDivider />
                </React.Fragment>
            );
        }

        const viewsByRecentSelection = userViewIDs
            .groupBy(viewID => recentViewIDs.includes(viewID));

        const recentUserViewIDs = viewsByRecentSelection.get(true) || null;
        const nestedUserViewIDs = viewsByRecentSelection.get(false) || null;

        return (
            <React.Fragment>
                <MenuHeader>
                    {formatStr(MESSAGE_SELECT_USER_VIEW)}
                </MenuHeader>

                {this.renderUserViews(recentUserViewIDs)}

                {nestedUserViewIDs && nestedUserViewIDs.size > 0 && (
                    <li role='presentation'
                        className='dropdown-submenu'
                    >
                        <a role='menuitem' tabIndex={-1} href='#'>
                            {formatStr(MESSAGE_MORE_USER_VIEWS)}
                        </a>
                        <Dropdown.Menu>
                            {this.renderUserViews(nestedUserViewIDs)}
                        </Dropdown.Menu>
                    </li>
                )}

                <MenuDivider />
            </React.Fragment>
        );
    }
}

SelectUserView.propTypes = {
    userViewIDs: ImmutablePropTypes.orderedSetOf(PropTypes.string).isRequired,
    recentViewIDs: ImmutablePropTypes.orderedSetOf(PropTypes.string).isRequired,
    currentViewID: PropTypes.string,
    selectView: PropTypes.func.isRequired,
    onSelect: PropTypes.func
};

class _UserViewMenuItem extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.onSelectHandler = this.onSelectHandler.bind(this);
    }

    onSelectHandler(event, eventKey) {
        const {view, selectView, onSelect} = this.props;
        selectView(view.get(constants.ID));
        onSelect(event, eventKey);
    }

    render() {
        const {view, active, edited} = this.props;
        const viewName = view.get('name');
        return (
            <MenuItem
                key={viewName}
                active={active}
                onSelect={this.onSelectHandler}
            >
                {viewName} {edited && `(${formatStr(MESSAGE_EDITED)})`}
            </MenuItem>
        );
    }
}

_UserViewMenuItem.propTypes = {
    viewID: PropTypes.string,
    view: proptypes.OBJECT_PROPTYPE.isRequired,
    active: PropTypes.bool,
    selectView: PropTypes.func.isRequired,
    onSelect: PropTypes.func.isRequired,
    edited: PropTypes.bool
};

function mapUVMIDispatchToProps(state, ownProps) {
    return {
        view: ownProps.view || state.objectsById.get(ownProps.viewID),
        edited: ownProps.view ?
            ownProps.view.get('edited') :
            selectors.getEditedViewByID(state, ownProps.viewID)
    };
}

const UserViewMenuItem = connect(mapUVMIDispatchToProps)(_UserViewMenuItem);

class UserViewsDropdown extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.state = {
            showManagement: false,
            showSaveAs: false
        };
        this.warnBeforeLeavingEditedViews = this.warnBeforeLeavingEditedViews.bind(this);
        this.saveView = this.saveView.bind(this);
        this.saveViewAs = this.saveViewAs.bind(this);

        this.openSaveViewAsDialog = this.openSaveViewAsDialog.bind(this);
        this.closeSaveViewAsDialog = this.closeSaveViewAsDialog.bind(this);
        this.renderSaveViewAsDialog = this.renderSaveViewAsDialog.bind(this);

        this.openManageViewsDialog = this.openManageViewsDialog.bind(this);
        this.closeManageViewsDialog = this.closeManageViewsDialog.bind(this);
        this.renderManageViewsDialog = this.renderManageViewsDialog.bind(this);
    }

    componentWillMount() {
        const {setupViews, currentView} = this.props;

        window.addEventListener("beforeunload", this.warnBeforeLeavingEditedViews);

        if (currentView) {
            setupViews();
        }
    }

    componentWillUnmount() {
        window.removeEventListener("beforeunload", this.warnBeforeLeavingEditedViews);
    }

    componentWillReceiveProps(nextProps) {
        const {setupViews, currentView, updateDocumentTitle} = nextProps;
        const prevView = this.props.currentView;

        if (
            (currentView ? currentView.get(constants.ID) : undefined) !==
            (prevView ? prevView.get(constants.ID) : undefined)
        ) {
            updateDocumentTitle(currentView.get('name'));
            setupViews();
        }
    }

    warnBeforeLeavingEditedViews(event) {
        const {editedViewNames} = this.props;

        if (editedViewNames > '') {
            const confirmationMessage = (
                `Your edited view(s) "${editedViewNames}" will be lost if you continue.`
            );
            Console.error(confirmationMessage);
            (event || window.event).returnValue = confirmationMessage;
            return confirmationMessage;
        } else {
            return undefined;
        }
    }

    saveView() {
        const {currentView, saveView} = this.props;
        saveView(currentView.get(constants.ID), currentView.get('condition'));
    }

    saveViewAs(name) {
        const {saveViewAs, currentView} = this.props;
        saveViewAs(name, currentView.get('condition'));
    }

    openSaveViewAsDialog() {
        this.setState({showSaveAs: true});
    }

    closeSaveViewAsDialog() {
        this.setState({showSaveAs: false});
    }

    renderSaveViewAsDialog() {
        return (
            <SaveUserViewAsDialog
                saveViewAs={this.saveViewAs}
                closeDialog={this.closeSaveViewAsDialog}
            />
        );
    }

    openManageViewsDialog() {
        this.setState({showManagement: true});
    }

    closeManageViewsDialog() {
        this.setState({showManagement: false});
    }

    renderManageViewsDialog() {
        const {userViewIDs, defaultView, renameView, deleteView} = this.props;

        if (!defaultView) {
            return null;
        }

        return (
            <ManageUserViewsDialog
                userViewIDs={userViewIDs.toOrderedSet()}
                defaultView={defaultView}
                renameView={renameView}
                deleteView={deleteView}
                closeDialog={this.closeManageViewsDialog}
            />
        );
    }

    render() {
        const {defaultView, userViewIDs, recentViewIDs, currentView, selectView} = this.props;
        const {showSaveAs, showManagement} = this.state;

        if (!currentView) {
            return null;
        }

        const currentViewID = currentView.get(constants.ID);
        const edited = currentView.get('edited');

        return (
            <React.Fragment>
                <NavDropdown
                    className={helpers.prefixNS('user-views')}
                    title={(
                        <UserViewsLabel
                            viewName={currentView.get('name')}
                            edited={edited} />
                    )}
                >
                    <DefaultUserView
                        defaultView={defaultView}
                        currentViewID={currentViewID}
                        selectView={selectView}
                    />

                    <SelectUserView
                        userViewIDs={userViewIDs.toOrderedSet()}
                        recentViewIDs={recentViewIDs.toOrderedSet()}
                        currentViewID={currentViewID}
                        selectView={selectView}
                    />

                    <MenuItem
                        className={helpers.prefixNS('save-current-view')}
                        disabled={
                            !(currentView.get('edited') &&
                            !currentView.get('isEditable')
                        )}
                        onSelect={this.saveView}
                    >
                        {formatStr(MESSAGE_SAVE_USER_VIEW)}
                    </MenuItem>

                    <MenuItem
                        className={helpers.prefixNS('save-current-view-as')}
                        onSelect={this.openSaveViewAsDialog}
                    >
                        {formatStr(MESSAGE_SAVE_USER_VIEW_AS)}
                    </MenuItem>

                    <MenuDivider />

                    <MenuItem
                        className={helpers.prefixNS('open-view-dialog')}
                        onSelect={this.openManageViewsDialog}
                    >
                        {formatStr(MESSAGE_MANAGE_USER_VIEWS)}
                    </MenuItem>

                </NavDropdown>

                {showSaveAs && this.renderSaveViewAsDialog()}
                {showManagement && this.renderManageViewsDialog()}
            </React.Fragment>
        );
    }
}

UserViewsDropdown.propTypes = {
    defaultView: proptypes.USER_VIEW,
    currentView: proptypes.USER_VIEW,
    recentViewIDs: ImmutablePropTypes.listOf(PropTypes.string).isRequired,
    userViewIDs: ImmutablePropTypes.listOf(PropTypes.string).isRequired,
    setupViews: PropTypes.func.isRequired,
    selectView: PropTypes.func.isRequired,
    saveView: PropTypes.func.isRequired,
    saveViewAs: PropTypes.func.isRequired,
    renameView: PropTypes.func.isRequired,
    deleteView: PropTypes.func.isRequired,
    updateDocumentTitle: PropTypes.func.isRequired,
    editedViewNames: PropTypes.string.isRequired
};

function mapStateToProps(state) {
    return {
        defaultView: selectors.getDefaultView(state),
        recentViewIDs: selectors.getRecentViewIDs(state),
        currentView: selectors.getCurrentView(state),
        userViewIDs: selectors.getUserViewIDs(state),
        editedViewNames: selectors.getEditedViewNames(state)
    };
}

function mapDispatchToProps(dispatch) {
    return {
        setupViews: () => {dispatch(setupViews())},
        selectView: (viewID) => {dispatch(selectUserView(viewID))},
        saveView: (viewID, condition) => {dispatch(saveUserView(viewID, condition))},
        saveViewAs: (name, condition) => {dispatch(saveUserViewAs(name, condition))},
        renameView: (viewID, name) => {dispatch(renameUserView(viewID, name))},
        deleteView: (viewID) => {dispatch(deleteUserView(viewID))},
        updateDocumentTitle: (title) => {dispatch(updateDocumentTitle(title))}
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(UserViewsDropdown);
