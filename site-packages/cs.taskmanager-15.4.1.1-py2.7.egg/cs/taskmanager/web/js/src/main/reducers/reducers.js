/* -*- mode: javascript; coding: utf-8 -*-
 * $Id: reducers.js 183976 2018-09-17 14:53:30Z cso $
 *
 * Copyright (c) 1990 - 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 */

import Immutable from 'immutable';
import * as actions from '../actions/actions';
import {
    getCurrentCustomViewFromOwnState, getViewPathFromOwnState, getViewIDPath
} from '../views/selectors';

export default function(state, action) {
    switch (action.type) {
        case actions.UPDATE_DOCUMENT_TITLE:
            return updateDocumentTitle(state, action.payload);
        case actions.VIEW.DO_SELECT:
            return selectView(state, action.payload);
        case actions.VIEW.SELECTED:
            return updateRecentViews(state, action.payload);
        case actions.VIEW.SET_EDITED:
            return setViewEdited(state, action.payload, true);
        case actions.VIEW.SET_UNEDITED:
            return setViewEdited(state, action.payload, false);
        case actions.VIEW.NEW:
        case actions.VIEW.SAVED:
        case actions.VIEW.RENAMED:
            return updateSettings(state, action.payload);
        case actions.VIEW.NEW_OPTIMISTIC:
            return newUserViewOptimistic(state, action.payload);
        case actions.VIEW.RENAME_OPTIMISTIC:
            return renameViewOptimistic(state, action.payload);
        case actions.VIEW.DELETE_OPTIMISTIC:
            return deleteViewOptimistic(state, action.payload);
        case actions.TYPE.SELECT:
            return changeType(state, action.payload, true);
        case actions.TYPE.DESELECT:
            return changeType(state, action.payload, false);
        case actions.TYPE.CLEAR:
            return clearType(state);
        case actions.CONTEXT.SELECT:
            return changeContext(state, action.payload, true);
        case actions.CONTEXT.DESELECT:
            return changeContext(state, action.payload, false);
        case actions.CONTEXT.CLEAR:
            return clearContext(state);
        case actions.DEADLINE.SET_DAYS:
            return setDeadlineDays(state, action.payload);
        case actions.DEADLINE.SET_RANGE:
            return setDeadlineRange(state, action.payload);
        case actions.DEADLINE.ACTIVATE:
            return activateDeadlineFilter(state, action.payload);
        case actions.USER.SELECT:
            return changeUser(state, action.payload, true);
        case actions.USER.DESELECT:
            return changeUser(state, action.payload, false);
        case actions.USER.INCLUDE_ROLE_TASKS:
            return includeRoleTasks(state, action.payload);
        default:
            return state;
    }
}

function updateDocumentTitle(state, payload) {
    document.title = payload;
    return state;
}

function selectView(state, payload) {
    const path = getViewIDPath('current');
    return state.setIn(path, payload.viewID);
}

function updateRecentViews(state, payload) {
    return state.setIn(
        getViewIDPath('recent'),
        Immutable.fromJS(payload['recentUserViews'])
    );
}

function setViewEdited(state, payload, edited) {
    const {viewID} = payload;
    const path = getViewPathFromOwnState(state, viewID).concat(['edited']);
    return state.setIn(path, edited);
}

function updateSettings(state, payload) {
    const {settings} = payload;
    const newSettings = Immutable.fromJS(settings);
    const byIDPath = getViewIDPath('byID');
    // only update names of edited views
    const editedViews = state
        .getIn(byIDPath)
        .filter(view => view.get('edited'))
        .map((view, viewID) => view.set(
            'name',
            newSettings.getIn(byIDPath.concat([viewID, 'name']))
        ));
    byIDPath.shift(); // remove leading "settings" from path
    return state.set('settings', newSettings.mergeIn(byIDPath, editedViews));
}

function deleteViewOptimistic(state, payload) {
    const {viewID} = payload;
    // remove from settings.userViews.custom only; others are updated asynchronously
    const path = getViewIDPath('custom');
    return state.setIn(
        path,
        state.getIn(path).filter(x => x !== viewID)
    );
}

/*
 * A new view is currently being created in the backend as a copy of the current view.
 * Before the server responds with the complete data, we fake it in the most minimal way possible.
 *
 * Also reset the current view's "edited" status to false.
 */
function newUserViewOptimistic(state, payload) {
    const {dummyID} = payload;
    const dummyViewPath = getViewIDPath('byID').concat([dummyID]);
    const currentView = getCurrentCustomViewFromOwnState(state);
    const currentViewIDPath = getViewIDPath('current');
    const currentViewEditedPath = getViewIDPath('byID').concat([
        state.getIn(currentViewIDPath), 'edited'
    ]);

    return state
        .setIn(currentViewEditedPath, false)
        .setIn(dummyViewPath, currentView)
        .setIn(currentViewIDPath, dummyID);
}

function renameViewOptimistic(state, payload) {
    const {viewID, name} = payload;
    const path = getViewIDPath('default');
    const defaultID = state.getIn(path);

    if (defaultID === viewID) {
        const namePath = getViewPathFromOwnState(state, defaultID).concat(['name']);
        return state.setIn(namePath, name);
    } else {
        const namePath = getViewPathFromOwnState(state, viewID).concat(['name']);
        return state.setIn(namePath, name);
    }
}

function changeCondition(state, key, changeSet, add) {
    const currentPath = getViewPathFromOwnState(state, 'current');

    if (!currentPath[currentPath.length - 1]) {
        return state;
    }

    const path = currentPath.concat(['condition', key]);
    const currentCondition = state.getIn(path);

    if (add) {
        return state.setIn(path, currentCondition.toSet().union(changeSet).toList());
    } else {
        return state.setIn(path, currentCondition.toSet().subtract(changeSet).toList());
    }
}

function changeType(state, payload, add) {
    const typeIDs = [payload.typeID];
    return changeCondition(state, 'types', typeIDs, add);
}

function clearType(state) {
    const path = getViewPathFromOwnState(state, 'current').concat(['condition', 'types']);
    return state.setIn(path, Immutable.List());
}

function changeContext(state, payload, add) {
    const contextIDs = [payload.contextID] || payload.contextIDs;
    return changeCondition(state, 'contexts', contextIDs, add);
}

function clearContext(state) {
    const path = getViewPathFromOwnState(state, 'current').concat(['condition', 'contexts']);
    return state.setIn(path, Immutable.List());
}

function setDeadlineDays(state, payload) {
    return state
        .setIn(
            getViewPathFromOwnState(state, 'current').concat(['condition', 'deadline', 'days']),
            payload.days
        )
        .setIn(
            getViewPathFromOwnState(state, 'current').concat(['condition', 'deadline', 'active']),
            'days'
        );
}

function setDeadlineRange(state, payload) {
    return state
        .setIn(
            getViewPathFromOwnState(state, 'current').concat(['condition', 'deadline', 'range']),
            Immutable.Map(payload)
        )
        .setIn(
            getViewPathFromOwnState(state, 'current').concat(['condition', 'deadline', 'active']),
            'range'
        );
}

function activateDeadlineFilter(state, payload) {
    const value = payload.active ? payload.filterName : null;
    return state.setIn(
        getViewPathFromOwnState(state, 'current').concat(['condition', 'deadline', 'active']),
        value
    );
}

function changeUser(state, payload, add) {
    const {userID} = payload;
    return changeCondition(state, 'users', [userID], add);
}

function includeRoleTasks(state, payload) {
    return state.setIn(
        getViewPathFromOwnState(state, 'current').concat(['condition', 'roles']),
        payload.includeRoleTasks
    );
}
