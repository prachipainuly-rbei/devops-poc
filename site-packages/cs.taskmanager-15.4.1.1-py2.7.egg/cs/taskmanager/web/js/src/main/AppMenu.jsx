import React from 'react';
import {Registry, ButtonToolbar, ButtonGroup} from 'cs-web-components-base';
import {connect, PropTypes} from 'cs-web-components-externals';
import * as helpers from '../helpers';
import * as proptypes from '../proptypes';
import {formatStr} from '../i18n';
import {getTasks} from '../actions/actions';
import TypeFilter from './filters/TypeFilter';
import ContextFilter from './filters/ContextFilter';
import DeadlineFilter from './filters/DeadlineFilter';
import ResponsibleFilter from './filters/ResponsibleFilter';
import UserViewsDropdown from './views/UserViews';
import {getCurrentViewCondition} from './views/selectors';

const FETCH_DELAY = helpers.debugMode() ? 100 : 1000; // ms to wait before fetching tasks after last filter change (only in non-debug mode)
const MESSAGE_APP_TITLE = 'app_title';

const ApplicationBar = Registry.findComponent('cs-web-components-base-ApplicationBar');

class AppMenu extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.delayedGetTasks = helpers.debounce(this.delayedGetTasks.bind(this), FETCH_DELAY);
    }

    delayedGetTasks(props) {
        const {condition, getTasks} = props;
        getTasks(condition);
    }

    componentWillReceiveProps(nextProps) {
        const {condition, getTasks} = nextProps;
        const oldCondition = this.props.condition;

        if (condition !== oldCondition) {
            if (oldCondition === proptypes.DEFAULT_CONDITION) {
                // load initial tasks /wo delay
                getTasks(condition);
            } else {
                // load tasks for new condition /w delay
                this.delayedGetTasks(nextProps);
            }
        }
    }

    render() {
        const appElement = {
            active: true,
            key: componentNameSpace,
            name: formatStr(MESSAGE_APP_TITLE)
        };
        const userViews = {
            active: true,
            key: helpers.prefixNS('user-views'),
            component: (<UserViewsDropdown />)
        };
        return (
            <ApplicationBar items={[appElement, userViews]}>
                <Filters />
            </ApplicationBar>
        );
    }
}

AppMenu.propTypes = {
    condition: proptypes.VIEW_CONDITION,
    getTasks: PropTypes.func.isRequired
};

function mapStateToProps(state) {
    return {
        condition: getCurrentViewCondition(state)
    };
}

function mapDispatchToProps(dispatch) {
    return {
        getTasks: (condition) => {
            /* called when a filter changes (also initially)
             * set ignoreTemporary = true to indicate we don't want temporary tasks after this action completes
             */
            dispatch(getTasks(condition, true));
        }
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(AppMenu);

const Filters = () => (
    <ButtonToolbar className='pull-right'>
        <ButtonGroup className={helpers.prefixNS('filters')}>
            <TypeFilter />
            <ContextFilter />
            <DeadlineFilter />
            <ResponsibleFilter />
        </ButtonGroup>
    </ButtonToolbar>
);
