/* -*- mode: javascript; coding: utf-8 -*-
 * $Id: sagas.js 185099 2018-10-16 06:51:55Z cso $
 *
 * Copyright (c) 1990 - 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 */

import Immutable from 'immutable';
import {ReduxSaga} from 'cs-web-components-externals';
const {put, call, takeEvery} = ReduxSaga.effects;
import {
    getJSON, postJSON, deleteObject, receivedCollection, Console, getAppSetup
} from 'cs-web-components-base';
import * as actions from '../actions/actions';
import {SHOW_TASKS_LOADING_INDICATOR} from "../actions/actions";

const URL_GET_TASKS = getAppSetup().getIn(['links', componentNameSpace, 'tasks']);
const URL_GET_NEW_TASKS = getAppSetup().getIn(['links', componentNameSpace, 'newTasks']);

function getRequestMethod(getOrPost) {
    switch (getOrPost) {
        case actions.GET:
            return getJSON;
        case actions.POST:
            return postJSON;
        case actions.DELETE:
            return deleteObject;
    }
    throw new Error('request method has to be either GET, POST or DELETE');
}

export function getPKeyFromIDs(restIDs) {
    // primary key is everything from the last / forward
    return restIDs.map(restID => restID.split('/').pop());
}

export function getRelativeRestID(restID) {
    try {
        // strip protocol, host and domain
        return new URL(restID).pathname;
    } catch (e) {
        if (e instanceof TypeError) {
            return restID;
        } else {
            throw e;
        }
    }
}

export function getConditionPayload(condition) {
    const payload = {
        users: getPKeyFromIDs(condition.get('users')).toJS(),
        roles: condition.get('roles', false),
        types: getPKeyFromIDs(condition.get('types', Immutable.List())).toJS(),
        contexts: condition.get('contexts', Immutable.List()).map(x => getRelativeRestID(x)).toJS()
    };

    const activeDeadline = condition.getIn(['deadline', 'active']);

    switch (activeDeadline) {
        case 'days': {
            payload.days = condition.getIn(['deadline', 'days']);
            break;
        }
        case 'range': {
            payload.start = condition.getIn(['deadline', 'range', 'start']);
            payload.end = condition.getIn(['deadline', 'range', 'end']);
            break;
        }
        default: {
            break;
        }
    }

    return payload;
}

export function* mergeObjectStore(payload) {
    if (payload && payload.objects) {
        yield put(receivedCollection(null, payload.objects));
    }
}

export function* backendRequest(action, url, type, payload, meta) {
    if (!url) {
        throw new Error('no URL given');
    }

    yield put(actions.backendRequestInFlight(`${action} ${url}`, true));

    try {
        const result = yield call(getRequestMethod(action), url, payload || {});
        yield put(actions.backendRequestInFlight(`${action} ${url}`, false));
        yield call(mergeObjectStore, result);

        if (type) {
            yield put({
                type: type,
                payload: result,
                meta: meta
            });
        }
    } catch (error) {
        yield put(actions.backendRequestInFlight(`${action} ${url}`, false));
        yield put(actions.notifyError(error));
        throw error;
    }
}

export function* getTasks(action) {
    yield put({type: SHOW_TASKS_LOADING_INDICATOR});

    const payload = getConditionPayload(action.payload.condition);
    const meta = {ignoreTemporary: Boolean(action.payload.ignoreTemporary)};

    if (payload.users.length === 0) {
        yield put({
            type: actions.CLEAR_TASKS
        });
    } else {
        try {
            yield call(backendRequest, actions.GET, URL_GET_TASKS, actions.TASKS, payload, meta);
        } catch (error) {
            Console.error(error);
        }
    }
}

export function* getNewTasks(action) {
    const payload = getConditionPayload(action.payload.condition);

    if (payload.users.length > 0) {
        try {
            yield call(backendRequest, actions.GET, URL_GET_NEW_TASKS, actions.NEW_TASKS, payload);
        } catch (error) {
            Console.error(error);
        }
    }
}

export function* postUserSettings(action) {
    const {payload, optimistic} = action.payload;
    // apply optimistic updates immediately
    if (optimistic) {
        yield put(actions.optimisticUpdateUserSettings(optimistic));
    }
    try {
        yield call(
            backendRequest,
            actions.POST,
            actions.URL_SETTINGS,
            actions.SAVE_USER_SETTINGS_RESPONSE,
            payload
        );
    } catch (error) {
        Console.error(error);
    }
}

export default function* setupSagas() {
    yield takeEvery(actions.GET_TASKS, getTasks);
    yield takeEvery(actions.GET_NEW_TASKS, getNewTasks);
    yield takeEvery(actions.SAVE_USER_SETTINGS, postUserSettings);
}
