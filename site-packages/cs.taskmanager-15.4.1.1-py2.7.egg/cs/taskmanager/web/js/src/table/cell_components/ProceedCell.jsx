import React from 'react';
import Immutable from 'immutable';
import {connect, PropTypes, ImmutablePropTypes} from 'cs-web-components-externals';
import {Button} from 'cs-web-components-base';
import {MenuItem} from 'react-bootstrap';
import * as constants from '../../constants';
import * as helpers from '../../helpers';
import * as proptypes from '../../proptypes';
import {getTasks} from '../../actions/actions';
import {getTargetStatuses, changeStatus} from '../actions/actions';
import StatusCell from './StatusCell';
import {STATUS_PROPTYPE} from './StatusCell';
import {ProceedModal, isValid} from './ProceedModal';
import {CELL_PROPTYPE, isDeleted, customSort} from './index';
import {getCurrentView} from '../../main/views/selectors';

function getRowID(row) {
    return row.get(constants.CDB_OBJECT_ID);
}

const PLUGIN_STATUS_CELL = 'cs-tasks-custom-status-cell';

/**
 * Displays a dropdown with possible target statuses. Selecting a target status will change the object's status if
 * no mandatory additional attributes are missing. Else a modal dialog to enter these attributes is shown.
 *
 * React Properties
 * ................
 *
 * +---------------+---------------------------+---------+----------------------------------------------------------+
 * | Property      | Type                      | Default | Use                                                      |
 * +===============+===========================+=========+==========================================================+
 * | value         | Immutable.Map             | \-      | Keys are described below.                                |
 * +---------------+---------------------------+---------+----------------------------------------------------------+
 * | value.current | Immutable.Map (Status)    | \-      | The object's current status.                             |
 * +---------------+---------------------------+---------+----------------------------------------------------------+
 * | value.targets | Immutable.List (Statuses) | \-      | Possible target statuses.                                |
 * +---------------+---------------------------+---------+----------------------------------------------------------+
 * | proceed       | Function (Required)       | \-      | Function to change the object's status.                  |
 * +---------------+---------------------------+---------+----------------------------------------------------------+
 * | getTasks      | Function (Required)       | \-      | Function to reload all tasks.                            |
 * +---------------+---------------------------+---------+----------------------------------------------------------+
 * | isGroup       | Boolean                   | \-      | If true, only the current status is shown, no dropdown.  |
 * +---------------+---------------------------+---------+----------------------------------------------------------+
 *
 * The standard cell property ``row`` is required.
 *
 * ``value.current`` contains a status and ``value.targets`` a list of statuses. For details on the status value, see
 * the documentation of the property ``value`` of the component
 * :ref:`cs-taskmanager-web-table.cell_components.StatusCell.__module__`.
 *
 * Grouping
 * ........
 *
 * Cells are grouped by their combination of the current status's color, icon URL and label.
 *
 * Sorting
 * .......
 *
 * Proceed cells are sorted by their current status's label (``value.current.data.label``).
 *
 * Filtering
 * .........
 *
 * Values match the table filter if the current status's label contains the filter text.
 *
 */
class ProceedCell extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.getStatusCellComponent = this.getStatusCellComponent.bind(this);
        this.emptyAttributes = Immutable.Map();
        this.state = {
            showModalForNextStatus: null,
            statusCellComponent: this.getStatusCellComponent(this.props),
            attributes: this.emptyAttributes
        };
        this.initAttributes = this.initAttributes.bind(this);
        this.getAttributes = this.getAttributes.bind(this);
        this.setAttributes = this.setAttributes.bind(this);
        this.getMissingAttributes = this.getMissingAttributes.bind(this);
        this.proceedTo = this.proceedTo.bind(this);
        this.refreshTable = this.refreshTable.bind(this);
        this.modalClosed = this.modalClosed.bind(this);
        this.proceedToggled = this.proceedToggled.bind(this);
        this.onSelectHandler = this.onSelectHandler.bind(this);
        this.initAttributes(args);
    }

    getStatusCellComponent(props) {
        return helpers.getTaskPlugin(
            props.row,
            PLUGIN_STATUS_CELL,
            StatusCell
        );
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.row.get(constants.PLUGIN_DISCRIMINATORS) !==
            this.props.row.get(constants.PLUGIN_DISCRIMINATORS)) {
            this.setState({
                statusCellComponent: this.getStatusCellComponent(nextProps)
            });
        }
        if (nextProps.value !== this.props.value) {
            this.initAttributes(nextProps);
        }
    }

    // additional user-provided attributes from modal
    initAttributes(props) {
        if (props.value) {
            const attributes = props.value.get(constants.TARGETS).reduce(
                (result, status) => result.set(
                    status.getIn(['data', 'status']),
                    status.getIn(['data', 'attributes'])
                ),
                this.emptyAttributes
            );
            this.setState({attributes: attributes});
            this.setState({attributes: attributes});
        }
    }

    getAttributes(nextStatus) {
        return this.state.attributes.get(
            nextStatus.getIn(['data', 'status'])
        ) || this.emptyAttributes;
    }

    setAttributes(status, kwargs) {
        this.setState(prevState => ({
            attributes: prevState.attributes.set(status, kwargs)
        }));
    }

    getMissingAttributes(nextStatus) {
        if (!nextStatus) {
            return null;
        }
        const attrs = nextStatus.getIn(['data', 'attributes']);

        if (attrs) {
            const mandatory = attrs
                .filter((attrs) => attrs.get('mandatory'))
                .keySeq()
                .toSet();
            return mandatory.intersect(
                this.getAttributes(nextStatus)
                    .filter((attrs) => !isValid(attrs.get('value')))
                    .keySeq()
            );
        } else {
            return Immutable.Set();
        }
    }

    proceedTo(nextStatus, event) {
        const missing = this.getMissingAttributes(nextStatus);
        const attributes = this.getAttributes(nextStatus);
        const {proceed, row, condition} = this.props;

        if (nextStatus && missing.size === 0) {
            this.setState({
                showModalForNextStatus: null
            });
            // proceed action refreshes the tasks table itself
            proceed(
                getRowID(row),
                nextStatus.getIn(['data']),
                attributes && attributes.toJS(),
                condition
            );
        } else {
            this.setState({
                showModalForNextStatus: nextStatus
            });
        }
        if (event) {
            helpers.stopEvent(event);
        }
    }

    refreshTable() {
        const {getTasks, condition} = this.props;
        getTasks(condition);
    }

    modalClosed(canceled) {
        if (canceled) {
            this.setState({
                showModalForNextStatus: null
            });
        } else {
            const nextStatus = this.state.showModalForNextStatus;
            this.proceedTo(nextStatus);
        }
    }

    proceedToggled(isOpen) {
        const {row, value, getProceed} = this.props;

        if (value && isOpen) {
            if (!value.get(constants.TARGETS).size) {
                getProceed(getRowID(row));  // load target statuses
            }
        } else {
            const proceed = document.getElementById(
                helpers.prefixNS(`proceed-btn-${getRowID(row)}`)
            );
            proceed.blur();
        }
    }

    onSelectHandler(key, e) {
        const {value} = this.props;
        this.proceedTo(value.getIn([constants.TARGETS, key]), e);
    }

    render() {
        const {value, row, column, isGroup} = this.props;
        const {statusCellComponent, showModalForNextStatus} = this.state;
        const isReadOnly = isGroup || isDeleted(row);
        const currentStatus = value ? (
            React.createElement(statusCellComponent, {
                value: value.get('current'),
                row: row,
                column: column,
                isGroup: isGroup
            })
        ) : constants.NULL;

        if (isReadOnly) {
            return currentStatus;
        }

        const loading = value && value.get(constants.TARGETS) === 0;

        return (
            <span className={helpers.prefixNS('proceed-cell')}>
                <Button.DropdownTextButton
                    label={currentStatus}
                    className={helpers.prefixNS('proceed-button')}
                    id={helpers.prefixNS(`proceed-btn-${getRowID(row)}`)}
                    onToggle={this.proceedToggled}
                    onSelect={this.onSelectHandler}>
                    {loading ? constants.LOADING : (
                        value && value.get(constants.TARGETS).map((s, index) => (
                            <MenuItem key={`next-status-${index}`} eventKey={index}>
                                {React.createElement(statusCellComponent, {
                                    value: s,
                                    row: row,
                                    column: column,
                                    getTasks: this.refreshTable
                                })}
                            </MenuItem>
                        ))
                    )}
                </Button.DropdownTextButton>
                {(!isGroup && showModalForNextStatus) && (
                    <ProceedModal
                        status={showModalForNextStatus.getIn(['data', 'status'])}
                        attributes={this.getAttributes(showModalForNextStatus)}
                        setAttributes={this.setAttributes}
                        onClose={this.modalClosed}
                    />
                )}
            </span>
        );
    }
}

ProceedCell.groupByFunction = (value) => (
    // only use current color, icon and label for grouping
    value.filter((val, key) => key === 'current').setIn(
        ['current', 'data'],
        value.getIn(['current', 'data']).filter(
            (val, key) => (
                key === 'color' ||
                key === 'label' ||
                key === 'icon_url'
            )
        )
    )
);

ProceedCell.sortFunction = (a, b) => (
    customSort(x => x.getIn(['current', 'data', 'label']), '', a, b)
);

ProceedCell.filterFunction = (value, loweredText) => {
    const valueStr = value && value.getIn(['current', 'data', 'label']) || '';
    return valueStr.toLowerCase().indexOf(loweredText) > -1;
};

ProceedCell.propTypes = {
    ...CELL_PROPTYPE,
    row: ImmutablePropTypes.map.isRequired,
    value: ImmutablePropTypes.contains({
        current: STATUS_PROPTYPE,
        [constants.TARGETS]: ImmutablePropTypes.listOf(STATUS_PROPTYPE)
    }),
    condition: proptypes.VIEW_CONDITION,
    proceed: PropTypes.func.isRequired,
    getTasks: PropTypes.func.isRequired
};

function mapStateToProps(state) {
    return {
        condition: getCurrentView(state).get('condition')
    };
}

function mapDispatchToProps(dispatch) {
    return {
        getProceed: (task_oid) => {dispatch(getTargetStatuses(task_oid))},
        proceed: (task_oid, proceed_to, kwargs, condition) => {
            dispatch(changeStatus(task_oid, proceed_to, kwargs, condition));
        },
        getTasks: (condition) => {dispatch(getTasks(condition))}
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(ProceedCell);
