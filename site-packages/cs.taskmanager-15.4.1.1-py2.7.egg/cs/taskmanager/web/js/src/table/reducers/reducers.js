/* -*- mode: javascript; coding: utf-8 -*-
 * $Id: reducers.js 180826 2018-07-23 06:49:09Z cso $
 *
 * Copyright (c) 1990 - 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 */

import Immutable from 'immutable';
import * as actions from '../actions/actions';
import * as constants from '../../constants';
import * as helpers from '../../helpers';
import {getReadStatusCSSClasses} from '../../reducers/reducers';

const COL_TAGS = 'cs_tasks_col_tags';
const COL_READ_STATUS = 'cs_tasks_col_read_status';
const COL_STATUS = 'cs_tasks_col_status';

const SETTINGS = 'settings';
const TABLE = 'table';
const ROWS = 'rows';
const COLUMNS = 'columns';
const ATTRIBUTE = 'attribute';
const TAGS = 'tags';
const CLASSNAME = 'className';
const DELTA = 'delta';
const PROCEEDING = 'proceeding';

export default function(state, action) {
    switch (action.type) {
        case actions.RECEIVED_SETTINGS:
            return receivedSettings(state, action.payload);
        case actions.SAVE_TAGS_RESPONSE:
            return saveTagsResponse(state, action.payload);
        case actions.SAVE_READ_STATUS_RESPONSE:
            return saveReadStatusResponse(state, action.payload);
        case actions.TARGET_STATUSES:
            return targetStatuses(state, action.payload);
        case actions.STATUS_CHANGE_IN_FLIGHT:
            return statusChangeInFlight(state, action.payload);
        default:
            return state;
    }
}

function receivedSettings(state, payload) {
    return state.set(SETTINGS, Immutable.fromJS(payload[SETTINGS]));
}

function aggregateAllTags(state, tagsIndex) {
    let aggregated = Immutable.Set([]);

    state.getIn([TABLE, ROWS]).forEach(row => {
        aggregated = aggregated.union(row.getIn([COLUMNS, tagsIndex]));
    });

    return state.set(constants.USER_TAGS, aggregated.toList());
}

function saveTagsResponse(state, payload) {
    const tagsIndex = state.getIn([TABLE, COLUMNS]).findIndex(
        x => x.get(ATTRIBUTE) === COL_TAGS
    );
    const mergedTags = state.setIn(
        [
            TABLE,
            ROWS,
            helpers.getTaskIndex(state.getIn([TABLE, ROWS]), payload[constants.TASK_OID]),
            COLUMNS,
            tagsIndex
        ],
        Immutable.fromJS(payload[TAGS])
    );
    return aggregateAllTags(mergedTags, tagsIndex);
}

function saveReadStatusResponse(state, payload) {
    const rowIndex = helpers.getTaskIndex(state.getIn([TABLE, ROWS]), payload[constants.TASK_OID]);
    const readIndex = state.getIn([TABLE, COLUMNS]).findIndex(
        x => x.get(ATTRIBUTE) === COL_READ_STATUS
    );
    const columns = state.getIn([TABLE, ROWS, rowIndex, COLUMNS]);
    // request may have been made before tasks are loaded
    if (columns !== undefined) {
        return state.mergeIn([TABLE, ROWS, rowIndex], {
            [COL_READ_STATUS]: payload[COL_READ_STATUS],
            [CLASSNAME]: getReadStatusCSSClasses(
                payload[COL_READ_STATUS],
                state.getIn([TABLE, ROWS, rowIndex, CLASSNAME])
            ),
            [COLUMNS]: columns.set(readIndex, payload[COL_READ_STATUS])
        });
    }
    return state;
}

function targetStatuses(state, payload) {
    const rowIndex = helpers.getTaskIndex(state.getIn([TABLE, ROWS]), payload[constants.TASK_OID]);
    const proceedIndex = state.getIn([TABLE, COLUMNS]).findIndex(
        x => x.get(ATTRIBUTE) === COL_STATUS
    );

    return state.setIn(
        [TABLE, ROWS, rowIndex, COLUMNS, proceedIndex, constants.TARGETS],
        Immutable.fromJS(payload[constants.TARGETS])
    );
}

function statusChangeInFlight(state, payload) {
    return state.setIn(
        [DELTA, PROCEEDING],
        state.getIn([DELTA, PROCEEDING]).add(payload[constants.TASK_OID])
    );
}
