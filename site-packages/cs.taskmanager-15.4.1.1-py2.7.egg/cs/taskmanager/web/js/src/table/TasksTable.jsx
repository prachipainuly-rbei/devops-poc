import React from 'react';
import Immutable from 'immutable';
import {Alert} from 'react-bootstrap';
import {
    reselect, connect, PropTypes, ImmutablePropTypes, browserHistory
} from 'cs-web-components-externals';
const {createSelector} = reselect;
import * as helpers from '../helpers';
import * as constants from '../constants';
import * as proptypes from '../proptypes';
import {selectRows, getTasks} from '../actions/actions';
import {fetchSettings, saveReadStatus} from './actions/actions';
import {
    Registry,
    Table,
    TableOperationToolbar
} from 'cs-web-components-base';
import Notifications from '../main/Notifications';
import {getCurrentViewCondition} from '../main/views/selectors';

const ContextObjectWrapper = Registry.findComponent('cs-web-components-base-ContextObjectWrapper');
const TableWrapper = Registry.findComponent('cs-web-components-base-TableWrapper');

const ROWS = 'rows';
export const TABLE_CONTEXT_PATH = helpers.prefixNS('tasks-table-context');
const OPERATION_CONTEXT = 'CsTasksTable';

class TasksTable extends React.PureComponent {
    constructor(...args) {
        super(...args);
        const tableOptions = Table.PredefinedTables.getDefaultTableOptions();
        tableOptions.Table = Table.Scrolled(Table.Table);
        tableOptions.toolbarButtons.push({
            toolbarButtons: [
                () => (
                    <ContextObjectWrapper readPath={TABLE_CONTEXT_PATH}>
                        <TableOperationToolbar
                            operationContextName={OPERATION_CONTEXT}
                            refreshTable={this.refreshTable.bind(this)}
                        />
                    </ContextObjectWrapper>
                )
            ]
        });
        this.FeatureTable = () => Table.PredefinedTables.DefaultTable(tableOptions);
        this.refreshTable = this.refreshTable.bind(this);
        this.setCurrentURLFromPrimarySelection = this.setCurrentURLFromPrimarySelection.bind(this);
        this.resetURL = this.resetURL.bind(this);
        this.onSelect = this.onSelect.bind(this);
    }

    refreshTable() {
        const {getTasks, condition} = this.props;
        getTasks(condition);
    }

    componentWillMount() {
        this.props.getSettings();  // triggers loading tasks
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.currentSelection !== this.props.currentSelection) {
            this.setSelectedTaskRead(nextProps);
        }

        if (nextProps.table.get(ROWS) !== this.props.table.get(ROWS)) {
            this.resetURL(nextProps);
        }
    }

    // reset url if primary selection is missing
    // TODO what if selection contains other (existing) tasks?
    resetURL(newerProps) {
        const props = newerProps || this.props;
        const selected = props.currentSelection.get(constants.TASK_OIDS);

        if (selected.size > 0) {
            if (
                helpers.getTaskIndex(
                    props.table.get(ROWS),
                    props.currentSelection.get(constants.TASK_OIDS).last()
                ) === -1
            ) {
                this.setCurrentURLFromPrimarySelection();
            }
        }
    }

    // change current URL/route
    setCurrentURLFromPrimarySelection(primarySelection) {
        if (primarySelection) {
            browserHistory.push(`${helpers.basePath}/${primarySelection}`);
        } else {
            // empty selection
            browserHistory.push(helpers.basePath);
        }
    }

    /*
     * The current selection consists of 0..n rows:
     *
     * - The last selected row is the "primary selection". It controls both the current URL/route
     *   and the details area. It is also the context object for operations triggered in the table
     *   header.
     * - The first 0..n-1 selected rows are the "secondary selection". They too are context objects
     *   for operations triggered in the table header.
     *
     * The following actions only respect a single row:
     * - Switching the read status,
     * - Changing the status using the status column dropdown and
     * - Modifying tags.
     */
    onSelect(oids) {
        if (oids.size > 0) {
            const primarySelection = oids.last();
            const {currentSelection, table, selectRows} = this.props;

            // load operations for table header using ui_links of all selected rows
            this.context.loadTaskOperations(
                table.get(ROWS)
                    .filter(row => oids.includes(row.get('id')))
                    .map(row => row.get(constants.ID))
            );

            selectRows(oids);

            if (currentSelection.get(constants.TASK_OIDS).last() !== primarySelection) {
                this.setCurrentURLFromPrimarySelection(primarySelection);
            }
        } else {
            this.setCurrentURLFromPrimarySelection();
        }
    }

    setSelectedTaskRead(nextProps) {
        const nextTask = nextProps.selectedTask;

        if (!nextTask) {
            return;
        }

        const {selectedTask, setReadStatus} = this.props;

        if (!selectedTask || nextTask !== selectedTask) {
            const selectedTaskRow = nextProps.table.get(ROWS).filter(row => (
                row.get('id') === nextTask.get(constants.CDB_OBJECT_ID)
            ));

            if (selectedTaskRow && !selectedTaskRow.get('read_status')) {
                setReadStatus(nextTask.get(constants.CDB_OBJECT_ID), 1);
            }
        }
    }

    render() {
        const {table, initSelected, hiddenColumns} = this.props;

        if (table && table.get('error')) {
            return (
                <div>
                    <p className='text-error'>
                        {this.props.table.get('error')}
                    </p>
                </div>
            );
        }

        if (!table || table.get('fetching')) {
            return (
                <Alert bsStyle='info'>...</Alert>
            );
        }

        const tableID = helpers.prefixNS('tasks-table');

        return (
            <TableWrapper
                title={<Notifications />}
                hiddenColumns={hiddenColumns}
                id={tableID}
                collapsible={false}
                settingID={tableID}
                initSelected={initSelected}
                tableDef={table}
                rowValues={table.get(ROWS)}
                contentHeight='100%'
                singleSelection={false}
                withSelector={true}
                onSelectionChanged={this.onSelect}
                table={this.FeatureTable}
            />
        );
    }
}

TasksTable.contextTypes = {
    loadTaskOperations: PropTypes.func.isRequired
};

TasksTable.propTypes = {
    condition: proptypes.VIEW_CONDITION,
    table: proptypes.TABLE,
    hiddenColumns: ImmutablePropTypes.setOf(PropTypes.string),
    currentSelection: proptypes.CURRENT_SELECTION,
    initSelected: ImmutablePropTypes.orderedSetOf(PropTypes.string).isRequired,
    selectedTask: proptypes.OBJECT_PROPTYPE,
    selectRows: PropTypes.func.isRequired,
    setReadStatus: PropTypes.func.isRequired,
    getTasks: PropTypes.func.isRequired,
    getSettings: PropTypes.func.isRequired
};

const EMPTY_SELECTION = Immutable.OrderedSet();

function _getInitSelected(currentSelection) {
    const selectedOIDs = currentSelection.get(constants.TASK_OIDS);

    if (selectedOIDs) {
        return selectedOIDs;
    } else {
        return EMPTY_SELECTION;
    }
}

export const getInitSelected = createSelector(
    [_getInitSelected],
    initSelected => initSelected
);

function mapStateToProps(state) {
    const ownState = state[helpers.prefixNS('reducer')];
    const currentSelection = ownState.get('currentSelection');
    const currentSelectionOIDS = ownState.getIn(['currentSelection', constants.TASK_OIDS]);

    return {
        currentSelection,
        initSelected: getInitSelected(currentSelection),
        selectedTask: state.objectsById.get(
            ownState.getIn(
                ['currentSelection', 'byObjectID', currentSelectionOIDS.last(), constants.ID]
            )
        ),
        condition: getCurrentViewCondition(state),
        table: ownState.get('table'),
        hiddenColumns: ownState.get('hiddenColumns')
    };
}

function mapDispatchToProps(dispatch) {
    return {
        selectRows: (task_oids) => {dispatch(selectRows(task_oids))},
        setReadStatus: (task_oid, read_status) => {
            dispatch(saveReadStatus(task_oid, read_status));
        },
        getTasks: (condition) => {dispatch(getTasks(condition))},
        getSettings: () => {dispatch(fetchSettings())}
    };
}

export default connect(mapStateToProps, mapDispatchToProps)(TasksTable);
