import React from 'react';
import Immutable from 'immutable';
import {Label, Form, FormGroup} from 'react-bootstrap';
import {saveTags} from '../actions/actions';
import {connect, ImmutablePropTypes, PropTypes, classNames} from 'cs-web-components-externals';
import {FormControl} from 'cs-web-components-base';
import {formatStr} from '../../i18n';
import * as helpers from '../../helpers';
import * as constants from '../../constants';
import {EMPTY, CELL_PROPTYPE, isDeleted, customSort} from './index';

const MESSAGE_TAGS_TOOLTIP_1 = 'tags_tooltip_1';
const MESSAGE_TAGS_TOOLTIP_2 = 'tags_tooltip_2';

class TagLabel extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.removeTag = this.removeTag.bind(this);
    }

    removeTag(event) {
        const {removeTag, index} = this.props;
        removeTag(index);
        helpers.stopEvent(event);
    }

    render() {
        const {tag, index, active} = this.props;
        return (
            <Label
                key={`tag-${index}`}
                bsStyle='primary'
                className={classNames(
                    helpers.prefixNS('task-tag'),
                    helpers.prefixNS(`task-tag-${tag}`)
                )}
            >
                {tag}
                {active && (
                    <span
                        className={helpers.prefixNS('remove-tag')}
                        onClick={this.removeTag}
                    >
                        &times;
                    </span>
                )}
            </Label>
        );
    }
}

TagLabel.propTypes = {
    tag: PropTypes.string.isRequired,
    index: PropTypes.number.isRequired,
    active: PropTypes.bool.isRequired,
    removeTag: PropTypes.func.isRequired
};

/**
 * Displays a list of deletable tags and an input field for adding new ones.
 *
 * React Properties
 * ................
 *
 * +----------+----------------+---------+----------------------------------------+
 * | Property | Type           | Default | Use                                    |
 * +==========+================+=========+========================================+
 * | value    | Immutable.List | \-      | List of strings representing the tags. |
 * +----------+----------------+---------+----------------------------------------+
 * | setTags  | Function       | \-      | Function to change the row's tags.     |
 * |          | (Required)     |         |                                        |
 * +----------+----------------+---------+----------------------------------------+
 * | isGroup  | Boolean        | \-      | If true, interaction is disabled.      |
 * +----------+----------------+---------+----------------------------------------+
 *
 * The standard cell property ``row`` is required.
 *
 * Sorting
 * .......
 *
 * Tag cells are sorted by their concatenated tag strings.
 *
 * Filtering
 * .........
 *
 * Values match the table filter if the comma-separated tags string contains the filter text.
 *
 */
class TagsCell extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.removeTag = this.removeTag.bind(this);
        this.addTag = this.addTag.bind(this);
    }

    removeTag(index) {
        let indexToRemove = index;
        if (index === -1) {
            // remove last tag
            indexToRemove += this.props.value.size;
        }
        const newTags = this.props.value.concat().splice(indexToRemove, 1);
        this.props.setTags(this.props.row.get('id'), newTags);
    }

    addTag(value) {
        if (value && typeof value === 'string') {
            const tags = value > '' ? value.split(',') : [];
            this.props.setTags(
                this.props.row.get('id'),
                this.props.value.concat(tags).filter(
                    tag => typeof tag === 'string'
                )
            );
        }
        helpers.stopEvent(event);
    }

    render() {
        const {value, isGroup, row} = this.props;
        const active = !(isGroup || isDeleted(row));

        if (value !== undefined && value !== null) {
            return (
                <span className={helpers.prefixNS('task-tag-wrapper')}>
                    {value.map((tag, index) => (
                        <TagLabel
                            key={tag}
                            tag={tag}
                            index={index}
                            active={active}
                            removeTag={this.removeTag}
                        />
                    ))}
                    {active && (
                        <TagInput
                            name={`tag-input-${value[constants.ID]}`}
                            addTag={this.addTag}
                            removeTag={this.removeTag}
                            showPlaceholder={!value.size}
                        />
                    )}
                </span>
            );
        } else {
            return EMPTY;
        }
    }
}

TagsCell.sortFunction = (a, b) => (
    customSort(x => x.map(i => i.toLowerCase()).join(''), '', a, b)
);

TagsCell.filterFunction = (value, loweredText) => {
    const valueStr = value.join(', ') || '';
    return valueStr.toLowerCase().indexOf(loweredText) > -1;
};

TagsCell.propTypes = {
    ...CELL_PROPTYPE,
    value: ImmutablePropTypes.listOf(PropTypes.string),
    setTags: PropTypes.func.isRequired
};

function mapDispatchToProps(dispatch) {
    return {
        setTags: (task_oid, tags) => {dispatch(saveTags(task_oid, tags))}
    };
}

export default connect(null, mapDispatchToProps)(TagsCell);

class _TagInput extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.emptyMatches = Immutable.List();
        this.state = {
            text: '',
            matches: this.emptyMatches
        };
        this.filterTags = this.filterTags.bind(this);
        this.keyDownHandler = this.keyDownHandler.bind(this);
        this.keyUpHandler = this.keyUpHandler.bind(this);
        this.onTextChange = this.onTextChange.bind(this);
        this.onSelectAt = this.onSelectAt.bind(this);
    }

    filterTags(data, value) {
        const lowered = value.toLowerCase();
        const filtered = data.filter(item => (
            lowered !== '' && item.toLowerCase().indexOf(lowered) === 0)
        );
        if (filtered.size === 0) {
            return this.emptyMatches;
        } else {
            return filtered;
        }
    }

    keyDownHandler(event) {
        const {removeTag} = this.props;

        switch (event.key) {
            case 'Backspace':
                if (event.target.value === '') {
                    removeTag(-1);
                }
                break;
        }
    }

    keyUpHandler() {
        this.props.addTag(this.state.text);
        this.setState({
            text: '',
            matches: this.emptyMatches
        });
    }

    // TypeAhead
    onTextChange(event) {
        const {data} = this.props;
        const value = event.target.value;
        this.setState({
            text: value,
            matches: this.filterTags(data, value)
        });
    }

    onSelectAt(idx) {
        this.setState((prevState, props) => {
            const {data} = props;
            const hit = prevState.matches.get(idx);
            return {
                text: hit,
                matches: this.filterTags(data, hit)
            };
        });
    }
    // /TypeAhead

    render() {
        const {name, showPlaceholder, addTag} = this.props;
        const {text, matches} = this.state;

        const placeholder = formatStr(MESSAGE_TAGS_TOOLTIP_1);
        const tooltip = `${placeholder}\n${formatStr(MESSAGE_TAGS_TOOLTIP_2)}`;

        return (
            <Form
                inline
                onSubmit={helpers.stopEvent}
                className={helpers.prefixNS('tags-input-form')}
            >
                <FormGroup bsSize='small'>
                    <TypeAheadTagInput
                        value={text}
                        matched={matches}
                        onChange={this.onTextChange}
                        onSelectAt={this.onSelectAt}
                        name={name}
                        className={helpers.prefixNS('tags-input')}
                        onBlur={addTag}
                        onKeyDown={this.keyDownHandler}
                        onEnter={this.keyUpHandler}
                        title={tooltip}
                        placeholder={showPlaceholder ? placeholder : null}
                    />
                 </FormGroup>
            </Form>
        );
    }
}

_TagInput.defaultProps = {
    showPlaceholder: true
};

_TagInput.propTypes = {
    name: PropTypes.string.isRequired,
    addTag: PropTypes.func.isRequired,
    removeTag: PropTypes.func.isRequired,
    showPlaceholder: PropTypes.bool,
    data: ImmutablePropTypes.list
};

function mapStateToProps(state) {
    const ownState = state[helpers.prefixNS('reducer')];
    return {
        data: ownState.get(constants.USER_TAGS)
    };
}

const TagInput = connect(mapStateToProps)(_TagInput);

const TypeAheadTagInput = FormControl.WithTypeAhead(FormControl.TextInput);
