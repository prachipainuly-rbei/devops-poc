import React from 'react';
import {shallow, mount} from 'enzyme';
import DateCell from '../DateCell';
import {getFormattedDate} from '../DateCell';
import moment from 'moment';
import * as helpers from '../../../helpers';

const TODAY = moment();

const getDate = (momentObject) => Immutable.Map({
    iso: momentObject.toISOString(),
    epoch: momentObject.unix(),
    overdue: TODAY.isAfter(momentObject, 'day')
});

const YESTERDAY = getDate(moment().add(-1, 'days'));

const beforeTwoDays = getDate(moment().add(-2, 'days'));

function staticDateFormat() {
    return moment.defaultFormat = 'YYYY-MM-DDTHH:mm:ss.sssZ';
}

describe('The getFormattedDate function', () => {
    /**
     * Mocks the function setupMoment, because the time format in an installation with different language
     * settings is different.
     */
    helpers.setupMoment = jest.fn(staticDateFormat);

    it('returns the correct DATE_CACHE', () => {
        const actualdate = moment().startOf('day');
        const date = moment('05 July 2018 14:48 UTC').startOf('day');
        const diff = moment.duration(date.diff(actualdate));
        const days = getFormattedDate(date).days;
        const formatted_date = getFormattedDate(date).formatted_date;
        const humanized_delta = getFormattedDate(date).humanized_delta;

        expect(days).toBe(diff.asDays());
        expect(formatted_date).toBe('2018-07-05T00:00:00.000+02:00');
        expect(humanized_delta).toBe(helpers.humanizeDuration(diff));
    });
});

describe('The DateCell component', () => {
    /**
     * Mocks the function setupMoment, because the time format in an installation with different language
     * settings is different.
     */
    helpers.setupMoment = jest.fn(staticDateFormat);

    it('with Yesterday unstyled displays a span with the passed value', () => {
        const wrapper = shallow(<DateCell value={YESTERDAY} unstyled />);

        expect(wrapper.find('.cs-taskmanager-web-date-unstyled').length).toBe(1);
        expect(wrapper.find('span').length).toBe(1);
        expect(wrapper.find('div').length).toBe(0);
        expect(wrapper.find('Label').length).toBe(0);
    });

    it('with Yesterday displays a div and Label with the passed value', () => {
        const wrapper = shallow(<DateCell value={YESTERDAY} />);

        expect(wrapper.find('.cs-taskmanager-web-date').length).toBe(1);
        expect(wrapper.find('div').length).toBe(1);
        expect(wrapper.find('Label').length).toBe(1);
    });

    it('with no date displays an empty Label ("--")', () => {
        const wrapper = mount(<DateCell />);

        expect(wrapper.find('.cs-taskmanager-web-date').length).toBe(2);
        expect(wrapper.find({ bsStyle: 'default' }).length).toBe(1);
        expect(wrapper.find('div').length).toBe(1);
        expect(wrapper.find('Label').length).toBe(1);
        expect(wrapper.find('Label').text()).toBe('--');
    });
});

describe('The DateCell component function getFormattedDate ', () => {
    const datecell = new DateCell();

    it('with no parameter set the value in the state to null', () => {
        /**
        * Mocks the function setState.
        */
        datecell.setState = jest.fn();

        datecell.getFormattedDate();
        expect(datecell.setState.mock.calls.length).toBe(1);
        expect(datecell.setState.mock.calls[0][0]).toEqual({"value": null});
    });

    it('with a parameter value parameter set the state to the passed date', () => {
        const date = getDate(moment('05 July 2018 14:48 UTC'));
        /**
        * Mocks the function setState.
        */
        datecell.setState = jest.fn();
        datecell.getFormattedDate(date);
        expect(datecell.setState.mock.calls.length).toBe(1);
        const result = datecell.setState.mock.calls[0][0];
        expect(result.label).toEqual("danger");
        expect(result.value).toEqual("2018-07-05T00:00:00.000+02:00");
    });
});

describe('The DateCell component function getLabelStyleAndValue', () => {
    const datecell = new DateCell();

    it('with days > 0 (future) return the label "default"', () => {
        const value = getDate(moment().add(+5, 'days'));
        const formatted_date = getFormattedDate(value.get('iso'));
        expect(datecell.getLabelStyleAndValue(formatted_date).label).toEqual('default');
    });

    it('with days < 0 (past) return the label "danger"', () => {
        const value = getDate(moment('05 July 2018 14:48 UTC'));
        const formatted_date = getFormattedDate(value.get('iso'));
        expect(datecell.getLabelStyleAndValue(formatted_date).label).toEqual('danger');
        expect(datecell.getLabelStyleAndValue(formatted_date).value).toEqual('2018-07-05T00:00:00.000+02:00')
    });

    it('with days = 0 (today) return the label "info"', () => {
        const value = getDate(moment());
        const formatted_date = getFormattedDate(value.get('iso'));
        expect(datecell.getLabelStyleAndValue(formatted_date).label).toBe('info');
        expect(datecell.getLabelStyleAndValue(formatted_date).tooltip).toBe(getFormattedDate(value).formatted_date);
    });
});

describe('The DateCell component function sortFunction', () => {
    it('with a < b sort it correctly', () => {
        const a = beforeTwoDays;
        const b = YESTERDAY;
        expect(DateCell.sortFunction([a],[b])).toBe(-1);
    });

    it('with a > b sort it correctly', () => {
        const a = YESTERDAY;
        const b = beforeTwoDays;
        expect(DateCell.sortFunction([a],[b])).toBe(1);
    });

    it('with a = b sort it correctly', () => {
        const a = YESTERDAY;
        const b = YESTERDAY;
        expect(DateCell.sortFunction([a],[b])).toBe(0);
    });
});

describe('The DateCell component function filterFunction', () => {
    const value = moment('05 July 2018 14:48 UTC');

    it('with a loweredText that can be find in the value', () => {
        const loweredText = "2018";
        expect(DateCell.filterFunction(value,loweredText)).toBe(true);
    });

    it('with a loweredText that cannot be find in the value', () => {
        const loweredText = "2017";
        expect(DateCell.filterFunction(value,loweredText)).toBe(false);
    });
});
