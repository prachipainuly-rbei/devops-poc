import React from 'react';
import moment from 'moment';
import {Label} from 'react-bootstrap';
import {PropTypes} from 'cs-web-components-externals';
import * as constants from '../../constants';
import * as helpers from '../../helpers';
import {DATE_PROPTYPE} from '../../proptypes';
import {CELL_PROPTYPE, customSort} from './index';

const MAX_EPOCH = 9999999999;
const DATE_CACHE = {};
const TODAY = moment().startOf('day');

export function getFormattedDate(isodate) {
    helpers.setupMoment();
    if (!DATE_CACHE.hasOwnProperty(isodate)) {
        const date = moment(isodate).startOf('day');
        if (date.isValid()) {
            const diff = moment.duration(date.diff(TODAY));
            DATE_CACHE[isodate] = {
                'isodate': isodate,
                'formatted_date': date.format(),
                'humanized_delta': helpers.humanizeDuration(diff),
                'days': diff.asDays()
            };
        } else {
            DATE_CACHE[isodate] = {
                'isodate': isodate,
                'error': 'invalid date'
            };
        }
    }
    return DATE_CACHE[isodate];
}

/**
 * Displays a date in configured date format. The tooltip contains a
 * human-readable, relative date. Dates also use label styles:
 *
 * +----------------+---------------+
 * | Date           | Label Style   |
 * +================+===============+
 * | In the past    | danger        |
 * +----------------+---------------+
 * | Today          | info          |
 * +----------------+---------------+
 * | In the future  | default       |
 * +----------------+---------------+
 * | null           | default       |
 * +----------------+---------------+
 *
 * "Yesterday", "Today" and "Tomorrow" are special cases; They directly use the humanized date and the formatted date
 * as tooltip.
 *
 * React Properties
 * ................
 *
 * +---------------+---------------+---------+----------------------------------------------------------------------+
 * | Property      | Type          | Default | Use                                                                  |
 * +===============+===============+=========+======================================================================+
 * | value         | Immutable.Map | \-      | The date object to be displayed. Its keys are described below.       |
 * +---------------+---------------+---------+----------------------------------------------------------------------+
 * | value.iso     | String        | \-      | The date in ISO format for calculating displayed representations.    |
 * +---------------+---------------+---------+----------------------------------------------------------------------+
 * | value.overdue | Boolean       | \-      | Indicates whether this date lies in the past or not.                 |
 * +---------------+---------------+---------+----------------------------------------------------------------------+
 * | value.epoch   | Number        | \-      | Seconds since the epoch. Used for sorting.                           |
 * +---------------+---------------+---------+----------------------------------------------------------------------+
 * | unstyled      | Boolean       | \-      | If true, the date will be displayed inline and without label style.  |
 * +---------------+---------------+---------+----------------------------------------------------------------------+
 *
 * No properties are required.
 *
 * Sorting
 * .......
 *
 * Date cells are sorted by their value.epoch value, defaulting to the maximum value allowed for epochs. This means
 * null-dates are sorted as being as far in the future as possible.
 *
 * Filtering
 * .........
 *
 * Values match the table filter if either displayed or tooltip value contains the filter text.
 *
 */
export default class DateCell extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.getFormattedDate = this.getFormattedDate.bind(this);
        this.getLabelStyleAndValue = this.getLabelStyleAndValue.bind(this);
    }

    getFormattedDate(value) {
        if (value && value.get('iso')) {
            // format and humanize date
            const formatted_date = getFormattedDate(value.get('iso'));
            this.setState(this.getLabelStyleAndValue(formatted_date));
        } else {
            this.setState({value: null});
        }
    }

    componentWillMount() {
        this.getFormattedDate(this.props.value);
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.value !== this.props.value) {
            this.getFormattedDate(nextProps.value);
        }
    }

    getLabelStyleAndValue(date) {
        const {days, humanized_delta, formatted_date} = date;
        switch (true) {
            case (days > 0):
                /*
                 * future
                 * show date as normal text
                 * show humanized date if it is tomorrow
                 */
                return {
                    label: 'default',
                    value: days === 1 ? humanized_delta : formatted_date,
                    tooltip: days === 1 ? formatted_date : humanized_delta
                };
            case (days < 0):
                /*
                 * past
                 * show date as label-danger
                 * show humanized date if it is yesterday
                 */
                return {
                    label: 'danger',
                    value: days === -1 ? humanized_delta : formatted_date,
                    tooltip: days === -1 ? formatted_date : humanized_delta
                };
            default:
                // today
                return {
                    label: 'info',
                    value: humanized_delta,
                    tooltip: formatted_date
                };
        }
    }

    render() {
        const {label, value, tooltip} = this.state;
        const {unstyled} = this.props;

        if (unstyled) {
            return (
                <span
                    className={helpers.prefixNS('date-unstyled')}
                    title={tooltip}
                >
                    {value || constants.NULL}
                </span>
            );
        } else {
            return (
                <div>
                    <Label
                        bsStyle={label}
                        className={helpers.prefixNS('date')}
                        title={tooltip}
                    >
                        {value || constants.NULL}
                    </Label>
                </div>
            );
        }
    }
}

DateCell.sortFunction = (a, b) => (
    customSort(x => x.get('epoch'), MAX_EPOCH, a, b)
);

DateCell.filterFunction = (value, loweredText) => {
    const date = value && getFormattedDate(value.get('iso'));
    const valueStr = date && date.formatted_date + date.humanized_delta || '';
    return valueStr.toLowerCase().indexOf(loweredText) > -1;
};

DateCell.propTypes = {
    ...CELL_PROPTYPE,
    value: DATE_PROPTYPE,
    unstyled: PropTypes.bool
};
