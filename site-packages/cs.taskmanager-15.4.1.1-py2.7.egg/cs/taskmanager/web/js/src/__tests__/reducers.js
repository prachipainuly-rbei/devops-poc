/*
 * Copyright (C) 1990 - 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: reducers.js 185258 2018-10-18 11:15:26Z cso $"
 */

/* eslint-env jest */

import Immutable from 'immutable';
import * as actions from '../actions/actions';
import {getReadStatusCSSClasses} from '../reducers/reducers';
import reducer from '../reducers/reducers';

describe('The helper function "getReadStatusCSSClasses"', () => {
    test('fails for non-splittable existing class parameter', () => {
        expect(() => getReadStatusCSSClasses(null, 1)).toThrow();
    });

    test('returns a single CSS class', () => {
        expect(getReadStatusCSSClasses()).toBe(' cs-taskmanager-web-task-unread');
    });

    test('appends a single CSS class to existing classes', () => {
        expect(getReadStatusCSSClasses(true, 'abc')).toBe('abc cs-taskmanager-web-task-read');
    });
});

const TASKS_STATUS = Immutable.fromJS({
    table: {
        rows: [
            {cdb_object_id: 'leave'},
            {cdb_object_id: 'stay'},
            {cdb_object_id: 'updated'},
            {cdb_object_id: 'processed'}
        ]
    },
    delta: {
        proceeding: 'processed',
        temporaryTasks: Immutable.Set(['leave'])
    }
});
const TASKS_PAYLOAD = Immutable.fromJS({ // immutable, so we can use deep copies easily
    table: {
        columns: [
            {contentRenderer: 'x'}
        ],
        rows: [
            {cdb_object_id: 'updated', a: 'o'},
            {cdb_object_id: 'new', read_status: true}
        ],
    },
    userTags: ['a', 'b', 'c']
});

describe('The root reducer', () => {
    test('registers asynchronous backend requests in flight', () => {
        let state = Immutable.Map({
            inFlight: Immutable.Set()
        });
        const expected = [
            Immutable.Set([0]),
            Immutable.Set([0, 1])
        ];

        for (let i=0; i<2; i++) {
            state = reducer(
                state,
                {
                    type: actions.BACKEND_REQUEST_IN_FLIGHT,
                    payload: {
                        actionName: i,
                        isInFlight: true
                    }
                }
            );
            expect(state).toEqual(Immutable.Map({
                inFlight: expected[i]
            }));
        }
    });

    test('deregisters asynchronous backend requests in flight', () => {
        let state = Immutable.Map({
            inFlight: Immutable.Set([2, 1, 0])
        });
        const expected = [
            Immutable.Set([2, 1]),
            Immutable.Set([2]),
            Immutable.Set([]),
            Immutable.Set([])
        ];

        for (let i=0; i<4; i++) {
            state = reducer(
                state,
                {
                    type: actions.BACKEND_REQUEST_IN_FLIGHT,
                    payload: {
                        actionName: i
                    }
                }
            );
            expect(state).toEqual(Immutable.Map({
                inFlight: expected[i]
            }));
        }
    });

    test('optimistically updates user settings', () => {
        let state = Immutable.Map();
        state = reducer(
            state,
            {
                type: actions.OPTIMISTIC_UPDATE_USER_SETTINGS,
                payload: {a: 'a', b: 'b'}
            }
        );
        expect(state).toEqual(Immutable.fromJS({
            settings: {a: 'a', b: 'b'}
        }));
        state = reducer(
            state,
            {
                type: actions.OPTIMISTIC_UPDATE_USER_SETTINGS,
                payload: {a: 'A', c: 'c'}
            }
        );
        expect(state).toEqual(Immutable.fromJS({
            settings: {a: 'A', b: 'b', c: 'c'}
        }));
    });

    test('toggles the task loading indicator', () => {
        const result = reducer(
            Immutable.Map(),
            {
                type: actions.SHOW_TASKS_LOADING_INDICATOR
            }
        );
        expect(result).toEqual(Immutable.fromJS({
            table: {
                fetching: true
            }
        }));
    });

    test('ignores tasks fetched for another user', () => {
        const state = Immutable.fromJS({
            settings: {
                userID: 'ernie'
            }
        });
        const result = reducer(
            state,
            {
                type: actions.TASKS,
                payload: {
                    userID: 'bert'
                }
            }
        );
        expect(result).toBe(state);
    });

    test('displays fetched tasks', () => {
        const result = reducer(
            TASKS_STATUS,
            {
                type: actions.TASKS,
                payload: TASKS_PAYLOAD.toJS(),
                meta: {}
            }
        );
        expect(result).toEqual(Immutable.fromJS({
            table: {
                columns: [{contentRenderer: undefined}],
                rows: [
                    {cdb_object_id: 'stay', className: 'deleted'},
                    {cdb_object_id: 'processed', className: 'deleted'},
                    {
                        cdb_object_id: 'updated', a: 'o',
                        className: ' cs-taskmanager-web-task-unread'
                    },
                    {
                        cdb_object_id: 'new', read_status: true,
                        className: ' cs-taskmanager-web-task-unread'
                    }
                ]
            },
            delta: {
                newTasks: Immutable.Set(),
                missingTasks: Immutable.Set(),
                temporaryTasks: Immutable.Set(['processed', 'stay']),
                proceeding: Immutable.Set()
            },
            userTags: ['a', 'b', 'c']
        }));
    });

    test('displays fetched tasks ignoring temporary tasks', () => {
        const result = reducer(
            TASKS_STATUS,
            {
                type: actions.TASKS,
                payload: TASKS_PAYLOAD.toJS(),
                meta: {
                    ignoreTemporary: true
                }
            }
        );
        expect(result).toEqual(Immutable.fromJS({
            table: {
                columns: [{contentRenderer: undefined}],
                rows: [
                    // FIXME 'stay' and 'processed' shouldn't be here
                    //{cdb_object_id: 'stay', className: 'deleted'},
                    //{cdb_object_id: 'processed', className: 'deleted'},
                    {
                        cdb_object_id: 'updated', a: 'o',
                        className: ' cs-taskmanager-web-task-unread'
                    },
                    {
                        cdb_object_id: 'new', read_status: true,
                        className: ' cs-taskmanager-web-task-unread'
                    }
                ]
            },
            delta: {
                newTasks: Immutable.Set(),
                missingTasks: Immutable.Set(),
                temporaryTasks: Immutable.Set(),
                proceeding: Immutable.Set()
            },
            userTags: ['a', 'b', 'c']
        }));
    });

    test('displays an update notification', () => {
        const result = reducer(
            Immutable.fromJS({
                table: {
                    rows: [
                        {cdb_object_id: 'old'},
                        {cdb_object_id: 'updated'},
                        {cdb_object_id: 'temp1'},
                        {cdb_object_id: 'temp2'}
                    ]
                },
                delta: {
                    temporaryTasks: Immutable.Set(['temp1', 'temp2']),
                    newTasks: Immutable.Set(),
                    missingTasks: Immutable.Set()
                }
            }),
            {
                type: actions.NEW_TASKS,
                payload: ['new', 'updated', 'temp2']
            }
        );
        expect(result).toEqual(Immutable.fromJS({
            table: {
                rows: [
                    {cdb_object_id: 'old'},
                    {cdb_object_id: 'updated'},
                    {cdb_object_id: 'temp1'},
                    {cdb_object_id: 'temp2'}
                ]
            },
            delta: {
                temporaryTasks: Immutable.Set(['temp1', 'temp2']),
                newTasks: Immutable.Set(['new', 'updated', 'temp2']),
                missingTasks: Immutable.Set(['old'])
            }
        }));
    });
});
