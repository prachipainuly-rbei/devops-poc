/*
 * Copyright (C) 1990 - 2018 CONTACT Software GmbH
 * All rights reserved.
 * http://www.contact-software.com
 *
 * Revision "$Id: sagas.js 185258 2018-10-18 11:15:26Z cso $"
 */

/* eslint-env jest */

// FIXME URLs are wrong because appSetup is not set up

import Immutable from 'immutable';
import * as matchers from 'jest-immutable-matchers';
import {ReduxSaga} from 'cs-web-components-externals';
const {call} = ReduxSaga.effects;
import {getJSON, postJSON} from 'cs-web-components-base';
import * as actions from '../actions/actions';
import * as sagas from '../sagas/sagas';

describe('The helper function "getPKeyFromIDs"', () => {
    test('fails without a valid parameter', () => {
        expect(() => (sagas.getPKeyFromIDs())).toThrow(TypeError);
    });

    test('returns the leaf paths of a list of URLs', () => {
        const result = sagas.getPKeyFromIDs([
            'https://www.example.com/x/y/a',
            'http://www.example.com/x/y/b',
            'c'
        ]);
        expect(result).toEqual(['a', 'b', 'c']);
    });
});

describe('The helper function "getRelativeRestID"', () => {
    test('fails without a valid parameter', () => {
        for (const x of [
            undefined,
            'www.example.com',
            '/a/b/c'
        ]) {
            expect(() => (sagas.getRelativeRestID(x))).toThrow();
        }
    });

    test('returns the leaf paths of a list of URLs', () => {
        for (const x of [
            'https://www.example.com/a/b/c',
            'http://www.example.com/a/b/c',
            'http://example.com/a/b/c'
        ]) {
            const result = sagas.getRelativeRestID(x);
            expect(result).toBe('/a/b/c');
        }
        const result = sagas.getRelativeRestID('x://www.example.com');
        expect(result).toBe('');
    });
});

describe('The helper function "getConditionPayload"', () => {
    test('fails without a valid parameter', () => {
        for (const x of [
            undefined,
            'not an Immutable.Map',
            {'users': null},
            Immutable.Map()
        ]) {
            expect(() => (sagas.getConditionPayload(x))).toThrow();
        }
    });

    test('returns a default payload object from a minimal Immutable.List', () => {
        const condition = Immutable.fromJS({
            users: ['a']
        });
        const result = sagas.getConditionPayload(condition);
        expect(result).toEqual({
            users: ['a'],
            roles: false,
            types: [],
            contexts: []
        });
    });

    test('returns a payload object from an Immutable.List', () => {
        const condition = Immutable.fromJS({
            users: ['a', '/b', 'x/c'],
            roles: true,
            types: ['a', '/b', 'x/c'],
            contexts: ['http://x/a', 'http://x/b']
        });
        const result = sagas.getConditionPayload(condition);
        expect(result).toEqual({
            users: ['a', 'b', 'c'],
            roles: true,
            types: ['a', 'b', 'c'],
            contexts: ['/a', '/b']
        });
    });

    test('returns a payload object with days from an Immutable.List', () => {
        const condition = Immutable.fromJS({
            users: ['a'],
            deadline: {
                active: 'days',
                days: -2
            }
        });
        const result = sagas.getConditionPayload(condition);
        expect(result).toEqual({
            users: ['a'],
            roles: false,
            types: [],
            contexts: [],
            days: -2
        });
    });

    test('returns a payload object with date range from an Immutable.List', () => {
        const condition = Immutable.fromJS({
            users: ['a'],
            deadline: {
                active: 'range',
                range: {
                    start: 'A',
                    end: 'O'
                }
            }
        });
        const result = sagas.getConditionPayload(condition);
        expect(result).toEqual({
            users: ['a'],
            roles: false,
            types: [],
            contexts: [],
            start: 'A',
            end: 'O'
        });
    });
});

describe('The generator "mergeObjectStore"', () => {
    test('will do nothing with an invalid payload', () => {
        const generator = sagas.mergeObjectStore();
        expect(generator.next().value).toBe(undefined);
    });

    test('will do nothing if payload contains no object', () => {
        const generator = sagas.mergeObjectStore({});
        expect(generator.next().value).toBe(undefined);
    });

    test('will put one "receivedCollection" action for all payload objects', () => {
        const objA = {'@id': 'a'};
        const objB = {'no': 'idea'};
        const generator = sagas.mergeObjectStore({
            objects: [objA, objB]
        });
        const effectA = generator.next().value;
        expect(effectA.PUT.action).toEqual({
            meta: {
                url: null
            },
            payload: [
                {"@id": "a"},
                {"no": "idea"}
            ],
            type: "cs-web-components-base-RECEIVED_COLLECTION"
        });
        expect(generator.next().value).toBe(undefined);
    });
});

describe('The generator "backendRequest"', () => {
    test('will fail if no URL is given', () => {
        const generator = sagas.backendRequest();
        expect(() => generator.next()).toThrow('no URL given');
    });

    test('will remember the request as in-flight', () => {
        const generator = sagas.backendRequest(null, 'url');
        const effect = generator.next().value;
        expect(effect.PUT.action).toEqual(
            actions.backendRequestInFlight('null url', true)
        );
    });

    test('issues a GET request to the backend', () => {
        const generator = sagas.backendRequest('GET', 'url', 'success', 'payload', 'rita');
        expect(generator.next().value.PUT.action).toEqual(
            actions.backendRequestInFlight('GET url', true)
        );
        expect(generator.next().value).toEqual(
            call(getJSON, 'url', 'payload')
        );
        expect(generator.next().value.PUT.action).toEqual(
            actions.backendRequestInFlight('GET url', false)
        );
        expect(generator.next().value).toEqual(
            call(sagas.mergeObjectStore, undefined)
        );
        expect(generator.next().value.PUT.action).toEqual({
            type: 'success',
            payload: undefined,
            meta: 'rita'
        });
    });

    test('issues a POST request to the backend', () => {
        const generator = sagas.backendRequest('POST', 'url', 'success', 'payload', 'rita');
        expect(generator.next().value.PUT.action).toEqual(
            actions.backendRequestInFlight('POST url', true)
        );
        expect(generator.next().value).toEqual(
            call(postJSON, 'url', 'payload')
        );
        expect(generator.next().value.PUT.action).toEqual(
            actions.backendRequestInFlight('POST url', false)
        );
        expect(generator.next().value).toEqual(
            call(sagas.mergeObjectStore, undefined)
        );
        expect(generator.next().value.PUT.action).toEqual({
            type: 'success',
            payload: undefined,
            meta: 'rita'
        });
    });

    test('handles failed requests', () => {
        const generator = sagas.backendRequest('PUT', 'url', 'success', 'payload', 'rita');
        expect(generator.next().value.PUT.action).toEqual(
            actions.backendRequestInFlight('PUT url', true)
        );
        expect(generator.next().value.PUT.action).toEqual(
            actions.backendRequestInFlight('PUT url', false)
        );

        // mock notifyError as it would return a thunk
        actions.notifyError = jest.fn();
        actions.notifyError.mockReturnValueOnce({type: 'mock'});

        expect(generator.next().value.PUT.action).toEqual(
            {type: 'mock'}
        );
        expect(actions.notifyError.mock.calls).toEqual(
            [[new Error('request method has to be either GET, POST or DELETE')]]
        );
    });
});

describe('The saga "getTasks"', () => {
    beforeEach(() => {
        jest.addMatchers(matchers);
    });

    test('immediately shows the loading indicator', () => {
        const action = {
            type: actions.GET_TASKS
        };
        const generator = sagas.getTasks(action);
        const effect = generator.next().value;
        expect(effect.PUT.action).toEqual({
            type: actions.SHOW_TASKS_LOADING_INDICATOR
        });
        expect(() => generator.next()).toThrow();  // invalid condition
    });

    test('clears the current tasks if no user condition is given', () => {
        const action = {
            type: actions.GET_TASKS,
            payload: {
                condition: Immutable.fromJS({
                    users: []
                })
            }
        };
        const generator = sagas.getTasks(action);
        generator.next()  // loading indicator
        const effect = generator.next().value;
        expect(effect.PUT.action).toEqual({
            type: actions.CLEAR_TASKS
        });
    });

    test('makes an asynchronous request to the backend', () => {
        const action = {
            type: actions.GET_TASKS,
            payload: {
                condition: Immutable.fromJS({
                    users: ['a']
                })
            }
        };
        const generator = sagas.getTasks(action);
        generator.next();  // loading indicator
        expect(generator.next().value).toEqual(
            call(
                sagas.backendRequest,
                'GET',
                undefined, // FIXME should be '/internal/tasks/tasks',
                actions.TASKS,
                {
                    users: ['a'],
                    roles: false,
                    types: [],
                    contexts: []
                },
                {ignoreTemporary: false}
            )
        );
    });
});

describe('The saga "getNewTasks"', () => {
    beforeEach(() => {
        jest.addMatchers(matchers);
    });

    test('fails without valid condition payload', () => {
        const action = {
            type: actions.GET_NEW_TASKS
        };
        expect(() => sagas.getNewTasks(action).next()).toThrow();
    });

    test('does nothing if no user condition is given', () => {
        const action = {
            type: actions.GET_NEW_TASKS,
            payload: {
                condition: Immutable.fromJS({
                    users: []
                })
            }
        };
        const generator = sagas.getNewTasks(action);
        expect(generator.next().value).toBe(undefined);
    });

    test('makes an asynchronous request to the backend', () => {
        const action = {
            type: actions.GET_NEW_TASKS,
            payload: {
                condition: Immutable.fromJS({
                    users: ['a']
                })
            }
        };
        const generator = sagas.getNewTasks(action);
        expect(generator.next().value).toEqual(
            call(
                sagas.backendRequest,
                'GET',
                undefined, // FIXME should be '/internal/tasks/new_tasks',
                actions.NEW_TASKS,
                {
                    users: ['a'],
                    roles: false,
                    types: [],
                    contexts: []
                }
            )
        );
    });
});

describe('The saga "postUserSettings"', () => {
    beforeEach(() => {
        jest.addMatchers(matchers);
    });

    test('immediately applies optimistic updated', () => {
        const action = {
            type: actions.SAVE_USER_SETTINGS,
            payload: {
                optimistic: 'immediate update'
            }
        };
        const generator = sagas.postUserSettings(action);
        const effect = generator.next().value;
        expect(effect.PUT.action).toEqual({
            type: actions.OPTIMISTIC_UPDATE_USER_SETTINGS,
            payload: 'immediate update'
        });
    });

    test('makes an asynchronous request to the backend', () => {
        const action = {
            type: actions.SAVE_USER_SETTINGS,
            payload: {
                payload: 'new settings'
            }
        };
        const generator = sagas.postUserSettings(action);
        expect(generator.next().value).toEqual(
            call(
                sagas.backendRequest,
                'POST',
                undefined, // FIXME should be '/internal/tasks/settings',
                actions.SAVE_USER_SETTINGS_RESPONSE,
                'new settings'
            )
        );
    });
});
