import React from 'react';
import Immutable from 'immutable';
import {Alert} from 'react-bootstrap';
import {connect, ImmutablePropTypes, PropTypes} from 'cs-web-components-externals';
import {Registry, getPlugin} from 'cs-web-components-base';
import {formatStr} from '../../i18n';
import * as constants from '../../constants';
import * as helpers from '../../helpers';
import * as proptypes from '../../proptypes';
import TaskContextTree from './TaskContextTree';
import TaskReferenceList from './TaskReferenceList';

const ContentBlock = Registry.findComponent('cs-web-components-base-ContentBlock');
const ObjectActivities = Registry.findComponent('cs-activitystream-web-ObjectActivities');

const CONTENT_BLOCK_CLASSNAME = helpers.prefixNS('details-contentblock');
const CONTENT_BLOCK_BODY_CLASSNAME = helpers.prefixNS('details-contentblock-body');

const PLUGIN_DESC = 'cs-tasks-desc';
const PLUGIN_CUSTOM = 'cs-tasks-custom';
const PLUGIN_RELSHIP = 'cs-tasks-custom-relship';

const MESSAGE_ACTIVITIES = 'activities';
const MESSAGE_DESCRIPTION = 'description';
const MESSAGE_CONTEXT = 'context';
const MESSAGE_NO_SELECTION_HEADER = 'no_selection_header';
const MESSAGE_NO_SELECTION = 'no_selection';

const DETAIL_BLOCK_PROPTYPES = {
    task: proptypes.OBJECT_PROPTYPE.isRequired,
    taskInfo: proptypes.TASK_INFO.isRequired
};

function getTaskPluginElement(task, taskInfo, name, fallback) {
    const resolved = helpers.getTaskPlugin(taskInfo, name, fallback);
    return resolved ?
        React.createElement(resolved, {task, taskInfo}) :
        null;
}

function getPluginLabel(plugin, prop) {
    if (plugin) {
        switch (typeof plugin.getLabel) {
            case 'string':
                return plugin.getLabel;
            case 'function':
                return plugin.getLabel(prop);
        }
    }
    return constants.NULL;
}

function DetailBlock({label, children}) {
    return (
        <ContentBlock expanded collapsible
                      key={label}
                      className={CONTENT_BLOCK_CLASSNAME}
                      title={label ? label : constants.NULL}>
            <ContentBlock.Body className={CONTENT_BLOCK_BODY_CLASSNAME} >
                {children}
            </ContentBlock.Body>
        </ContentBlock>
    );
}

DetailBlock.propTypes = {
    label: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.element,
        PropTypes.func
    ])
};

function TaskContext({task, taskInfo}) {
    return (
        <DetailBlock label={formatStr(MESSAGE_CONTEXT)}
            className={helpers.prefixNS('detail-block')} >
            <TaskContextTree task={task} taskInfo={taskInfo}
                className={helpers.prefixNS('taskcontexttree')} />
        </DetailBlock>
    );
}

TaskContext.propTypes = DETAIL_BLOCK_PROPTYPES;

function TaskDescription({task, taskInfo}) {
    const description = getTaskPluginElement(task, taskInfo, PLUGIN_DESC);
    return description ? (
        <DetailBlock label={formatStr(MESSAGE_DESCRIPTION)}
            className={helpers.prefixNS('detail-block')}
            >
            {description}
        </DetailBlock>
    ) : null;
}

TaskDescription.propTypes = DETAIL_BLOCK_PROPTYPES;

/*
 * TaskRelship is the component rendering a relationship content block in cs.taskmanager's detail
 * pane.
 * For displaying custom relationships, see TaskReferenceList.
 */
function _TaskRelship({task, relship}) {
    const references = relship.get('references');

    if (references && references.size > 0) {
        const renderer = getPlugin(
            PLUGIN_RELSHIP,
            name => relship.get('relshipName') === name,
            TaskReferenceList
        );
        return (
            <DetailBlock label={getPluginLabel(renderer, relship)}
                        className={helpers.prefixNS('detail-block')} >
                {React.createElement(renderer, {task, relship})}
            </DetailBlock>
        );
    }
    return null;
}

_TaskRelship.propTypes = {
    task: proptypes.OBJECT_PROPTYPE.isRequired,
    relship: ImmutablePropTypes.contains({
        references: ImmutablePropTypes.list.isRequired
    }).isRequired
};

const NO_OBJECTS = Immutable.List();

function mapStateToProps(state, ownProps) {
    const references = ownProps.relship.get('references');
    return {
        // TODO will always trigger a re-render if references is not empty
        objects: references ? (
            references.map(ID => state.objectsById.get(ID)).filter(o => o)
        ) : NO_OBJECTS
    };
}

const TaskRelship = connect(mapStateToProps)(_TaskRelship);

function CustomTaskPlugin({task, taskInfo}) {
    const custom = helpers.getTaskPlugin(taskInfo, PLUGIN_CUSTOM);
    return custom ? (
        <DetailBlock label={getPluginLabel(custom)}
                    className={helpers.prefixNS('detail-block')} >
            {React.createElement(custom, {task: task, taskInfo: taskInfo})}
        </DetailBlock>
    ) : null;
}

CustomTaskPlugin.propTypes = DETAIL_BLOCK_PROPTYPES;

function TaskActivities({contextObject}) {
    return (
        <DetailBlock label={formatStr(MESSAGE_ACTIVITIES)}
                    className={helpers.prefixNS('detail-block')}>
            <ObjectActivities instanceName={componentNameSpace}
                              contextObject={contextObject}
                              className={helpers.prefixNS('object-activities')} />
        </DetailBlock>
    );
}

TaskActivities.propTypes = {
    contextObject: ImmutablePropTypes.contains({
        [constants.CDB_OBJECT_ID]: PropTypes.string.isRequired
    }).isRequired
};

function TaskManagerIntro() {
    return (
        <Alert bsStyle="info" className={helpers.prefixNS('detail-blocks-alert')} >
            <strong>
                {formatStr(MESSAGE_NO_SELECTION_HEADER)}
            </strong>
            <p>
                {formatStr(MESSAGE_NO_SELECTION)}
            </p>
        </Alert>
    );
}

export default {
    DetailBlock,
    TaskContext,
    TaskDescription,
    TaskRelship,
    CustomTaskPlugin,
    TaskActivities,
    TaskManagerIntro
};
