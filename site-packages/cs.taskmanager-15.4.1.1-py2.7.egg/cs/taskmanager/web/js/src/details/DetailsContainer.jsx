import React from 'react';
import Immutable from 'immutable';
import {
    ImmutablePropTypes,
    ReactRouter,
    connect,
    PropTypes,
} from 'cs-web-components-externals';
import {Registry} from 'cs-web-components-base';
import {selectRows} from '../actions/actions';
import {getTaskDetails, resetTaskDetails} from './actions/actions';
import * as constants from '../constants';
import * as helpers from '../helpers';
import * as proptypes from '../proptypes';
import DetailBlocks from './components/DetailBlocks';

const ContentBlockGroup = Registry.findComponent('cs-web-components-base-ContentBlockGroup');
const detailRoute = `${helpers.basePath}/:${constants.TASK_OID}`;

function getDisplayName(SomeComponent) {
    return SomeComponent.displayName || SomeComponent.name || 'Component';
}

const AS_CONTEXT = 'activities_context';

/*
 * HOC to actually trigger fetching/resetting the selected task's details
 */
function wrapDetails(WrappedComponent) {
    class DetailWrapper extends React.PureComponent {
        constructor(props) {
            super(props);
            this.state = {
                pathname: props.history.location.pathname
            };
            this.getTaskOIDFromPath = this.getTaskOIDFromPath.bind(this);
            this.updateTaskDetailsFromURL = this.updateTaskDetailsFromURL.bind(this);
            this.removeHistoryListener = null;
        }

        getTaskOIDFromPath() {
            const {pathname} = this.state;
            const match = ReactRouter.matchPath(pathname, {path: detailRoute});
            return match && match.params[constants.TASK_OID];
        }
        componentWillMount() {
            // PureComponent blocks route updates, so we
            // listen to the history changes by ourselves
            this.removeHistoryListener = this.props.history.listen(
                location => {
                    const prev = this.state.pathname;
                    this.setState({pathname: location.pathname}, () => {
                        if (location.pathname !== prev) {
                            const selection = this.getTaskOIDFromPath();
                            this.updateTaskDetailsFromURL(selection);
                        }
                    });
                });
        }

        componentWillUnmount() {
            if (this.removeHistoryListener) {
                this.removeHistoryListener();
                this.removeHistoryListener = null;
            }
        }

        updateTaskDetailsFromURL(task_object_id) {
            if (task_object_id) {
                this.props.getTaskDetails(task_object_id);
            } else {
                this.props.resetTaskDetails();
            }
        }

        componentDidMount() {
            const {selectRows} = this.props;
            const selection = this.getTaskOIDFromPath();

            if (selection) {
                selectRows(Immutable.OrderedSet([selection]));
            }
            this.updateTaskDetailsFromURL(selection);
        }

        render() {
            return (
                <WrappedComponent {...this.props} />
            );
        }
    }

    DetailWrapper.propTypes = {
        currentSelection: proptypes.CURRENT_SELECTION,
        selectRows: PropTypes.func.isRequired,
        getTaskDetails: PropTypes.func.isRequired,
        resetTaskDetails: PropTypes.func.isRequired,
        history: PropTypes.object
    };
    DetailWrapper.displayName = `DetailWrapper(${getDisplayName(WrappedComponent)})`;

    function mapStateToProps(state) {
        const ownState = state[helpers.prefixNS('reducer')];
        return {
            currentSelection: ownState.get('currentSelection')
        };
    }

    function mapDispatchToProps(dispatch) {
        return {
            selectRows: (task_oids) => {dispatch(selectRows(task_oids))},
            getTaskDetails: (task_oid) => {
                dispatch(getTaskDetails(task_oid));
            },
            resetTaskDetails: () => {dispatch(resetTaskDetails())}
        };
    }

    return connect(mapStateToProps, mapDispatchToProps)(DetailWrapper);
}

class DetailsContainer extends React.PureComponent {
    constructor(...args) {
        super(...args);
        this.state = {firstTask: true};  // only load task operations once
        this.emptyRelships = [];
    }

    render() {
        const {task, taskInfo, activityContext} = this.props;
        if (task && taskInfo) {
            return (
                <ContentBlockGroup id={helpers.prefixNS('details-container')}>
                    <DetailBlocks.TaskContext task={task} taskInfo={taskInfo} />
                    <DetailBlocks.TaskDescription task={task} taskInfo={taskInfo} />
                    {(
                        taskInfo.get(constants.RELSHIPS) || this.emptyRelships
                    ).map((relship, index) => (
                        <DetailBlocks.TaskRelship
                            task={task}
                            relship={relship}
                            key={`relship-${index}`}
                        />
                    ))}
                    <DetailBlocks.CustomTaskPlugin task={task} taskInfo={taskInfo} />
                    <DetailBlocks.TaskActivities contextObject={activityContext} />
                </ContentBlockGroup>
            );
        } else {
            // no selection - show useful information about tasks app
            return (
                <div id={helpers.prefixNS('details-container')}>
                    <DetailBlocks.TaskManagerIntro />
                </div>
            );
        }
    }
}

DetailsContainer.contextTypes = {
    loadTaskOperations: PropTypes.func.isRequired
};

DetailsContainer.propTypes = {
    task: proptypes.OBJECT_PROPTYPE,
    taskInfo: proptypes.TASK_INFO,
    activityContext: ImmutablePropTypes.contains({
        [constants.CDB_OBJECT_ID]: PropTypes.string.isRequired
    })
};

function mapStateToProps(state) {
    const ownState = state[helpers.prefixNS('reducer')];
    const taskInfo = ownState.getIn([
        'currentSelection', 'byObjectID', ownState.getIn(['currentSelection', constants.TASK_OID])
    ]);
    const task = taskInfo && state.objectsById.get(taskInfo.get(constants.ID));

    const row = ownState.getIn(['table', 'rows']).filter(
        row => row.get(constants.CDB_OBJECT_ID) === ownState.getIn(
            ['currentSelection', constants.TASK_OID]
        )
    ).last();
    const activityContextID = row && row.get(AS_CONTEXT);

    return {
        task: task,
        taskInfo: taskInfo,
        activityContext: state.objectsById.get(activityContextID, task)
    };

}

const ConnectedDetailsContainer = connect(mapStateToProps, null)(DetailsContainer);
export default ReactRouter.withRouter(wrapDetails(ConnectedDetailsContainer));
