# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#
# Version:  $Id: rest_app.py 185258 2018-10-18 11:15:26Z cso $

"""
REST backend for cs.taskmanager.web, mounted @ /internal/tasks
"""

__revision__ = "$Id: rest_app.py 185258 2018-10-18 11:15:26Z cso $"
__docformat__ = "restructuredtext en"

import webob

from cdb.objects.org import User
from cdb.platform.gui import Message

from cs.platform.web import JsonAPI
from cs.platform.web.root import Internal
from cs.platform.web.root import get_v1
from cs.platform.web.rest.support import decode_key_component
from cs.taskmanager.conditions import getConditions
from cs.taskmanager.user_views import RECENT
from cs.taskmanager.web import constants
from cs.taskmanager.web import util
from cs.taskmanager.web.main import MOUNTEDPATH
from cs.taskmanager.web import rest_app_model


def raiseOnError(result):
    if isinstance(result, dict):
        error = result.get("error", None)
        if error:
            raise webob.exc.HTTPInternalServerError(error)
    return result


class App(JsonAPI):
    pass


@Internal.mount(app=App, path=MOUNTEDPATH)
def _mount_app():
    return App()


@App.path(path="settings", model=rest_app_model.PersonalBaseModel)
def _get_settings_model():
    return rest_app_model.PersonalBaseModel()


def add_user_links(users, request):
    result = []

    for persno in users:
        user = User.ByKeys(decode_key_component(persno))
        if user:
            result.append(util.getRestObject(user, request)[constants.REST_ID])

    return result


@App.json(model=rest_app_model.PersonalBaseModel)
def get_initial_settings(model, request):
    result = raiseOnError(model.getInitialSettings(request))
    return result


@App.json(model=rest_app_model.PersonalBaseModel, request_method="POST")
def set_settings(model, request):
    users = []

    if request.json.get("user", None):
        requested_users = [
            util.decode_key_component(u) for u in request.json["users"]
        ]
        for user in User.KeywordQuery(personalnummer=requested_users):
            if model.checkShowTasks(user):
                users.append(user.personalnummer)

    result = {
        "settings": model.app_settings,
        "users": add_user_links(users, request),
    }

    result["settings"].update(request.json)
    model.app_settings = result["settings"]

    return result


@App.path(path="tasks", model=rest_app_model.TasksModel)
def _get_tasks_model():
    return rest_app_model.TasksModel()


def get_tasks_condition(request):
    """
    Conditions for getting (new) tasks. Must contain at least one parameter
    "users" and may contain optional parameters "types", "contexts", "roles",
    "days", "start" and "end".
    """
    return getConditions(
        set([
            util.restID2primaryKeys(user_rest_id)
            for user_rest_id in request.params.getall("users")
        ]),
        request.params.get("roles", False) == "true",
        set([
            util.restID2primaryKeys(type_rest_id)
            for type_rest_id in request.params.getall("types")
        ]),
        set([
            util.restID2oid(context_rest_id)
            for context_rest_id in request.params.getall("contexts")
        ]),
        request.params.get("days"),
        request.params.get("start"),
        request.params.get("end"))


@App.json(model=rest_app_model.TasksModel)
def get_tasks(model, request):
    condition = get_tasks_condition(request)
    result = raiseOnError(model.getTasksForTable(condition, request))
    return result


@App.path(path="new_tasks", model=rest_app_model.NewTasksModel)
def _get_new_tasks_model():
    return rest_app_model.NewTasksModel()


@App.json(model=rest_app_model.NewTasksModel)
def get_new_tasks(model, request):
    condition = get_tasks_condition(request)
    return raiseOnError(model.getNewTasks(condition))


@App.path(path="task_details", model=rest_app_model.TaskDetailsModel)
def _get_task_details_model():
    return rest_app_model.TaskDetailsModel()


@App.json(model=rest_app_model.TaskDetailsModel)
def get_task_details(model, request):
    try:
        task_oid = request.params["task_object_id"]
    except KeyError:
        raise webob.exc.HTTPBadRequest

    task, task_class_name = model.getTaskDetails(task_oid)
    result = {
        "task_object_id": task_oid,
        "task": {
            constants.REST_ID: None,
            constants.PLUGIN_DISCRIMINATORS: [],
            constants.CONTEXT: [],
            constants.RELSHIPS: None,
            constants.OBJECTTYPES: None,
        },
        "objects": {},  # make a pseudo-set since dicts are not hashable
    }

    def _add_object(obj):
        rest_obj = util.getRestObject(obj, request, include_relships=True)

        if rest_obj is None:
            return None

        result["objects"][rest_obj[constants.REST_ID]] = rest_obj
        return rest_obj[constants.REST_ID]

    task_rest_id = _add_object(task)
    result["task"][constants.REST_ID] = task_rest_id

    if not task_rest_id:
        raise webob.exc.HTTPNotFound(
            Message.GetMessage("cs_tasks_unknown_task", task_oid))

    context_model = rest_app_model.TaskContextModel(task)

    for context_obj in context_model.getTaskContext():
        context_rest_id = _add_object(context_obj)
        result["task"][constants.CONTEXT].append(context_rest_id)

    relship_model = rest_app_model.TaskRelshipModel(task).getTaskRelships()
    clsdefs = {}

    for rship in relship_model:
        ids = []
        for rship_obj in rship["references"]:
            ref_rest_id = _add_object(rship_obj)
            ids.append(ref_rest_id)
            clsdefs[rship_obj.GetClassname()] = rship_obj.GetClassDef()
        rship["references"] = ids

    result["task"][constants.RELSHIPS] = relship_model

    if clsdefs:
        result["task"][constants.OBJECTTYPES] = [
            util.classname2restID(clsdef, request)
            for clsdef in clsdefs.values()]

    if task_class_name:  # may be None if task is not active anymore
        # inject first applicable name for loading frontend plugins
        result["task"].update(
            util.getPluginDiscriminatorInfo(task, task_class_name)
        )

    result["objects"] = result["objects"].values()
    return result


@App.path(path="tag", model=rest_app_model.TagModel)
def _get_tag_model():
    return rest_app_model.TagModel()


@App.json(model=rest_app_model.TagModel)
def get_tags(model, request):
    try:
        task_oid = request.params["task_object_id"]
    except KeyError:
        raise webob.exc.HTTPBadRequest

    return raiseOnError(model.getTags(task_oid))


@App.json(model=rest_app_model.TagModel, request_method="POST")
def set_tags(model, request):
    try:
        task_oid = request.json["task_object_id"]
        tags = request.json["tags"]
    except KeyError:
        raise webob.exc.HTTPBadRequest

    result = raiseOnError(model.setTags(task_oid, tags))

    return {
        "task_object_id": task_oid,
        "tags": result,
    }


@App.path(path="read_status", model=rest_app_model.ReadStatusModel)
def _get_read_status_model():
    return rest_app_model.ReadStatusModel()


@App.json(model=rest_app_model.ReadStatusModel, request_method="POST")
def set_read_status(model, request):
    try:
        task_oid = request.json["task_object_id"]
        read_status = request.json["read_status"]
    except KeyError:
        raise webob.exc.HTTPBadRequest

    return raiseOnError(model.setReadStatus(task_oid, read_status))


@App.path(path="proceed", model=rest_app_model.ProceedModel)
def _get_proceed_model():
    return rest_app_model.ProceedModel()


@App.json(model=rest_app_model.ProceedModel)
def get_next_statuses(model, request):
    try:
        task_oid = request.params["task_object_id"]
    except KeyError:
        raise webob.exc.HTTPBadRequest

    return raiseOnError(model.getNextStatuses(task_oid))


@App.json(model=rest_app_model.ProceedModel, request_method="POST")
def proceed(model, request):
    try:
        # NOTE: kwargs are additional parameters for the status change
        # operation. They may not include parameters unknown to the operation,
        # or it will fail
        kwargs = {
            k: v.get("value", None) for k, v in request.json.items()
            if k not in ("users", "task_object_id", "proceed_to")
        }
        task_oid = request.json["task_object_id"]
        proceed_to = request.json["proceed_to"]
    except KeyError:
        raise webob.exc.HTTPBadRequest

    result = raiseOnError(
        model.proceed(request, task_oid, proceed_to, **kwargs))

    if result["task_row"]:
        result["task_row"] = [
            util.obj2rest(value, request) for value in result["task_row"]]
    return result


@App.path(path="users", model=rest_app_model.UserModel)
def get_user_model(request):
    return rest_app_model.UserModel()


@App.json(model=rest_app_model.UserModel, request_method="GET")
def get_users(model, request):
    try:
        limit = int(request.params["limit"])
        rest_app = get_v1(request).child("collection")
        result = []
        query_res = model.getUsers(request.params["query"], limit)
        for user in query_res["users"]:
            user_json = request.view(user, app=rest_app)
            user_json["org_name"] = user.Organization.name
            user_json["first_last"] = "%s %s" % (user.firstname, user.lastname)
            user_json["last_first"] = "%s %s" % (user.lastname, user.firstname)
            result.append(user_json)
        return {"users": result}
    except KeyError:
        raise webob.exc.HTTPBadRequest


@App.path(path="remember_user_view/{view_object_id}",
          model=rest_app_model.RememberUserViewModel)
def get_rememeber_user_view_model(request, view_object_id):
    return rest_app_model.RememberUserViewModel(view_object_id)


@App.json(model=rest_app_model.RememberUserViewModel, request_method="POST")
def remember_user_view_selection(model, request):
    recent_views = model.rememberUserViewSelection(request)
    return {
        RECENT: recent_views
    }


@App.path(path="new_user_view", model=rest_app_model.NewUserViewModel)
def get_new_user_view_model(request):
    return rest_app_model.NewUserViewModel()


@App.json(model=rest_app_model.NewUserViewModel, request_method="POST")
def new_user_view(model, request):
    payload = request.json
    return model.newUserView(
        payload["name"],
        payload["condition"],
        request
    )


@App.path(path="user_view/{view_object_id}",
          model=rest_app_model.UserViewModel)
def get_user_view_model(request, view_object_id):
    return rest_app_model.UserViewModel(view_object_id)


@App.json(model=rest_app_model.UserViewModel, request_method="POST")
def save_user_view(model, request):
    payload = request.json

    keys = set(payload.keys())

    if "condition" in keys:
        return model.saveUserView(payload["condition"], request)
    elif "name" in keys:
        return model.renameUserView(payload["name"], request)
    else:
        raise webob.exc.HTTPBadRequest


@App.json(model=rest_app_model.UserViewModel, request_method="DELETE")
def delete_user_view(model, request):
    return model.deleteUserView(request)
