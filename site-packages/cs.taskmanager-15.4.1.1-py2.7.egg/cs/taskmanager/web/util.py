# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#

"""
Utility functions for translating IDs
"""

__revision__ = "$Id: "
__docformat__ = "restructuredtext en"

import re
import urllib
from cdbwrapc import CDBClassDef
from collections import Hashable
from collections import OrderedDict
from morepath.error import LinkError

from cdb import misc
from cdb import sqlapi
from cdb.objects import Object
from cdb.objects.cdb_file import CDB_File

from cs.platform.web.rest.classdef.main import get_classdef
from cs.platform.web.rest.generic.model import Workflow
from cs.platform.web.rest.support import decode_key_component
from cs.platform.web.rest.support import get_object_from_rest_name
from cs.platform.web.rest.support import get_restlink
from cs.platform.web.rest.support import get_restlink_by_keys
from cs.platform.web.rest.support import rest_name
from cs.platform.web.root import get_v1
from cs.platform.web.root.main import _get_dummy_request
from cs.platform.web.uisupport import get_ui_link
from cs.taskmanager.mapping import ByID
from cs.taskmanager.mixin import WithTasksIntegration
from cs.taskmanager.web import constants

__all__ = [
    "oid2restID",
    "classname2restID",
    "userID2restID",
    "restID2oid",
    "restID2primaryKeys",
    "getLinks",
    "getRestObject",
    "clearRestObjectCache",
    "obj2rest",
    "getPluginDiscriminatorInfo",
]

CLASSNAME = "(?P<classname>[a-z_]+)"
RESTNAME = "(?P<restname>[a-z_]+)"
OBJ_KEYS = "(?P<keys>[A-Za-z_%0-9 ~]+)"
REST_ID_PATTERN_CLASS = re.compile(
    r"^.*/api/v1/class/{}(/.*)?$".format(CLASSNAME))
REST_ID_PATTERN_OBJ = re.compile(
    r"^.*/api/v1/collection/{}/{}$".format(RESTNAME, OBJ_KEYS))


class lru_memoized_args(object):
    """
    Simple LRU memoize inspired by
    - https://wiki.python.org/moin/PythonDecoratorLibrary#Memoize and
    - https://www.kunxi.org/blog/2014/05/lru-cache-in-python

    Ignores keyword arguments when looking for cache hits.

    Expects all non-keyword arguments to be hashable.

    Usage:

    .. code-block:: python

        @lru_memoized_args
        def get_something(a, b):
            return a and b

        # cache misses
        get_something(True, True)
        get_something(True, b=True)

        # cache hits
        get_something(True, True)
        get_something(True, b=False)

        get_something.clearCache()


    :param func: Function to call for cache misses.
    :type func: function

    :param capacity: Maximum capacity of the cache. Should be reasonably small
        to prevent memory leaks in long-running processes. Defaults to 250.
    :type capacity: int or None

    :returns: Function return value for cache misses, otherwise cached return
        value.
    :rtype: any
    """
    def __init__(self, func, capacity=None):
        self._cache = OrderedDict()
        self._capacity = capacity or 250
        self.func = func

    def clearCache(self):
        self._cache = OrderedDict()

    def __repr__(self):
        """
        Return the function's docstring.
        """
        return self.func.__doc__

    def getKey(self, key):
        # raises KeyError
        value = self._cache.pop(key)
        self._cache[key] = value
        return value

    def setKey(self, key, value):
        try:
            self._cache.pop(key)
        except KeyError:
            if len(self._cache) >= self._capacity:
                misc.log(7, "cache overflow")
                self._cache.popitem(last=False)
        self._cache[key] = value

    def _makeKey(self, arg):
        if isinstance(arg, Object):
            return arg.ID()  # object ID or serialized primary keys

        return str(arg)

    def __call__(self, *args, **kwargs):
        if not isinstance(args, Hashable):
            # uncacheable. a list, for instance.
            # better to not cache than blow up.
            misc.log_error("uncacheable args '{}'".format(args))
            return self.func(*args, **kwargs)

        key = " ".join(self._makeKey(arg) for arg in args)

        try:
            cache_hit = self.getKey(key)
            misc.log(9, "cache hit '{}'".format(args))
            return cache_hit

        except KeyError:
            misc.log(9, "cache miss '{}'".format(args))
            cache_miss = self.func(*args, **kwargs)
            self.setKey(key, cache_miss)
            return cache_miss


@lru_memoized_args
def _oid2restID(cdb_object_id, request):
    """
    Internal, please use oid2restID.
    """
    obj = ByID(cdb_object_id)
    if obj:
        return get_restlink(obj, request)


def oid2restID(cdb_object_id, request=None):
    """
    Returns a REST ID (a ``@id`` URL) for given ``cdb_object_id``. Uses a cache
    based on ``cdb_object_id`` only.

    .. warning::

        Caller is responsible for checking read access.

    :param cdb_object_id: The object's internal UUID.
    :type cdb_object_id: str

    :param request: A request object.
    :type request: webob.request.Request or None

    :returns: A URL representing the object. If a request was given, the URL is
        absolute, else it is relative, e.g. lacking the protocol and host part.
    :rtype: str
    """
    return _oid2restID(cdb_object_id, request=request)


@lru_memoized_args
def _classname2restID(classname, request):
    if request is None:
        request = _get_dummy_request()

    clsdef_app = get_classdef(request)
    return request.link(CDBClassDef(classname), app=clsdef_app)


def classname2restID(classname, request=None):
    """
    Returns the REST ID of a CDB class.

    :param classname: A CDB class or its classname.
    :type classname: CDBClassDef or str or unicode

    :returns: REST ID of the class.
    :rtype: str

    :raises: TypeError if the type of ``classname`` is wrong.
    """
    if isinstance(classname, CDBClassDef):
        classname = classname.getClassname()

    if isinstance(classname, unicode):
        classname = str(classname)

    return _classname2restID(classname, request=request)


@lru_memoized_args
def _userID2restID(user_id, request):
    if request is None:
        request = _get_dummy_request()
    keys = {"personalnummer": user_id}
    return get_restlink_by_keys("angestellter", keys, request)


def userID2restID(user_id, request=None):
    return _userID2restID(user_id, request=request)


@lru_memoized_args
def restID2oid(rest_id):
    rest_id = decode_key_component(rest_id)

    def _get_oid(_rest_name, keys):
        obj = get_object_from_rest_name(_rest_name, keys)
        if obj:
            return obj.cdb_object_id

    classMatch = REST_ID_PATTERN_CLASS.match(rest_id)
    if classMatch:
        return classMatch.groupdict()["classname"]

    objMatch = REST_ID_PATTERN_OBJ.match(rest_id)
    if objMatch:
        groupdict = objMatch.groupdict()
        return _get_oid(groupdict["restname"], groupdict["keys"])


@lru_memoized_args
def restID2primaryKeys(rest_id):
    """
    returns @-separated, URI-decoded pkey values from rest_id
    """
    pkeys = sqlapi.quote(rest_id.rsplit("/")[-1])
    return decode_key_component(pkeys)


@lru_memoized_args
def _getCollectionApp(request):
    """identify and cache the collection app to calculate links with"""
    if request is None:
        request = _get_dummy_request()
    return get_v1(request).child("collection")


@lru_memoized_args
def _getLinks(obj, request):
    collection_app = _getCollectionApp(request=request)
    try:
        return {
            constants.REST_ID: request.link(obj, app=collection_app),
            constants.REST_DESCRIPTION: obj.GetDescription(),
            constants.REST_UI_LINK: get_ui_link(request, obj)
        }
    except LinkError:
        return {
            "error": "class '{}' is not rest-activated".format(
                obj.GetClassname()),
        }


def getLinks(obj, request):
    """return a dict containing ui and REST link of obj"""
    return _getLinks(obj, request=request)


@lru_memoized_args
def _getRestObject(obj, request, include_relships=False):
    """
    return the full REST API representation of obj
    """
    if not obj:
        return None

    if request is None:
        request = _get_dummy_request()

    collection_app = _getCollectionApp(request=request)

    if isinstance(obj, CDB_File):
        result = request.view(
            obj,
            app=collection_app,
            name="file_meta",
        )
        result[constants.IS_FILE] = True
    else:
        if rest_name(obj):
            if include_relships:
                result = request.view(obj, app=collection_app)
            else:
                result = request.view(
                    obj,
                    app=collection_app,
                    # use relship-target over default view, because
                    # resolving relships is _expensive_
                    name="relship-target",
                )
        else:
            result = {
                constants.REST_DESCRIPTION: obj.GetDescription(),
                constants.REST_ICON_LINK: obj.GetObjectIcon()
            }

    if obj.GetObjectKind():
        result.update({constants.REST_STATUS: Workflow(obj).current_status})

    return result


def getRestObject(obj, request, include_relships=False):
    """
    return the full REST API representation of obj
    """
    return _getRestObject(
        obj,
        request=request,
        include_relships=include_relships,
    )


def clearRestObjectCache():
    _getRestObject.clearCache()


def obj2rest(value, request):
    return getRestObject(value, request) if isinstance(
        value, Object) else value


@lru_memoized_args
def getPluginDiscriminatorInfo(task, std_name):
    """
    Returns a map that contains all information the frontend needs
    to find plugins. `task` is the specific task and `std_name` the
    fallback discriminator - usually the name of the task class.
    """
    plugin_discriminators = []
    if isinstance(task, WithTasksIntegration):
        # There might be a task specific discriminator
        plgd = task.getPluginDiscriminator(std_name)
        if plgd:
            plugin_discriminators.append(plgd)

    plugin_discriminators.append(std_name)
    return {constants.PLUGIN_DISCRIMINATORS: plugin_discriminators}
