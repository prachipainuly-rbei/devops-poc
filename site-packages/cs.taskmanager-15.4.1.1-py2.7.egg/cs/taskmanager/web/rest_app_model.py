# -*- mode: python; coding: utf-8 -*-
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact-software.com
#
# Version:  $Id: rest_app_model.py 185791 2018-10-29 12:43:39Z cso $

import json

from cdb import auth
from cdb import CADDOK
from cdb import constants as cdbConstants
from cdb import sqlapi
from cdb.objects import Object
from cdb.objects import ObjectCollection
from cdb.objects.operations import operation
from cdb.objects.org import User
from cdb.util import ErrorMessage
from cdb.util import get_label

from cs.taskmanager import settings
from cs.taskmanager.conf import SYSTEM_COLUMN_NAMES
from cs.taskmanager.conf import get_cache
from cs.taskmanager.mapping import TaskClassByTaskOID
from cs.taskmanager.mapping import getMappedTask
from cs.taskmanager.mapping import getMappedTasks
from cs.taskmanager.userdata import ReadStatus
from cs.taskmanager.userdata import Tags
from cs.taskmanager.user_views import CATEG_DEFAULT
from cs.taskmanager.user_views import CATEG_USER
from cs.taskmanager.user_views import CURRENT
from cs.taskmanager.user_views import UserView
from cs.taskmanager.user_views import RECENT
from cs.taskmanager.web import constants
from cs.taskmanager.web.main import APPNAME
from cs.taskmanager.web import util
from cs.taskmanager.mapping import ByID

MIN_COL_WIDTH = 38


class PersonalBaseModel(object):
    """
    base model, providing access to

    * access checks
    * logged in user's settings

    this class does not handle user context switching for accessing that user's
    tasks, since accessing another user's objects must not include their
    settings, tags, read_status, or access rights.
    """
    def __init__(self):
        self.user = None

    @property
    def app_settings(self):
        return settings.AppSettings.read(persno=auth.persno, use_cache=False)

    @app_settings.setter
    def app_settings(self, value):
        settings.AppSettings.write(value, persno=auth.persno)

    @property
    def table_settings(self):
        return settings.TableSettings.read(persno=auth.persno, use_cache=False)

    @table_settings.setter
    def table_settings(self, value):
        settings.TableSettings.write(value, persno=auth.persno)

    def getInitialSettings(self, request):
        util.clearRestObjectCache()
        app_settings = self.app_settings.copy()

        defaultView = UserView.GetDefaultView()
        if not defaultView:
            return {
                "error": ErrorMessage("cs_tasks_no_default_settings").errp[0],
            }

        recentViews = app_settings.get(RECENT, [])
        currentView = UserView.ByKeys(
            app_settings.get(CURRENT, None)
        ) or defaultView
        userViews = UserView.ForUser()
        allViews = userViews.union(set([defaultView, currentView]))
        cache = get_cache()

        app_settings.update({
            # if user is allowed to see caddok's tasks, they either ARE caddok
            # or are granted "show_tasks" for other users
            "userSelection": not self.checkShowTasks(["caddok"]),
            "taskClasses": [
                util.classname2restID(c, request)
                for c in sorted(cache.classnames)
            ],
            "contextClassnames": cache.context_classnames,
            "userViews": {
                "recent": [util.oid2restID(r, request) for r in recentViews],
                "current": util.oid2restID(currentView.cdb_object_id, request),
                "default": util.oid2restID(defaultView.cdb_object_id, request),
                "custom": [
                    util.oid2restID(u.cdb_object_id, request) for u in sorted(
                        userViews,
                        key=lambda x: x["name_{}".format(CADDOK.ISOLANG)]
                    )
                ],
                "byID": {
                    util.oid2restID(
                        u.cdb_object_id,
                        request
                    ): u.toJSON(request)
                    for u in allViews
                },
            },
        })

        if RECENT in app_settings.keys():
            del app_settings[RECENT]

        return {
            "settings": app_settings,
            "objects": [util.getRestObject(v, request) for v in allViews],
        }

    def checkShowTasks(self, users):
        for persno in users:
            user = User.ByKeys(persno)

            if not (user and user.CheckAccess("show_tasks")):
                return {"error": ErrorMessage(
                    "cs_tasks_unknown_task", persno).errp[0]}

    def checkRead(self, object_id):
        obj = ByID(object_id)
        if not (obj and obj.CheckAccess("read")):
            return {"error": ErrorMessage(
                "cs_tasks_unknown_task", object_id).errp[0]}

    def _getTaskColumns(self):
        """
        list of column definitions in JSON form
        """
        table_settings = self.table_settings
        last_used = table_settings["lastUsed"]

        if last_used == "###CSWEB_DEFAULT_TABLE_SETTINGS###":
            last_used = ""

        table_config = table_settings["configurations"][last_used]

        def toJSON(coldef):
            try:
                width = table_config["columnWidths"][coldef.name]
            except KeyError:
                width = MIN_COL_WIDTH

            return {
                "id": coldef.name,
                "attribute": coldef.name,
                "contentRenderer": coldef.plugin_component,
                "label": get_label(coldef.name) if coldef.name else "",
                "tooltip": coldef.getTooltip(),
                "width": {
                    "unit": "px",
                    "value": width,
                },
            }

        def _getColumnPosition(coldict):
            try:
                return table_config["orderedColumns"].index(coldict["id"])
            except ValueError:
                return 999

        # get column definition from cache
        json_columns = [
            toJSON(coldef) for coldef in get_cache().columns.values()]

        # apply default order
        col_position = {c["id"]: _getColumnPosition(c) for c in json_columns}
        json_columns = sorted(
            json_columns, key=lambda x: col_position[x["id"]])

        # transform to table's needs
        return {"columns": json_columns}


class TaskDetailsModel(PersonalBaseModel):
    def getTaskDetails(self, task_object_id):
        util.clearRestObjectCache()

        task = ByID(task_object_id)
        if task and task.CheckAccess("read"):
            taskClass = TaskClassByTaskOID(task_object_id)
            return task, taskClass.name if taskClass else None

        return None, None


class NewTasksModel(PersonalBaseModel):
    def getNewTasks(self, condition):
        error = self.checkShowTasks(condition.users)
        if error:
            return error

        # getHeaders does not cut it as long as we're using conditions that are
        # only applicable post-mapping (e.g. contexts)
        tasks, _ = getMappedTasks(condition)  # ignore mapped tasks
        return [task.cdb_object_id for task in tasks]


class TasksModel(PersonalBaseModel):
    def getTasks(self, condition):
        error = self.checkShowTasks(condition.users)
        if error:
            return error

        # tasks, rows
        return getMappedTasks(condition)

    def getTasksForTable(self, condition, request):
        util.clearRestObjectCache()
        user_tags = set([])

        def get_object_value(obj, include_icon=True):
            description = obj.GetDescription()
            rest_obj = util.obj2rest(obj, request)
            result = {
                "link": {
                    "to": rest_obj.get(constants.REST_UI_LINK, None),
                    "title": description,
                },
                "text": description,
            }
            if include_icon:
                result["icon"] = {
                    "src": obj.GetObjectIcon(),
                    "size": "sm",
                    "title": description,
                }

            return result

        def get_column_value(task, row, col):
            attr = col["attribute"]

            if attr in SYSTEM_COLUMN_NAMES:
                return row[attr]

            value = row.get(attr, None)

            if attr == "cs_tasks_col_tags" and value:
                user_tags.update(set(value))

            elif attr == "cs_tasks_col_name":
                return get_object_value(task, include_icon=False)

            if isinstance(value, Object):
                return get_object_value(value)

            return value

        def get_row(task, row, cols):
            task_oid = task.cdb_object_id
            task_class = row["task_class"]
            links = util.getLinks(task, request)

            if "error" in links.keys():
                return links["error"]

            result = {
                "id": task_oid,
                "cdb_object_id": task_oid,
                # persistent_id is needed for selecting table rows
                "persistent_id": task_oid,
                "task_class": task_class,
                constants.REST_ID: links.get(constants.REST_ID, None),
                constants.REST_UI_LINK: links.get(
                    constants.REST_UI_LINK,
                    None
                ),
                constants.ACTIVITY_CONTEXT: util.getRestObject(
                    row[constants.ACTIVITY_CONTEXT],
                    request
                ),
                "columns": [get_column_value(task, row, col) for col in cols],
            }

            result.update(util.getPluginDiscriminatorInfo(task, task_class))
            result.update({attr: row[attr] for attr in SYSTEM_COLUMN_NAMES})

            return result

        error = self.checkShowTasks(condition.users)
        if error:
            return error

        columns = self._getTaskColumns()
        tasks, rows = self.getTasks(condition)
        rows = [
            get_row(tasks[i], row, columns["columns"])
            for i, row in enumerate(rows)
        ]

        table = {
            "name": "{}-tasks-table".format(APPNAME),
            "rows": rows,
            "fetching": False,
            "error": "",
        }
        table.update(columns)

        # sorting, grouping is done client-side
        return {
            "table": table,
            "userTags": list(user_tags),
        }


class TaskContextModel(object):
    def __init__(self, task, taskClass=None, references=None):
        self.task = task
        self.references = references
        if not references:
            self.taskClass = taskClass if taskClass else TaskClassByTaskOID(
                task.cdb_object_id)

    def getTaskContext(self):
        util.clearRestObjectCache()
        referer = self.task
        result = []

        if self.references:
            references = self.references
        else:
            if not getattr(self, "taskClass", None):
                return []  # non-existing task
            references = [c.reference_name for c in self.taskClass.Context]

        for reference_name in references:
            rs_obj = getattr(referer, reference_name, None)
            if isinstance(rs_obj, Object) and rs_obj.CheckAccess("read"):
                result.append(rs_obj)
                referer = rs_obj

        result.reverse()
        return result


class TaskRelshipModel(object):
    def __init__(self, task, taskClass=None, relships=None):
        self.task = task
        self.relships = relships
        if not relships:
            self.taskClass = taskClass if taskClass else TaskClassByTaskOID(
                task.cdb_object_id
            )

    def _resolve(self, rship):
        resolved = getattr(self.task, rship[0], None)

        if resolved is None:
            resolved = []
            isObjectList = True
        elif isinstance(resolved, Object):
            resolved = [resolved]
            isObjectList = True
        else:
            isObjectList = (
                isinstance(resolved, list) and
                len(resolved) and
                isinstance(resolved[0], Object)
            )

        if isinstance(resolved, ObjectCollection) or isObjectList:
            # Powerscript Reference (Object or ObjectCollection/list)
            return [{
                "relshipName": rship[0],
                "mappedName": get_label(rship[1]),
                "references": [
                    x for x in resolved
                    if x.CheckAccess("read")
                ],
            }]
        # else: custom Powerscript result

        return resolved

    def getTaskRelships(self):
        util.clearRestObjectCache()

        if self.relships:
            relships = self.relships
        else:
            if not getattr(self, "taskClass", None):
                return []  # non-existing task
            relships = [
                (x.reference_name, x.label)
                for x in self.taskClass.Relships
            ]

        result = []

        for rship in relships:
            result += self._resolve(rship)

        return result


class ReadStatusModel(PersonalBaseModel):
    def setReadStatus(self, task_object_id, read_status):
        """
        sets the read_status of given task, if user is granted read access
        """
        error = self.checkRead(task_object_id)
        if error:
            return error

        if read_status:
            ReadStatus.setTaskRead(task_object_id)
        else:
            ReadStatus.setTaskUnread(task_object_id)

        return {
            "task_object_id": task_object_id,
            "cs_tasks_col_read_status": ReadStatus.getReadStatus(
                task_object_id)
        }


class TagModel(PersonalBaseModel):
    def getTags(self, task_object_id):
        error = self.checkRead(task_object_id)
        if error:
            return error

        return Tags.getTaskTags(auth.persno, task_object_id)

    def setTags(self, task_object_id, tags):
        error = self.checkRead(task_object_id)
        if error:
            return error

        Tags.setTaskTags(auth.persno, task_object_id, tags)
        return Tags.getTaskTags(auth.persno, task_object_id)


class ProceedModel(PersonalBaseModel):
    def _getTaskRow(self, mapped_task):
        if mapped_task:
            return [mapped_task.get(col["attribute"], None)
                    for col in self._getTaskColumns()["columns"]]

    def getNextStatuses(self, task_object_id):
        error = self.checkRead(task_object_id)
        if error:
            return error

        task = ByID(task_object_id)

        try:
            result = task.getCsTasksProceedData(targets=True)
        except:  # pylint: disable=bare-except
            result = None

        if isinstance(result, dict):
            result["task_object_id"] = task_object_id
            return result

        return {
            "error": ErrorMessage("cs_tasks_failed_targets").errp[0],
            "task_object_id": task_object_id}

    def proceed(self, request, task_object_id, proceed_to, **kwargs):
        error = self.checkRead(task_object_id)
        if error:
            return error

        task = ByID(task_object_id)

        error = task.csTasksProceed(proceed_to, **kwargs)
        if error:
            return error

        return {
            "task_row": self._getTaskRow(getMappedTask(task_object_id)),
            "task_object_id": task_object_id,
        }


class UserModel(object):
    @classmethod
    def getUsers(cls, query, limit):
        query = sqlapi.quote(query.lower())
        conds = [
            """(LOWER(name) LIKE '%%{{0}}%%' OR
            LOWER(firstname {0} ' ' {0} lastname) LIKE '%%{{0}}%%' OR
            LOWER(lastname {0} ' ' {0} firstname) LIKE '%%{{0}}%%' OR
            LOWER(beruf) LIKE '%%{{0}}%%' OR
            LOWER(abt_nummer) LIKE '%%{{0}}%%' OR
            LOWER(personalnummer) LIKE '%%{{0}}%%')
            """.format(sqlapi.SQLstrcat()),
            "(active_account='1' AND visibility_flag=1)"
        ]
        return {
            "users": User.Query(
                " AND ".join(conds).format(query), max_rows=limit)}


class UserViewBaseModel(object):
    def __init__(self, view_object_id):
        self.view_object_id = view_object_id
        self.view = self._getUserView()

    def _getUserView(self):
        view = UserView.ByKeys(self.view_object_id)
        if not (view and view.CheckAccess("read")):
            raise ValueError("unknown user view")
        return view


class DistinctQueue(object):
    """
    Queue (LIFO) holding a list of distinct values. The first item is the most
    recently added one.

    Duplicates are removed upon initialization.

    x = DistinctQueue([0, 0, 1, 2, 1, 3, 0, 3])
    list(x)  # [0, 1, 2]
    list(x.enqueue(4)) # [4, 0, 1]
    list(x.enqueue(0)) # [0, 4, 1]
    list(x.enqueue(3)) # [3, 0, 4]
    list(x.enqueue(2)) # [2, 3, 0]
    list(x.enqueue(1)) # [1, 2, 3]
    """
    def __init__(self, value_list):
        if not isinstance(value_list, list):
            raise TypeError('need a list')
        self._capacity = 3
        self._values = value_list
        self._remove_duplicates()
        self._enforce_capacity()

    def _remove_duplicates(self):
        found = set()
        result = list(reversed(self._values))
        for value in self._values:
            if value in found:
                result.remove(value)
            else:
                found.add(value)
        result.reverse()
        self._values = result

    def _enforce_capacity(self):
        self._values = self._values[:self._capacity]

    def __iter__(self):
        return self._values.__iter__()

    def enqueue(self, value):
        while value in self._values:
            self._values.remove(value)
        self._values.insert(0, value)
        self._enforce_capacity()
        return self


class RememberUserViewModel(UserViewBaseModel, PersonalBaseModel):
    def isDefaultView(self):
        return self.view.category == CATEG_DEFAULT or (
            self.view.Customizes and
            self.view.Customizes.category == CATEG_DEFAULT
        )

    def rememberUserViewSelection(self, request):
        new_app_settings = self.app_settings.copy()
        new_app_settings[CURRENT] = self.view_object_id

        if not self.isDefaultView():
            # enqueue new date and cut head so max queue length is preserved
            # use an ordered "set" to eliminate duplicates
            dates = DistinctQueue(
                new_app_settings.get(RECENT, [])
            )
            dates.enqueue(self.view_object_id)
            new_app_settings[RECENT] = list(dates)

        self.app_settings = new_app_settings
        return [
            util.oid2restID(x, request)
            for x in self.app_settings.get(RECENT, [])
        ]


def prepare_user_view_condition(condition):
    result = dict(condition)
    result["types"] = [util.restID2oid(x) for x in result["types"]]
    result["contexts"] = [util.restID2oid(x) for x in result["contexts"]]
    result["users"] = [util.restID2primaryKeys(x) for x in result["users"]]
    return unicode(json.dumps(result))


def simulate_view_selection(model, view, request):
    model = RememberUserViewModel(view.cdb_object_id)
    model.rememberUserViewSelection(request)
    return model.getInitialSettings(request)


class UserViewModel(UserViewBaseModel, PersonalBaseModel):
    def deleteUserView(self, request):
        if self.view.category == CATEG_DEFAULT:
            raise RuntimeError(
                "default views cannot be deleted from inside cs.taskmanager"
            )
        operation(cdbConstants.kOperationDelete, self.view)
        return self.getInitialSettings(request)

    def saveUserView(self, condition, request):
        condition = prepare_user_view_condition(condition)

        if self.view.category == CATEG_USER:
            # update custom view
            kwargs = self.view.toDict()
            kwargs[self.view.__condition_attr__] = condition
            view = operation(
                cdbConstants.kOperationModify, self.view, **kwargs
            )
        else:
            # create a custom copy of default or preconfigured views
            kwargs = self.view.getCustomCopyAttributes(None, condition)
            view = operation(
                cdbConstants.kOperationCopy, self.view, **kwargs
            )

        return simulate_view_selection(self, view, request)

    def renameUserView(self, name, request):
        if self.view.category == CATEG_USER:
            # rename custom view
            kwargs = self.view.toDict()
            kwargs["name_{}".format(CADDOK.ISOLANG)] = name
            operation(cdbConstants.kOperationModify, self.view, **kwargs)
            return self.getInitialSettings(request)
        else:
            # create a custom copy of default or preconfigured views
            kwargs = self.view.getCustomCopyAttributes(name)
            newView = operation(cdbConstants.kOperationCopy, self.view, **kwargs)
            return simulate_view_selection(self, newView, request)


class NewUserViewModel(PersonalBaseModel):
    def newUserView(self, name, condition, request):
        kwargs = UserView.GetCustomAttributes(
            name,
            prepare_user_view_condition(condition)
        )
        newView = operation(cdbConstants.kOperationNew, UserView, **kwargs)
        return simulate_view_selection(self, newView, request)
