#!/usr/bin/env powerscript
# coding: utf-8
#
# Copyright (C) 1990 - 2018 CONTACT Software GmbH
# All rights reserved.
# http://www.contact.de/

"""
Module supporting selenium tests for cs.taskmanager and its plugins

This is a public API, so breaking changes inside released versions are not
allowed!
"""

__docformat__ = "restructuredtext en"
__revision__ = "$Id: webdriver_support.py 185149 2018-10-16 13:36:57Z cso $"

import os
import platform
import time
from selenium import webdriver
from selenium.common.exceptions import NoAlertPresentException
from selenium.common.exceptions import StaleElementReferenceException
from selenium.common.exceptions import TimeoutException
from selenium.common.exceptions import UnexpectedAlertPresentException
from selenium.common.exceptions import WebDriverException
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.alert import Alert
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support import wait
from cdb import misc
from cdb import util
from cdb.validationkit.util import get_server_url
from cdb.validationkit.util import login_webdriver
from cdb.validationkit.util import logout_webdriver

IS_BUILDBOT = platform.node().lower().find("bbc") > - 1


def urljoin(*segments):
    """
    Returns a URL consisting of strings `segments`, each separated by exactly
    one `/`. If the first segment starts with any slashes, a single leading
    slash is preserved.
    """
    result = "/".join(s.strip("/") for s in segments)

    if segments[0].startswith("/"):
        result = "/{}".format(result)

    return result


class WebDriver(object):
    """
    Wrapper for webdriver browser classes, providing upper-cased convience
    methods.

    Usage example:

    .. code-block:: python
        d = WebDriver("chrome")
        d.Login()
        d.GetElement(byId="cs-web-components-base-table")
        d.get_window_size()

    .. note::
        Every property, attribute or method defined in this class contains at
        least one upper-case character.

        Attributes without upper-case characters are routed through to
        self.Driver in order to access all standard attributes of the
        underlying webdriver class.
    """
    BROWSER_MAP = {
        "chrome": webdriver.Chrome,
        "firefox": webdriver.Firefox,
        "ie": webdriver.Ie,
    }

    def __init__(self, browser, server_url=None, timeout=None):
        """
        - Sets up selenium webdriver for string `browser` as `self.Driver`.
        - `self.ServerUrl` contains `server_url` if given, else the URL derived
          from a running Apache service.
        - `self.LoggedIn` tracks if this instance currently is logged into an
          Elements session.
        - Int `timeout` sets the webdriver's timeout value, defaulting to 15.

        .. warning::
            Will raise a WebDriverException if instantiation of the selenium
            webdriver class fails.
        """
        browser_class = self.BROWSER_MAP[browser]
        kwargs = self._DefaultKwargs(browser)
        self.Timeout = timeout or 15
        self.ShortTimeout = 5 if IS_BUILDBOT else 1
        self.AnimationTimeout = 0.4 if IS_BUILDBOT else 0.2
        self.LoggedIn = False
        self.ServerUrl = server_url or get_server_url()
        self.Driver = self._SetupDriver(browser_class, kwargs)
        self.Table = TaskManagerTable(self)
        self.Proceed = TaskManagerProceed(self)
        self.Detail = TaskManagerDetail(self)

    def __getattr__(self, attr):
        """
        Routes every attribute through to `self.Driver` if it's lower-cased.
        """
        if attr.islower():
            return getattr(self.Driver, attr)
        else:
            return self.__getattribute__(attr)

    def _DefaultKwargs(self, browser):
        """
        Returns kwargs for selenium webdriver class constructors. Default
        return value is an empty dict.
        """
        if browser == "ie":
            caps = webdriver.DesiredCapabilities.INTERNETEXPLORER.copy()
            caps.update({
                "nativeEvents": False,
                "unexpectedAlertBehaviour": "accept",
                "ignoreProtectedModeSettings": True,
                "disable-popup-blocking": True,
                "enablePersistentHover": True,
            })
            return {"capabilities": caps}

        if browser == "chrome":
            return {"desired_capabilities": None}

        if browser == "firefox":
            return {"capabilities": None}

        return {}

    def _SetupDriver(self, browser_class, kwargs):
        """
        Instantiate selenium webdriver class `browser_class` with given
        `kwargs`. Raises a `WebDriverException` if instantiation fails.
        """
        try:
            driver = browser_class(**kwargs)
            return driver
        except WebDriverException:
            misc.log_traceback(
                "Driver for '{}' not installed or in path?".format(
                    browser_class))
            raise

    def WaitForAnimation(self):
        time.sleep(self.AnimationTimeout)

    def ActionChains(self):
        return ActionChains(self.Driver)

    def Get(self, url):
        self.get(urljoin(self.ServerUrl, url))

    def Alert(self):
        return Alert(self.Driver)

    @property
    def Keys(self):
        return Keys

    @property
    def TimeoutException(self):
        return TimeoutException

    @property
    def WebDriverException(self):
        return WebDriverException

    def SendKeys(self, element, keys):
        # incomplete send_keys application seem to be a common problem
        for key in keys:

            if IS_BUILDBOT:
                time.sleep(0.03)
            else:
                time.sleep(0.02)

            element.send_keys(key)

    def SelectFromLegacyBrowser(self, browser_button, attr, value):
        """
        attr: searchable attribute
        """
        self.Click(browser_button)

        filter_input = self.GetElement(
            byCSS="tfoot th[data-elink-catalog-attribute={}] "
                  ".filter-input".format(attr))
        self.SendKeys(filter_input, value)

        select = self.GetElement(byClass="icon-check-empty")
        actions = self.ActionChains().move_to_element(
            select).click().release()
        actions.perform()

        self.WaitUntilModalClosed()

    def Login(self, username=None, password=None):
        """
        If `self.LoggedIn` is `True`, reloads the current page to reset any
        caches. Else, logs in using the provided credentials.
        """
        if self.LoggedIn:
            self.Driver.refresh()  # Reload page to reset caches
            return

        is_logged_in = login_webdriver(self.Driver,
                                       username=username,
                                       password=password or "",
                                       language="de")

        os.environ["CADDOK_ELINK_DEBUG"] = "True"  # we rely on debug mode
        self.Get("/")
        self.LoggedIn = is_logged_in

    def Logout(self):
        """
        If `self.LoggedIn` is `True`, logs out of the current session.
        """
        if not self.LoggedIn:
            return

        logout_webdriver(self.Driver)
        self.LoggedIn = False

    def WaitUntilModalClosed(self):
        # short timeout because a modal may not actually exist
        modal = self.GetElement(byClass="modal", timeout=self.ShortTimeout)
        if modal:
            try:
                self.WaitUntilInvisible(modal, timeout=self.ShortTimeout)
            except StaleElementReferenceException:
                pass

    def WaitUntilModalOpened(self):
        # explicit wait because modals fade in
        modal = self.GetElement(byClass="modal")
        if modal:
            self.WaitUntilVisible(modal, timeout=self.ShortTimeout)
            self.WaitForAnimation()

    def WaitUntilURLChanged(self, old_url):
        """
        Blocks until the current URL does not end with string `old_url`. May
        raise a TimeoutException.
        """
        wait.WebDriverWait(self.Driver, self.Timeout).until(
            lambda d: not d.current_url.endswith(old_url))

    def WaitUntilInvisible(self, element, timeout=None):
        """
        Wait until given `element` is not visible. May raise a
        TimeoutException.
        """
        wait.WebDriverWait(self.Driver, timeout or self.Timeout).until_not(
            EC.visibility_of(element))

    def WaitUntilVisible(self, element, timeout=None):
        """
        Wait until given `element` is visible. May raise a TimeoutException.
        """
        wait.WebDriverWait(self.Driver, timeout or self.Timeout).until(
            EC.visibility_of(element))

    def waitUntilAttributeIs(self, element, attribute, value, timeout=None):
        timeout = timeout or self.Timeout

        wait.WebDriverWait(self.Driver, timeout).until(
            lambda driver: element.get_attribute(attribute) == value)

    def ConfirmAlert(self):
        try:
            alert = self.Driver.switch_to.alert
            alert.accept()
        except NoAlertPresentException:
            raise

    def GetElement(self, timeout=None, multi=None, **kwargs):
        """
        Locates an element by means of WebDriverWait and find_element_by...
        functions.

        If `timeout` is truthy, it overrides self.Timeout for locating the
        element.

        `kwargs` must contain at least one of these keys:

        +---------------+---------------------+----------------------+
        | Key           | find_element_by_... | find_elements_by_... |
        |               | (multi `False`)     | (multi `True`)       |
        +===============+=====================+======================+
        | byId          | id                  | -                    |
        +---------------+---------------------+----------------------+
        | byName        | name                | name                 |
        +---------------+---------------------+----------------------+
        | byXPath       | xpath               | xpath                |
        +---------------+---------------------+----------------------+
        | byLink        | link_text           | link_text            |
        +---------------+---------------------+----------------------+
        | byPartialLink | partial_link_text   | partial_link_text    |
        +---------------+---------------------+----------------------+
        | byTag         | tag_name            | tag_name             |
        +---------------+---------------------+----------------------+
        | byClass       | class_name          | class_name           |
        +---------------+---------------------+----------------------+
        | byCSS         | css_selector        | css_selector         |
        +---------------+---------------------+----------------------+

        The first key containing a non-empty value will be used.

        TimeoutExceptions are caught and `None` is returned.
        """
        def _locate(function):
            try:
                return wait.WebDriverWait(
                    self.Driver, timeout or self.Timeout).until(function)
            except TimeoutException:
                return [] if multi else None

        locators = {
            "single": [
                ("byId", "find_element_by_id"),
                ("byName", "find_element_by_name"),
                ("byXPath", "find_element_by_xpath"),
                ("byLink", "find_element_by_link_text"),
                ("byPartialLink", "find_element_by_partial_link_text"),
                ("byTag", "find_element_by_tag_name"),
                ("byClass", "find_element_by_class_name"),
                ("byCSS", "find_element_by_css_selector"),
            ],
            "multi": [
                ("byName", "find_elements_by_name"),
                ("byXPath", "find_elements_by_xpath"),
                ("byLink", "find_elements_by_link_text"),
                ("byPartialLink", "find_elements_by_partial_link_text"),
                ("byTag", "find_elements_by_tag_name"),
                ("byClass", "find_elements_by_class_name"),
                ("byCSS", "find_elements_by_css_selector"),
            ],
        }

        for arg, locator in locators["multi" if multi else "single"]:
            value = kwargs.get(arg, None)
            if value:
                return _locate(lambda d: getattr(d, locator)(value))

    def MoveTo(self, element):
        """
        Scroll the page so `element` is visible in the current viewport.
        """
        actions = self.ActionChains()
        actions.move_to_element(element)
        actions.perform()

    def Click(self, element):
        """
        Ensure `element` is visible and click it
        """
        self.WaitUntilVisible(element)
        element.click()

    def GetAndClick(self, **kwargs):
        """
        Combines GetElement and Click for convenience. Returns the resulting
        element after it's been clicked.
        """
        element = self.GetElement(**kwargs)

        if element is None:
            raise RuntimeError("no element found: {}".format(kwargs))

        self.Click(element)
        return element

    # cs.taskmanager-specific helpers
    def waitForAsyncActions(self):
        "wait until cs.taskmanager DebugMode has no pending async actions"
        self.WaitForAnimation()  # prevents StaleElementReferenceException
        fetching = self.GetElement(
            byClass="cs-taskmanager-web-debug-info__fetching")
        assert fetching, (
            "debug component not found - cs.taskmanager.settings.DebugMode active?"
        )

        self.waitUntilAttributeIs(fetching, "data-fetching", "false")

    def openTaskManager(self):
        """
        point selenium-driven browser to cs.taskmanager,
        wait until completely loaded
        """
        tasks_url = urljoin(self.ServerUrl, "tasks")
        self.Login()

        try:
            self.get(tasks_url)
        except UnexpectedAlertPresentException:
            self.ConfirmAlert()

        self.waitForAsyncActions()

    def confirmModal(self):
        selector = ".cs-web-components-base-semantic-button-primary"
        self.GetAndClick(byCSS=".modal-footer > {}".format(selector))
        self.WaitUntilModalClosed()


class TaskManagerBase(object):
    def __init__(self, driver):
        self.webdriver = driver

    def __GetOrGetAndClick__(self, **kwargs):
        if kwargs.get("click", False):
            method = self.webdriver.GetAndClick
        else:
            method = self.webdriver.GetElement

        return method(**kwargs)


class TaskManagerProceed(TaskManagerBase):
    def GetProceedCell(self, task, click=False):
        """
        return proceed cell for given task object

        if click is True, also open it and
        wait for target statuses to be loaded
        """
        proceed_id = "cs-taskmanager-web-proceed-btn-{}".format(
            task.cdb_object_id
        )
        result = self.__GetOrGetAndClick__(byId=proceed_id, click=click)

        if click:
            self.webdriver.waitForAsyncActions()

        return result

    def FillInProceedAttributes(self, **kwargs):
        "fill in proceed attributes from kwargs in open modal"
        for key, value in kwargs.items():
            text_input = self.webdriver.GetElement(byName=key)
            self.webdriver.SendKeys(text_input, value)

    def GetTargetStatuses(self, task):
        "return shown status cells for task (requires open proceed dropdown)"
        return self.webdriver.GetElement(
            multi=True,
            byCSS="ul[aria-labelledby='cs-taskmanager-web-proceed-btn-{}']"
                  " .cs-taskmanager-web-status".format(task.cdb_object_id)
        )

    def Proceed(self, task, status, proceedOpen=False, **kwargs):
        """
        change given task object's status to status labeled ``status``

        if proceedOpen is False, open the dropdown first

        kwargs has to contain any mandatory attributes for the status change
        """
        # jobs are not rolled back reliably while counters are
        util.init_counter("system_posting", "mq_system_posting", "cdbmq_id")

        if not proceedOpen:
            self.GetProceedCell(task, True)

        self.webdriver.GetAndClick(byLink=status)

        if kwargs:
            self.FillInProceedAttributes(**kwargs)
            self.webdriver.confirmModal()

        self.webdriver.waitForAsyncActions()


class TaskManagerTable(TaskManagerBase):
    def GetAllRows(self):
        return self.webdriver.GetElement(multi=True, byCSS="tbody tr")

    def GetRow(self, task, deleted=False, click=False):
        """
        return row for given task object

        if deleted is True, require row to be striked-through
        """
        selector = "tr{}[data-row-id='{}']".format(
            ".deleted" if deleted else "",
            task.cdb_object_id
        )

        if click:
            # click selection element to prevent accidentally clicking links
            checkbox = "cs-web-components-base-formcontrols-label-aftercontrol"
            self.webdriver.GetAndClick(byCSS="{} .{}".format(
                selector,
                checkbox,
            ))
            self.webdriver.waitForAsyncActions()

        return self.webdriver.GetElement(byCSS=selector)

    def GetDeadlineCell(self, task):
        selector = 'tr[data-row-id="{}"] .cs-taskmanager-web-date'.format(
            task.cdb_object_id
        )
        return self.webdriver.GetElement(byCSS=selector)


class TaskManagerDetail(TaskManagerBase):
    def GetContextObjects(self, click=False):
        return self.__GetOrGetAndClick__(
            multi=True,
            byClass="cs-taskmanager-web-task-context-node",
            click=click,
        )

    def GetAttributes(self):
        return self.webdriver.GetElement(
            multi=True,
            byCSS=".cs-taskmanager-web-attribute > *",
        )

    def GetLongText(self):
        "return (single) long text node from task details"
        return self.webdriver.GetElement(byId="cs-taskmanager-web-long-text")
